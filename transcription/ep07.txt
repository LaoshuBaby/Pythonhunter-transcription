[00:00.000 --> 00:09.960] 这首歌曲的歌词是《一生一世》的主题曲
[00:09.960 --> 00:19.960] 这首歌曲的歌词是《一生一世》的主题曲
[00:19.960 --> 00:32.920] 这首歌曲的歌词是《一生一世》的主题曲
[00:32.920 --> 00:34.280] 各位听众朋友们好
[00:34.280 --> 00:36.760] 欢迎来到这一期的《不舍者说》节目
[00:36.760 --> 00:39.560] 我是这一期的主持人赖信涛
[00:39.560 --> 00:43.080] 这一期我们邀请到了我的一个朋友David
[00:43.080 --> 00:45.720] 这一期其他的主持人都有点事情
[00:45.720 --> 00:49.760] 所以录制只有我们两个了
[00:49.760 --> 00:52.120] David你来自己介绍一下吧
[00:52.120 --> 00:52.960] 大家好
[00:52.960 --> 00:54.040] 我是David
[00:54.040 --> 00:55.360] 这期主持人都不在了
[00:55.360 --> 00:57.199] 所以我是临时凑出来的
[00:57.199 --> 00:57.839] 不不不
[00:57.839 --> 00:59.239] 不是不在了
[00:59.239 --> 01:02.480] 他们都有事
[01:02.480 --> 01:07.479] 我是一个主要在知识突破领域工作的程序员
[01:07.479 --> 01:09.360] 第一份工作是在上海
[01:09.360 --> 01:11.759] 在平安的金融科技里面
[01:11.759 --> 01:17.320] 我的工作一直都和一个编程语言Lisp相关
[01:17.320 --> 01:19.560] 一个我非常喜欢的编程语言
[01:19.560 --> 01:21.560] 在平安的时候
[01:21.560 --> 01:25.080] 通过Lisp进入了这个语音网知识突破的领域
[01:25.080 --> 01:26.520] 然后又到欧洲
[01:26.520 --> 01:32.800] 然后又给一个知识突破的一个公司做那个consultancy
[01:32.800 --> 01:33.920] 一直到现在
[01:33.920 --> 01:38.200] 我现在在悉尼做这个知识突破相关的engineering
[01:38.200 --> 01:40.560] David给我介绍过很多次知识突破
[01:40.560 --> 01:42.720] 但是我都一直没有理解
[01:42.720 --> 01:43.960] 要不你再解释一遍
[01:43.960 --> 01:47.720] 知识突破其实是大概10年还是09年的时候
[01:47.720 --> 01:49.600] 谷歌提出来的一个概念
[01:49.600 --> 01:52.760] 其实这个概念在上个世纪
[01:52.760 --> 01:55.520] 可能应该是80年代左右吧
[01:55.520 --> 01:59.280] 80 90年代的时候就已经出来了
[01:59.280 --> 02:00.720] 一开始这个概念叫做
[02:00.720 --> 02:01.800] UEO
[02:01.800 --> 02:03.280] Semantic Web
[02:03.280 --> 02:05.160] Semantic Networks
[02:05.160 --> 02:06.440] 那么一开始的时候
[02:06.440 --> 02:08.560] 由于当时的计算能力有限
[02:08.560 --> 02:13.040] 然后这个机器学习还没有完全崛起
[02:13.040 --> 02:14.640] 所以当时的规模都很小
[02:14.640 --> 02:21.359] 主要是由一部分特定领域的技术人员编辑这样的一个知识工程
[02:21.359 --> 02:25.160] 但现在的话完全是存储这个规模也上来了
[02:25.160 --> 02:27.000] 计算能力也上来了
[02:27.000 --> 02:29.559] 这机器学习的各种技术蓬勃发展
[02:29.559 --> 02:33.519] 所以已经完全就是用这个各种知识挖掘
[02:33.519 --> 02:37.160] 各种那个datamining知识发现
[02:37.160 --> 02:40.519] information extraction这样的技术来构成一个图谱
[02:40.520 --> 02:44.960] 比如说你现在去Google上搜索姚明有多高
[02:44.960 --> 02:47.200] 它会直接告诉你一个很精准的答案
[02:47.200 --> 02:50.560] 或者姚明从哪一年到哪一年的时候
[02:50.560 --> 02:51.480] 在哪里工作
[02:51.480 --> 02:52.160] 在哪个球队
[02:52.160 --> 02:54.040] 它都能告诉你一个很精准的答案
[02:54.040 --> 02:58.480] 而不是通过这个自负算上的这个去匹配了
[02:58.480 --> 03:03.120] 它会以一个非常结构化的一个知识体系的形式呈现给你答案
[03:03.120 --> 03:04.480] 大概就是这些图谱
[03:04.480 --> 03:06.720] 你听说过那个NEO4J吗
[03:06.720 --> 03:07.600] 我知道
[03:07.600 --> 03:09.360] 那是一个图数据库是吧
[03:09.360 --> 03:09.880] 加瓦的
[03:09.880 --> 03:11.040] 对那是个图数据库
[03:11.040 --> 03:12.200] 图数据库有两种
[03:12.200 --> 03:15.440] 然后NEO4J是比较新的一种
[03:15.440 --> 03:18.720] 它是这个就是你完全定义对那个数据结构
[03:18.720 --> 03:22.400] 然后各种各样的数据结构可以以那个Node
[03:22.400 --> 03:24.519] 或者编就是edge的方式存在
[03:24.519 --> 03:27.359] 然后就形成一个很大型的一个网络
[03:27.359 --> 03:30.079] 这样的话它就不会有那个table
[03:30.079 --> 03:35.120] 就是传统的那个relational database的那种table的那种东西
[03:35.120 --> 03:39.280] 然后它查询的时候就完全就是各种匹配嘛
[03:39.280 --> 03:41.400] 然后另外一种就是三元组的这种数据库
[03:41.400 --> 03:44.560] 那就是比较传统的那个知识图
[03:44.560 --> 03:46.600] 现在可能是NEO4J这种比较吃香
[03:46.600 --> 03:47.920] 拿到了很多投资吧
[03:47.920 --> 03:48.400] 我估计是
[03:48.400 --> 03:52.040] OK你的之前的编程语言都是用Lisp嘛
[03:52.040 --> 03:55.920] 然后我们今天的话题就是来聊一下
[03:55.920 --> 03:58.600] 函数式编程和Python
[03:58.600 --> 03:59.840] 作为一个Lisp程序员
[03:59.840 --> 04:02.920] 要不你先聊一下你是怎么看待Python这门语言的
[04:02.920 --> 04:07.400] 作为一个Lisp程序员是怎么看待Python这个语言的
[04:07.400 --> 04:08.160] 就很有意思
[04:08.160 --> 04:11.760] 对就是上次在PyCon上有个大神跟我们说
[04:11.760 --> 04:12.960] Python是Lisp
[04:12.960 --> 04:14.800] 这不能这么说不能这么说的
[04:14.800 --> 04:18.200] 那那个要是说动态语言里面
[04:18.200 --> 04:21.360] 就除了Lisp以外最像Lisp的可能是东亚里面
[04:21.360 --> 04:23.760] 唯一一个走向世界的一个编程语言
[04:23.760 --> 04:25.920] Ruby是比较像Lisp的
[04:25.920 --> 04:29.680] Python还是稍微就是它的
[04:29.680 --> 04:33.440] 比如最简单的那个Lambda表达式
[04:33.440 --> 04:34.840] 这被截肢了嘛
[04:34.840 --> 04:37.240] 是吧大家同不同意
[04:37.240 --> 04:40.320] 基本上就是被截肢的一个构造了
[04:40.320 --> 04:42.560] 然后再加上它的那个
[04:42.560 --> 04:46.000] 词法作用域可能很多Lisp程序员都不能接受
[04:46.000 --> 04:47.000] 主要是哪一点
[04:47.000 --> 04:50.120] 比如说现在有段程序代码是比如说
[04:50.120 --> 04:51.520] X等于1
[04:51.520 --> 04:53.720] 然后把这个X带到一个for循环里面去
[04:53.720 --> 04:56.760] for X in range怎么样怎么样
[04:56.760 --> 04:58.360] 然后就做了一堆事情
[04:58.360 --> 05:00.720] 然后那个在出来这个循环之后
[05:00.720 --> 05:02.440] 那个X其实是依赖于那个
[05:02.440 --> 05:04.080] 复循环表达式里面的语句的
[05:04.080 --> 05:07.280] 它不是在复循环里面之前的那个1了
[05:07.280 --> 05:08.960] 对我觉得也是这一点
[05:08.960 --> 05:11.440] 因为Python没有Quark作用域
[05:11.440 --> 05:13.560] 函数内的作用域都是一样的
[05:13.560 --> 05:17.400] 对所以Python应该不能说是一个Lisp
[05:17.400 --> 05:20.120] 但是它们有很多相通的地方
[05:20.120 --> 05:23.680] 包括现在在那个人工智能领域的这个
[05:23.680 --> 05:24.799] 这个大方一彩
[05:24.799 --> 05:27.120] 其实都跟它的这个灵活性有关系的
[05:27.120 --> 05:28.680] 就动态源的灵活性是有关系的
[05:28.680 --> 05:31.560] Python的这个工具啊工具链啊是
[05:31.560 --> 05:35.640] 我大概是我15年15年的时候参加工作
[05:35.640 --> 05:37.480] 然后16年的时候开始写Python
[05:37.480 --> 05:41.120] 就Python整个工具链社区是令我叹为观之
[05:41.120 --> 05:43.760] 因为Lisp它其实社区规模很小
[05:43.760 --> 05:46.920] 工具链也也也对也没什么
[05:46.920 --> 05:48.440] 没什么特别啊
[05:48.440 --> 05:49.760] 不是说它没有特别完善的
[05:49.760 --> 05:52.520] 就没有得到整个社区社区认可的
[05:52.520 --> 05:54.360] de facto的那种工具链
[05:54.360 --> 05:55.840] 它不像Python
[05:55.840 --> 05:56.880] 我记得16年的时候
[05:56.880 --> 05:59.520] 我还不会用那个virtual environment
[05:59.520 --> 06:00.840] 那现在是肯定要用这东西了
[06:00.840 --> 06:03.479] 或者用康大的那个那个environment
[06:03.479 --> 06:06.599] Python我是觉得他们的Lambda
[06:06.599 --> 06:08.919] 虽然不是一个完整的Lambda
[06:08.919 --> 06:11.840] 但是它是一个就实用的
[06:11.840 --> 06:14.200] 就是很多功能
[06:14.200 --> 06:15.799] 它没有的你也用不到
[06:15.799 --> 06:19.080] 但是它有的你它有的就是它这种形式
[06:19.080 --> 06:21.359] 可以让你用起来比较方便
[06:21.359 --> 06:23.760] 这个这个这个问题
[06:23.760 --> 06:26.520] 虽然就是你从其他语言过来人
[06:26.520 --> 06:28.200] 可能觉得可能觉得很困惑吧
[06:28.200 --> 06:30.920] 但是如果你第一门语言就学的是Python的话
[06:30.920 --> 06:32.760] 那也就很容易接受这个设定
[06:32.760 --> 06:35.360] Python就是确实很务实
[06:35.360 --> 06:36.400] 写一行就写一行吧
[06:36.400 --> 06:38.520] 它可能就是为了让你只是
[06:38.520 --> 06:39.719] 既然是匿名函数了
[06:39.719 --> 06:41.760] 那你就就就就尽量一点
[06:41.760 --> 06:44.360] 不要不要搞花里胡哨的写那么多行
[06:44.360 --> 06:45.760] 然后再加了一个
[06:45.760 --> 06:49.280] 再再再上面再加一个那个绑定的变量啊什么的
[06:49.280 --> 06:50.120] 就直接就一行
[06:50.120 --> 06:52.000] 对这个如果是新学的那个
[06:52.000 --> 06:54.200] 就第一门语言学的是Python的话
[06:54.200 --> 06:55.760] 应该还是可以接受的吧
[06:55.760 --> 06:57.280] 只不过
[06:57.280 --> 06:58.599] 我觉得还是比较奇怪
[06:58.599 --> 07:00.159] 因为都既然已经搞这个东西了
[07:00.159 --> 07:04.200] 为什么不能把它做成一个完整的一个一个构造呢
[07:04.200 --> 07:05.640] 为什么把它给截肢呢
[07:05.640 --> 07:07.359] 可能他们认为就
[07:07.359 --> 07:09.119] 如果你有一个很复杂的函数的话
[07:09.119 --> 07:11.440] 那么你应该给它一个名字
[07:11.440 --> 07:11.679] 嗯
[07:11.679 --> 07:13.719] Lambda只适用于比如说你
[07:13.719 --> 07:15.200] 你给一个list排序
[07:15.200 --> 07:16.799] 你想定义一下
[07:16.799 --> 07:19.599] 那个用对象的哪一个属性来排序的话
[07:19.599 --> 07:21.239] 这个时候你可以用一个Lambda
[07:21.239 --> 07:22.799] 然后他们又只有一行
[07:22.799 --> 07:26.000] 他们就把这个功能给限制限制住了
[07:26.000 --> 07:28.880] 就是你只能用于这种场景
[07:29.880 --> 07:30.640] 嗯嗯
[07:31.320 --> 07:31.760] 嗯
[07:31.760 --> 07:33.280] 这是这是官方的解释吗
[07:33.280 --> 07:35.080] 还是社区里面的解释
[07:35.080 --> 07:35.280] 啊
[07:35.280 --> 07:36.640] 这是我的解释
[07:36.640 --> 07:37.680] 哈哈
[07:37.680 --> 07:38.680] 对对
[07:38.680 --> 07:42.600] 我我我基本上认同这个这个这个这个解释
[07:42.600 --> 07:44.200] 就是Python还是一个
[07:44.200 --> 07:45.760] 那个很务实的一个语言
[07:45.760 --> 07:46.240] 对吧
[07:46.240 --> 07:49.800] 就因为假如说假如说Java没有那个Lambda的话
[07:49.800 --> 07:53.360] 你要写一个list排序的那个叫
[07:53.360 --> 07:54.000] 嗯
[07:54.000 --> 07:55.280] competitor
[07:55.280 --> 07:56.320] 你要勾到一个类
[07:56.320 --> 07:59.679] 然后实现里面的一个方法就比较复杂
[07:59.679 --> 08:02.479] 我们听众里面可能多少多少人都会有Java程序
[08:02.479 --> 08:04.719] 我自己也写过Java
[08:04.719 --> 08:07.119] 就Java的那套从那个Java 8
[08:07.119 --> 08:08.479] 啊对你也写过Java
[08:08.479 --> 08:10.640] 从Java 8引入的那套那个
[08:10.640 --> 08:13.840] 所谓的Lambda表达实在是哇太太冗长
[08:13.840 --> 08:15.760] 很让人费解
[08:15.760 --> 08:17.119] 我还不如不用呢是吧
[08:17.119 --> 08:19.760] 对他的那个Lambda有很多概念
[08:19.760 --> 08:21.479] stream开关
[08:21.479 --> 08:24.039] 然后有一个什么collector那些东西
[08:24.040 --> 08:27.960] 但就是你要去花很多时间去理解它里面的概念
[08:27.960 --> 08:29.520] Python就是一个Lambda
[08:29.520 --> 08:30.880] 里面就是个函数
[08:30.880 --> 08:34.200] 所以你可以花五分钟学一下那个Python的Lambda
[08:34.200 --> 08:36.600] 但是学Java的那个stream那一套
[08:36.600 --> 08:38.159] 可能要很长时间
[08:38.159 --> 08:42.520] 对大家可能不知道那个Java的委员会
[08:42.520 --> 08:47.240] 就是这个语言specification的委员会和Cognizant的委员会
[08:47.240 --> 08:49.360] 里面都有同一个人叫做Guy Steele
[08:49.360 --> 08:51.360] 是从MIT出来的
[08:51.360 --> 08:53.160] 就是一个人
[08:53.160 --> 08:54.800] 而且他算是一个leader
[08:54.800 --> 08:57.920] 就是在那个committee里面算是一个leader
[08:57.920 --> 09:01.319] 就是同一个人会主导着两个完全
[09:01.319 --> 09:05.839] 在哲学上在这个控制沟通上完全不同的语言
[09:05.839 --> 09:08.040] 这个肯定是有原因的
[09:08.040 --> 09:10.880] Java的这个冗长啊什么的
[09:10.880 --> 09:13.839] 他其实就是方便这个工程化
[09:13.839 --> 09:15.880] 方便也不是说方便招人吧
[09:15.880 --> 09:19.160] 就是他只要给出一些什么那些什么EMR图
[09:19.160 --> 09:21.600] 是叫EMR图吧
[09:21.600 --> 09:25.680] 还是什么就那种各种流程图啊各种
[09:25.680 --> 09:26.880] 对对对
[09:26.880 --> 09:28.520] 对ER图不好意思
[09:28.520 --> 09:32.560] ER图然后各种那个specification一样东西
[09:32.560 --> 09:36.200] 那就是那就是再加再复制一些ID
[09:36.200 --> 09:38.960] 基本上这个就肯定能写出来
[09:38.960 --> 09:40.000] 并且做测试了
[09:40.000 --> 09:41.440] 他没有那些灵活性
[09:41.440 --> 09:43.840] 在工程上其实也是个好事情
[09:43.840 --> 09:45.080] 从某种程度上来说
[09:45.080 --> 09:49.080] OK那除了Lambda还有什么你觉得python奇怪的吗
[09:49.080 --> 09:50.080] 对你来说
[09:50.080 --> 09:52.600] 这个奇怪的其实对于我来说
[09:52.600 --> 09:56.440] 最奇怪的根源在于那个2跟3的分离
[09:56.440 --> 09:58.320] 可能你接触的时间比较久
[09:58.320 --> 09:59.520] 可能会接触到这些东西
[09:59.520 --> 10:04.840] 比如说Mac还有那个filter这样的函数
[10:04.840 --> 10:08.480] 在2里面它返回的是整个那个整个列表
[10:08.480 --> 10:11.040] 或者整个那个iterable的那个东西
[10:11.040 --> 10:12.880] 在3里面它返回的是一个generator
[10:12.880 --> 10:15.200] 然后你在3里面还要再用一个list
[10:15.200 --> 10:18.240] 再要用一次才能看到它的那个真正的那个值
[10:18.240 --> 10:19.120] 但是一开始的时候
[10:19.120 --> 10:20.720] 我学的时候是从2开始学的
[10:20.720 --> 10:22.120] 是从python2开始写
[10:22.120 --> 10:24.120] 然后转到3的时候
[10:24.120 --> 10:25.880] 就很多东西就感觉就变了
[10:25.880 --> 10:26.880] 然后也不知道怎么搞的
[10:26.880 --> 10:29.240] 2就被已经它是什么
[10:29.240 --> 10:30.720] 从哪天开始不维护了是吧
[10:30.720 --> 10:32.360] 下一个月1月1号
[10:32.360 --> 10:34.440] 对就很快就不维护了是吧
[10:34.440 --> 10:35.640] 对
[10:35.640 --> 10:38.680] 反而一个generator更合理一点
[10:38.680 --> 10:39.760] 对吧可以接受
[10:39.760 --> 10:42.400] 是是是确实是确实是
[10:42.400 --> 10:43.800] 对更合理一点
[10:43.800 --> 10:47.480] 然后还有它的那个那个自主产的那个表
[10:47.480 --> 10:48.960] 那个表现上也不太一样吧
[10:48.960 --> 10:49.480] 我记得
[10:49.480 --> 10:52.640] 反而是2里面它不是默认的那个UTF是吧
[10:52.640 --> 10:56.120] 对我记得2开始的时候都要加个那个U
[10:56.120 --> 10:59.200] 作为那个相当于声明
[10:59.200 --> 11:01.840] 这个是UTF-8的那个自主产
[11:01.840 --> 11:03.080] 对unicode
[11:03.080 --> 11:06.720] 2是好像是U跟
[11:06.720 --> 11:10.560] 就是你不写U的话就是一个二进制的东西
[11:10.560 --> 11:12.920] 然后你写U的话就是一个unicode自主产
[11:12.920 --> 11:14.200] 到3的话
[11:14.200 --> 11:16.920] 你要不写的话就是一个unicode
[11:16.920 --> 11:18.760] 如果你前面写个B的话
[11:18.760 --> 11:21.960] 就是一个二进制
[11:21.960 --> 11:22.720] 这个很头疼
[11:22.720 --> 11:25.480] 对就是这个2跟3的分裂还是
[11:25.480 --> 11:27.560] 可能还确实挺奇怪的
[11:27.560 --> 11:29.520] 不知道你们社区里面自己人怎么
[11:29.520 --> 11:31.520] 这个我感觉就是
[11:31.520 --> 11:32.960] 2的一些设计东西不好
[11:32.960 --> 11:34.680] 如果你保持向后兼容的话
[11:34.680 --> 11:38.200] 你就没办法fix这些设计不好的东西
[11:38.200 --> 11:40.360] 所以不如来一次
[11:40.360 --> 11:41.880] 相当于是
[11:41.880 --> 11:43.160] 推倒重来
[11:43.160 --> 11:43.880] 不是推倒重来
[11:43.880 --> 11:46.000] 就是来一次不向后兼容的版本
[11:46.000 --> 11:48.480] 来一次大版本不向后兼容了
[11:48.480 --> 11:49.320] 对我开玩笑的
[11:49.320 --> 11:51.120] 推倒重来是在
[11:51.120 --> 11:54.320] 你有没有听过一个语言叫V语言
[11:54.320 --> 11:55.480] 哦VLON是吧
[11:55.480 --> 11:56.280] VLON
[11:56.280 --> 11:58.480] 听说过但是我没有去看过
[11:58.480 --> 12:01.600] 有兴趣的朋友可以去了解一下这个语言
[12:01.600 --> 12:06.040] 那是对很多程序员智商上的侮辱我觉得
[12:06.040 --> 12:07.600] 当然作者热情很高
[12:07.600 --> 12:11.160] 但是这个语言从他一开始造势什么的
[12:11.160 --> 12:13.600] 感觉既要取代Go又要取代Python
[12:13.600 --> 12:16.160] 甚至要取代Rust
[12:16.160 --> 12:20.640] 然后他就完全没有考虑什么向后兼容这些东西
[12:20.640 --> 12:23.719] 然后还要说什么今天要发布1.0版本吗
[12:23.719 --> 12:29.439] 对向后兼容确实是语言的向后兼容
[12:29.439 --> 12:31.319] 我觉得挺头疼的
[12:31.319 --> 12:34.000] Python的前身是什么叫什么ABC是吧
[12:34.000 --> 12:36.199] 是一个最爱教学的语言叫ABC
[12:36.199 --> 12:38.120] 对我原来读过一个论文
[12:38.120 --> 12:41.439] 对二语言的时候
[12:41.439 --> 12:42.880] 就是那个做统计的
[12:42.880 --> 12:44.720] 做很多技术学界应该也知道
[12:44.720 --> 12:46.640] 二语言的前身是Scheme
[12:46.640 --> 12:48.360] 是Lisp的一个方言
[12:48.360 --> 12:49.840] 但是他在设计的时候
[12:49.840 --> 12:53.320] 就是很多东西也借鉴了ABC上的东西
[12:53.320 --> 12:55.040] 那可能是九几年的事情吧
[12:55.040 --> 12:57.360] 就2000年左右的时候的事情
[12:57.360 --> 12:58.880] 就是Python的这个
[12:58.880 --> 13:02.680] 它的出现其实对21世纪的很多语言
[13:02.680 --> 13:05.040] 都是有很大的影响
[13:05.040 --> 13:08.640] OK 接下来我们再聊一下函数式编程吧
[13:08.640 --> 13:10.080] 其实刚刚也聊到过一期了
[13:10.080 --> 13:11.680] 这个概念我都不知道是
[13:11.680 --> 13:12.760] 就是历史上这个概念
[13:12.760 --> 13:15.120] 我都不知道是哪个阶段正式提出来的
[13:15.120 --> 13:16.800] 很有可能是
[13:16.800 --> 13:19.560] 就是最早期的这个东西
[13:19.560 --> 13:21.720] 它完全是为了做那种定理证明啊
[13:21.720 --> 13:23.720] 逻辑运算这些东西提出来的
[13:23.720 --> 13:27.920] 我学的第一个函数式编程的语言叫做ML
[13:27.920 --> 13:30.280] ML的有一个时间叫做SML
[13:30.280 --> 13:32.360] 就是Standard ML
[13:32.360 --> 13:35.480] ML的那个缩写是Math Language
[13:35.480 --> 13:36.840] 它这个语言
[13:36.840 --> 13:38.800] 就是你可以看到就是这个语言
[13:38.800 --> 13:40.360] 确实跟其他语言很不一样
[13:40.360 --> 13:41.400] 从历史上来说
[13:41.400 --> 13:43.640] 一开始是Fortran跟Lisp
[13:43.640 --> 13:45.439] 两个最早的两个
[13:45.439 --> 13:47.840] 就是高级语言的两个先锋
[13:47.840 --> 13:50.000] 然后有一个Algo就是Algorithm
[13:50.000 --> 13:53.319] 就是C语言的那种那套体系的各种方言
[13:53.319 --> 13:56.079] 然后又出了这个函数式编程
[13:56.079 --> 13:59.360] 然后就是那个Prolog就是逻辑编程
[13:59.360 --> 14:02.040] 就函数式编程它的这个
[14:02.040 --> 14:05.040] 它的这个这个
[14:05.040 --> 14:05.560] 怎么说呢
[14:05.560 --> 14:07.360] 它的这个这个发展
[14:07.360 --> 14:10.040] 其实是相对来讲稍微晚一点的
[14:10.040 --> 14:13.199] 因为当年的那个那个情况
[14:13.199 --> 14:15.839] GC就是那个垃圾回收跟不上
[14:15.839 --> 14:17.400] 很多优化跟不上
[14:17.400 --> 14:18.920] 所以那个语言完全是
[14:18.920 --> 14:19.880] 也不是说完全是
[14:19.880 --> 14:22.839] 大部分情况都是用于那个学术研究
[14:22.839 --> 14:25.959] 然后就导致出现了很多学术上的名词
[14:25.959 --> 14:28.360] 可能大家如果想学那个函数编程的话
[14:28.360 --> 14:29.719] 会听说各种
[14:29.719 --> 14:31.439] 像颗粒化呀
[14:31.439 --> 14:34.439] 什么First Order Function
[14:34.439 --> 14:37.560] 就是一节一节函数啊这种东西
[14:37.560 --> 14:40.239] 模式匹配什么Lazy Evaluation
[14:40.239 --> 14:42.199] 还什么按需求值按值求值
[14:42.199 --> 14:44.280] 什么东西的各种各种各种各样的
[14:44.280 --> 14:45.880] 那种比较学术化的名词
[14:45.880 --> 14:48.599] 特别是如果你从那个Haskell
[14:48.599 --> 14:49.839] 去学函数变成的话
[14:49.839 --> 14:54.640] 那简直了可能可能很难啃下来
[14:54.640 --> 14:57.000] 有一本书叫什么
[14:57.000 --> 14:58.880] Learn Haskell for Fun
[14:58.880 --> 15:01.359] 那本书其实一点都不好玩
[15:01.359 --> 15:04.680] 我觉得就是学函数变成的话
[15:04.680 --> 15:05.760] 如果是务实
[15:05.760 --> 15:07.319] 我觉得拿Python学函数变成
[15:07.320 --> 15:08.080] 就可以
[15:08.080 --> 15:10.080] 因为Python的那个特性
[15:10.080 --> 15:11.680] 特性上的支持已经挺不错的了
[15:11.680 --> 15:14.080] 你完全是你如果只要学习的话
[15:14.080 --> 15:17.040] 知道函数变成的这个
[15:17.040 --> 15:18.960] 就为什么为什么说它是函数变成的
[15:18.960 --> 15:21.320] 就是从数学上来说
[15:21.320 --> 15:24.520] 一个函数它有这个输入和输出嘛
[15:24.520 --> 15:26.400] 然后函数变成的目的就是
[15:26.400 --> 15:29.760] 所有的输入输出都经过一系列的这个函数调用
[15:29.760 --> 15:31.840] 保证就是每一个函数
[15:31.840 --> 15:35.280] 它的同样的输入都会得到同样的输出
[15:35.280 --> 15:36.240] 大概就是这么一个意思
[15:36.240 --> 15:37.520] 其实就是那你在
[15:37.520 --> 15:38.800] 你别说Python
[15:38.800 --> 15:40.720] 你在C语言里面也可以做到
[15:40.720 --> 15:42.960] 就是所有的变量都在站上生成
[15:42.960 --> 15:46.040] 然后你只要保证就是它的这个输出是一致的就可以了
[15:46.040 --> 15:48.680] 那C语言其实也是函数式变成语言
[15:48.680 --> 15:51.600] 所以一个语言是不是函数式变成的语言
[15:51.600 --> 15:53.600] 它没有一个明显的界限对吧
[15:53.600 --> 15:54.800] 界限嘛
[15:54.800 --> 15:58.240] 界限我觉得就我个人来说
[15:58.240 --> 15:59.160] 我觉得是没有
[15:59.160 --> 15:59.720] 变成嘛
[15:59.720 --> 16:01.520] 就主要就是为了务实
[16:01.520 --> 16:04.400] Haskell号称它是最纯的这个
[16:04.400 --> 16:05.720] 函数式变成语言
[16:05.720 --> 16:07.600] 我今天说这话可能比较招黑啊
[16:07.600 --> 16:10.720] 就是Haskell一直就是说它是最纯的函数式变成语言
[16:10.720 --> 16:15.680] 但是整个变成的目的不就是为了给这个state造成这个
[16:15.680 --> 16:17.240] 就是Mutation嘛
[16:17.240 --> 16:18.720] 就造成这个修改嘛
[16:18.720 --> 16:19.080] 是吧
[16:19.080 --> 16:21.880] 你变成如果一直跑下来什么都不改
[16:21.880 --> 16:23.680] 感觉从直觉上来讲
[16:23.680 --> 16:26.560] 就是跟人的直觉是违背的呀
[16:26.560 --> 16:31.520] 它的这个思想的好处就是它能保证很多它的安全性跟一致性
[16:31.520 --> 16:33.320] 这个这一点确实是可以的
[16:33.320 --> 16:37.680] 就是所有的输入到输出经历过一系列的函数调用
[16:37.680 --> 16:39.600] 然后每个函数它在它的意义
[16:39.600 --> 16:42.160] 它是数学上的那种函数是一个映射
[16:42.160 --> 16:44.720] 就是给同样的输入都给同样的输出
[16:44.720 --> 16:48.240] 但是这种特性在很多语言里面都可以做到
[16:48.240 --> 16:52.240] 不在于说你这个语言到底是所谓什么号称的这个函数式语言
[16:52.240 --> 16:57.400] 还是其他不强调自己是函数式语言的语言
[16:57.400 --> 16:57.920] 对吧
[16:57.920 --> 17:00.880] 哪怕就是函数语言这个社区本身的其他语言
[17:00.880 --> 17:04.920] 它也没说自己是完全是纯的函数式
[17:04.920 --> 17:11.000] 像OCaml跟Fsharp它都提供一定的修改值的机制
[17:11.000 --> 17:13.200] 包括List也是
[17:13.200 --> 17:16.560] 我记得我在15年的时候还是16年的时候
[17:16.560 --> 17:19.760] 那年的那个函数式开发者大会
[17:19.760 --> 17:24.960] 它的那个宣传用语就完全是把函数式语言当成了
[17:24.960 --> 17:26.480] Haskell一家独有的东西
[17:26.480 --> 17:28.800] 它就是它那个它应该是宣传吧
[17:28.800 --> 17:30.120] 还是海报之类的东西
[17:30.120 --> 17:32.959] 就是上面用的全是Haskell的语法呀或者结构
[17:32.959 --> 17:36.080] 然后造成了整个社区的一个一个一个抨击
[17:36.080 --> 17:37.800] 就是难道你不知道还有OCaml吗
[17:37.800 --> 17:40.199] 难道你不知道还有动态的List呀
[17:40.199 --> 17:43.000] 还有像包括那个那个瑞典那个语言叫什么来着
[17:43.000 --> 17:45.120] 那个Erlang
[17:45.120 --> 17:46.959] 我也不知道怎么读
[17:46.959 --> 17:49.760] 不可修改可能是函数语言一大特点吧
[17:49.760 --> 17:52.560] 就是它是非常不建议你
[17:52.560 --> 17:56.399] 任意的修改这个一个一个变量的值
[17:56.399 --> 17:58.800] 包括像现在比较新的那个Rust也是
[17:58.800 --> 18:02.159] 在默认的时候是默认的一个一个一个变量声明
[18:02.159 --> 18:04.320] 是不可变的一个一个变量
[18:06.480 --> 18:09.600] 这个有个好处就是你在看到一个代码里面
[18:09.600 --> 18:13.360] 如果这个语言它它就比如Haskell
[18:13.360 --> 18:16.159] 它完全不提供这种修改的机制的话
[18:16.159 --> 18:17.760] 那你只要看到这个变量名
[18:17.760 --> 18:18.879] 你就知道这个是什么
[18:18.879 --> 18:20.159] 从头到尾它都是同一个东西
[18:20.159 --> 18:21.440] 这个术语叫什么来着
[18:21.440 --> 18:23.360] 叫引用透明
[18:24.320 --> 18:26.320] 我那时候读那个SICP的时候
[18:26.320 --> 18:28.159] 有一张专门讲这个的
[18:28.160 --> 18:29.440] 他那个时候就很辩证
[18:29.440 --> 18:31.600] 他没有说这个东西是完全是好的
[18:31.600 --> 18:34.240] 这东西是有好有好处也有坏处
[18:34.240 --> 18:37.440] 那你如果可以改的话肯定更灵活
[18:37.440 --> 18:41.680] 或者说就是一开始像那个像C源那些东西
[18:41.680 --> 18:45.200] 肯定就是到处都在改嘛对吧
[18:45.200 --> 18:47.360] 到处都在修改这个这个
[18:47.360 --> 18:49.440] 对到处都在修改这个值
[18:49.440 --> 18:51.280] 它对它在这个硬件上面来说
[18:51.280 --> 18:53.200] 其实是很直接的一个操作
[18:53.200 --> 18:54.640] 你在硬件来说确实就是这样
[18:54.640 --> 18:56.560] 它不宁在替换那个修改
[18:56.560 --> 18:59.120] 那个不好意思那个计算机里面的值
[18:59.120 --> 19:01.919] 或者在交换那个指针里面的东西
[19:01.919 --> 19:02.480] 对吧
[19:02.480 --> 19:04.159] 只有当你这个
[19:04.159 --> 19:07.200] 其实函数是变成的新奇
[19:07.200 --> 19:08.240] 主要依赖于这个
[19:08.240 --> 19:11.040] 主要靠的就是变成语言理论的这个
[19:11.040 --> 19:12.560] 这个这个这个壮大
[19:12.560 --> 19:14.960] 包括这个各种编译器优化的这个东西
[19:14.960 --> 19:16.800] 如果你的GC跟不上的话
[19:16.800 --> 19:18.399] 这个语言还是不行
[19:18.399 --> 19:21.040] 性能性能还是很难接受嘛
[19:23.040 --> 19:25.760] 你想每一个数据结构
[19:25.760 --> 19:28.000] 当然了它数据结构有很多优化的东西
[19:28.000 --> 19:30.560] 你就我们就说那个各种那个
[19:30.560 --> 19:32.879] 数的那个insert跟delete
[19:32.879 --> 19:34.320] 它每次insert跟delete的时候
[19:34.320 --> 19:36.960] 都要在堆上创建新的那个
[19:36.960 --> 19:38.720] 那个数据这哪吃得消
[19:38.720 --> 19:41.120] 然后时间长了就要进行一次GC
[19:41.120 --> 19:42.800] 时间长了就要进行一次GC
[19:42.800 --> 19:44.000] 对吧
[19:44.000 --> 19:46.560] 当然它在它其实数据结构是有各种优化的
[19:46.560 --> 19:50.240] 它就是利用那个多星多星求是来进行各种优化的
[19:50.240 --> 19:53.360] OK接下来我们再聊一下
[19:53.360 --> 19:54.960] 函数式编程
[19:54.960 --> 19:56.960] 刚刚你提到那些概念
[19:56.960 --> 20:00.080] 首先先聊一下类型推导
[20:00.080 --> 20:03.920] 类型推导是这个
[20:03.920 --> 20:09.680] 很多静态这个函数式编程语言的一个非常显著的特性
[20:09.680 --> 20:13.920] 甚至包括像那个C-sharp里面好像都带这个特性
[20:13.920 --> 20:16.080] 因为我现在在的公司
[20:16.080 --> 20:19.040] 他们是用那个.net的那个工具链的
[20:19.040 --> 20:23.520] 就是在不写这个类型声明的情况下
[20:23.520 --> 20:26.400] 它的编译器本身可以推导出这个变量
[20:26.400 --> 20:28.879] 这个函数的类型是什么
[20:28.879 --> 20:31.520] 大概大概大概就是这个这个这种机制
[20:31.520 --> 20:34.160] 那这个这个机制背后就要求
[20:34.160 --> 20:38.879] 你的这个编译器它有一套这个在在逻辑里面叫unification
[20:38.879 --> 20:42.240] 大概就是解一个其实就解一个方程了
[20:42.240 --> 20:45.120] 然后这个方程有一些位置变量和有一些已知变量
[20:45.120 --> 20:47.760] 在已知变量的情况下怎么推导出位置变量的值
[20:47.760 --> 20:49.920] 只不过这个方程它是一个symbolic
[20:49.920 --> 20:52.080] 是一个符号的这个符号计算
[20:52.080 --> 20:53.600] 它不是数值计算
[20:53.600 --> 20:54.879] 大概就是这么一个机制
[20:54.879 --> 20:58.560] 这样的好处肯定就是很多时候不用写那个
[20:58.560 --> 21:01.679] 这样的好处就是你很多时候不用写那个
[21:01.679 --> 21:03.360] 不用写那个类型嘛
[21:03.360 --> 21:08.399] 然后它的这个编译器本身的这个推导的话可以保证这个
[21:08.399 --> 21:10.480] 就错误它会大大的减少
[21:10.480 --> 21:16.960] 然后我们再来聊一下你刚提到那些比较学术的东西
[21:16.960 --> 21:19.919] 颗粒化跟多性求值
[21:19.919 --> 21:21.280] first order function
[21:21.280 --> 21:25.520] 颗粒化那个patent有个包叫functools
[21:25.520 --> 21:29.600] 里面有一个构造是叫partial 是吧
[21:29.600 --> 21:30.240] 是partial
[21:30.240 --> 21:33.760] 简单来说就是因为patent它自己已经有这个
[21:33.760 --> 21:37.600] 可以传参数的这个特性之后
[21:37.600 --> 21:40.720] 那么比如说现在一个函数它接收若干个参数
[21:40.720 --> 21:45.520] 其中的一些参数它可以一个一个的一个一个的那个apply
[21:45.520 --> 21:47.600] 比如说现在有一堆ABC
[21:47.600 --> 21:50.720] 它如果partial application第一个A
[21:50.720 --> 21:52.720] 然后它就返回一个新的函数
[21:52.720 --> 21:56.000] 这个函数只接受两个参数分别是B跟C
[21:56.000 --> 21:58.560] 对或者你只partial A跟B
[21:58.560 --> 22:00.160] 然后它就呈现一个新的参数
[22:00.160 --> 22:03.200] 新的函数只接受最后那个C
[22:03.200 --> 22:04.720] 就是这么个东西
[22:04.720 --> 22:06.160] 其实说起来都很简单
[22:06.160 --> 22:08.640] 但是非要说什么颗粒化
[22:08.640 --> 22:13.760] 新增出来的函数完全携带着之前的那个各种那个变量的状态
[22:13.760 --> 22:15.360] 所以这是一个非常非常好的抽象
[22:15.360 --> 22:19.600] 它基本上可以用这些特性来实现这个这个OOP
[22:19.600 --> 22:20.879] 来实现这个面向对象
[22:20.879 --> 22:24.399] 因为面向对象完全就是带着那个状态的各种结构体
[22:24.399 --> 22:27.280] 你现在只不过是要用函数把这些状态给封装起来
[22:27.280 --> 22:31.600] 颗粒化它是就很多那个函数设备人员
[22:31.600 --> 22:33.360] 就特别静态的函数设备人员
[22:33.360 --> 22:35.600] 它的那个它的那个所有的函数
[22:35.600 --> 22:37.840] 默认的其实都是可以可以那个颗粒化的
[22:37.840 --> 22:40.719] 所以就导致它没有基本上不要写什么括号
[22:40.719 --> 22:43.040] 就是它你写一个函数名
[22:43.040 --> 22:44.560] 它之后的就是你挨个写
[22:44.560 --> 22:47.760] 你写一两个就哪怕这个函数有十个行三
[22:47.760 --> 22:50.000] 你只写一两个都没有关系
[22:50.000 --> 22:53.520] 它就它它只会得到一个被partial application的这个这个
[22:53.520 --> 22:54.640] 这个新的函数
[22:54.640 --> 22:57.840] 不像其他语言你就必须要写那个完全就十个行三
[22:57.840 --> 22:58.960] 就必须十个行三
[22:58.960 --> 23:01.520] 当然你可以写有什么optional的那个行三
[23:01.520 --> 23:03.760] 就就大概我的我的意思就是
[23:03.760 --> 23:06.080] 就是它这个自由度就在于
[23:06.080 --> 23:10.160] 一个函数可以传函数跟访问函数的时候
[23:10.160 --> 23:13.040] 这个抽象是绝对是到了一个新的层次
[23:13.040 --> 23:15.120] 只要有那个first order function
[23:15.120 --> 23:16.480] 这些都有了对吧
[23:16.480 --> 23:18.720] 所以它只要支持first order function
[23:18.720 --> 23:21.520] 它就可以对跟你说的到一个新的层次
[23:21.520 --> 23:24.640] 像刚刚你说的那个函数是编程的
[23:24.640 --> 23:26.400] 就是你可以传两个参数
[23:26.400 --> 23:29.520] 后面那些都都会被颗粒化的那种
[23:29.520 --> 23:30.960] 它会返回一个新的函数
[23:30.960 --> 23:32.320] 这样不是很难debug吗
[23:32.320 --> 23:34.720] 就是假如说你要调用这个函数的话
[23:34.720 --> 23:36.800] 结果它没有返回的真实的结果
[23:36.800 --> 23:38.320] 反而你得到了一个新的函数
[23:38.320 --> 23:39.520] 为什么很难debug呢
[23:39.520 --> 23:40.960] 因为它不会报错
[23:40.960 --> 23:42.240] 就是假如说python的话
[23:42.240 --> 23:44.320] 都会告诉你这个函数期望三个
[23:44.320 --> 23:45.360] 但是你传了两个
[23:45.360 --> 23:46.639] 都会很明确的告诉你
[23:46.639 --> 23:48.879] 你只要看到过程中找到这一行
[23:48.879 --> 23:50.479] 你就知道哪里错了对吧
[23:50.479 --> 23:52.639] 但是它那个不会的
[23:52.639 --> 23:54.080] 因为类型推导会告诉你的
[23:54.080 --> 23:55.760] 如果你的类型不符合
[23:55.760 --> 24:00.240] 就是你apply了两三个形态之后
[24:00.240 --> 24:01.679] 它的类型推导会告诉你的
[24:01.679 --> 24:04.879] 但是你刚刚不是说只要传两个
[24:04.879 --> 24:06.959] 它会就是aplay两次
[24:06.959 --> 24:08.399] 然后得到一个新的函数吗
[24:08.399 --> 24:09.760] 对
[24:09.760 --> 24:11.840] 那这个函数也是有类型的呀
[24:11.840 --> 24:16.320] 就是下次用到这个返回值的时候
[24:16.320 --> 24:18.879] 它发现这个东西是个函数
[24:18.879 --> 24:19.840] 是一个变量
[24:19.840 --> 24:23.360] 对这个都是在运行前可以检查出来的
[24:23.360 --> 24:26.560] 就是编译的时候都可以检查出来的
[24:26.560 --> 24:28.480] 如果不符合的话它编译会报错
[24:28.480 --> 24:29.760] 它的这个debug
[24:29.760 --> 24:32.560] SML它完全是基本上是教学跟学术语言了
[24:32.560 --> 24:35.280] 它debug我觉得我当时也没
[24:35.280 --> 24:36.800] 因为我当时只是拿来学的嘛
[24:36.800 --> 24:38.720] ocaml的话我也只是拿来学
[24:38.720 --> 24:40.240] 那个Fsharp
[24:40.240 --> 24:43.120] 就是.net上的那个函数语言
[24:43.120 --> 24:44.880] 那个debug是真是好
[24:44.880 --> 24:47.920] 它毕竟有.net跟那个visual studio
[24:47.920 --> 24:50.080] 哇那个下端点跟什么
[24:50.080 --> 24:54.560] 还有那个看那个各种CPU和那个time的那个metrics
[24:54.560 --> 24:58.400] 那个是真的是一流的那个体验
[24:58.400 --> 24:59.920] 那个是看到实时的吗
[24:59.920 --> 25:00.960] 还是看到
[25:00.960 --> 25:02.560] 实时的
[25:02.560 --> 25:06.000] 就visual studio的那个debug真的是
[25:06.000 --> 25:09.200] 所以它是宇宙第一的那个IT
[25:09.200 --> 25:11.440] 这个道理它那个debug确实很可以
[25:11.440 --> 25:14.800] Java的debug体验确实也比其他的好很多
[25:14.800 --> 25:16.480] Java的IDE
[25:16.480 --> 25:17.760] 就是在Lisp里面
[25:17.760 --> 25:20.160] 我不知道在其他语言里面有没有可能做到这一点
[25:20.160 --> 25:21.120] 可能比较难
[25:21.120 --> 25:23.360] 在Lisp里面它是停住让你有选项的
[25:23.360 --> 25:24.240] 可以让你修改它
[25:24.240 --> 25:26.160] 修改这个当前这个站上的值
[25:26.160 --> 25:28.160] 然后让你重新执行这段操作
[25:28.160 --> 25:30.480] 这个叫restart的一个机制
[25:30.480 --> 25:32.240] 这个确实是一个非常好的机制
[25:32.240 --> 25:33.440] 这个我觉得才是
[25:33.440 --> 25:35.040] 当然你现在说这个是debug
[25:35.040 --> 25:37.040] 但这个其实是它语言本身的一部分
[25:37.040 --> 25:40.480] 它这个类型叫状态系统的一部分
[25:40.480 --> 25:42.000] 就异常系统的一部分
[25:42.000 --> 25:43.600] 它不叫异常它叫状态
[25:43.600 --> 25:44.720] 叫condition
[25:44.720 --> 25:46.560] 我想要的一个东西其实是这样
[25:46.560 --> 25:48.480] 就是我们程序挂在这里了
[25:48.480 --> 25:50.320] 然后我跑到这里的时候
[25:50.320 --> 25:51.040] 我发现它挂了
[25:51.040 --> 25:52.960] 那我只能再重新走一遍流程
[25:52.960 --> 25:54.560] 就有没有可能就是
[25:54.560 --> 25:56.000] 我进了这个函数了
[25:56.000 --> 25:57.280] 我发现这个函数错了
[25:57.280 --> 25:59.920] 然后我想退回去
[25:59.920 --> 26:00.879] 就退出去
[26:00.879 --> 26:03.040] 就比如说退到上10号
[26:03.040 --> 26:04.960] 然后再重新执行这个过程
[26:04.960 --> 26:05.840] 这个可以吗
[26:05.840 --> 26:08.080] 这个在Lisp
[26:08.080 --> 26:09.679] 在QoPo Lisp里面可以实现
[26:09.679 --> 26:11.600] 在那个SKIM里面是完全可以实现的
[26:11.600 --> 26:13.280] 一个叫continuation的一个操作
[26:13.280 --> 26:15.199] 他们一直用的一个比喻叫做
[26:15.199 --> 26:16.720] 给程序打洞
[26:16.720 --> 26:19.040] 给这行代码打一个洞
[26:19.040 --> 26:20.639] 然后并且把这个洞给记录下来
[26:20.639 --> 26:22.639] 然后比如说把这个洞
[26:22.639 --> 26:24.879] 可以存储成一个变量
[26:24.879 --> 26:26.320] 然后你再用这个变量的时候
[26:26.320 --> 26:28.879] 可以回到当前的那个
[26:28.879 --> 26:30.639] 你在调用这段代码时候的状态
[26:30.639 --> 26:32.080] 叫做continuation
[26:32.080 --> 26:33.760] 是个非常强大的操作
[26:33.760 --> 26:36.000] 对但是开销也比较高
[26:36.000 --> 26:37.600] Debug开销其实
[26:37.600 --> 26:39.920] 我觉得默认都是接受开销的
[26:39.920 --> 26:41.680] 不是它那个是完全是语言的一部分
[26:41.680 --> 26:43.600] 那个是它语言标准的一部分
[26:43.600 --> 26:46.320] 是一个我觉得应该是挺有名的一个创造
[26:46.320 --> 26:47.680] 就是像后来的那个
[26:47.680 --> 26:49.120] Core Routine
[26:49.120 --> 26:50.640] 包括Generator
[26:50.640 --> 26:52.240] Generator不是可以那个
[26:52.240 --> 26:53.440] send和receive吗
[26:53.440 --> 26:54.000] 记得吧
[26:54.000 --> 26:54.879] 都是可以用那个
[26:54.879 --> 26:57.200] 一个叫continuation的一个东西来实现的
[26:57.200 --> 26:58.720] 这个东西能记住
[26:58.720 --> 27:00.960] 你这个函数修改了哪些变量
[27:00.960 --> 27:02.800] 你可以完全把他们退回去吗
[27:02.800 --> 27:06.000] 对它能记住就是当前站上的所有东西
[27:06.000 --> 27:07.600] 就是无非就是看你怎么用
[27:07.600 --> 27:09.520] 它可以用来实现很多东西
[27:09.520 --> 27:10.560] 异常
[27:10.560 --> 27:11.760] Core Routine
[27:11.760 --> 27:13.040] Generator
[27:13.040 --> 27:15.120] 像那个什么break
[27:15.120 --> 27:16.560] break continue
[27:16.560 --> 27:18.399] return这些关键字都可以用它来实现
[27:18.399 --> 27:19.440] 退回去的话
[27:19.440 --> 27:21.600] 所有的它修改的状态全都退回去了
[27:21.600 --> 27:23.040] 应该不能说是退回去
[27:23.040 --> 27:23.919] 举个例子吧
[27:23.919 --> 27:25.919] 比如说你知道
[27:25.919 --> 27:28.560] 比如说在做一个象棋的一个
[27:28.560 --> 27:30.639] 就是棋类的一个搜索算法
[27:30.640 --> 27:33.200] 你现在遇到一个分支的时候
[27:33.200 --> 27:34.720] 下面有两个分支
[27:34.720 --> 27:37.280] 但是你不知道哪个分支是最优解
[27:37.280 --> 27:38.640] 所以你先走
[27:38.640 --> 27:39.600] 先走第一个
[27:39.600 --> 27:40.880] 然后再往下走的时候
[27:40.880 --> 27:42.720] 那个状态可能是会被修改掉的
[27:42.720 --> 27:43.440] 然后你走到
[27:43.440 --> 27:45.360] 再往下走的时候走到某一步
[27:45.360 --> 27:46.480] 你发现哎呀不对了
[27:46.480 --> 27:47.680] 这个解其实不是最优解
[27:47.680 --> 27:49.520] 所以你要退回去
[27:49.520 --> 27:50.480] 然后你就用那个
[27:50.480 --> 27:51.680] 用那个continuation退回去
[27:51.680 --> 27:53.680] 退到那个当前你记录的那个节点
[27:53.680 --> 27:55.760] 所以跟他们有各种比喻
[27:55.760 --> 27:57.120] 什么给程序打动啊
[27:57.120 --> 27:58.080] 还有什么时间旅行
[27:58.080 --> 27:59.040] time travel
[27:59.040 --> 28:00.080] 都比较形象
[28:00.080 --> 28:01.360] 有点像time travel
[28:01.360 --> 28:02.399] 其实就是让你在
[28:02.399 --> 28:03.919] 可以让你在站上来回的走
[28:03.919 --> 28:04.720] 那我有个问题
[28:04.720 --> 28:07.280] 假如涉及到外部状态的改变怎么办
[28:07.280 --> 28:10.240] 比如说你往一个文件里面写了一些东西
[28:10.240 --> 28:11.600] 然后把文件关掉了
[28:11.600 --> 28:14.399] 你如果要想要time travel回去的话
[28:14.399 --> 28:15.120] 那就没准
[28:15.120 --> 28:16.720] 如果是一个文件剧本
[28:16.720 --> 28:18.000] 然后又被关掉了
[28:18.000 --> 28:19.679] 那它肯定就会报错了嘛
[28:19.679 --> 28:20.560] 已经被关掉了
[28:20.560 --> 28:22.480] 所以这种时候还会变成就有好处
[28:22.480 --> 28:23.120] 不会那个
[28:23.120 --> 28:24.159] 不会有那个修改
[28:24.159 --> 28:25.520] 你看在那个Haskell里面
[28:25.520 --> 28:26.720] 它那个IO的操作
[28:26.720 --> 28:28.879] 都用了一个叫什么mona的这个东西
[28:28.880 --> 28:30.560] 来避免这种状态的修改
[28:30.560 --> 28:31.280] 因为按理说
[28:31.280 --> 28:33.360] 哪怕就是一个随机入生设计
[28:33.360 --> 28:34.960] 它其实都有修改对吧
[28:34.960 --> 28:35.360] 对
[28:35.360 --> 28:37.840] Haskell里面有套非常漂亮的叫mona的
[28:37.840 --> 28:39.840] mona的中文翻译过来
[28:39.840 --> 28:41.120] mona的那个算子
[28:41.120 --> 28:42.560] 这种东西来把它给
[28:42.560 --> 28:44.560] 给这个抽象
[28:45.360 --> 28:48.080] 那接下来我们聊一下例子evaluation
[28:48.720 --> 28:50.080] 惰性求值
[28:51.600 --> 28:53.280] 我还是用一个例子吧
[28:53.280 --> 28:54.560] 大家有没有想过
[28:54.560 --> 28:57.360] 怎么用一个函数来实现if
[28:57.360 --> 29:03.120] 或者说为什么if语句不能用这个函数来实现
[29:03.120 --> 29:07.280] 就是因为它你在函数传那个传餐的时候
[29:07.280 --> 29:10.159] 那个餐必须要被求值了
[29:10.159 --> 29:10.959] 然后才开始
[29:10.959 --> 29:12.959] 才能用这个函数应用到那些
[29:12.959 --> 29:14.000] 那个参数上的
[29:14.000 --> 29:15.919] 这就导致一个问题就是
[29:15.919 --> 29:19.120] 如果if就是那个if
[29:19.120 --> 29:20.399] 如果为真的话
[29:20.399 --> 29:23.199] 它只会那个执行那个真的语句
[29:23.199 --> 29:24.879] 不会执行那个else那个语句的
[29:24.880 --> 29:27.440] 是吧
[29:27.440 --> 29:28.400] 对
[29:28.400 --> 29:32.240] 所以这种时候就要用这种惰性求值的机制
[29:32.240 --> 29:33.520] 来做这种东西
[29:33.520 --> 29:38.720] 当然if可以用这个函数来实现
[29:38.720 --> 29:40.000] 但大概就是这个意思
[29:40.000 --> 29:42.240] 就是一堆一堆行餐
[29:42.240 --> 29:43.920] 只有当它必须要被求值的时候
[29:43.920 --> 29:45.520] 它才会被求值
[29:45.520 --> 29:47.520] 我之前提到过那个
[29:47.520 --> 29:51.280] 在Hashibench里面的这个各种数据结构的优化
[29:51.280 --> 29:53.280] 它很多都是用这个惰性求值来做的
[29:53.280 --> 29:56.480] 它这个比如数的这个insert delete
[29:56.480 --> 30:00.480] 就是如果你
[30:00.480 --> 30:02.879] 如果你因为它不允许修改吧
[30:02.879 --> 30:05.280] 它就完全是要在堆上面生成一堆纸
[30:05.280 --> 30:06.240] 堆上面生成一堆纸
[30:06.240 --> 30:07.840] 那这个开销是非常非常大的
[30:07.840 --> 30:09.280] 是很疯狂的一件事情
[30:09.280 --> 30:13.120] 所以它会用惰性求值来做这个事情
[30:13.120 --> 30:17.120] 惰性求值跟函数识别程没有什么必然的关系
[30:17.120 --> 30:17.600] 对吧
[30:17.600 --> 30:18.720] 没有必然的关系
[30:18.720 --> 30:20.879] 函数识别程就是我刚刚说的
[30:20.880 --> 30:27.040] 就是输入输出通过一些数学意义上的函数进行的这个运算
[30:27.040 --> 30:30.240] 惰性求值它只是编程语言
[30:30.240 --> 30:32.240] 其中的一个构造一个特性
[30:32.240 --> 30:34.960] 这取决于解释器或者编译器的这个实现
[30:34.960 --> 30:36.800] 我们今天聊的这些话题
[30:36.800 --> 30:38.480] 感觉都是编程语言相关的
[30:38.480 --> 30:41.040] 不是特定函数识别程的对吧
[30:41.040 --> 30:43.200] 我觉得甚至就是以后编程语言
[30:43.200 --> 30:45.840] 应该不用声明它是什么函数识别程语言了
[30:45.840 --> 30:49.520] 就今后的之后的编程语言应该都会有这些东西
[30:49.520 --> 30:52.080] 因为现在编译器的效率上来了
[30:52.080 --> 30:56.480] 然后GNA的开销变得没有那么小心翼翼了
[30:56.480 --> 30:57.920] 这些东西自然而然就会出来
[30:57.920 --> 31:01.520] 它的出现它兴起完全是自然而然的事情
[31:01.520 --> 31:05.840] 而且它就是它有很多东西确实
[31:05.840 --> 31:08.000] 跟利率抽象
[31:08.000 --> 31:09.760] 那我们最后再来聊一下
[31:09.760 --> 31:13.280] 作为一个低语言式Lisp的程序员
[31:13.280 --> 31:15.760] 那么对于低语言式Python的程序员
[31:15.760 --> 31:19.280] 去学习Lisp的话有什么建议或者推荐的资料呢
[31:19.280 --> 31:22.480] 我看你《天春》里面也没有认识一个叫散格的程序员
[31:22.480 --> 31:23.120] 天春是吧
[31:23.120 --> 31:24.800] 对天春
[31:24.800 --> 31:26.399] 他之前是在网易上一个ID
[31:26.399 --> 31:28.480] 然后他之前是在网易工作的
[31:28.480 --> 31:32.399] 是网易的那个Linux的System Administrator
[31:32.399 --> 31:34.399] System管理员
[31:34.399 --> 31:37.840] 他对Lisp的学习完全就是
[31:37.840 --> 31:41.280] 肯那个Common Lisp的那个Specification
[31:41.280 --> 31:45.680] 那本书我记得是1050几页吧
[31:45.680 --> 31:47.120] 具体50多少我记不得了
[31:47.120 --> 31:49.040] 因为我尝试去肯那本书
[31:49.040 --> 31:51.040] 我没有肯得下来
[31:51.040 --> 31:52.560] 因为那本书实在是太长了
[31:52.560 --> 31:55.280] 包括了整个语言的变动的历史
[31:55.280 --> 31:57.280] 然后还分第一版和第二版
[31:57.280 --> 31:59.600] 第二版里面就多了一个
[31:59.600 --> 32:01.040] 勉强炼向系统
[32:01.040 --> 32:04.080] 勉强炼向系统又完全是用Lisp的宏给实现的
[32:04.080 --> 32:06.080] 就是没有什么新的
[32:06.080 --> 32:08.080] 其实没有什么新的那个
[32:08.080 --> 32:09.280] 新的动力
[32:09.280 --> 32:12.080] 完全是他们自己提出来的概念上的东西
[32:12.080 --> 32:16.560] 那个第二版直接把书的内容扩充了将近一倍我记得
[32:16.560 --> 32:18.560] 很长的一段
[32:18.560 --> 32:20.560] 然后这个语言
[32:20.560 --> 32:22.560] 就Common Lisp这个语言很大
[32:22.560 --> 32:25.600] 但是放在现在来看的话也不是那么大
[32:25.600 --> 32:27.600] 因为在那个年代还没有
[32:27.600 --> 32:29.600] Unicode还没有规范化
[32:29.600 --> 32:31.600] 多显存还没有规范化
[32:31.600 --> 32:33.600] 很多东西都没有规范化
[32:33.600 --> 32:35.600] 甚至还没有
[32:35.600 --> 32:37.600] 甚至很多语言还不支持这些东西
[32:37.600 --> 32:39.600] 那时候CCR家也没有规范化的吧
[32:39.600 --> 32:43.600] 那本书是80年到85年的时候
[32:43.600 --> 32:45.600] 1980到85年的时候
[32:45.600 --> 32:47.600] 总而言之就是
[32:47.600 --> 32:49.600] 我个人是不太建议去
[32:49.600 --> 32:51.600] 通过那本书来学习Common Lisp
[32:51.600 --> 32:53.600] Common Lisp有两本其他书叫做
[32:53.600 --> 32:55.600] Anti-Common Lisp和Only Lisp
[32:55.600 --> 32:57.600] 这两本书是
[32:57.600 --> 32:59.600] 比较建议来学这个
[32:59.600 --> 33:01.600] 这个Common Lisp的书
[33:01.600 --> 33:03.600] 因为
[33:03.600 --> 33:07.600] 因为你如果去读一个语言的
[33:07.600 --> 33:09.600] Specification就算读下来
[33:09.600 --> 33:11.600] 你可能还是不会写
[33:11.600 --> 33:13.600] 还是不太会写这个语言的代码
[33:13.600 --> 33:15.600] 更不要说去Debug
[33:15.600 --> 33:17.600] 去Distribute
[33:17.600 --> 33:19.600] 你的代码
[33:19.600 --> 33:21.600] 是吧
[33:21.600 --> 33:23.600] 在总的来说的话
[33:23.600 --> 33:25.600] 我甚至不推荐
[33:25.600 --> 33:27.600] 用Common Lisp来学
[33:27.600 --> 33:29.600] 这个Lisp
[33:29.600 --> 33:31.600] 因为学Common Lisp的话
[33:31.600 --> 33:33.600] 还有一个问题就是你得会Emacs
[33:33.600 --> 33:35.600] 这意味着
[33:35.600 --> 33:37.600] 你为了要学Lisp
[33:37.600 --> 33:39.600] 得学另外一个工具
[33:39.600 --> 33:41.600] 除非你已经会Emacs
[33:41.600 --> 33:43.600] 然后学Emacs的时候
[33:43.600 --> 33:45.600] 你肯定多少还要会
[33:45.600 --> 33:47.600] 写一点它的Emacs Lisp
[33:47.600 --> 33:49.600] Emacs Lisp又是
[33:49.600 --> 33:51.600] Lisp的一个方言
[33:51.600 --> 33:53.600] 然后它跟Common Lisp又不一样
[33:53.600 --> 33:55.600] 所以就很容易就纏在一起
[33:55.600 --> 33:57.600] 我是这么觉得的
[33:57.600 --> 33:59.600] 如果你真想学Common Lisp的话
[33:59.600 --> 34:01.600] 可能要花不少时间
[34:01.600 --> 34:03.600] 才能走下来
[34:03.600 --> 34:05.600] 我更推荐去学Skip
[34:05.600 --> 34:07.600] 有本好书是北京大学
[34:07.600 --> 34:09.600] 邱宗彦老师翻译的
[34:09.600 --> 34:11.600] 叫
[34:11.600 --> 34:13.600] 很多人都听过我吧
[34:13.600 --> 34:15.600] 叫SICP
[34:15.600 --> 34:17.600] 计算机程序的构造与解释
[34:17.600 --> 34:19.600] 这本书我觉得
[34:19.600 --> 34:21.600] 写的挺好
[34:21.600 --> 34:23.600] 中文它有的翻译
[34:23.600 --> 34:25.600] 它翻译的年代比较久远
[34:25.600 --> 34:27.600] 有的地方翻译的比较奇怪
[34:27.600 --> 34:29.600] 但整本书我觉得还是
[34:29.600 --> 34:31.600] 很值得读一读的
[34:31.600 --> 34:33.600] 当年这本书是MIT的
[34:33.600 --> 34:35.600] 相当于Introduction to Computer Science
[34:35.600 --> 34:37.600] 就是入门课
[34:37.600 --> 34:39.600] 入门课
[34:39.600 --> 34:41.600] 我觉得这本书难度非常高
[34:41.600 --> 34:43.600] 其实就是反映出了
[34:43.600 --> 34:45.600] 这个程序员的
[34:45.600 --> 34:47.600] 时代的一个变化
[34:47.600 --> 34:49.600] 当年的程序员可能是
[34:49.600 --> 34:51.600] 很多很多东西
[34:51.600 --> 34:53.600] 它这本书里面讲到很多像我们之前提到的东西
[34:53.600 --> 34:55.600] 洛兴求智也好啊
[34:55.600 --> 34:57.600] 克里挖也好啊
[34:57.600 --> 34:59.600] 函数之一等公民啊那些东西
[34:59.600 --> 35:01.600] 它其实都提到了
[35:01.600 --> 35:03.600] 但是现在你想做一个程序员
[35:03.600 --> 35:05.600] 其实这些东西都没有必要在一个个学得那么深了
[35:05.600 --> 35:07.600] 因为都有包
[35:07.600 --> 35:09.600] 有一个SCHEME的方言叫做Racket
[35:09.600 --> 35:11.600] 我非常建议可以用Racket来去学SICP
[35:11.600 --> 35:13.600] Racket是比较成熟的一个IDE
[35:13.600 --> 35:15.600] 相当成熟的一个IDE
[35:15.600 --> 35:17.600] 所以在有IDE的情况下
[35:17.600 --> 35:19.600] 并且那个IDE的按键绑定好像是有Emacs
[35:19.600 --> 35:21.600] 有Vim
[35:21.600 --> 35:23.600] 有MacOS
[35:23.600 --> 35:25.600] 就是它绑定还是比较多样的
[35:25.600 --> 35:27.600] 可定制性还是比较优化的
[35:27.600 --> 35:29.600] 所以我建议大家去试试看
[35:29.600 --> 35:31.600] 这个Racket
[35:31.600 --> 35:33.600] 其实是一个很好的方案
[35:33.600 --> 35:35.600] 因为它是一个很好的方案
[35:35.600 --> 35:37.600] 可定制性还是比较友好
[35:37.600 --> 35:39.600] 还比较高的
[35:39.600 --> 35:41.600] Racket本身也是一个比较成熟的LISP方言
[35:41.600 --> 35:43.600] 我觉得LISP在黑客文化里面
[35:43.600 --> 35:45.600] 还是有一定地位的
[35:45.600 --> 35:47.600] 在整个黑客历史里面
[35:47.600 --> 35:49.600] 在历史里面肯定是有一定地位的
[35:49.600 --> 35:51.600] 但是在整个黑客文化里面
[35:51.600 --> 35:53.600] 还是挺特殊的一个东西
[35:53.600 --> 35:55.600] 哪怕现在很多人可能不知道LISP
[35:55.600 --> 35:57.600] 或者看它这个括号
[35:57.600 --> 35:59.600] 或者它这个语法
[35:59.600 --> 36:01.600] 因为很多人看到这个括号
[36:01.600 --> 36:03.600] 就会把它和语法结合起来
[36:03.600 --> 36:05.600] 但其实LISP的语法相当相当简单
[36:05.600 --> 36:07.600] 相当相当简单
[36:07.600 --> 36:09.600] 基本上如果以后我有孩子
[36:09.600 --> 36:11.600] 我基本上很有信心
[36:11.600 --> 36:13.600] 能在一天的时间内
[36:13.600 --> 36:15.600] 哪怕只有小学的阅历
[36:15.600 --> 36:17.600] 基本上有信心
[36:17.600 --> 36:19.600] 能在一天的时间内
[36:19.600 --> 36:21.600] 把它交回LISP的编程
[36:21.600 --> 36:23.600] 非常非常简单
[36:23.600 --> 36:25.600] LISP的成功之处
[36:25.600 --> 36:27.600] 我觉得就在于一个非常简单的语言
[36:27.600 --> 36:29.600] 可以被复杂到
[36:29.600 --> 36:31.600] 可以被复杂到
[36:31.600 --> 36:33.600] 被复杂到现在的这个状态
[36:33.600 --> 36:35.600] 所谓的复杂就是有更多的
[36:35.600 --> 36:37.600] 优化
[36:37.600 --> 36:39.600] 有更多的控制构造
[36:39.600 --> 36:41.600] 更多的抽象
[36:41.600 --> 36:43.600] 不是说不必要的复杂
[36:43.600 --> 36:45.600] 时间也差不多了
[36:45.600 --> 36:47.600] 到最后我们的推荐环节
[36:47.600 --> 36:49.600] 我给大家推荐一个叫
[36:49.600 --> 36:51.600] Notion的笔记应用
[36:51.600 --> 36:53.600] 我觉得它
[36:53.600 --> 36:55.600] 首先你不要把它看成一个
[36:55.600 --> 36:57.600] 纯粹的笔记应用
[36:57.600 --> 36:59.600] 它是可以给你建一个个人的
[36:59.600 --> 37:01.600] 一个人的笔记
[37:01.600 --> 37:03.600] 用来让你管理知识的
[37:03.600 --> 37:05.600] 当然了可能是因为我不怎么做笔记
[37:05.600 --> 37:07.600] 我大多数是只在PDF上标注
[37:07.600 --> 37:09.600] 或者做一些脑图
[37:09.600 --> 37:11.600] 这样的事情
[37:11.600 --> 37:13.600] 其实做笔记
[37:13.600 --> 37:15.600] 单独把文章里的东西摘出来
[37:15.600 --> 37:17.600] 做笔记这种事情
[37:17.600 --> 37:19.600] 其实我做的并不是很多
[37:19.600 --> 37:21.600] 所以我可能更喜欢Notion
[37:21.600 --> 37:23.600] 它的层级会非常清晰
[37:23.600 --> 37:25.600] 就一个概念
[37:25.600 --> 37:27.600] 它下面有各种纸条
[37:27.600 --> 37:29.600] 这些东西它非常适合做这个事情
[37:29.600 --> 37:31.600] 然后
[37:31.600 --> 37:33.600] 你如果做脑图的时候
[37:33.600 --> 37:35.600] 你肯定会加各种多媒体的reference
[37:35.600 --> 37:37.600] 图片视频什么的
[37:37.600 --> 37:39.600] 它也非常适合干这个事情
[37:39.600 --> 37:41.600] 或者甚至是PDF
[37:41.600 --> 37:43.600] 因为它可以把上传上去的多媒体
[37:43.600 --> 37:45.600] 直接嵌在当前的页面上
[37:45.600 --> 37:47.600] 所以觉得它非常适合做
[37:47.600 --> 37:49.600] 就是个人Wiki
[37:49.600 --> 37:53.600] 当然个人Wiki和笔记的区分到底哪里
[37:53.600 --> 37:55.600] 我也说不清了
[37:55.600 --> 37:57.600] 像Evernote这些应用
[37:57.600 --> 37:59.600] 所以我这边推荐就是利用Notion
[37:59.600 --> 38:01.600] 这样的个人Wiki
[38:01.600 --> 38:03.600] 相当于你把
[38:03.600 --> 38:05.600] 你读过的东西编译成一个数据结构
[38:05.600 --> 38:07.600] 然后把这个数据结构保存在Notion里面
[38:07.600 --> 38:09.600] 如果你想写博客
[38:09.600 --> 38:11.600] 或者做脑图
[38:11.600 --> 38:13.600] 或者做PPT什么的
[38:13.600 --> 38:15.600] 只要再把这个数据结构
[38:15.600 --> 38:17.600] 重新打印成
[38:17.600 --> 38:19.600] 或者编译成
[38:19.600 --> 38:21.600] 你想要定制的形式就可以了
[38:21.600 --> 38:23.600] 这个比喻我觉得是我比较推荐的形式
[38:23.600 --> 38:25.600] OK那这一期的节目我们就到这里
[38:25.600 --> 38:27.600] 跟大家说再见了
[38:27.600 --> 38:29.600] 也不知道蓝云堂会不会发钱给我
[38:29.600 --> 38:31.600] 但我还是来了
[38:31.600 --> 38:33.600] 希望
[38:33.600 --> 38:35.600] 可以积极地指出我的错误
[38:35.600 --> 38:37.600] 我们今天说的东西都比较
[38:37.600 --> 38:39.600] 可能我也有口误吧
[38:39.600 --> 38:41.600] 如果你针对
[38:41.600 --> 38:43.600] 还是变成感兴趣的话
[38:43.600 --> 38:45.600] 就随便挑一门高级语言
[38:45.600 --> 38:47.600] 起码现在很多高级语言都只是这些特性
[38:47.600 --> 38:49.600] 大胆地去练就好了
[38:49.600 --> 38:51.600] 不用去纠结于
[38:51.600 --> 38:53.600] 到底是OCaml还是Haskell
[38:53.600 --> 38:55.600] 只要大胆去学
[38:55.600 --> 38:57.600] 就可以了
[38:57.600 --> 39:21.600] OK大家再见
[39:27.600 --> 39:29.600] OK
[39:29.600 --> 39:31.600] OK
[39:31.600 --> 39:33.600] OK
[39:33.600 --> 39:35.600] OK
[39:35.600 --> 39:37.600] OK
[39:37.600 --> 39:39.600] OK
[39:39.600 --> 39:41.600] OK
[39:41.600 --> 39:43.600] OK
[39:43.600 --> 39:45.600] OK
[39:45.600 --> 39:47.600] OK
[39:47.600 --> 39:49.600] OK
[39:49.600 --> 39:51.600] OK
[39:51.600 --> 39:53.600] OK
[39:53.600 --> 39:55.600] OK
[39:55.600 --> 39:57.600] OK
[39:57.600 --> 39:59.600] OK
[39:59.600 --> 40:01.600] OK
[40:01.600 --> 40:03.600] OK
[40:03.600 --> 40:05.600] OK
[40:05.600 --> 40:07.600] OK
[40:07.600 --> 40:09.600] OK
[40:09.600 --> 40:11.600] OK
[40:11.600 --> 40:13.600] OK
[40:13.600 --> 40:15.600] OK
[40:15.600 --> 40:17.600] OK
[40:17.600 --> 40:19.600] OK
[40:19.600 --> 40:21.600] OK
[40:21.600 --> 40:23.600] OK
[40:23.600 --> 40:25.600] OK
[40:25.600 --> 40:27.600] OK
[40:27.600 --> 40:29.600] OK
[40:29.600 --> 40:31.600] OK
[40:31.600 --> 40:33.600] OK
[40:33.600 --> 40:35.600] OK
[40:35.600 --> 40:37.600] OK
[40:37.600 --> 40:39.600] OK
[40:39.600 --> 40:41.600] OK
[40:41.600 --> 40:43.600] OK
[40:43.600 --> 40:45.600] OK
[40:45.600 --> 40:47.600] OK
[40:47.600 --> 40:49.600] OK
[40:49.600 --> 40:51.600] OK
