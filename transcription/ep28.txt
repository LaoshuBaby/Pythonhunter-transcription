[00:00.000 --> 00:29.960] 大家好欢迎来到
[00:29.960 --> 00:31.720] 最新一期的补舌者说
[00:31.720 --> 00:33.600] 我是主持人Like9M
[00:33.600 --> 00:36.400] 然后今天另外一位主播是小白
[00:36.400 --> 00:37.600] 和大家打个招呼吧
[00:37.600 --> 00:39.200] 大家好我是小白
[00:39.200 --> 00:40.360] 然后今天我们的
[00:40.360 --> 00:42.600] 我们请到的嘉宾是郑立迪
[00:42.600 --> 00:45.000] 然后是我在Google的同事
[00:45.000 --> 00:49.200] 他在Google是负责GRPC和Python这一块
[00:49.200 --> 00:50.920] 所以我们想今天请他来
[00:50.920 --> 00:54.240] 是聊一聊有关就是GRPC的一些话题
[00:54.240 --> 00:55.520] 那么在此之前
[00:55.520 --> 00:58.160] 我们先请他来介绍一下自己吧
[00:58.160 --> 00:59.720] Hello大家好
[00:59.720 --> 01:00.760] 我是郑立迪
[01:00.760 --> 01:02.800] 然后我现在是一个
[01:02.800 --> 01:04.080] 我现在在谷歌工作
[01:04.080 --> 01:07.480] 然后我每天主要工作就是维护GRPC Python
[01:07.480 --> 01:10.840] 然后我去年做的一个比较大的
[01:10.840 --> 01:12.080] 跟Python相关的项目
[01:12.080 --> 01:14.680] 是发布了GRPC Python的Async
[01:14.680 --> 01:15.560] 还有API
[01:15.560 --> 01:18.240] 然后我用Python的话
[01:18.240 --> 01:20.520] 大概有六七年的历史
[01:20.520 --> 01:22.800] 但一开始主要是写一些小工具
[01:22.800 --> 01:24.039] 小脚本之类的
[01:24.039 --> 01:26.200] 然后直到最近三年加入谷歌之后
[01:26.200 --> 01:29.120] 才开始认真的使用这本语言
[01:29.120 --> 01:31.560] 我们先回溯一下
[01:31.560 --> 01:33.800] 就是你方便透露一下
[01:33.800 --> 01:35.600] 你是从哪个学校毕业的吗
[01:35.600 --> 01:39.000] 或者如果不方便也可以不说
[01:39.000 --> 01:41.920] 就我本科是在人民大学
[01:41.920 --> 01:46.360] 然后我的硕士是在卡奈金梅隆
[01:46.360 --> 01:49.080] 哇人大是不是
[01:49.080 --> 01:50.560] 就是一说起人大
[01:50.560 --> 01:52.320] 大家不会想到是学计算机吗
[01:52.320 --> 01:55.400] 就感觉是金融啊什么这种方面
[01:55.400 --> 01:56.560] 对呀
[01:56.560 --> 01:58.320] 所以我们就是一个二等学科
[01:58.320 --> 01:59.919] 我们的那个教学楼都在
[01:59.919 --> 02:03.440] 就是整个学校学院的最边上
[02:03.440 --> 02:04.880] 最破的一栋
[02:04.880 --> 02:07.839] 在人大学计算机是个什么样的感觉
[02:07.839 --> 02:11.039] 在人大学计算机
[02:11.039 --> 02:13.440] 其实我之前是有打OI的
[02:13.440 --> 02:15.280] 所以我刚开始进来的时候
[02:15.280 --> 02:16.320] 我觉得课程太简单
[02:16.320 --> 02:17.680] 我就跑去教务处说
[02:17.680 --> 02:20.400] 老师我能不能直接上大三大四的课程
[02:20.400 --> 02:21.320] 老师说不行
[02:21.320 --> 02:22.240] 就算是同样的知识
[02:22.240 --> 02:23.799] 你再听一遍也会有新的收获
[02:23.799 --> 02:25.320] 那就不要赶出去了
[02:25.320 --> 02:28.440] 那最后你就再听吗
[02:28.440 --> 02:30.239] 还是你就敲课不去了
[02:30.239 --> 02:34.600] 然后我就开始了就是堕落的大学生活呀
[02:34.600 --> 02:36.600] 那为什么就是你打OI的话
[02:36.600 --> 02:37.400] 你是保送吗
[02:37.400 --> 02:38.799] 还是你是高考
[02:38.799 --> 02:39.720] 我是保送
[02:39.720 --> 02:40.440] 对
[02:40.440 --> 02:41.079] 保送
[02:41.079 --> 02:42.280] 那为什么不选
[02:42.280 --> 02:45.880] 比如说一些更传统的比较强的学校呢
[02:45.880 --> 02:50.000] 像就是上海交大或者北航什么北邮这种
[02:50.000 --> 02:52.160] 因为当年其实我考瓜
[02:52.160 --> 02:53.880] 当年有一道题我做出来了
[02:53.880 --> 02:57.320] 但是我的测试输出没有删
[02:57.320 --> 02:58.320] OK
[02:58.320 --> 02:59.840] 然后挂了100分
[02:59.840 --> 03:03.040] 于是我就没有选择其实
[03:03.040 --> 03:07.880] 不对人大难道分比那些要低吗你的意思是
[03:07.880 --> 03:12.880] 就是人大他在竞赛这方面
[03:12.880 --> 03:16.079] 他确实竞争力不如清北和上交之类的
[03:16.079 --> 03:17.079] OK
[03:17.079 --> 03:18.079] 那跟
[03:18.079 --> 03:20.200] 所以就相当于反正轮到你选的话
[03:20.200 --> 03:22.440] 最好的也就只有人大是吧
[03:22.440 --> 03:23.440] 是这个意思
[03:23.440 --> 03:24.440] 对差不多
[03:24.440 --> 03:27.040] 但感觉这样子说会不会对母校有点不敬
[03:27.040 --> 03:31.079] 没事这个大家都会调侃什么考败来这之类的
[03:31.079 --> 03:34.840] 也是大家都是第三名
[03:34.840 --> 03:36.840] 是
[03:36.840 --> 03:41.160] 那然后你结束Python是一个什么样的契机呢
[03:41.160 --> 03:42.920] 我觉得学校里应该是不教对吧
[03:42.920 --> 03:44.960] 学校里不教
[03:44.960 --> 03:45.800] 对
[03:45.800 --> 03:48.079] 但一开始学Python的时候
[03:48.079 --> 03:50.240] 我好像是自己搭了一个Jungle服务器
[03:50.240 --> 03:52.560] 然后我就找了一个中文的Jungle教程
[03:52.560 --> 03:54.320] 然后就一页一页的跟下来
[03:54.320 --> 03:55.840] 然后就把它学下来了
[03:55.840 --> 03:57.520] 就纯粹是兴趣
[03:57.520 --> 04:00.720] 所以当然就是可能也是想做一个网站了
[04:00.720 --> 04:01.240] 对
[04:01.240 --> 04:04.840] 但后来我发现Python最好用的还是做爬虫
[04:04.840 --> 04:09.520] 就比如说有人想要过来找我爬那种什么单美论坛的小说
[04:09.520 --> 04:11.280] 我就可以把它写一个脚本
[04:11.280 --> 04:14.720] 然后他就可以一次性爬个十几二十本小说
[04:14.720 --> 04:17.640] 或者是最近像显卡不是特别难抢吗
[04:17.640 --> 04:19.120] 我就自己写了一个程序
[04:19.120 --> 04:20.760] 然后把它放在树莓上跑
[04:20.760 --> 04:22.760] 然后就自己去看有没有显卡放出来
[04:22.760 --> 04:25.039] 然后就可以去买这样子
[04:25.039 --> 04:26.840] 不错不错
[04:26.840 --> 04:31.640] 那这个我们要深入挖掘一下帮妹子下小说这个话题对吧
[04:31.640 --> 04:35.159] 所以有什么
[04:35.159 --> 04:37.159] 所以能靠Python找到妹子吗
[04:37.159 --> 04:40.760] 最后这个妹子不是靠Python找到的
[04:40.760 --> 04:41.840] OK
[04:41.840 --> 04:44.240] 那然后就是
[04:44.240 --> 04:49.280] 所以你去CMU的话应该还是比较难生的吧
[04:49.280 --> 04:52.000] 毕竟还是CMU对吧
[04:52.000 --> 04:54.599] 还行吧
[04:54.599 --> 04:59.559] 但我其实是在大学期间我一直都有在中关村干活
[04:59.559 --> 05:02.000] 所以我升进起来会比较简单一点
[05:02.000 --> 05:03.599] 相对来说
[05:03.599 --> 05:06.400] 在中关村干活是个什么状况
[05:06.400 --> 05:08.000] 你是实习吗
[05:08.000 --> 05:11.599] 就类似实习那样子给创业公司打工
[05:11.599 --> 05:14.719] 你都去哪里实习过呢
[05:14.719 --> 05:16.400] 都是一些不知名的小公司
[05:16.400 --> 05:18.119] 我觉得说出来大家也不会知道
[05:18.120 --> 05:19.560] 跟我当年差不多
[05:19.560 --> 05:21.440] 我实习过的公司绝对没人知道
[05:21.440 --> 05:24.480] 但我当年就是搜那个有哪些Python实习
[05:24.480 --> 05:26.480] 然后真的就非常非常少
[05:26.480 --> 05:28.320] 所以就随便找了一个
[05:28.320 --> 05:30.000] 那你一开始就很喜欢Python
[05:30.000 --> 05:32.200] 搜的时候就搜Python实习
[05:32.200 --> 05:34.400] 对我当时是想找一个用Python的实习
[05:34.400 --> 05:35.920] 我不是本科手是研究生手
[05:35.920 --> 05:37.760] 那时候我已经用过一段时间Python了
[05:37.760 --> 05:39.400] 所以这样子
[05:39.400 --> 05:41.400] OK所以你之后就去CMU
[05:41.400 --> 05:43.560] 然后就来了Google对吧
[05:43.560 --> 05:45.080] 对
[05:45.080 --> 05:48.640] 你想稍微聊一下就是在CMU的情况吗
[05:48.640 --> 05:50.840] 因为我觉得可能有些听众也是比较好奇的
[05:50.840 --> 05:52.680] 就大概是个什么感觉
[05:52.680 --> 05:55.719] 在这种是不是竞争非常激烈
[05:55.719 --> 05:59.479] CMU的课程安排是比较紧的
[05:59.479 --> 06:00.919] 就每周都会有小任务
[06:00.919 --> 06:02.919] 每周都会有小测试这个样子
[06:02.919 --> 06:04.760] 然后其实我印象最深的是
[06:04.760 --> 06:06.440] 他最后有一门课
[06:06.440 --> 06:07.880] 他最后是一个打榜环节
[06:07.880 --> 06:10.680] 就会大家组成那种三个人三个人一起的小队
[06:10.680 --> 06:12.080] 然后去完成同一个任务
[06:12.080 --> 06:13.400] 然后大家一起跑Benchmark
[06:13.400 --> 06:14.440] 看谁的分数比较高
[06:14.440 --> 06:15.440] 就可以带绑手
[06:15.440 --> 06:16.440] 嗯
[06:16.440 --> 06:18.680] 然后我记得我为了拼那个项目
[06:18.680 --> 06:21.000] 我们就连续编程30个小时
[06:21.000 --> 06:22.040] 就找了一间会议室
[06:22.040 --> 06:23.240] 就住在那个地方
[06:23.240 --> 06:25.160] 最后测试榜刷到了第一
[06:25.160 --> 06:26.960] 但是正式跑的时候却出8个了
[06:26.960 --> 06:29.240] 特别的后悔
[06:29.240 --> 06:30.760] 哦
[06:30.760 --> 06:33.400] 那个是个什么是个什么课程
[06:33.400 --> 06:36.720] 它是那个云计算
[06:36.720 --> 06:40.120] 然后它相当于是给你大概是多少
[06:40.120 --> 06:41.960] 1T左右的推特数据
[06:41.960 --> 06:43.159] 然后要你建数据库
[06:43.160 --> 06:47.720] 然后建完数据库要建那个后端和low balancer
[06:47.720 --> 06:49.560] 然后最后来跑那个Benchmark
[06:49.560 --> 06:51.440] 看你的这个服务器架构
[06:51.440 --> 06:53.560] 在有限的开支里面能够接受
[06:53.560 --> 06:54.920] 能够跑多少的请求
[06:54.920 --> 06:55.600] 对
[06:55.600 --> 06:56.760] 哦
[06:56.760 --> 06:58.320] 那你们当然是用什么语言写
[06:58.320 --> 06:59.160] C++
[06:59.160 --> 07:00.680] 我选择Golang
[07:00.680 --> 07:01.200] Golang
[07:01.200 --> 07:02.400] OK
[07:02.400 --> 07:03.640] C++太难写了
[07:03.640 --> 07:04.840] 我的天
[07:04.840 --> 07:05.440] 嗯
[07:05.440 --> 07:06.160] 是
[07:06.160 --> 07:06.840] OK
[07:06.840 --> 07:08.040] 嗯
[07:08.040 --> 07:09.160] 然后我觉得
[07:09.160 --> 07:09.960] 对我挺好奇
[07:09.960 --> 07:10.960] 你是一加入Google
[07:10.960 --> 07:16.680] 就进了这个GRPC的组来维护Python GRPC吗
[07:16.680 --> 07:17.280] 是的
[07:17.280 --> 07:19.599] 我刚加入进来的时候
[07:19.599 --> 07:21.479] 这个组有
[07:21.479 --> 07:23.599] 对这个组就是人基本上走光了
[07:23.599 --> 07:25.560] 之前的GRPC维护者
[07:25.560 --> 07:31.599] 所以我进来以后就相当于是承担了这个维护的任务
[07:31.599 --> 07:33.760] 那你知道他们为啥都走掉了吗
[07:33.760 --> 07:35.359] 呃
[07:35.359 --> 07:36.640] 其实我也不知道
[07:36.640 --> 07:37.240] OK
[07:37.240 --> 07:41.520] 对因为我觉得就是这种还挺怎么说
[07:41.520 --> 07:43.000] 就是呃
[07:43.000 --> 07:46.000] 就一般来讲你是没得选的吧
[07:46.000 --> 07:49.000] 我不知道你当时加入的时候是有几个组给你了offer
[07:49.000 --> 07:50.160] 然后你选了一个呢
[07:50.160 --> 07:51.280] 还是就是呃
[07:51.280 --> 07:52.240] 他们就要你了
[07:52.240 --> 07:53.560] 然后你就来这儿
[07:53.560 --> 07:54.320] 呃
[07:54.320 --> 07:55.800] 当时他是有
[07:55.800 --> 07:57.040] 我应该是看了六个组
[07:57.040 --> 07:58.200] 最后选了GRPC
[07:58.200 --> 07:59.320] 我觉得最合适
[07:59.320 --> 08:00.640] OK
[08:00.640 --> 08:03.880] 对因为这个项目在开源圈也有一定知名度
[08:03.880 --> 08:05.480] 然后我自己以前也用过
[08:05.480 --> 08:06.000] 是的
[08:06.000 --> 08:06.480] 是的
[08:06.480 --> 08:06.880] 对
[08:06.880 --> 08:08.560] 我还觉得挺羡慕的
[08:08.560 --> 08:11.719] 就是比我们这种呃干一些杂活的要好
[08:11.719 --> 08:12.880] 不会不会
[08:12.880 --> 08:13.640] 呃
[08:13.640 --> 08:15.320] 那就是你在
[08:15.320 --> 08:15.760] 呃
[08:15.760 --> 08:17.560] 就是维护GRPC这边的话
[08:17.560 --> 08:19.680] 你是只维护GRPC Python呢
[08:19.680 --> 08:20.840] 还是呃
[08:20.840 --> 08:23.920] 就是你他的主项目你也会参与
[08:23.920 --> 08:24.280] 呃
[08:24.280 --> 08:26.080] 他的主项目我也会参与
[08:26.080 --> 08:31.560] 包括他们最近现在在做一个就是服务发现相关的工作
[08:31.560 --> 08:35.799] 然后我也是在就是在为这个项目贡献代码
[08:35.799 --> 08:37.599] 但是Python还是我的主线
[08:37.599 --> 08:38.199] 对
[08:38.199 --> 08:38.880] 好
[08:38.880 --> 08:39.559] OK
[08:39.559 --> 08:41.839] 不过我今天看你好像还没有Python readability
[08:41.839 --> 08:44.400] 这个着实震惊了一下
[08:44.400 --> 08:45.160] 哦
[08:45.160 --> 08:45.760] 是这样的
[08:45.760 --> 08:48.359] 因为GRPC是一个开源项目
[08:48.359 --> 08:49.959] 我根本就没有
[08:49.959 --> 08:52.760] 内部我都没怎么提交代码
[08:52.760 --> 08:54.199] 哦
[08:54.199 --> 08:55.079] 懂了懂了懂了
[08:55.079 --> 08:56.839] 行这个这个待会也可以聊一下
[08:56.839 --> 08:57.280] OK
[08:57.280 --> 08:58.040] 那好
[08:58.040 --> 09:00.359] 那我们就是聊完了你的经历
[09:00.359 --> 09:03.040] 就正式来聊一下GRPC这边
[09:03.040 --> 09:03.760] 就是
[09:03.760 --> 09:04.359] 呃
[09:04.360 --> 09:05.840] 我们刚刚一直说RPC
[09:05.840 --> 09:07.720] 然后就但是什么是RPC呢
[09:07.720 --> 09:08.080] 呃
[09:08.080 --> 09:09.600] 要不你先来介绍一下
[09:09.600 --> 09:10.000] 好
[09:10.000 --> 09:10.320] 呃
[09:10.320 --> 09:13.280] RPC全称就是remote procedure core
[09:13.280 --> 09:16.240] 就是远程的呃过程调用
[09:16.240 --> 09:18.240] 那其实这个东西很好理解
[09:18.240 --> 09:20.160] 因为呃过程调用什么
[09:20.160 --> 09:22.320] 其实就是你调用一个函数
[09:22.320 --> 09:23.240] 就是过程调用
[09:23.240 --> 09:26.360] 那远程过程调用就是调用别的机器上的函数
[09:26.360 --> 09:29.520] 那调动别的机器上的函数调用本地有什么区别呢
[09:29.520 --> 09:30.960] 就是中间加了一层网络
[09:30.960 --> 09:32.960] 那这里面就加了很多的不确定性
[09:32.960 --> 09:33.400] 所以呢
[09:33.400 --> 09:37.560] 你可能就需要一个呃一个库去帮你处理这样的事情
[09:37.560 --> 09:37.880] 呃
[09:37.880 --> 09:38.840] 比如说
[09:38.840 --> 09:42.120] 你有很多的很多的客户端
[09:42.120 --> 09:43.959] 然后调用同一台机器上的函数
[09:43.959 --> 09:45.959] 那你要怎么做这个load balance
[09:45.959 --> 09:47.760] 或者是当这台机器不行了
[09:47.760 --> 09:48.920] 然后你要怎么切换
[09:48.920 --> 09:50.480] 无缝切换到下一台机器
[09:50.480 --> 09:52.560] 然后做呃fault tolerance
[09:52.560 --> 09:54.840] 这些都是GRPC给帮你处理的情况
[09:55.439 --> 09:55.959] 嗯
[09:55.959 --> 09:56.319] 对
[09:56.319 --> 09:59.199] 所以就是GRPC和RPC的关系是什么
[09:59.199 --> 10:00.040] 呃
[10:00.040 --> 10:01.360] GRPC的话
[10:01.360 --> 10:03.079] 它是一个RPC的框架
[10:03.080 --> 10:08.400] 它本体是实现在一个HTTP2上面的一个RPC框架
[10:08.400 --> 10:10.080] 它就是RPC一种实现
[10:10.080 --> 10:12.040] 事实上市面上有非常多的RPC
[10:12.040 --> 10:12.760] 让我想想
[10:13.520 --> 10:15.560] 比如说像微软的stripped
[10:15.560 --> 10:18.760] 或者是其他一瞬间我也想不起来
[10:18.760 --> 10:19.520] 嗯
[10:19.520 --> 10:24.040] GRPC其实就是呃反正是google做的一个一套RPC的框架嘛
[10:24.040 --> 10:26.240] 因为那个G就代表google对吧
[10:26.240 --> 10:26.680] 呃
[10:26.680 --> 10:29.520] 其实G并不是代表google
[10:29.520 --> 10:29.960] 啊
[10:29.960 --> 10:30.640] 不是吗
[10:30.640 --> 10:31.440] 不是
[10:31.440 --> 10:31.920] 对
[10:31.920 --> 10:35.599] 其实G是我们每次release的时候都会随便选一个词
[10:35.599 --> 10:36.240] 不是随便选
[10:36.240 --> 10:40.560] 就是负责这个release的人有权选择这个G代表什么
[10:40.560 --> 10:44.560] 就比如说呃我们1.0版本这个G的意思是GRPC本身
[10:44.560 --> 10:46.000] G stand for GRPC
[10:46.000 --> 10:48.959] 然后像我负责的最近的这个release1.36
[10:48.959 --> 10:50.640] 这个G的意思是gummy bear
[10:50.640 --> 10:52.319] 也就是小熊软糖
[10:52.319 --> 10:53.040] 哈哈
[10:53.040 --> 10:53.680] what
[10:53.680 --> 10:58.520] 那不是这个等会我想知道就这个名字是在哪里有体现的
[10:58.520 --> 11:01.760] 它会有一个像安卓的那样有一个版本的名字吗
[11:01.760 --> 11:02.319] 还是
[11:02.319 --> 11:04.240] 对会有一个版本的名字
[11:04.240 --> 11:08.840] 会跟着你的release原代码shift的时候会写在那个里面
[11:08.840 --> 11:10.400] 哦
[11:10.400 --> 11:11.480] 这
[11:11.480 --> 11:13.240] 长见识了
[11:13.240 --> 11:15.080] 这个呃感觉很有意思
[11:15.080 --> 11:16.840] 这个这个为什么会这样的
[11:16.840 --> 11:20.400] 就只是一个呃一种相当于程序员的幽默吗
[11:20.400 --> 11:21.040] 还是
[11:21.040 --> 11:23.240] 对我觉得像是一个小彩蛋
[11:23.240 --> 11:24.400] 嗯
[11:24.400 --> 11:25.600] ok ok
[11:25.600 --> 11:28.760] 那你要不再介绍一下像GRPC支持的语言啊
[11:28.760 --> 11:30.720] 然后就是实现原理这些
[11:30.720 --> 11:34.320] 哦GRPC它支持的语言很多
[11:34.320 --> 11:39.200] 它支持像呃python ruby php java golang
[11:39.200 --> 11:42.480] 呃甚至还有rust和swift
[11:42.480 --> 11:47.760] 但是我们官方支持的就只有呃首先是c++ java
[11:47.760 --> 11:48.440] golang
[11:48.440 --> 11:50.800] 然后还有python node c sharp
[11:50.800 --> 11:51.280] objective
[11:51.280 --> 11:53.080] 反正就是支持非常多的语言
[11:53.080 --> 11:57.800] 然后呃下一个问题是什么来着
[11:57.800 --> 11:59.880] 它的实现原理
[11:59.880 --> 12:06.920] 呃它的实现原理它是一个建立在http2之上的RPC框架
[12:06.920 --> 12:11.800] 对我觉得这个就是一般大家说起GRPC最呃最常被提及的一点吧
[12:11.800 --> 12:16.560] 就是它是那个呃http2用http2的
[12:16.560 --> 12:22.840] 因为像像其他的RPC可能就直接是呃在tcp之上自己弄了一个协议
[12:22.840 --> 12:23.120] 对吧
[12:23.120 --> 12:29.040] 那就说嗯为什么GRPC要用http2呢
[12:29.040 --> 12:33.839] 嗯一开始想的是http2可以在更多的场合
[12:33.839 --> 12:37.199] 比如说很多proxy它不一定支持你自己
[12:37.199 --> 12:41.319] 呃不一定支持这些比较活改过的tcp的版本
[12:41.319 --> 12:43.839] 它但它应该会支持http2
[12:43.839 --> 12:45.760] 呃还有就是它的优势
[12:45.760 --> 12:49.480] 但它的优势主要相对来说是针对http1.1的
[12:49.480 --> 12:52.199] 就相对于http1.1的
[12:52.199 --> 12:56.000] 因为http1.1就有很多就是被人诟病的情况
[12:56.000 --> 12:59.320] 比如说呃它每个连接只能同时处理一个请求
[12:59.320 --> 13:04.320] 或者是它有那个呃head of line blocking的问题
[13:04.320 --> 13:06.840] 就是你前一个请求没有处理完
[13:06.840 --> 13:09.600] 你下一个请求就没有办法开始之类的问题
[13:09.600 --> 13:16.520] 但http2它就是它最大的特性就是呃它的一个connection可以同时处理非常多的请求
[13:16.520 --> 13:20.440] 就你一个请求它所有的那种小的小的request
[13:20.440 --> 13:24.240] 它会变成像是一个小的呃像是stream一样
[13:24.240 --> 13:28.640] 就你同时可以处理可能成千上万个stream用同一个connection都是没有问题的
[13:28.640 --> 13:37.640] 嗯是对这个呃反正http2还是就是应该前几年还是一个比较火的话题吧
[13:37.640 --> 13:40.720] 然后我当时也稍微研究过一下还写过几篇文章
[13:40.720 --> 13:45.680] 呃我比较好奇你们对然后我比较好奇你们用过
[13:45.680 --> 13:50.760] 就是用了http2里的哪些呃就哪些设施呢
[13:50.760 --> 13:55.760] 比如说它的那个流控制啊优先级或者这些东西你们都用了吗
[13:55.760 --> 13:57.760] 还是只是套一个壳相当于
[13:57.760 --> 14:01.840] 呃流控制我们用的比较多
[14:01.840 --> 14:07.880] 因为在streaming ap在streaming RPC的时候我们会用流控制来保护后端的服务器
[14:07.880 --> 14:10.640] 就流控制本身它就是一个保护机制嘛
[14:10.640 --> 14:13.680] 嗯对你先介你要不先介绍一下什么是流控制
[14:13.680 --> 14:22.319] 流控制其实是呃在就是扣呃在在一个RPC请求里面客户端可以不停的给后端发数据
[14:22.319 --> 14:25.160] 但有时候有这个情况就那个客户端性能太强了
[14:25.160 --> 14:27.520] 然后后端他数据可能处理不过来
[14:27.520 --> 14:30.199] 那么这个数据就可能一直堆积在后端服务器
[14:30.199 --> 14:32.640] 然后慢慢堆积堆积后端的内存就炸这种情况
[14:32.640 --> 14:38.520] 所以流控制它的机制就是后端当他发现自己收到的数据已经处理不过来的时候
[14:38.520 --> 14:42.240] 他就会开始就是pushback拒绝客户端这边的请求
[14:42.240 --> 14:45.080] 相当于形成一个自动的就是限流功能
[14:45.080 --> 14:49.880] 嗯对就它有一些那些一些window的一些设定啊
[14:49.880 --> 14:53.720] 然后就是呃就是但我不知道这些能改吗
[14:53.720 --> 14:55.560] 还是它就是一个固定的值
[14:55.560 --> 14:57.720] 呃这些都是能改的
[14:57.720 --> 15:02.760] 呃举个例子比如说呃比如说你在中国
[15:02.760 --> 15:06.720] 然后你要做一个服务美国美国区用户的一个服务
[15:06.720 --> 15:11.000] 那你的这个呃这个flow control的window就可以限制的比较大
[15:11.000 --> 15:14.360] 因为有可能你这个数据在发的过程中你还没到
[15:14.360 --> 15:16.400] 但是又但是由于中美距离很远
[15:16.400 --> 15:18.360] 所以可能有非常多的数据在路上
[15:18.360 --> 15:20.560] 你这个buffer就可以设的宽一点对吧
[15:20.560 --> 15:22.240] 但buffer设的宽也有坏处
[15:22.240 --> 15:24.440] 就它可能会影响你的响应时间
[15:24.880 --> 15:25.920] 这个怎么说呢
[15:25.920 --> 15:29.440] 就比如说你中间有很多层的proxy就像一个后端服务
[15:29.440 --> 15:34.400] 然后假设每一层proxy都可能存个几百兆的这个服务请求的话
[15:34.400 --> 15:39.400] 那还有可能有可能就是你的请求会被堆积在某一个proxy
[15:39.400 --> 15:42.120] 然后导致它最后响应时间变慢
[15:42.120 --> 15:42.880] 嗯
[15:42.880 --> 15:44.079] 所以对
[15:44.079 --> 15:45.160] 明白了明白了
[15:45.160 --> 15:50.560] 那像就是呃什么server push这种你们应该是没有用了对吧
[15:50.560 --> 15:54.720] 呃这个没有这个我们主要是客户端发起的
[15:54.720 --> 15:55.720] ok
[15:55.720 --> 15:59.800] 但但我们也支持server端的那个streaming RPC
[15:59.800 --> 16:01.600] 对呃streaming
[16:01.600 --> 16:05.480] 它的streaming应该跟http2的那个是
[16:05.480 --> 16:07.480] 是用它的那个server push那套吗
[16:07.480 --> 16:09.800] 还是就是是怎么实现的呢
[16:09.800 --> 16:11.280] 呃
[16:11.280 --> 16:14.160] 它streaming应该是用server push吧
[16:14.160 --> 16:16.320] 就是客户端发一个简短的请求
[16:16.320 --> 16:20.800] 然后服务端就是用server push来回应
[16:20.800 --> 16:23.400] 比较常见的场景就是像数据库之类的
[16:23.400 --> 16:25.200] 就你发一个很短的请求
[16:25.200 --> 16:29.400] 然后就给你一页一页的把那个数据库的数据给你还过去
[16:29.400 --> 16:30.280] 嗯
[16:30.280 --> 16:31.000] ok
[16:31.000 --> 16:35.920] 呃就还有个问题是呃现在不是那个http3又出来了吗
[16:35.920 --> 16:39.760] 然后然后这个又怎么说
[16:39.760 --> 16:47.000] 就是就是会不会以后翻大家发现那个就是最长支持的http协议反而又不是http2了
[16:47.000 --> 16:49.560] 然后那会不会影响gRPC呢
[16:49.560 --> 16:53.839] 呃事实上http2本身我觉得它支持的范围就很有限
[16:53.839 --> 16:57.199] 比如说呃它其实相对http1有它有个劣势
[16:57.199 --> 16:59.880] 就它浏览器的支持不够好
[16:59.880 --> 17:05.879] 呃像比如说你没办法直接用javascript在chrome之类的浏览器里面用gRPC
[17:05.880 --> 17:11.240] 因为像http它现在不是有那个呃header还有trailer
[17:11.240 --> 17:14.200] trailer header就相当于它的呃header
[17:14.200 --> 17:16.280] 这个应该叫翻译成什么
[17:16.280 --> 17:20.200] 呃反正就是它的这个请求头有可能在前面有可能在后面
[17:20.200 --> 17:26.080] 但是chrome它并不允许把那个在后面的请求头发给就是开发者
[17:26.080 --> 17:29.840] 总而言之就是gRPC因为使用http2
[17:29.840 --> 17:33.440] 但http2目前在浏览器里面就只能用来请求资源文件
[17:33.440 --> 17:35.640] 并不能使用它来开发
[17:35.640 --> 17:36.640] 应用
[17:36.640 --> 17:37.640] 嗯
[17:38.840 --> 17:39.840] 不太懂
[17:39.840 --> 17:42.840] 就是请呃相当于
[17:43.280 --> 17:46.280] 就相当于你比如说你去搞一个这种
[17:46.280 --> 17:49.960] 呃你要动态的拿一些数据回来填充页面
[17:49.960 --> 17:52.200] 然后这个就不能用http2吗
[17:52.200 --> 17:54.600] 意思是就只能去请求图片那些东西
[17:54.960 --> 17:59.000] 呃对目前最大的用处还是请求图片之类的
[17:59.000 --> 18:00.000] 嗯
[18:00.440 --> 18:01.440] 这样啊
[18:02.800 --> 18:05.080] 对然后接下来说到http3
[18:05.080 --> 18:10.000] http3其实它的呃protocol本身和http2是几乎一样
[18:10.000 --> 18:13.399] 它唯一的区别是http2它是跑在tcp上
[18:13.399 --> 18:15.840] 而http3跑在udp上
[18:16.480 --> 18:20.919] 所以呃未来会用http3吗
[18:20.919 --> 18:25.399] 感觉不太会因为RPC还是要建立在tcp上的感觉
[18:26.080 --> 18:30.320] 呃其实呃http3它本身也有像从事啊
[18:30.320 --> 18:32.399] 就是保证数据完整性之类的
[18:32.399 --> 18:34.240] 呃一些一些措施
[18:34.240 --> 18:36.160] 但我这是我个人觉得
[18:36.160 --> 18:39.320] 我觉得udp用起来还是比较困难
[18:39.320 --> 18:43.480] 因为很多呃网络服务商他不一定会
[18:43.840 --> 18:46.160] 就他可能udp的权限会设置比较低
[18:46.160 --> 18:48.760] 就比如说tcp现在流量比较大
[18:48.760 --> 18:52.560] 那他可能就会把udp这些没有必要的包就给drop了
[18:52.560 --> 18:54.560] 那你的使用用户体验就会很差
[18:55.480 --> 19:00.440] 哦我这个倒是第一次听说你的网络服务商只是isp吗
[19:00.720 --> 19:01.320] 这种
[19:01.320 --> 19:04.919] 就不管是isp或者是cloud provider
[19:04.919 --> 19:08.159] 就你很难保证就是在tcp和udp之间的公平
[19:08.159 --> 19:10.360] 而在tcp和udp之间
[19:10.360 --> 19:14.760] 因为udp是呃它的稳定性的保障是不那么
[19:14.760 --> 19:15.840] 不那么solid的
[19:15.840 --> 19:18.000] 所以他可能会有这样的问题
[19:18.000 --> 19:20.600] 是呃等会就是就是呃
[19:20.600 --> 19:24.560] 我不知道你说的保障到底是就是udp协议本身
[19:24.560 --> 19:26.879] 还是说网络服务商他有一个取舍
[19:26.879 --> 19:30.399] 因为我们知道就是udp本身是就是呃
[19:30.400 --> 19:34.480] 相当于就不如就怎么说不如tcp的那个呃
[19:34.480 --> 19:35.640] 应该叫保障还是叫
[19:35.640 --> 19:38.160] 但你刚刚又提到说网络服务商他本身有个取舍
[19:39.000 --> 19:41.760] 具体这个我也不是不是非常的清楚
[19:43.000 --> 19:43.920] ok ok
[19:43.920 --> 19:44.720] 嗯
[19:45.520 --> 19:47.640] 这对因为感觉这个还挺有意思
[19:47.640 --> 19:50.840] 就是哦以前还没太没太听说过
[19:51.120 --> 19:55.240] 嗯这个跟那个说的那个叫网络中立性有关吗
[19:55.240 --> 19:56.840] 还是是两码事
[19:57.640 --> 19:59.040] 我觉得是有关系的
[19:59.040 --> 20:03.680] 嗯感觉感觉这个话题如果就是听众
[20:03.680 --> 20:05.639] 中有特别懂的也可以联系我们
[20:05.639 --> 20:07.480] 呃可以可以来做一期节目
[20:07.480 --> 20:08.639] 对ok
[20:08.639 --> 20:11.399] 然后关于jrbc还有一个比较大特点吧
[20:11.399 --> 20:14.240] 就是他用了一个叫做protocol buffer的东西
[20:14.240 --> 20:18.480] 嗯protocol buffer他其实就是google做的一个这种
[20:18.480 --> 20:22.639] 呃二进制的二进制的传输协议
[20:22.639 --> 20:23.760] 应该可以这么说
[20:23.760 --> 20:26.040] 呃也不是也也不能说就是传输协议
[20:26.040 --> 20:29.040] 应该就是二进制的一种格式吧
[20:29.040 --> 20:30.639] 呃要不你来讲一下
[20:30.639 --> 20:33.000] 哦我觉得他有点像一个契约
[20:33.000 --> 20:35.720] 就是在日常开发中大家都会遇到
[20:35.720 --> 20:37.280] 比如说前端要给后端发数据
[20:37.280 --> 20:40.760] 那么他要制定说我的这个数据里面包含什么东西
[20:40.760 --> 20:44.200] 那么protocol buffer就是一个这个定义api的一门语言
[20:44.200 --> 20:47.080] 他就可以说比如说我请求这个服务
[20:47.080 --> 20:48.360] 我要给你发的信息
[20:48.360 --> 20:50.280] 呃数据里面有哪些信息
[20:50.280 --> 20:51.960] 然后每个域是什么类型
[20:51.960 --> 20:54.200] 然后我接收的里面有哪些信息
[20:54.200 --> 20:55.120] 每个域有什么类型
[20:55.120 --> 20:56.360] 他就是一门这样的语言
[20:56.360 --> 21:00.040] 然后GRPC天生是和protocol buffer结合的非常紧密的
[21:00.040 --> 21:02.040] 嗯那么是怎么紧密呢
[21:02.040 --> 21:05.639] 呃就相当于如果你提供protocol buffer文件的话
[21:05.639 --> 21:10.000] 我们会帮你生成对应的GRPC的handle
[21:10.000 --> 21:13.199] 就相当于我们会把那些类给你生成好
[21:13.199 --> 21:17.000] 然后你然后用户在使用的时候就可以直接
[21:17.000 --> 21:19.080] 比如说像python import这个文件
[21:19.080 --> 21:20.679] 然后就可以直接用GRPC
[21:20.679 --> 21:23.479] 然后看起来就好像是调用本地的程序一样
[21:23.480 --> 21:26.640] 嗯说白了就是呃我来解释一下
[21:26.640 --> 21:30.720] 说白就是那个呃你写一个GRPC的服务
[21:30.720 --> 21:33.280] 你只需要写一个protocol buffer的文件
[21:33.280 --> 21:35.880] 对那个你在那个文件里面去定义
[21:35.880 --> 21:39.840] 呃你这个GRPC的他的请求是什么样子
[21:39.840 --> 21:42.040] 然后他的response是怎么样子
[21:42.040 --> 21:47.000] 然后然后他会他会帮你生成就是对应语言的代码
[21:47.000 --> 21:49.680] 对这个这个其实怎么说呢
[21:49.680 --> 21:51.880] 我不知道我不知道其他的RPC是不是
[21:51.880 --> 21:58.280] 呃都有一个就是这种对应的像protocol buffer的东西
[21:59.280 --> 22:00.880] 我觉得是有的吧
[22:00.880 --> 22:06.680] 像像微软做的thrift就是跟protocol buffer类似的机制
[22:06.680 --> 22:10.720] 那个嗯那个是Facebook做的吧
[22:10.720 --> 22:12.080] 哦是Facebook对
[22:12.080 --> 22:16.400] 然后还有像其实像Java这种类似的协议就很多了
[22:16.400 --> 22:20.120] 像那个soap还有以前的那个企业总线EBS
[22:20.120 --> 22:24.879] 这都是很类似都是你用一门特别的这种接口定义语言
[22:24.879 --> 22:27.560] 然后来把你的服务要接受什么样的信息写出来
[22:27.560 --> 22:29.080] 他帮你生成对应的类
[22:29.080 --> 22:31.120] 对那protocol buffer还
[22:31.120 --> 22:34.959] 哦不那GRPC能支持非protocol buffer吗
[22:34.959 --> 22:37.679] 可以支持GRPC本身是中立的
[22:37.679 --> 22:38.479] 是的
[22:38.479 --> 22:44.280] 那那他这个要怎么就是那要怎么写那个服务的定义呢
[22:44.280 --> 22:47.360] 呃GRPC本身是有提供
[22:47.360 --> 22:49.639] 比如说protocol buffer他给你生成的类
[22:49.640 --> 22:52.760] 事实上是实现了一个generic
[22:52.760 --> 22:56.160] 就他事实上实现了一个server service的类
[22:56.160 --> 22:58.800] 然后这个service的类他会自动帮你绑定
[22:58.800 --> 23:01.160] 比如说你的请求要用这个encoder
[23:01.160 --> 23:04.560] 就是response要用这个decoder之类的
[23:04.560 --> 23:10.280] 那么如果你要用json或者是其他的其他的这种encoding的话
[23:10.280 --> 23:13.160] 你就把那个encoder和decoder换一下就可以
[23:13.160 --> 23:15.280] 但他就不能自动帮你生成了
[23:15.280 --> 23:16.720] 你就得手写了
[23:16.720 --> 23:18.200] 是的没错
[23:18.200 --> 23:19.400] 了解
[23:19.400 --> 23:25.160] 那我们差不多应该就是给听众们介绍一下GRPC
[23:25.160 --> 23:29.160] 然后看就我们是先聊一下GRPC python
[23:29.160 --> 23:30.600] 还是先聊一下服务发现的
[23:30.600 --> 23:33.400] 要不要不你先聊一下GRPC python吧
[23:33.400 --> 23:34.720] 好
[23:34.720 --> 23:40.520] GRPC python它是一个比较特殊的python包
[23:40.520 --> 23:44.400] 因为它绝大多数逻辑都是在c和c++这个层面实现的
[23:44.400 --> 23:50.720] 然后python它事实上只是一层包在它c API上面的一层
[23:50.720 --> 23:54.720] 就是有点像是glue code一样的东西
[23:54.720 --> 23:59.880] 然后我们和c和c core之间的结合用的是Cython这门语言
[23:59.880 --> 24:01.680] 我其实还挺喜欢Cython这门语言的
[24:01.680 --> 24:03.400] 它写起来就和python差不多
[24:03.400 --> 24:07.600] 但是它会把python这门语言然后翻译成对应的c++代码
[24:07.600 --> 24:09.920] 这个能具体聊一聊吗
[24:09.920 --> 24:13.640] 就是说因为我其实也只是稍微看过一点Cython
[24:13.640 --> 24:14.600] 我没有实际用过
[24:14.600 --> 24:17.800] 就是就我知道Cython有很多种用法
[24:17.800 --> 24:19.920] 就是你可以写一个c extension
[24:19.920 --> 24:23.360] 你也可以就是把你的python文件
[24:23.360 --> 24:27.200] 直接变成一个c++的动态连接库
[24:27.200 --> 24:30.760] 然后那你们是怎么用的
[24:30.760 --> 24:34.080] 我们的用法是把它写成一个c extension
[24:34.080 --> 24:38.480] 然后Cython还有一个有意思的用法
[24:38.480 --> 24:41.040] 就之前我们在聊的时候你有说
[24:41.040 --> 24:44.159] 比如说你有些工作就在python里面你想做
[24:44.159 --> 24:47.159] 但是它又很消耗CPU
[24:47.159 --> 24:50.080] 那你就想说能不能在这个地方按需并行
[24:50.080 --> 24:51.879] 其实Cython是有类似的功能的
[24:51.879 --> 24:54.080] 就是你可以给它
[24:54.080 --> 25:00.000] 你可以把某些函数过程写成告诉它说这个函数可以并行
[25:00.000 --> 25:01.879] 然后它就会自动帮你处理
[25:01.879 --> 25:05.159] 就是如何在python里面并行处理的问题
[25:05.159 --> 25:07.879] 它应该是我理解没错的话
[25:07.880 --> 25:11.680] 就像这种Cython还有其他一些这种c++的wrapper
[25:11.680 --> 25:14.800] 它都是相当于说这部分它就放在c++里跑
[25:14.800 --> 25:17.120] 所以它就没有Gil的那个约束了
[25:17.120 --> 25:19.000] 对吧,所以它就能并行
[25:19.000 --> 25:21.640] 是的
[25:21.640 --> 25:24.120] 在实现JRPD Python的过程中
[25:24.120 --> 25:26.120] 就经常需要和Gil战斗
[25:26.120 --> 25:30.240] 就是你要进入Core的代码之前就先releaseGil
[25:30.240 --> 25:32.200] 就我把Gil给放松开了
[25:32.200 --> 25:33.720] 接下来我要怎么跑都可以
[25:33.720 --> 25:35.120] 然后我回到python
[25:35.120 --> 25:37.760] 就是我要调用任何python的object的时候
[25:37.760 --> 25:39.000] 我要把Gil给拿回来
[25:39.000 --> 25:42.400] 不然就永远卡住或者是就挂了
[25:42.400 --> 25:45.879] 这个releaseGil是怎么做到的
[25:45.879 --> 25:48.080] 它python有API能releaseGil吗
[25:48.080 --> 25:50.480] 有的
[25:50.480 --> 25:54.800] 是C那边的对吧
[25:54.800 --> 25:57.560] 对,Cpython API
[25:57.560 --> 26:00.160] OK,怪我都没用过
[26:00.160 --> 26:05.840] 对,之前也是看一篇文章
[26:05.840 --> 26:08.760] 还是一个博客讲过
[26:08.760 --> 26:10.199] 就是说在python
[26:10.199 --> 26:11.760] 就很多人说python要去
[26:11.760 --> 26:13.480] 想在python里去掉Gil
[26:13.480 --> 26:15.280] 但实际上不太现实
[26:15.280 --> 26:18.360] 因为那个python的就是像
[26:18.360 --> 26:22.040] 它的垃圾回收和reference counting很依赖于Gil
[26:22.040 --> 26:25.040] 然后如果去掉的话
[26:25.040 --> 26:27.959] 如果去掉并且想找一个好的替代的话
[26:27.959 --> 26:30.120] 可能反而会让性能下降
[26:30.120 --> 26:32.600] 所以其实还是不是那么好去掉
[26:32.600 --> 26:35.120] 然后我看你还写到
[26:35.120 --> 26:37.679] 就是说如何实现asyncIO
[26:37.679 --> 26:40.479] 这个你要讲讲吧
[26:40.479 --> 26:43.919] 像刚才说的在gRPC core里面
[26:43.919 --> 26:45.719] 就是所有的这种网络层
[26:45.719 --> 26:49.600] 就包括你如何在Windows建立TCP连接
[26:49.600 --> 26:51.280] 如何在Linux建立TCP连接
[26:51.280 --> 26:54.760] 就如此类的所有库都是通过我们底层的C代码实现的
[26:54.760 --> 26:57.919] 但是asyncIO这样就没有办法加入进去
[26:57.919 --> 26:59.919] 因为asyncIO它本身也要求
[26:59.919 --> 27:02.199] 它要掌握这个TCP连接对吧
[27:02.200 --> 27:05.880] 所以我们相当于是
[27:05.880 --> 27:08.800] 在中间做了一个polar thread
[27:08.800 --> 27:12.040] 就相当于这个polar thread它完全是一个C的代码
[27:12.040 --> 27:15.120] 它会负责跟C进行交流
[27:15.120 --> 27:18.520] 然后当它从C里面获得什么信息以后
[27:18.520 --> 27:22.360] 就会以socket的形式发给Python这个thread来把它唤醒
[27:22.360 --> 27:26.360] 这样好像需要有点抽象
[27:26.360 --> 27:28.360] 有点抽象
[27:28.360 --> 27:32.199] 可能因为我也不是特别了解Python的asyncIO
[27:32.199 --> 27:35.760] 就是你要不再讲一遍
[27:35.760 --> 27:37.159] 就讲细一点
[27:37.159 --> 27:40.600] 我们可以先从什么是asyncIO开始说起
[27:40.600 --> 27:42.639] 它本身其实是一个event loop
[27:42.639 --> 27:47.560] 相当于是以前很多任务你把它拆成了很多线程来完成
[27:47.560 --> 27:49.959] 它现在相当于拆成了很多邪程来完成
[27:49.959 --> 27:52.479] 然后总体来说就只使用一个核
[27:52.479 --> 27:56.679] 然后所有的这些邪程
[27:56.680 --> 27:59.160] 它就在一个对立里面排排队
[27:59.160 --> 28:01.400] 然后排队执行
[28:01.400 --> 28:03.200] 然后当它遇到一个什么
[28:03.200 --> 28:05.080] 比如说需要blocking的code的时候
[28:05.080 --> 28:08.040] 比如说你需要发送一个请求
[28:08.040 --> 28:10.760] 或者是等一个什么连接过来的时候
[28:10.760 --> 28:13.120] 它就会进入一个类似休眠的状态
[28:13.120 --> 28:16.560] 然后把这个核让给下一个邪程去进行
[28:16.560 --> 28:18.880] 这个可以理解
[28:18.880 --> 28:19.520] 对吧
[28:19.520 --> 28:22.560] 那么在做这个的过程中就相当于
[28:22.560 --> 28:28.320] 就是这个唤醒和休眠的过程就相当于是一个polling engine
[28:28.320 --> 28:32.560] 这个polling engine本身在GRPC里面是用c代码实现的
[28:32.560 --> 28:39.399] 那么我们就要想办法如何把这个GRPC的c代码和asyncIO结合在一起
[28:39.399 --> 28:44.200] 那中间就用了类似这样一个poller thread
[28:44.200 --> 28:47.600] 然后这个好像有点难讲清楚
[28:47.600 --> 29:00.560] 就是相当于就是可以理解为你们用c实现了那个event loop
[29:00.560 --> 29:05.600] 然后就是它和一些别的event loop实现有什么区别呢
[29:05.600 --> 29:08.600] 就我觉得你们应该是不是做了更多的事情
[29:08.600 --> 29:12.360] 我觉得经过你这么一总结会清晰很多
[29:12.360 --> 29:18.360] 就我目前的实现方式是c它这边有自己的一个event loop
[29:18.360 --> 29:20.439] 然后python这边有自己的一个event loop
[29:20.439 --> 29:24.959] 但中间有一个类似中间人一样的一个thread负责处理
[29:24.959 --> 29:26.560] 就是两边的沟通
[29:26.560 --> 29:28.120] 相当于python这边有什么事情
[29:28.120 --> 29:30.879] 它会告诉中间这个thread你要去监听什么事件
[29:30.879 --> 29:32.439] 而c这边有什么thread的话
[29:32.439 --> 29:35.560] 它会告诉这个中间人说你应该通知python这样子
[29:35.560 --> 29:38.760] 那这样会就是虽然我不懂具体细节
[29:38.760 --> 29:42.120] 但听起来会不会就是会有一些性能的问题
[29:42.120 --> 29:46.439] 因为你毕竟两边要通信会比就是说单纯的
[29:46.439 --> 29:50.120] 只有一个event loop要慢一些会有这样的问题吗
[29:50.120 --> 29:52.239] 是的这个会比我
[29:52.239 --> 29:53.959] 就我一开始做两个方案
[29:53.959 --> 29:57.000] 第一个方案就是我会把底层的所有库
[29:57.000 --> 30:01.080] 就原来原来c core在
[30:01.080 --> 30:03.399] 比如说你要创建tcp连接什么的
[30:03.399 --> 30:05.399] 我就把那个东西换成一个python函数
[30:05.399 --> 30:07.040] 把它塞到c的底层下面
[30:07.040 --> 30:08.679] 这个要比那种方案是要慢
[30:08.679 --> 30:09.919] 但它要稳定很多
[30:09.920 --> 30:12.360] 而且它可以处理就是
[30:12.360 --> 30:16.040] 比如说你在用acio的同时你想用多线程
[30:16.040 --> 30:20.120] 你想用blocking code这些都是可以的
[30:20.120 --> 30:24.280] 是对然后其实
[30:24.280 --> 30:27.480] 其实有一个就是你给过一个talk
[30:27.480 --> 30:32.920] 在euro python 2020的时候就是关于这个方面的对吧
[30:32.920 --> 30:35.520] 然后我们也会把这个链接贴出来
[30:35.520 --> 30:37.920] 大家可以去看一下
[30:37.920 --> 30:40.440] 对反正这块感觉还是
[30:40.440 --> 30:44.400] 就是如果不是专门做这块还是比较
[30:44.400 --> 30:48.240] 比较难搞懂就是有一些很多细节
[30:48.240 --> 30:51.200] 是的就你们有用过acio吗
[30:51.200 --> 30:53.840] 我只大概用过像
[30:53.840 --> 30:56.760] 对之前我还问小白我说他用过没有
[30:56.760 --> 30:59.120] 因为我其实没有怎么在python里用过
[30:59.120 --> 31:03.320] 我也是我基本上都是在javascript里边用
[31:03.320 --> 31:05.320] 对其实是很类似的
[31:05.320 --> 31:11.439] 对我看他们讲那个语法好像基本上都是一模一样的
[31:11.439 --> 31:13.840] 就是async await吗
[31:13.840 --> 31:18.399] 对但是python的async io就有很多
[31:18.399 --> 31:22.480] 感觉有很多复杂的概念什么task这种乱七八糟的东西
[31:22.480 --> 31:24.600] 然后javascript里就没有这些
[31:24.600 --> 31:28.080] 而且我觉得就是javascript它毕竟自带event loop
[31:28.080 --> 31:30.240] 所以写起来就非常的方便
[31:30.240 --> 31:31.560] 你不像python还得去
[31:31.560 --> 31:35.440] 你还是创建一个event loop对吧
[31:35.440 --> 31:38.080] 没错没错这点我很同意
[31:38.080 --> 31:40.080] 我觉得之前有看到有
[31:40.080 --> 31:42.520] 有用户在用async io api的时候
[31:42.520 --> 31:46.720] 他就本身可能是用flask之类的服务器
[31:46.720 --> 31:48.879] 然后就写这个东西然后在服务请求里面
[31:48.879 --> 31:51.080] 他每个请求来了就创建一个event loop
[31:51.080 --> 31:53.280] 然后跑一下gRPC async io api
[31:53.280 --> 31:55.600] 我就说你这个有点本末倒置啊大哥
[31:55.600 --> 32:00.200] 是我就感觉
[32:00.200 --> 32:02.360] 就是我是感觉python的
[32:02.360 --> 32:04.440] 虽然我没有用这样说可能有点偏颇
[32:04.440 --> 32:07.120] 但是感觉python里的async用起来还是
[32:07.120 --> 32:09.280] 就不如其他语言舒服吧
[32:09.280 --> 32:10.400] 就感觉很别扭
[32:10.400 --> 32:13.600] 你不像java或者C++你直接用多线程就好
[32:13.600 --> 32:15.640] 然后go你有这个groutine
[32:15.640 --> 32:20.920] 然后js里面你的async有比较简单比较好用
[32:20.920 --> 32:24.680] 就是python里这个就有点别角
[32:24.680 --> 32:26.000] 是的
[32:26.000 --> 32:30.120] 但其实它的task和javascript里面的promise
[32:30.120 --> 32:31.120] 概念是一样的
[32:31.120 --> 32:33.959] 和java和javascript的promise都是一样的
[32:33.959 --> 32:38.760] 既然聊这我来顺便问一下task和future的关系是啥
[32:38.760 --> 32:41.320] task是future的一层包装
[32:41.320 --> 32:44.399] future它本身是由底层的event loop实现的
[32:44.399 --> 32:47.120] 所以它可能会包含一些实现的细节在里面
[32:47.120 --> 32:49.080] 而task就是完全抽象的
[32:49.080 --> 32:51.639] 就是不管是什么event loop
[32:51.639 --> 32:53.639] 最后提供出来的接口都是一样的
[32:53.639 --> 32:55.800] ok好吧
[32:55.800 --> 32:59.639] 反正到时候如果有机会用再说吧
[32:59.640 --> 33:00.640] 对我现在没用过
[33:00.640 --> 33:03.440] 下面一个话题打算聊一下服务发现
[33:03.440 --> 33:08.680] 因为服务发现服务治理都是微服务这个领域里面的重要话题
[33:08.680 --> 33:12.240] 然后我不知道grpcc在这方面做多少
[33:12.240 --> 33:15.080] 还是说它会依赖一些其他框架来做
[33:15.080 --> 33:16.720] 你可以聊一下
[33:16.720 --> 33:17.600] ok
[33:17.600 --> 33:20.000] 我觉得可以从low balancing开始聊起
[33:20.000 --> 33:22.080] 就最简单的low balancing
[33:22.080 --> 33:23.640] 就比如说你有4台机器
[33:23.640 --> 33:26.360] 那你在4台机器前面放一台low balancing的机器
[33:26.360 --> 33:28.320] 然后它就开始12345678910
[33:28.320 --> 33:30.000] 就这样子做low balancing对吧
[33:30.000 --> 33:31.560] 但很快大家就会发现
[33:31.560 --> 33:34.040] 这台low balancing机器本身就成为了瓶颈
[33:34.040 --> 33:34.600] 那怎么办
[33:34.600 --> 33:37.080] 你就横向扩展或者做多层的low balancing
[33:37.080 --> 33:39.000] 但是这些都没有办法解决
[33:39.000 --> 33:41.600] 就是low balancing本身变成瓶颈的这个问题
[33:41.600 --> 33:45.040] 后面就有出现了像look aside low balancing
[33:45.040 --> 33:46.840] 就比如说我一个客户端
[33:46.840 --> 33:48.000] 我要连接后端的时候
[33:48.000 --> 33:50.480] 我并不是去连接某一个固定的地址
[33:50.480 --> 33:53.720] 而是我问一下本地的一个proxy
[33:53.720 --> 33:55.919] 问他说我应该连接哪一个后端
[33:55.919 --> 33:57.560] 然后他再去进行这个连接
[33:57.560 --> 33:59.480] 就相当于中间就没有了low balancing
[33:59.480 --> 34:02.760] 而low balancing这个行为本身是从客户端
[34:02.760 --> 34:03.679] 这边发现的
[34:03.679 --> 34:05.679] 但这又带来了另外一个问题
[34:05.679 --> 34:09.080] 就是如果你经过了一层
[34:09.080 --> 34:10.920] 这个look aside balancing的话
[34:10.920 --> 34:12.360] 那你的性能可能会下降
[34:12.360 --> 34:15.159] 因为你事实上是去访问了另外一个进程
[34:15.159 --> 34:15.639] 对吧
[34:15.639 --> 34:18.639] 或者说你想要在不同的语言里面实现
[34:18.639 --> 34:20.440] 这个东西其实也是很困难的
[34:20.440 --> 34:23.840] 因为你要保证你不同的stack之间的行为
[34:23.840 --> 34:24.600] 是一致的
[34:24.600 --> 34:26.759] 比如说你不管是你用C++
[34:26.760 --> 34:28.440] 还是用python用Node.js
[34:28.440 --> 34:31.360] 你最后实现出来的行为都是一样
[34:31.360 --> 34:32.760] 那这个东西如果
[34:32.760 --> 34:35.160] 你写一个后端服务
[34:35.160 --> 34:36.320] 你就要写一遍这个东西
[34:36.320 --> 34:38.480] 这个实在是不能接受
[34:38.480 --> 34:41.480] 就你指的这个东西指就是那个proxy
[34:41.480 --> 34:45.840] 就相当于可以告知客户端去访问哪个地址的
[34:45.840 --> 34:47.480] 这样一套东西是吗
[34:47.480 --> 34:48.880] 对没错
[34:48.880 --> 34:51.280] 就相当于是服务发现的一个接收端
[34:51.280 --> 34:53.480] 那GRPC现在想做的
[34:53.480 --> 34:58.480] 就相当于是有点把Envoy的功能做进GRPC的客户端里面
[34:58.480 --> 34:59.840] En什么
[34:59.840 --> 35:01.320] 那个词
[35:01.320 --> 35:02.760] Envoy
[35:02.760 --> 35:06.040] 就是一个知名proxy
[35:06.040 --> 35:07.600] Envoy proxy
[35:07.600 --> 35:11.040] 就如果你有用Easthill或Kubernetes的话
[35:11.040 --> 35:12.600] 就对它会比较熟悉一点
[35:12.600 --> 35:16.240] 因为他们就是相当于用这个东西来做
[35:16.240 --> 35:19.960] 所有的low balancing和请求转发的
[35:19.960 --> 35:26.320] 相当于可以把Envoy的相关功能做进GRPC里
[35:26.320 --> 35:27.840] 然后这样的话就可以
[35:27.840 --> 35:33.280] 我突然感觉这个话题好像跟Python的用户稍微有点远
[35:33.280 --> 35:36.360] 没有我们又不是只聊Python的
[35:36.360 --> 35:37.160] OK
[35:37.160 --> 35:39.560] 那你们有用过Easthill相关的吗
[35:39.560 --> 35:42.640] 我估计如果是Mazosaka来的话
[35:42.640 --> 35:45.160] 他肯定就是他虽然可能没用过
[35:45.160 --> 35:46.360] 但他应该知道
[35:46.360 --> 35:50.000] 就我其实像Kubernetes,Easthill我都没用过
[35:50.000 --> 35:52.080] 公司里也没这种场景
[35:52.080 --> 35:52.560] OK
[35:52.560 --> 35:54.680] 我觉得可以先从需求开始聊起
[35:54.680 --> 35:56.720] 像Easthill这样的control plan
[35:56.720 --> 36:01.160] 它主推的东西就是你要写服务的时候
[36:01.160 --> 36:02.520] 你完全不用管这个服务
[36:02.520 --> 36:04.080] 它东西是怎么帮你route的
[36:04.080 --> 36:06.120] 它完全帮你处理这个请求
[36:06.120 --> 36:08.920] 那它的做法就是像容器一样
[36:08.920 --> 36:11.280] 它每个容器里面除了跑它的服务以外
[36:11.280 --> 36:13.200] 还会放一份Envoy的进程
[36:13.200 --> 36:16.640] 就是放一份代理proxy的进程在里面
[36:16.640 --> 36:20.240] 然后你的服务会直接跟Envoy的进程进行对话
[36:20.240 --> 36:22.560] 然后Envoy来进行所有的routing
[36:22.560 --> 36:23.919] road balancing之类的工作
[36:23.919 --> 36:28.359] 它这个功能就会把开发本身变得很简单
[36:28.359 --> 36:31.359] 但是同时也导致了latency的增加
[36:31.359 --> 36:33.359] 还有就是需要更多的运算资源
[36:33.359 --> 36:36.200] 因为代理本身它也是需要额外的资源的
[36:36.200 --> 36:37.279] 还有与此同时
[36:37.279 --> 36:39.160] 如果你类似Easthill
[36:39.160 --> 36:42.120] 它并不是跑在一个Kubernetes的平台上的话
[36:42.120 --> 36:44.920] 比如说你在一个VM上面搭建Envoy
[36:44.920 --> 36:47.040] 那你要做的事情就非常的复杂了
[36:47.040 --> 36:52.359] 因为Envoy它底层是用类似IP table来做routing
[36:52.359 --> 36:53.839] 它保证你的这个进程
[36:53.839 --> 36:55.680] 所有的发出来和收到的信息
[36:55.680 --> 36:58.279] 都是由另外一个进程来接收的
[36:58.279 --> 37:01.440] 那这个设置IP table的过程可能是手动
[37:01.440 --> 37:03.600] 或者是要运营人员上去做的
[37:03.600 --> 37:05.120] 那这个时候就很可能出错
[37:05.120 --> 37:07.720] 而出错以后你的debug会非常的令人头疼
[37:07.720 --> 37:10.080] 不知道你们有没有用过这种比较底层的
[37:10.080 --> 37:11.799] 像IP table之类的工具
[37:11.800 --> 37:13.520] IP table还是知道的
[37:13.520 --> 37:14.040] 对
[37:14.040 --> 37:15.720] 就如果你设坏了的话
[37:15.720 --> 37:18.480] 那你可能就要重新配置这台机器了
[37:18.480 --> 37:20.360] 你就无法连接上去
[37:20.360 --> 37:22.160] 所以它运营起来会比较复杂
[37:22.160 --> 37:25.360] 那GRPC的愿景就是它希望说
[37:25.360 --> 37:29.720] 可以把中间这层proxy给取消掉
[37:29.720 --> 37:32.200] 相当于它可以直接和控制平台
[37:32.200 --> 37:34.560] 直接和管理服务器进行沟通
[37:34.560 --> 37:36.040] 然后管理服务器说
[37:36.040 --> 37:38.080] 我在哪里哪里发现了新的服务
[37:38.080 --> 37:40.200] 或者是哪个哪台服务器关闭了
[37:40.200 --> 37:43.640] 它直接管理服务告诉GRPC这件事情
[37:43.640 --> 37:47.520] 然后GRPC就可以自动帮用户代码做这些调整
[37:47.520 --> 37:49.160] 然后来把这些请求
[37:49.160 --> 37:51.720] 路由到合适的backend
[37:53.720 --> 37:55.879] 就是就刚才有几个概念
[37:55.879 --> 37:57.560] 我想理清一下
[37:57.560 --> 37:59.960] 就是你说到管理服务器对吧
[37:59.960 --> 38:03.000] 这个管理服务器是一个什么概念
[38:03.759 --> 38:05.799] 这个管理服务器的话
[38:05.800 --> 38:10.400] 我一瞬间竟然找不到除了GCP之外的例子
[38:10.400 --> 38:15.080] 我们就用谷歌的服务来做例子吧
[38:15.080 --> 38:18.040] 谷歌它本身有推出一个traffic director
[38:18.040 --> 38:18.960] 这个服务
[38:18.960 --> 38:20.600] 然后相当于你作为一个用户
[38:20.600 --> 38:24.000] 你就在谷歌云平台的界面上点点鼠标
[38:24.000 --> 38:26.240] 比如说你就设置我这个
[38:26.240 --> 38:27.760] backend指向了这个集群
[38:27.760 --> 38:29.480] 然后让它自己autoscaling之类的
[38:29.480 --> 38:31.080] 就相当于它这个UI
[38:31.080 --> 38:33.600] 你人工输入这些设置
[38:33.600 --> 38:39.040] 它背后就是会把这些所有的配置文件
[38:39.040 --> 38:41.720] 放在一个管理服务器上
[38:41.720 --> 38:42.640] 然后在管理服务器
[38:42.640 --> 38:45.640] 再来负责告诉各种GRPC之类的
[38:45.640 --> 38:48.040] 就是后端的企业
[38:48.040 --> 38:48.319] 对
[38:48.319 --> 38:48.839] 其实
[38:52.600 --> 38:56.240] 这个管理服务器不会又成了一个瓶颈了吗
[38:59.319 --> 39:01.799] 其实是的
[39:01.799 --> 39:02.640] 其实是的
[39:02.640 --> 39:04.400] 其实对
[39:04.400 --> 39:07.799] 其实它现在也有在做管理服务器的横向扩充
[39:07.799 --> 39:10.680] 还有caching之类的内容
[39:11.759 --> 39:14.600] 那我们就以一个请求的视角来说吧
[39:14.600 --> 39:16.040] 就说我一个请求来了
[39:16.040 --> 39:17.600] 那它是先到哪里呢
[39:17.600 --> 39:19.879] 就是在假设你GRPC已经实现了
[39:19.879 --> 39:22.000] 已经替代了anvil这套
[39:22.720 --> 39:24.960] 它的实现就是
[39:24.960 --> 39:27.720] GRPC在一个请求要发出去之前
[39:27.720 --> 39:32.480] 它会看看自己有没有关于后端的信息
[39:32.480 --> 39:37.040] 然后如果它其实是跟控制平台subscribe的消息
[39:37.040 --> 39:37.680] 就subscribe
[39:37.680 --> 39:40.240] 如果任何这些资源有变动的话
[39:40.240 --> 39:42.560] 就控制平台都会给它推这个更新
[39:42.560 --> 39:46.840] 那么GRPC它会看一下本地有的这些服务列表
[39:46.840 --> 39:48.840] 然后选择其中一个它觉得
[39:48.840 --> 39:50.560] 就是符合它的routing
[39:50.560 --> 39:53.560] 符合它的low balance设置的后端
[39:53.560 --> 39:54.840] 然后把这个请求发过去
[39:54.840 --> 39:56.720] 然后后端接收到的时候
[39:56.720 --> 39:59.800] 就跟普通的请求没有什么两样
[39:59.800 --> 40:00.320] 对
[40:00.320 --> 40:01.440] OK
[40:01.440 --> 40:05.480] 这样它其实GRPC确实就不仅仅是一套
[40:05.480 --> 40:06.840] 就是RPC的框架
[40:06.840 --> 40:09.640] 而是一套应该叫怎么说
[40:09.640 --> 40:12.080] 更大的框架
[40:12.080 --> 40:12.680] 是的
[40:12.680 --> 40:16.080] 它就相当于变成了服务发现的一部分
[40:16.080 --> 40:17.440] 有点意思
[40:17.440 --> 40:24.920] 这个大概就是什么时候能看到它变成这样子呢
[40:24.920 --> 40:30.160] 现在GRPC已经和谷歌本身的服务
[40:30.160 --> 40:32.879] 就是这部分已经做完了
[40:32.879 --> 40:35.680] 然后关于和Estio的结合我们还在做
[40:35.680 --> 40:37.200] OK
[40:37.200 --> 40:38.680] Interesting
[40:38.680 --> 40:44.399] 然后我们下面一个话题打算聊一下商业开源
[40:44.399 --> 40:50.600] 因为我们知道GRPC它是一个由商业公司主导的开源项目
[40:50.600 --> 40:53.440] 它和就是像这种个人的开源项目
[40:53.440 --> 40:55.120] 肯定有些不一样的地方
[40:55.120 --> 41:00.839] 那我们先从GRPC它的前身开始讲起吧
[41:00.839 --> 41:04.960] GRPC它的前身是一个叫做Stubby的内部框架
[41:04.960 --> 41:05.880] 也是RPC
[41:05.880 --> 41:09.240] 但Stubby它的特点就是它是基于TCP的
[41:09.240 --> 41:12.640] 同时它用了非常多谷歌内部的开源库
[41:12.640 --> 41:14.640] 不是谷歌内部的币源的库
[41:14.640 --> 41:16.640] 所以没有办法简单的开源
[41:16.640 --> 41:18.240] 对这是它的前身
[41:18.240 --> 41:20.160] 那Google为什么要做GRPC呢
[41:20.160 --> 41:21.080] 为什么不
[41:21.080 --> 41:22.680] 就是因为Stubby不好开源
[41:22.680 --> 41:23.440] 是吗
[41:23.440 --> 41:26.280] 对其实它本身是因为Stubby不好开源
[41:26.280 --> 41:28.880] 然后在特性方面
[41:28.880 --> 41:30.600] Stubby和GRPC其实类似
[41:30.600 --> 41:35.480] 而谷歌的愿景其实是它希望能够只做一份代码
[41:35.480 --> 41:37.480] 就如果谷歌要进行
[41:37.480 --> 41:39.320] 如果谷歌要做云服务的话
[41:39.320 --> 41:44.720] 那它就不可避免的要把这些API开放给开发者
[41:44.720 --> 41:46.960] 那开放给开发者就不能开放Stubby
[41:46.960 --> 41:49.280] 那就只能开放一个开源的框架
[41:49.280 --> 41:52.960] 那么这个开源框架之后就做了一个开源版本的Stubby
[41:52.960 --> 41:54.960] 就是GRPC
[41:54.960 --> 41:55.960] 对
[41:55.960 --> 42:00.680] 对其实好像公司里面有一个就是
[42:00.680 --> 42:04.680] 长期的计划就是用GRPC替换掉Stubby对吧
[42:04.680 --> 42:06.680] 对
[42:06.680 --> 42:09.560] 但是这个计划现在已经终止了
[42:09.560 --> 42:10.960] 是吗
[42:10.960 --> 42:13.680] 是的这个计划现在已经终止了
[42:13.680 --> 42:21.160] 其实主要的问题还是GRPC带来的性能提升实在是太少了
[42:21.160 --> 42:24.839] 并且它做了很多结构性的改动
[42:24.839 --> 42:27.560] 导致比如说你一个服务员还是用旧框架起的
[42:27.560 --> 42:28.759] 你现在换成新框架
[42:28.759 --> 42:31.000] 那你居然要重构很多的代码
[42:31.000 --> 42:35.200] 你可能要对然后这个在很多客户来说是不可接受
[42:35.200 --> 42:37.759] 就很多内部用户觉得是不可接受
[42:37.759 --> 42:39.920] 就是当你重新做了一遍你的服务
[42:39.920 --> 42:43.120] 然后性能提升就只有那么一点点甚至没有
[42:43.120 --> 42:46.520] 是对这种代价太大了
[42:46.520 --> 42:49.839] 那像就是这种商业开源
[42:49.840 --> 42:55.160] 你觉得和就是普通的非商业开源有什么区别
[42:55.160 --> 42:58.520] 其实我一开始在聊这个话题的时候
[42:58.520 --> 43:02.440] 我在想一个开源软件如何才能活下去
[43:02.440 --> 43:03.880] 你不觉得很神奇吗
[43:03.880 --> 43:06.560] 因为都是大家自发的去贡献
[43:06.560 --> 43:08.080] 它的商业模型是怎么样
[43:08.080 --> 43:11.480] 为什么大家会愿意不断的花时间去维护一个
[43:11.480 --> 43:13.680] 就是并不能为自己盈利的软件
[43:13.680 --> 43:14.800] 用爱发电
[43:14.800 --> 43:17.120] 对啊
[43:17.120 --> 43:19.360] 但用爱发电毕竟是少数人
[43:19.360 --> 43:24.120] 所以大多数是没法盈利的
[43:24.120 --> 43:26.160] 所以就很多也不能维持下去
[43:26.160 --> 43:29.720] 就做到后面也就慢慢就不做了
[43:29.720 --> 43:30.800] 有很多这样
[43:30.800 --> 43:33.200] 我觉得从大公司的角度来考虑的话
[43:33.200 --> 43:34.760] 他做这个商业开源
[43:34.760 --> 43:39.200] 他就可以把自己底层非常难以维护的代码
[43:39.200 --> 43:41.400] 开源出来然后和别的公司进行合作
[43:41.400 --> 43:44.000] 像谷歌他在做GRP开源
[43:44.000 --> 43:47.400] 那这个项目其实是有跟像LIFT,Drawbox
[43:47.400 --> 43:50.160] 甚至是Facebook都有一定的合作
[43:50.160 --> 43:53.680] 他们都会贡献可能一块feature或者是一块什么东西
[43:53.680 --> 43:57.160] 就相当于可以免费的利用这几个公司
[43:57.160 --> 43:59.080] 来共同维护一个框架
[43:59.080 --> 44:00.760] 然后把这个框架做好
[44:00.760 --> 44:02.840] 我感觉有点像一个杠杆
[44:02.840 --> 44:05.720] 难道Facebook没有自己的RPC框架吗
[44:05.720 --> 44:08.400] 他居然还要来用GRP
[44:08.400 --> 44:10.440] 对他有
[44:10.440 --> 44:14.000] 我觉得他本身既然是一个微服务
[44:14.000 --> 44:17.400] 他就是里面的开发者想要用什么东西都是可以的
[44:17.400 --> 44:19.800] OK
[44:19.800 --> 44:22.920] 刚才不是提到THRIFT就是Facebook的吗
[44:22.920 --> 44:24.520] 那这种就是
[44:24.520 --> 44:29.320] 那你有和其他的公司的员工合作过吗
[44:29.320 --> 44:31.960] 像ACIO这个工作
[44:31.960 --> 44:34.720] 我其实就是和欧洲的一家公司一起做的
[44:34.720 --> 44:38.040] 就是他们对Python ACIO这个功能非常感兴趣
[44:38.040 --> 44:40.040] 并且想要用GRPC
[44:40.040 --> 44:41.400] 那我就跟他聊
[44:41.400 --> 44:43.040] 既然我们都有这个需求
[44:43.040 --> 44:45.640] 那我们不如一起把ACIO API做出来
[44:45.640 --> 44:48.640] 然后我们就从开始写基础文档
[44:48.640 --> 44:49.960] 然后互相吵架
[44:49.960 --> 44:51.680] 然后到最后把代码写出来
[44:51.680 --> 44:53.360] 前后花了大概一年左右
[44:53.360 --> 44:55.160] 还是挺愉快的我觉得
[44:55.160 --> 44:57.400] 对这个我其实很感兴趣
[44:57.400 --> 45:00.000] 就是因为这种开发模式
[45:00.000 --> 45:01.720] 就感觉和在公司
[45:01.720 --> 45:03.520] 完全在公司内部工作不一样
[45:03.520 --> 45:05.759] 就是我不知道这块到底是怎么做的
[45:05.759 --> 45:10.040] 就比如说我们都知道要写设计文档
[45:10.040 --> 45:13.279] 那一般设计文档可能就是公司内部的一个Doc
[45:13.279 --> 45:15.960] 然后组内和相关的人来review一下
[45:15.960 --> 45:18.000] 那像这种就是合作的是
[45:18.000 --> 45:21.000] 公司怎么确保说你们实现的这套东西
[45:21.000 --> 45:23.759] 它是就在公司内部用是没有问题的呢
[45:23.759 --> 45:25.160] 就是是谁来审核呢
[45:27.160 --> 45:30.000] 就是我们的那个合作是
[45:30.000 --> 45:32.200] 就GRPC它本身有一个repo
[45:32.200 --> 45:35.840] 是专门来放这些各种提案的
[45:35.840 --> 45:37.480] 那它本身就是一个GitHub项目
[45:37.480 --> 45:40.360] 然后我的我的DesignDoc本身也是用markdown写的
[45:40.360 --> 45:42.920] 所以所有人都可以非常简单的去看
[45:42.920 --> 45:44.240] 就是看我写的东西
[45:44.240 --> 45:46.320] 然后提出提出疑义什么的
[45:46.320 --> 45:48.720] 像在开发ACIO API的过程中
[45:48.720 --> 45:51.840] 就有来自很多公司的请求
[45:51.840 --> 45:53.280] 像Dropbox
[45:53.280 --> 45:54.920] 主要还是来自Dropbox
[45:54.920 --> 45:56.640] 然后还有来自Uber的工程师
[45:56.640 --> 45:58.400] 都有来这边提意见说
[45:58.400 --> 46:00.440] 比如说我这个东西需要这么写
[46:00.440 --> 46:02.480] 或者是你们不能只想的微服务
[46:02.480 --> 46:03.400] 你们要考虑一下
[46:03.400 --> 46:07.840] monolithic的服务的一些情况就如此类的
[46:07.840 --> 46:08.240] 对
[46:09.280 --> 46:12.520] 所以相应于这个需求是源自外部的需求对吧
[46:12.520 --> 46:15.640] 然后所以你要跟你老板聊说我想做这个吗
[46:15.640 --> 46:16.720] 是这样吗
[46:16.720 --> 46:17.440] 是的
[46:17.440 --> 46:18.840] 我在聊的时候
[46:18.840 --> 46:20.000] 一个是我想做这个
[46:20.000 --> 46:23.360] 第二个是我觉得Python它本身的
[46:23.360 --> 46:26.400] Python它本身的Asynchronous Library
[46:26.400 --> 46:28.080] 其实是一个比较混乱的情况
[46:28.080 --> 46:29.160] 就比如说
[46:29.160 --> 46:31.840] 你说你要在JavaScript里面
[46:31.840 --> 46:33.560] 你要用Async的东西
[46:33.560 --> 46:35.960] 那你就可以用Async Await API
[46:35.960 --> 46:37.400] 但是如果你在Python里面
[46:37.400 --> 46:38.600] 你要用Async框架
[46:38.600 --> 46:39.520] 那别人就会问你
[46:39.520 --> 46:41.280] 你说的是哪一个Async框架
[46:41.280 --> 46:44.080] 比如说什么Gevent
[46:44.080 --> 46:45.480] Tornado
[46:45.480 --> 46:46.840] 然后
[46:47.440 --> 46:49.200] 还有好多Trail
[46:49.200 --> 46:50.840] 然后这种
[46:50.840 --> 46:52.080] 对
[46:52.440 --> 46:53.680] 就诸如此类的
[46:53.680 --> 46:56.440] 可能列出下来可以列出10个
[46:56.440 --> 46:59.960] 而且它们彼此之间又不太能互相在一起工作
[46:59.960 --> 47:00.880] 你一个进程里面
[47:00.880 --> 47:02.440] 就你一个Python的现成里面
[47:02.440 --> 47:03.840] 放两个Event Loop
[47:03.840 --> 47:05.360] 它基本上等于死机
[47:06.400 --> 47:07.600] 而Python
[47:07.600 --> 47:08.840] 我觉得Python的开发者
[47:08.840 --> 47:11.240] 他们一开始做Async IEO的意图
[47:11.240 --> 47:13.960] 是想要做一个类似统一的框架
[47:13.960 --> 47:16.120] 就不管你们底层是用什么实现的
[47:16.120 --> 47:18.200] 你们只要实现了Async IEO的这一套
[47:18.200 --> 47:19.280] Event Loop API
[47:19.280 --> 47:21.240] 那到时候写的代码都可以一样
[47:21.240 --> 47:22.960] 我觉得他们是有这个愿景在这里
[47:22.960 --> 47:24.000] 所以我就觉得
[47:24.000 --> 47:25.920] 如果GRPC能够做这个东西的话
[47:25.920 --> 47:28.840] 其实是可以帮Google吸引这一部分
[47:28.840 --> 47:31.920] 就是对Async IEO感兴趣的Python用户
[47:31.920 --> 47:33.360] 或者是这些公司
[47:33.360 --> 47:37.240] 然后包括这个Async IEO API
[47:37.240 --> 47:40.400] 其实现在在谷歌云的
[47:40.400 --> 47:43.080] 他们的Python Client都是有的
[47:43.080 --> 47:44.160] 都是已经用起来的
[47:44.160 --> 47:44.640] 对的
[47:44.640 --> 47:46.720] 所以我理解就是你跟老板说
[47:46.720 --> 47:48.280] 这个东西Impact很大
[47:48.280 --> 47:50.320] 然后能帮助Google Cloud
[47:50.320 --> 47:51.480] 就是怎么样
[47:51.480 --> 47:53.760] 超过Asia是吧
[47:53.760 --> 47:55.680] 好就一定要做
[47:55.680 --> 47:56.360] 对啊
[47:56.360 --> 47:58.120] 我们有了别的没有的东西
[47:58.120 --> 47:59.520] 就是一个卖点
[47:59.520 --> 48:01.839] 那这个怎么能说是别人没有的呢
[48:01.839 --> 48:03.600] 像GRPC它是开源的对吧
[48:03.600 --> 48:07.400] 那我AWS Azure把它直接拿过去
[48:07.400 --> 48:09.400] 作为他们的一个提供的基础库
[48:09.400 --> 48:10.319] 他不也有了吗
[48:10.319 --> 48:11.319] 是的
[48:11.319 --> 48:12.560] 这也是一个问题
[48:12.560 --> 48:20.440] 就很多时候都是谷歌花了很多工程师去做这个东西
[48:20.440 --> 48:22.440] 最后是AWS在喝糖
[48:22.440 --> 48:23.319] 吃肉
[48:23.319 --> 48:23.799] 对
[48:23.799 --> 48:25.359] 是
[48:25.359 --> 48:25.960] 挺惨的
[48:25.960 --> 48:27.680] 我觉得像Kubernetes
[48:27.680 --> 48:29.440] 对就很多东西聊到后面
[48:29.440 --> 48:33.359] 就是它就不是技术上的问题
[48:33.359 --> 48:35.040] 它是一个就是运营啊
[48:35.040 --> 48:36.560] 然后商业策略上的问题
[48:36.560 --> 48:39.200] 就是我看最近有很多人抱怨吧
[48:39.200 --> 48:40.240] 就是Google
[48:40.240 --> 48:43.879] 想找一个Google Cloud
[48:43.879 --> 48:46.120] 或者说就是Google的这种客服
[48:46.120 --> 48:48.120] 根本就找不到
[48:48.120 --> 48:49.680] 然后有个人做了一个对比
[48:49.680 --> 48:51.399] 就是同样的一个任务
[48:51.399 --> 48:53.480] 然后在AWS和Google Cloud上做
[48:53.480 --> 48:55.480] 然后Google Cloud花了几周
[48:55.480 --> 48:57.279] 他想去联系客服
[48:57.280 --> 48:58.920] 然后始终没有联系到
[48:58.920 --> 49:01.320] 然后AWS在一周内就帮他搞定
[49:01.320 --> 49:03.440] 就觉得这个事情你已经不是说
[49:03.440 --> 49:05.040] OK我技术领先
[49:05.040 --> 49:06.120] 虽然也没有领先吧
[49:06.120 --> 49:08.600] 就说即使你技术领先
[49:08.600 --> 49:11.360] 就能吸引到更多客户
[49:11.360 --> 49:14.120] 那你像其他方面不行的话
[49:14.120 --> 49:18.240] 那没有办法跟AWS来竞争
[49:18.240 --> 49:18.800] 是的
[49:18.800 --> 49:20.720] 这也是很困难的一个问题
[49:20.720 --> 49:22.360] 像AWS其实也宣布了
[49:22.360 --> 49:24.040] 他们开始支持GRPC
[49:24.040 --> 49:26.160] 就是作为一个通讯协议
[49:26.160 --> 49:28.359] 所以你们不能说
[49:28.359 --> 49:31.200] 如果是AWS就不能用
[49:31.200 --> 49:33.440] 没有办法在协议层面做这样的事情
[49:33.440 --> 49:36.240] 就不能说如果检测到AWS环境
[49:36.240 --> 49:37.839] 然后增加疫苗延迟
[49:37.839 --> 49:39.839] 这个是不行的
[49:39.839 --> 49:41.839] 哈哈哈哈
[49:41.839 --> 49:43.839] 哈哈哈哈
[49:43.839 --> 49:47.839] 对所以感觉
[49:47.839 --> 49:52.319] 那就像说你们做这种基础框架
[49:52.320 --> 49:56.680] 就是会背一些这种
[49:56.680 --> 49:59.680] 偏商业的KPI的压力吗
[49:59.680 --> 50:02.000] 其实不会
[50:02.000 --> 50:04.320] 就我们并没有说
[50:04.320 --> 50:06.000] 比如说谷歌内部有多少
[50:06.000 --> 50:08.520] 就是要达到百分之多少用户用GRPC
[50:08.520 --> 50:10.520] 这种指标是没有的
[50:10.520 --> 50:12.800] 那其实还挺好的
[50:12.800 --> 50:14.680] 对吧就你们至少也不用
[50:14.680 --> 50:17.160] 就是说想着要还要怎么推广之类的
[50:17.160 --> 50:20.160] 这种都是有别的人来做的
[50:20.160 --> 50:23.480] 但是也是需要去和客户进行meeting
[50:23.480 --> 50:26.480] 比如说云平台的几个大客户
[50:26.480 --> 50:28.480] 他们提了什么feature
[50:28.480 --> 50:33.200] 那就是直接放在你列表的最顶端
[50:33.200 --> 50:34.200] P0
[50:34.200 --> 50:36.720] 对P0 P1这样子
[50:36.720 --> 50:39.120] ok
[50:39.120 --> 50:41.839] 其实这期真应该把曼陀萨卡叫来
[50:41.839 --> 50:42.839] 因为他也是做云的
[50:42.839 --> 50:45.720] 我不做云我很多东西也不是很了解
[50:45.720 --> 50:48.480] 那你们有遇到过就是说
[50:48.480 --> 50:50.960] GRPC本身出问题然后你们要
[50:50.960 --> 50:53.680] 比如线上去帮客户解决bug之类的吗
[50:53.680 --> 50:57.200] 有过
[50:57.200 --> 51:00.480] 但这个其实和普通的公单没有什么区别
[51:00.480 --> 51:02.560] 我觉得不管是在阿里云或者是什么
[51:02.560 --> 51:04.520] 都是客户有一个什么问题
[51:04.520 --> 51:08.200] 然后最后发现最前端的技术人员
[51:08.200 --> 51:09.800] 无法提供技术支持
[51:09.800 --> 51:11.560] 那就会叫到后面的工程师
[51:11.560 --> 51:15.040] 那我看你还列了两个话题
[51:15.040 --> 51:16.880] 就是如何防止恶意代码
[51:16.880 --> 51:19.480] 从GitHub流入Google的生产环境和
[51:19.480 --> 51:21.480] Google和社区
[51:21.480 --> 51:25.480] 这个就关于第一点就防止恶意代码进入Google
[51:25.480 --> 51:28.000] 就是我觉得GRPC和其他一些
[51:28.000 --> 51:30.000] Google主导的客户框架还不一样
[51:30.000 --> 51:32.000] 因为我最近有
[51:32.000 --> 51:33.800] 参与一些Pytype的事情
[51:33.800 --> 51:37.040] 他们的开发模式是Google内部开发
[51:37.040 --> 51:38.360] 然后推到GitHub上
[51:38.360 --> 51:40.080] 就完全是一个单向的这种
[51:40.080 --> 51:43.280] 对基本算是完全基本是单向的
[51:43.280 --> 51:44.680] 至少大的feature都是
[51:44.680 --> 51:48.839] 像GRPC它是反过来的吗
[51:48.839 --> 51:50.839] 还是它是一个双向都有的
[51:50.839 --> 51:53.440] GRPC是反过来的
[51:53.440 --> 51:56.000] 相当于不管你要做什么改动
[51:56.000 --> 51:57.520] 你都要在GitHub进行
[51:57.520 --> 51:59.120] 然后这个代码会被
[51:59.120 --> 52:02.319] 就是import进Google的生产环境里面
[52:02.319 --> 52:05.799] 而事实上谷歌是有非常多的服务在用GRPC的
[52:05.799 --> 52:07.960] 就可能有八九位数的QPS
[52:07.960 --> 52:10.600] 就如果有人企图
[52:10.600 --> 52:14.480] 比如说如果一份恶意代码真的从GitHub提交了
[52:14.480 --> 52:17.400] 那可能真的会影响到Google的生产环境
[52:17.400 --> 52:21.880] 但是GRPC团队对这个东西的做法
[52:21.880 --> 52:23.840] 它其实是有点相信
[52:23.840 --> 52:28.240] 相信就是谷歌工程师的这种做法
[52:28.240 --> 52:32.520] 就每一个PR都至少需要有两个谷歌工程师
[52:32.520 --> 52:34.440] 盖章认证才可以提交
[52:34.440 --> 52:35.920] 就如果你是一个第三方
[52:35.920 --> 52:40.640] 那你至少要找两个谷歌工程师来对你代码进行代码审阅
[52:40.640 --> 52:46.000] 是,对,就是和一般的提交只需要一个人
[52:46.000 --> 52:48.120] LGTM还不一样,就需要两个
[52:48.120 --> 52:50.359] 所以相当于还是多一道保险
[52:50.359 --> 52:51.200] 对,是
[52:51.200 --> 52:55.839] 那应该有人试图提交过恶意代码吗
[52:55.839 --> 52:59.520] 从我这边倒是不是很清楚
[52:59.520 --> 53:01.799] 但可以和下一个话题连在一起
[53:01.799 --> 53:04.799] 就是开源社区对GRPC还是挺有兴趣的
[53:04.799 --> 53:07.960] 经常会考虑提交一些整合的框架什么的
[53:07.960 --> 53:09.879] 举一个比较好玩的例子
[53:09.880 --> 53:14.440] 比如说有人发现GRPC它本身只是一个通信协议
[53:14.440 --> 53:16.240] 那你做在TCP上做
[53:16.240 --> 53:18.080] 那做在USB上是不是也是做呢
[53:18.080 --> 53:22.400] 他就说如果我写一个GRPC over USB
[53:22.400 --> 53:23.960] 你们会不会接受
[53:23.960 --> 53:25.000] 诸如此类的
[53:25.000 --> 53:29.520] 但其实像这种开源的请求我们没有办法
[53:29.520 --> 53:32.600] 并不是说有人愿意免费帮我们写
[53:32.600 --> 53:33.840] 我们就能接受的
[53:33.840 --> 53:35.280] 因为你接受以后
[53:35.280 --> 53:38.320] 你可能还要面临的很多维护上的问题
[53:38.320 --> 53:40.320] 他有可能提交完以后
[53:40.320 --> 53:42.000] 他这个人就消失了
[53:42.000 --> 53:44.760] 所以在接收个人开发者的时候
[53:44.760 --> 53:46.120] 其实要非常谨慎
[53:46.120 --> 53:48.400] 个人开发者提交代码要非常谨慎
[53:48.400 --> 53:49.760] 是的
[53:49.760 --> 53:53.600] 所以你们更愿意接受一些来自其他大公司的代码
[53:53.600 --> 53:56.480] 对或者是你个人代码
[53:56.480 --> 54:00.280] 除非你实现了很多就是很详尽的test case
[54:00.280 --> 54:03.160] 就保可以保证这个代码持续的运行下去
[54:03.160 --> 54:05.000] 但这一点是很难做到的
[54:05.000 --> 54:08.200] 或者说是不是个人他就修一下BUG就行了
[54:08.200 --> 54:10.839] 然后别想加什么新feature了是吧
[54:10.839 --> 54:13.520] 就除非
[54:13.520 --> 54:16.080] 但你因为你作为个人你很难
[54:16.080 --> 54:18.919] 你很难去给一个承诺说
[54:18.919 --> 54:20.600] 接下来的5年里面
[54:20.600 --> 54:22.960] 如果这个feature出了什么BUG我要修
[54:22.960 --> 54:25.399] 但这个事情很可能变成
[54:25.399 --> 54:28.200] 比如说有一个个人用户他提交这个feature
[54:28.200 --> 54:31.200] 然后他修了一年以后他自己走了
[54:31.200 --> 54:33.439] 然后接下来就变成我来修这个BUG
[54:33.439 --> 54:35.240] 就会变成这个样子
[54:35.240 --> 54:35.839] 对
[54:35.839 --> 54:36.640] 是的
[54:36.640 --> 54:40.600] 所以就是要考虑维护成本的事情
[54:40.600 --> 54:44.960] 然后我觉得谷歌在开源这方面做的其实挺奇怪的
[54:44.960 --> 54:46.200] 像你说PyTab对吧
[54:46.200 --> 54:49.279] 它本身是从谷歌内部开源到外面
[54:49.279 --> 54:51.799] 开源到这个社区来相当于社区里面的人
[54:51.799 --> 54:54.720] 甚至连提交代码都是非常困难这件事情
[54:54.720 --> 54:58.720] 因为他们毕竟没有办法直接改变谷歌内部的代码对吧
[54:58.720 --> 55:02.799] 我觉得应该也是有少量的代码是从GitHub合进来的
[55:02.799 --> 55:04.879] 但我觉得主要的还是
[55:04.880 --> 55:09.200] 就至少内部的人的看法都是先在内部看法来推上去
[55:09.200 --> 55:12.280] 外面是可以贡献代码对不是说不能贡献
[55:12.280 --> 55:14.960] 对但外面的人贡献代码
[55:14.960 --> 55:17.000] 它事实上是需要一个谷歌工程师
[55:17.000 --> 55:18.120] 就看到这个PR
[55:18.120 --> 55:20.880] 然后在内部提交一份一模一样的改动
[55:20.880 --> 55:22.200] 到内部的生产环境
[55:22.200 --> 55:24.200] 然后再把它导出到GitHub来
[55:24.200 --> 55:25.160] 它是这个样子
[55:25.160 --> 55:26.520] 是这样的吗
[55:26.520 --> 55:27.160] 对
[55:27.160 --> 55:31.040] 至少我之前也有提交过PyTab相关的代码
[55:31.040 --> 55:32.640] 之前走的是这个流程
[55:32.640 --> 55:37.080] 哦但也许因为你本来就是Google的工程师
[55:37.080 --> 55:38.720] 所以我也不知道
[55:38.720 --> 55:41.120] anyway到时候我们可以我可以再看一下
[55:41.839 --> 55:45.560] 总之我觉得对开源环境其实也不是太友好
[55:45.560 --> 55:47.440] 它更像是我把代码放上来
[55:47.440 --> 55:48.319] 我就是开源了
[55:48.319 --> 55:51.680] 并不是说我有兴趣去维护这个社区什么的
[55:52.600 --> 55:56.839] 对就是就是大公司的开源其实怎么说呢
[55:56.839 --> 56:00.520] 很多也都是best effort或者只是KPI开源
[56:00.520 --> 56:02.560] 就我觉得Google至少还不是KPI开源
[56:02.560 --> 56:07.360] 就是不像某公司和某某某某某公司之类
[56:07.360 --> 56:11.080] 然后但可能有些时候确实就是说
[56:11.080 --> 56:13.000] 你们没有那么多精力去维护
[56:13.000 --> 56:17.160] 对就像我之前说的之前我找你的那个issue
[56:17.160 --> 56:21.120] 就是就是JRPC Windows的wheel打包的问题
[56:21.120 --> 56:25.200] 然后感觉如果不是有需求
[56:25.200 --> 56:27.840] 可能也就也一直也就不会管
[56:28.279 --> 56:31.080] 其实像Protobuf Python
[56:31.080 --> 56:33.960] 他们现在Windows的包一直都没有
[56:33.960 --> 56:37.360] 就三年久的Windows的wheel一直都没有release
[56:37.360 --> 56:38.920] 应该也是类似的问题
[56:39.759 --> 56:43.440] 还是还是比较难反正
[56:43.440 --> 56:46.240] 但商业开源还是有很强大的力量
[56:46.240 --> 56:48.880] 像Kubernetes就是一个跨公司的合作
[56:48.880 --> 56:50.080] 而且我觉得很成功
[56:51.360 --> 56:55.360] 然后其实它有一点不同公司分管不同部分的意思
[56:55.759 --> 56:58.640] 就比如说Lift或者是VMware
[56:58.640 --> 57:01.440] 他们对Node的层面就会比较有话语权
[57:01.440 --> 57:03.960] 在就是在PR或者在做设计的时候
[57:03.960 --> 57:09.720] 他们就会主导就是虚拟化和容器这方面相关的事情
[57:09.720 --> 57:11.960] 而谷歌最擅长的其实是low balancing
[57:11.960 --> 57:15.160] 那low balancing这一块的决策就可能主要是谷歌在做
[57:15.160 --> 57:19.200] 就有一种踩几百家之长的感觉
[57:20.359 --> 57:25.640] 对像Kubernetes这种项目还是可能还是比较少吧
[57:25.640 --> 57:29.640] 是的像这种比较成功的合作项目是比较少的
[57:29.640 --> 57:31.000] 而且它本身也很复杂
[57:31.000 --> 57:32.640] 大家每个公司都不想自己做
[57:32.640 --> 57:35.279] 于是就加入开源大军
[57:35.839 --> 57:39.720] 是像你之前说的那个叫什么
[57:39.720 --> 57:44.240] Estio是开源的吗
[57:44.240 --> 57:45.200] 也是开源的
[57:45.200 --> 57:49.000] 他也是这种各个公司有不少公司合作的吗
[57:49.000 --> 57:49.319] 还是
[57:49.319 --> 57:50.759] 是的他也是这样的
[57:50.759 --> 57:52.879] 好
[57:52.880 --> 57:57.360] 我们聊了一下商业开源然后以及公司和社区
[57:57.360 --> 58:02.800] 最后我们再来聊一下从GRPC出发聊聊Python的性能
[58:02.800 --> 58:05.560] 因为这也是一个老生常谈的话题了
[58:05.560 --> 58:07.720] 这个要从哪里开始聊呢
[58:07.720 --> 58:12.800] 我觉得我可以先聊一下之前我替换掉GRPC的经历
[58:12.800 --> 58:15.800] 就是Cyberbrain之前
[58:15.800 --> 58:18.200] 你知道Cyberbrain吗
[58:18.200 --> 58:19.360] 我需要先介绍一下
[58:19.360 --> 58:20.680] 我其实不知道
[58:20.680 --> 58:22.480] 不知道什么Cyberbrain
[58:22.480 --> 58:23.160] OK
[58:23.160 --> 58:25.760] 它是我个人搞的一个项目
[58:25.760 --> 58:27.800] 然后挂在我的GitHub上
[58:27.800 --> 58:30.280] 就是第一个项目
[58:30.280 --> 58:32.680] 它是一个Python调试工具
[58:32.680 --> 58:34.240] 这个项目之前
[58:34.240 --> 58:35.960] 就是从最开始
[58:35.960 --> 58:39.160] 它的服务器和客户端通信用的是GRPC
[58:39.160 --> 58:41.000] 因为我的客户端是Python
[58:41.000 --> 58:43.440] 然后服务器端是Node.js
[58:43.440 --> 58:45.320] 所以首先我需要一个跨语言的东西
[58:45.320 --> 58:46.960] 跨语言的RPC框架
[58:46.960 --> 58:52.120] 然后其次我想要有比较严格的schema
[58:52.120 --> 58:53.520] 然后我就用了GRPC
[58:53.520 --> 58:57.080] 因为其实也真的好像没有什么特别多选择
[58:57.080 --> 58:58.279] 最后就发现一个问题
[58:58.279 --> 59:00.000] 就是实现都实现了
[59:00.000 --> 59:01.040] 也没有
[59:01.040 --> 59:02.720] 就是功能上没有任何问题
[59:02.720 --> 59:04.000] 在最后发现
[59:04.000 --> 59:05.480] 性能上有问题
[59:05.480 --> 59:08.480] 就是因为GRPC它是
[59:08.480 --> 59:11.759] 自然你是会跟protocol buffer一起用
[59:11.759 --> 59:17.040] 我就发现Python的protocol buffer的serialization
[59:17.040 --> 59:19.759] 就是从Python代码变成一个这种
[59:19.759 --> 59:21.960] protocol buffer格式的二进制代码
[59:21.960 --> 59:23.320] 它非常非常慢
[59:23.320 --> 59:31.560] 就是反正慢到它大概占了整个程序的10%的时间
[59:31.560 --> 59:33.560] 然后我就去看怎么优化
[59:33.560 --> 59:38.120] 就官网说你可以用CRJ版本的protocol buffer
[59:38.120 --> 59:41.280] 但是要求你这台机器上
[59:41.280 --> 59:43.960] 先预先已经装好CRJ protocol buffer
[59:43.960 --> 59:49.040] 但是我这个是要分发给用户安装的这样一个Python库
[59:49.040 --> 59:49.760] 所以感觉
[59:49.760 --> 59:52.520] 我也不知道有没有办法说让他们去
[59:52.520 --> 59:54.600] 就提前装好CRJ protocol buffer
[59:54.600 --> 59:55.120] 也许有
[59:55.120 --> 59:56.800] 但是总之最后就没有走这条路
[59:56.800 --> 01:00:00.440] 然后就选择说把GRPC换掉
[01:00:00.440 --> 01:00:04.760] 最后我就牺牲了Schema的严谨性
[01:00:04.760 --> 01:00:06.160] 这个方面
[01:00:06.160 --> 01:00:08.160] 然后用了MessagePack
[01:00:08.160 --> 01:00:11.320] 就是另外一个这种更轻量级
[01:00:11.320 --> 01:00:13.840] 并且性能更好的一个这种
[01:00:13.840 --> 01:00:16.280] 就是serialization
[01:00:16.280 --> 01:00:17.960] deserialization的格式
[01:00:17.960 --> 01:00:21.480] 然后换了之后就是serialization这块
[01:00:21.480 --> 01:00:25.200] 你基本就从那个profile的图上看不见了
[01:00:25.200 --> 01:00:27.120] 就从一个10%的瓶颈
[01:00:27.120 --> 01:00:29.040] 变成一个几乎不占时间的东西了
[01:00:29.040 --> 01:00:31.520] 然后我觉得说
[01:00:31.520 --> 01:00:35.360] 就是有些时候性能还是真的挺重要的
[01:00:35.360 --> 01:00:36.080] 对
[01:00:36.080 --> 01:00:37.680] 然后我之前还写过一篇文章
[01:00:37.680 --> 01:00:39.560] 就是说我当时还想过说
[01:00:39.560 --> 01:00:41.640] 能不能不换掉GRPC
[01:00:41.640 --> 01:00:44.480] 而把serialization这块并行化呢
[01:00:44.480 --> 01:00:47.680] 就是因为我有可能有几千个protocol buffer我要生成
[01:00:47.680 --> 01:00:50.600] 如果能并行的话那也是一种方法
[01:00:50.600 --> 01:00:52.600] 但实际上也不行
[01:00:52.600 --> 01:00:56.160] 因为具体的可以看一下那篇文章
[01:00:56.160 --> 01:00:59.319] 就是叫做Why GIL is worse than we thought
[01:00:59.319 --> 01:01:00.839] 大概的意思就是说
[01:01:00.839 --> 01:01:02.839] 就是你如果想并行的去
[01:01:02.839 --> 01:01:04.520] 去执行serialization的话
[01:01:04.520 --> 01:01:06.000] 首先你用多线程是不行的
[01:01:06.000 --> 01:01:07.600] 因为Python多线程有GIL
[01:01:07.600 --> 01:01:09.720] 然后如果你用多进程的话
[01:01:09.720 --> 01:01:12.680] 你又得把这些生成好的protocol buffer
[01:01:12.680 --> 01:01:14.879] 给传到那个主进程里
[01:01:14.880 --> 01:01:18.280] 因为最后他要弄成一个更大的protocol buffer
[01:01:18.280 --> 01:01:19.680] 通过GRPC发出去
[01:01:19.680 --> 01:01:22.600] 但是Python的这个进程间通信
[01:01:22.600 --> 01:01:24.800] 他又要求这个object
[01:01:24.800 --> 01:01:26.240] 传递的这个object
[01:01:26.240 --> 01:01:27.920] 它是那个叫什么peekable的
[01:01:27.920 --> 01:01:29.880] 对就是Python的那个peekable
[01:01:29.880 --> 01:01:32.600] 对但是这些protocol buffer它是不peekable
[01:01:32.600 --> 01:01:34.520] 所以这个事情就根本没有办法做
[01:01:34.520 --> 01:01:36.960] 就没有办法并行
[01:01:36.960 --> 01:01:38.000] 稍微一点搞笑
[01:01:38.000 --> 01:01:39.960] 对就是你要把它传到另外一个进程
[01:01:39.960 --> 01:01:41.800] 你首先要把它serialize
[01:01:41.800 --> 01:01:44.760] 但你又需要另外一个线程来把它给serialize
[01:01:44.760 --> 01:01:45.760] 对
[01:01:45.760 --> 01:01:48.880] 就对你好然后你即使就说
[01:01:48.880 --> 01:01:51.840] 即使说你能够它是peekable的
[01:01:51.840 --> 01:01:53.360] 那你这个还是
[01:01:53.360 --> 01:01:56.880] 你又增加了一道serialization和deserialization的过程
[01:01:56.880 --> 01:01:59.320] 你这个东西是不是也可能成为瓶颈
[01:01:59.320 --> 01:02:00.880] 就是很麻烦
[01:02:00.880 --> 01:02:03.360] 对但其实我想问的是
[01:02:03.360 --> 01:02:05.640] 你觉得这10%的性能
[01:02:05.640 --> 01:02:08.160] 就是对用户体验影响大吗
[01:02:08.160 --> 01:02:11.440] 还是大的是这样的
[01:02:11.440 --> 01:02:14.720] 就是你知道我这个东西是一个调试工具
[01:02:14.720 --> 01:02:16.720] 然后它相当于是说
[01:02:16.720 --> 01:02:18.839] 你跑你自己的代码
[01:02:18.839 --> 01:02:21.560] 我会给你生成一个你的这个data flow的
[01:02:21.560 --> 01:02:23.040] 这样一张图
[01:02:23.040 --> 01:02:25.080] 那问题就在于说
[01:02:25.080 --> 01:02:27.359] 因为它本身就是做这些事儿
[01:02:27.359 --> 01:02:30.399] 就是所以给用户的原来执行代码时间
[01:02:30.399 --> 01:02:32.560] 增加了一些额外的开销
[01:02:32.560 --> 01:02:33.919] 比如说我原来跑代码
[01:02:33.919 --> 01:02:34.879] 一秒钟就跑完了
[01:02:34.879 --> 01:02:38.000] 那你用了cyberbrain可能要跑5秒钟
[01:02:38.000 --> 01:02:40.919] 对吧那这个东西实际上是会
[01:02:40.919 --> 01:02:43.080] 就会影响它的可用性的
[01:02:43.080 --> 01:02:45.759] 就是可能在那个例子里是10%
[01:02:45.759 --> 01:02:47.120] 那有些时候
[01:02:47.120 --> 01:02:48.880] 如果说我这个
[01:02:48.880 --> 01:02:50.720] 就是它执行的时间比较长
[01:02:50.720 --> 01:02:53.520] 我要serialize的东西比较多的话
[01:02:53.520 --> 01:02:55.880] 那可能就可能更长20% 30%
[01:02:55.880 --> 01:02:56.799] 这都是有可能的
[01:02:56.799 --> 01:02:59.080] 那这个东西就相当于它是一个
[01:02:59.080 --> 01:03:00.799] 可能你不可控
[01:03:00.799 --> 01:03:02.799] 然后会无限增长的一块
[01:03:02.799 --> 01:03:04.520] 它又不是说它是一个固定的开销
[01:03:04.520 --> 01:03:05.279] 比如就是一秒钟
[01:03:05.279 --> 01:03:06.200] 它不是这样子
[01:03:06.200 --> 01:03:07.200] 它会增长
[01:03:07.200 --> 01:03:11.120] 所以就还是很有必要消掉
[01:03:11.120 --> 01:03:14.680] 所以我觉得它的这块是确实会影响
[01:03:14.680 --> 01:03:16.680] 影响程序可用性
[01:03:16.680 --> 01:03:19.680] 对这个我同意
[01:03:19.680 --> 01:03:22.880] 但你其实花了额外的CPU cycle
[01:03:22.880 --> 01:03:24.520] 你获得的是
[01:03:24.520 --> 01:03:26.720] 就是你在传输的过程中
[01:03:26.720 --> 01:03:29.000] 它的这个binary是非常小的
[01:03:29.000 --> 01:03:30.480] 所以说如果你在远程调试
[01:03:30.480 --> 01:03:32.120] 然后网络并不好的情况下
[01:03:32.120 --> 01:03:33.319] 我觉得还是有点用的
[01:03:33.319 --> 01:03:34.839] 你是指
[01:03:34.839 --> 01:03:38.080] 我说protobuf serialize之后的结果
[01:03:38.080 --> 01:03:41.200] 然后同时它也可以给你提供
[01:03:41.200 --> 01:03:42.240] schema的检查
[01:03:42.240 --> 01:03:44.240] 就相当于它是一个墙类型的检查
[01:03:44.240 --> 01:03:45.640] 是对
[01:03:45.640 --> 01:03:47.200] 对我是就是
[01:03:47.200 --> 01:03:49.120] 这个schema层面我还是比较怀念的
[01:03:49.120 --> 01:03:50.200] 确实就是
[01:03:50.200 --> 01:03:52.440] MessagePack是没有schema的
[01:03:52.440 --> 01:03:56.680] 所以只能就是用文档或者代码的形式来
[01:03:56.680 --> 01:04:00.680] 来说明
[01:04:00.680 --> 01:04:02.240] 我还是比较喜欢说
[01:04:02.240 --> 01:04:03.319] 如果你有什么问题
[01:04:03.319 --> 01:04:04.759] 最好在build time
[01:04:04.759 --> 01:04:07.040] 就最好在编译的时候就给你指出来
[01:04:07.040 --> 01:04:09.400] 等到在long time出问题就太晚了
[01:04:09.400 --> 01:04:11.320] 是当然对
[01:04:11.320 --> 01:04:12.759] 当然这个是最理想
[01:04:12.759 --> 01:04:15.840] 然后当时其实换掉JRPC还有一个原因
[01:04:15.840 --> 01:04:18.560] 就是我在windows上老搞不好它的
[01:04:18.560 --> 01:04:20.680] protobuf的那些工具链
[01:04:20.680 --> 01:04:22.720] 当然这个跟性能好像没有什么关系
[01:04:22.720 --> 01:04:25.880] 所以就是从这个例子出发
[01:04:25.880 --> 01:04:27.440] 我觉得怎么说呢
[01:04:27.440 --> 01:04:30.480] 就是你要说性能不重要
[01:04:30.480 --> 01:04:31.279] 这肯定是不对的
[01:04:31.279 --> 01:04:33.400] 但是还是主要还是看场景吧
[01:04:33.400 --> 01:04:36.000] 就是有些场景
[01:04:36.000 --> 01:04:37.600] 你的性能不重要
[01:04:37.600 --> 01:04:39.120] 然后有些场景你的性能重要
[01:04:39.120 --> 01:04:41.520] 但是你能够通过一些方法来解决
[01:04:41.520 --> 01:04:44.240] 比如说如果只是请求数量比较多的话
[01:04:44.240 --> 01:04:45.280] 你可能用ebook
[01:04:45.280 --> 01:04:49.000] 然后如果你就是能够用更好的方式去架构程序的话
[01:04:49.000 --> 01:04:50.240] 也许用多线程也是可行
[01:04:50.240 --> 01:04:53.640] 但是有些情况下可能就绕不过去了
[01:04:53.640 --> 01:04:55.360] 然后你就比较尴尬
[01:04:55.360 --> 01:04:57.280] 对要么你就换库
[01:04:57.280 --> 01:04:59.280] 要么就有些公司就换语言了
[01:04:59.280 --> 01:05:01.280] 是呀
[01:05:01.280 --> 01:05:04.320] 就我觉得像比较主流几个python框架
[01:05:04.320 --> 01:05:06.720] 像flask jungle之类的
[01:05:06.720 --> 01:05:08.720] 它的QPS可能就是
[01:05:08.720 --> 01:05:11.880] 5000左右就没有办法再scale
[01:05:11.880 --> 01:05:13.680] 那你就只能用多线程去scale
[01:05:13.680 --> 01:05:16.400] 但如果你换成像golang或CR++之类的
[01:05:16.400 --> 01:05:19.760] 它就可以做到5万甚至10万QPS每个core
[01:05:19.760 --> 01:05:23.840] 这个性能的差距就是非常难以弥补的
[01:05:23.840 --> 01:05:27.360] 我的想法是你如果作为一门语言
[01:05:27.360 --> 01:05:30.480] 其实你如果并不是说开发一个
[01:05:30.480 --> 01:05:32.720] 就是对性能要求非常高的语言的时候
[01:05:32.720 --> 01:05:34.000] 其实python是很好用的
[01:05:34.000 --> 01:05:35.920] 因为它就是戳东西特别快
[01:05:35.920 --> 01:05:37.920] 你想要戳个什么服务出来就很快
[01:05:37.920 --> 01:05:40.960] 对但是当性能真的成为一个瓶颈的时候
[01:05:40.960 --> 01:05:43.040] 我觉得不管怎么hackpython
[01:05:43.040 --> 01:05:44.960] 难道你真的想写一个CR++插件
[01:05:44.960 --> 01:05:46.920] 插在你的python服务器上
[01:05:46.920 --> 01:05:48.680] 那你为什么不直接用CR++呢对吧
[01:05:48.680 --> 01:05:51.880] 是就是在机器学习领域
[01:05:51.880 --> 01:05:53.640] 其实大部分的库也都是
[01:05:53.640 --> 01:05:55.760] 就是用python把CR++包起来
[01:05:55.760 --> 01:05:56.720] 是的
[01:05:56.720 --> 01:05:59.360] 对当然从另外一个角度说
[01:05:59.360 --> 01:06:01.560] 就是这是之前我看沈薇
[01:06:01.560 --> 01:06:02.960] 她的视频里面的一个观点
[01:06:02.960 --> 01:06:05.920] 就是说因为python它开发的比较快
[01:06:05.920 --> 01:06:10.160] 所以你可以就是不断通过去优化一些
[01:06:10.160 --> 01:06:11.280] 一些算法层面
[01:06:11.280 --> 01:06:13.360] 然后来通过这样的
[01:06:13.360 --> 01:06:16.920] 就是相当于迭代你的算法
[01:06:16.920 --> 01:06:19.280] 来让它的性能更优
[01:06:19.280 --> 01:06:22.480] 对当然这个可能怎么说呢
[01:06:22.480 --> 01:06:23.800] 就是还是看场景
[01:06:23.800 --> 01:06:25.160] 有些时候这样有用
[01:06:25.160 --> 01:06:27.440] 有些时候可能就没有特别大用
[01:06:27.440 --> 01:06:29.800] 对我觉得还是应该发挥python
[01:06:29.800 --> 01:06:30.640] 作为Guru Code
[01:06:30.640 --> 01:06:32.960] 它最大的优势就是特别好用
[01:06:32.960 --> 01:06:36.560] 特别擅长把不同的语言结合在一起使用
[01:06:36.560 --> 01:06:38.640] 就你要有什么重要的功能
[01:06:38.640 --> 01:06:40.839] 然后又CPU需要消耗很多CPU
[01:06:40.839 --> 01:06:43.319] 就可以把它设置开成一个subprocess
[01:06:43.319 --> 01:06:44.600] 都是可以的
[01:06:44.600 --> 01:06:48.120] 那像就是因为你列了Sython吧
[01:06:48.120 --> 01:06:49.680] 就是我想问一下
[01:06:49.680 --> 01:06:55.520] 有考虑把JRPCpython用Sython重写的打算吗
[01:06:55.520 --> 01:07:00.040] 其实谷歌内部它有一个这样的effort
[01:07:00.040 --> 01:07:03.040] 因为Sython它本身是可以把python编译成C++
[01:07:03.040 --> 01:07:07.960] 然后C++就可以生成一个就是Dice
[01:07:07.960 --> 01:07:11.680] 就是总之就相当于是把python给编译了
[01:07:11.680 --> 01:07:12.600] 这个东西
[01:07:12.600 --> 01:07:16.279] 那YouTube它的整个前端都是用python写的
[01:07:16.279 --> 01:07:18.200] 他们就有做过这个实验
[01:07:18.200 --> 01:07:21.080] 如果把所有的python code全部都变成C++
[01:07:21.080 --> 01:07:21.320] code
[01:07:21.320 --> 01:07:22.279] 然后再编译的话
[01:07:22.279 --> 01:07:24.759] 事实上是可以带来10%的性能提升的
[01:07:24.759 --> 01:07:26.960] 但是这个项目最后却被取消了
[01:07:26.960 --> 01:07:31.200] 因为Sython它本身有很多不完善的工具链
[01:07:31.200 --> 01:07:33.600] 比如说它就甚至没有一个合适的linter
[01:07:33.600 --> 01:07:35.080] 也没有合适的formatter
[01:07:35.080 --> 01:07:41.240] 然后它可能带来的就是编译会导致你开发python的时候
[01:07:41.240 --> 01:07:43.480] 你比如说写出了什么问题
[01:07:43.480 --> 01:07:44.920] 它最多扔一个exception
[01:07:44.920 --> 01:07:47.240] 但如果你用C++编译之后
[01:07:47.240 --> 01:07:48.800] 它万一给你扔了一个secfold
[01:07:48.800 --> 01:07:52.240] 那这对很多python开发者来说都是无法接受的一个事情
[01:07:52.240 --> 01:07:55.960] 到最后大家就想说不如python它本身
[01:07:55.960 --> 01:07:57.760] 作为一门工具语言
[01:07:57.760 --> 01:07:59.520] 就应该把它优势给发挥出来
[01:07:59.520 --> 01:08:01.920] 就是它可以节省人员成本
[01:08:01.920 --> 01:08:03.000] 节省开发时间
[01:08:03.000 --> 01:08:06.720] 而不是想说去如何把它的性能调得更优
[01:08:06.720 --> 01:08:07.240] 对
[01:08:07.240 --> 01:08:11.640] 是所以后来就就是再逐渐用C++重写
[01:08:11.640 --> 01:08:12.120] 对
[01:08:12.120 --> 01:08:14.240] 所以现在还是逐渐C++重写
[01:08:14.240 --> 01:08:15.440] 是
[01:08:15.440 --> 01:08:20.760] 也是就是大家都说希望那个核心开发者把
[01:08:20.760 --> 01:08:24.240] 把精力多用到改进性能上面
[01:08:24.240 --> 01:08:26.479] 不要天天加余法堂
[01:08:28.120 --> 01:08:31.519] 但我还是觉得性能如果真的是个问题的话
[01:08:31.519 --> 01:08:33.880] 就还是不如换一门工具语言
[01:08:36.160 --> 01:08:36.840] OK
[01:08:36.840 --> 01:08:42.319] 那就是我们最后这个推荐
[01:08:42.319 --> 01:08:43.960] 不知道你有没有准备
[01:08:43.960 --> 01:08:46.760] 推荐让我看一眼
[01:08:46.760 --> 01:08:47.359] sorry
[01:08:48.279 --> 01:08:49.880] 我看一眼我的Github
[01:08:50.519 --> 01:08:51.080] OK
[01:08:51.080 --> 01:08:51.599] 行
[01:08:52.040 --> 01:08:52.960] 我看一下
[01:08:52.960 --> 01:08:55.080] 我之前有看到一个挺酷的
[01:08:55.080 --> 01:08:57.480] 也是一个debug的酷
[01:08:58.160 --> 01:09:00.359] 我虽然不知道你要说哪个
[01:09:00.359 --> 01:09:02.359] 但我知道你要说的我肯定都看过
[01:09:02.359 --> 01:09:05.160] 这么有自信的吗
[01:09:05.760 --> 01:09:07.600] 因为我看过所有这方面的酷
[01:09:08.120 --> 01:09:12.399] 好像这个酷还是挺常见的
[01:09:12.399 --> 01:09:14.240] 就是yep
[01:09:14.240 --> 01:09:14.880] yelp
[01:09:15.120 --> 01:09:16.600] 不知道你有没有听说过
[01:09:16.920 --> 01:09:18.760] y什么
[01:09:19.240 --> 01:09:20.480] yep
[01:09:20.479 --> 01:09:22.479] yep
[01:09:22.479 --> 01:09:23.679] 对
[01:09:23.679 --> 01:09:26.879] 它是用来debug Python C extension
[01:09:26.879 --> 01:09:28.679] 那还真不知道
[01:09:28.679 --> 01:09:29.359] 不好意思
[01:09:29.359 --> 01:09:31.919] 这方面确实是不太了解
[01:09:31.919 --> 01:09:33.919] yep
[01:09:33.919 --> 01:09:35.359] yep这个酷
[01:09:35.359 --> 01:09:39.319] 我当时在debug C extension的时候
[01:09:39.319 --> 01:09:40.839] 发现它有个很强大的功能
[01:09:40.839 --> 01:09:44.240] 比如说你用GDB来debug Python的时候
[01:09:44.240 --> 01:09:46.719] 你所有看到的东西可能都是
[01:09:46.719 --> 01:09:49.279] execute Python frame之类的东西
[01:09:49.279 --> 01:09:51.479] 它就可以把Python对应的函数
[01:09:51.479 --> 01:09:55.240] 帮你生成到最后的图表里面
[01:09:55.240 --> 01:09:56.880] 最后会生成一张非常漂亮的
[01:09:56.880 --> 01:09:59.599] 就是Python函数扣Python函数
[01:09:59.599 --> 01:10:00.920] 然后扣C++函数
[01:10:00.920 --> 01:10:03.280] 一直扣到底层libc的函数
[01:10:03.280 --> 01:10:04.759] 它都可以给你生成出来
[01:10:05.160 --> 01:10:06.000] 这个很酷
[01:10:06.440 --> 01:10:10.840] 我看一下它最新版本是15年发布的
[01:10:10.840 --> 01:10:12.400] 它是已经没有在维护了吗
[01:10:12.400 --> 01:10:14.200] 好像已经没有在维护了
[01:10:14.200 --> 01:10:16.200] 是的
[01:10:16.200 --> 01:10:20.000] 怎么这样
[01:10:20.000 --> 01:10:22.280] 有点遗憾
[01:10:22.280 --> 01:10:25.400] 不过还是很感谢推荐这个
[01:10:25.400 --> 01:10:26.400] 我不知道这个酷
[01:10:26.400 --> 01:10:29.880] ok所以酷你就推荐这个
[01:10:29.880 --> 01:10:34.000] 另外的再推荐一个
[01:10:34.000 --> 01:10:36.000] 比如说你最近正在看的东西
[01:10:36.000 --> 01:10:40.320] 就是书或者什么电影什么都可以
[01:10:40.320 --> 01:10:43.920] 推荐一款游戏
[01:10:43.920 --> 01:10:44.880] 好
[01:10:44.880 --> 01:10:47.960] 不知道有PS4的玩家们
[01:10:47.960 --> 01:10:50.880] 有没有玩过13机兵防卫圈
[01:10:50.880 --> 01:10:52.480] 这个是我之前一直想玩
[01:10:52.480 --> 01:10:55.760] 是没有PS4玩不了的游戏
[01:10:55.760 --> 01:11:00.040] 我觉得是一个特别神奇的一款游戏
[01:11:00.040 --> 01:11:02.520] 因为它的叙事非常特别
[01:11:02.520 --> 01:11:05.560] 甚至我觉得可能只有游戏敢做这样的叙事
[01:11:05.560 --> 01:11:08.080] 你在小说和电影里面是完全打不到的
[01:11:08.080 --> 01:11:09.440] 是一款很有意思的游戏
[01:11:09.440 --> 01:11:09.920] 对
[01:11:09.920 --> 01:11:12.600] 你就在不剧透的情况下
[01:11:12.600 --> 01:11:14.560] 说一下它还有什么其他的优点
[01:11:14.560 --> 01:11:19.560] 它甚至看起来的时候有点像诺兰的电影
[01:11:19.560 --> 01:11:23.600] 就是它会把一个故事可能拆成10份甚至20份
[01:11:23.600 --> 01:11:24.920] 然后以乱序告诉你
[01:11:24.920 --> 01:11:26.600] 但同时它有13条主线
[01:11:26.600 --> 01:11:28.760] 所以每个人的故事可能都拆成了20份
[01:11:28.760 --> 01:11:32.200] 然后就把所有的东西以随机的形式
[01:11:32.200 --> 01:11:33.760] 播放在你面前
[01:11:33.760 --> 01:11:37.280] 然后你要通过已有的信息去在自己脑中组合
[01:11:37.280 --> 01:11:39.040] 这个故事原来是这个样子的
[01:11:39.040 --> 01:11:45.000] 至少动画里和永生之九是差不多的
[01:11:45.000 --> 01:11:46.320] 你看过永生之九吗
[01:11:46.320 --> 01:11:48.000] 看过 有点像
[01:11:48.000 --> 01:11:50.160] 有点像是吧
[01:11:50.160 --> 01:11:52.320] 那个可能没有13条故事线
[01:11:52.320 --> 01:11:54.360] 但是听起来感觉是差不多的
[01:11:54.360 --> 01:11:55.080] 挺好
[01:11:55.080 --> 01:12:00.760] 这个也是反正希望有朝一日还是能玩上游戏吧
[01:12:00.760 --> 01:12:03.800] 要是能port到PC或者Switch就好了
[01:12:03.800 --> 01:12:06.800] 总有一天会port到Switch和PC
[01:12:06.800 --> 01:12:08.280] 总有一天
[01:12:08.280 --> 01:12:09.120] 好
[01:12:09.120 --> 01:12:12.000] 那小白你有什么要推荐的吗
[01:12:12.000 --> 01:12:13.519] 对 你还有什么要推荐吗
[01:12:13.519 --> 01:12:13.920] 也可以说
[01:12:13.920 --> 01:12:17.360] 我们也没有什么严格的数量限制
[01:12:17.360 --> 01:12:18.440] 我没有了
[01:12:18.440 --> 01:12:21.360] 就看各位主播吧
[01:12:21.360 --> 01:12:22.240] 行
[01:12:22.240 --> 01:12:24.080] 那小白你那边有吗
[01:12:24.080 --> 01:12:26.320] 我好像真的没什么
[01:12:26.320 --> 01:12:29.519] 我最近看的书都是一些cover
[01:12:29.519 --> 01:12:31.880] 然后也没有在写代码
[01:12:31.880 --> 01:12:34.519] 所以库的话用的也不是特别多
[01:12:34.519 --> 01:12:37.040] 所以小白是大学生吗
[01:12:37.040 --> 01:12:40.080] 算是吧
[01:12:40.080 --> 01:12:43.120] 现在还在读大学
[01:12:43.120 --> 01:12:45.920] 这样子年轻有为
[01:12:45.920 --> 01:12:48.360] 没有很搞笑的
[01:12:48.360 --> 01:12:50.680] 一会儿聊一会儿结束了
[01:12:50.680 --> 01:12:52.480] 然后可以跟你聊一下
[01:12:52.480 --> 01:12:53.760] OK
[01:12:53.760 --> 01:12:54.840] 这样子
[01:12:54.840 --> 01:12:57.200] 其实书的话我还有一本推荐
[01:12:57.200 --> 01:12:59.360] 但这本书就跟编程没有什么关系
[01:12:59.360 --> 01:13:01.440] 你说
[01:13:01.440 --> 01:13:05.160] 它是好像是前几年的经济学家
[01:13:05.160 --> 01:13:07.360] 诺贝尔经济学奖得主写的一本
[01:13:07.360 --> 01:13:09.120] 就是关于贫穷经济学
[01:13:09.120 --> 01:13:11.960] 他就讲为什么世界上有贫穷的存在
[01:13:11.960 --> 01:13:14.639] 就是我们如何去拯救世界上的贫穷
[01:13:14.639 --> 01:13:15.720] 就是你在看的时候
[01:13:15.720 --> 01:13:18.040] 你就会想很多
[01:13:18.040 --> 01:13:20.120] 就可能很多人的观点就是
[01:13:20.120 --> 01:13:22.400] 很多人穷是因为他不努力
[01:13:22.400 --> 01:13:23.320] 所以穷
[01:13:23.320 --> 01:13:24.480] 那有的人观点是
[01:13:24.480 --> 01:13:26.240] 我只要给穷人钱
[01:13:26.240 --> 01:13:29.160] 他们就是有钱去买更多生产工具
[01:13:29.160 --> 01:13:30.680] 然后就可以生产更多东西
[01:13:30.680 --> 01:13:32.680] 然后就可以逐渐变得有钱
[01:13:32.680 --> 01:13:33.000] 对
[01:13:33.000 --> 01:13:35.080] 他就可以帮你思考这些问题
[01:13:35.080 --> 01:13:38.280] 他的结论是你后面说这个吗
[01:13:38.280 --> 01:13:40.960] 就是说我们需要给穷人钱
[01:13:40.960 --> 01:13:42.600] 让他能够去发展自己吗
[01:13:42.600 --> 01:13:44.440] 他更像是做调查
[01:13:44.440 --> 01:13:48.880] 告诉你这不是一个简单的需求端和供给端的问题
[01:13:48.880 --> 01:13:51.840] 他是需要就是在供给端努力
[01:13:51.840 --> 01:13:53.240] 也需要在需求端努力
[01:13:53.240 --> 01:13:56.760] 那个等一下我想起来了
[01:13:56.760 --> 01:13:59.360] 我推荐一个访谈类的节目吧
[01:13:59.360 --> 01:14:01.000] 叫十三腰
[01:14:01.000 --> 01:14:01.960] 哦
[01:14:01.960 --> 01:14:03.519] 我就知道你要说这个
[01:14:03.520 --> 01:14:07.880] 因为我其实是比较喜欢看这种访谈类
[01:14:07.880 --> 01:14:09.040] 就是说话的节目
[01:14:09.040 --> 01:14:09.280] 对
[01:14:09.280 --> 01:14:12.880] 然后之前失眠的时候一直有看这个
[01:14:12.880 --> 01:14:14.680] 那好啊
[01:14:14.680 --> 01:14:15.280] 对啊
[01:14:15.280 --> 01:14:17.720] 就是这节目还是挺有名的
[01:14:17.720 --> 01:14:19.080] 不过我就看过一期
[01:14:19.080 --> 01:14:24.560] 你有特别喜欢的某几期吗
[01:14:24.560 --> 01:14:26.640] 还行
[01:14:26.640 --> 01:14:27.760] 我其实都挺喜欢的
[01:14:27.760 --> 01:14:30.720] 因为他找的这些人都特别的有意思
[01:14:30.720 --> 01:14:34.480] 就是你像他也找过他找过这些比较
[01:14:34.480 --> 01:14:36.760] 当时比较热门的一些人
[01:14:36.760 --> 01:14:38.600] 然后你像李诞
[01:14:38.600 --> 01:14:42.000] 然后马东罗振宇这一些
[01:14:42.000 --> 01:14:46.720] 然后他还找过很多这种人文社科类的这种学者
[01:14:46.720 --> 01:14:49.160] 比如说最近特别出名的罗翔
[01:14:49.160 --> 01:14:50.520] 罗老师
[01:14:50.520 --> 01:14:50.840] 对
[01:14:50.840 --> 01:14:52.360] 他也是有聊过
[01:14:52.360 --> 01:14:54.920] 就是不要把它当成一个节目
[01:14:54.920 --> 01:14:58.000] 就纯粹的当成两个人在聊天的话
[01:14:58.000 --> 01:14:59.720] 我会感觉特别有意思
[01:14:59.720 --> 01:15:00.720] 对
[01:15:05.720 --> 01:15:06.480] OK
[01:15:06.480 --> 01:15:10.760] 然后我这边暂时没有什么要推荐了
[01:15:10.760 --> 01:15:11.680] 那OK
[01:15:11.680 --> 01:15:13.640] 那我们今天差不多就这样
[01:15:13.640 --> 01:15:15.680] 我们给听众们打个招呼
[01:15:15.680 --> 01:15:16.400] 然后就结束了
[01:15:16.400 --> 01:15:17.680] 好
[01:15:17.680 --> 01:15:19.400] 那就各位听众我们下期再见
[01:15:19.400 --> 01:15:31.400] 拜拜
[01:15:49.400 --> 01:15:54.400] 我们下期再见
