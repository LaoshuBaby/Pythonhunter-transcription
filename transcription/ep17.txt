[00:00.000 --> 00:07.700] 欢迎收看请关注评论、点赞、转发
[00:07.700 --> 00:14.400] 这期视频的主题是
[00:14.400 --> 00:21.640] 这期视频的主题是
[00:21.640 --> 00:27.120] 这期视频的主题是
[00:27.120 --> 00:28.560] 各位听众朋友们大家好
[00:28.560 --> 00:30.560] 欢迎来到这一期的补车着说
[00:30.560 --> 00:32.360] 我们这一期的主题是
[00:32.360 --> 00:34.360] Use the Flick It, Look
[00:34.360 --> 00:36.760] 然后我们邀请到的嘉宾也是 Luke
[00:36.760 --> 00:39.560] Luke 跟大家做一下自我介绍
[00:39.560 --> 00:41.160] Hello 大家好
[00:41.160 --> 00:42.160] 我是 Luke
[00:42.160 --> 00:44.560] 我现在主要还是在用 Python
[00:44.560 --> 00:47.160] 然后之前也写过一段时间的 GoLang
[00:47.160 --> 00:51.160] 然后职业的话主要还是做的后端这一方面的
[00:51.160 --> 00:51.960] 就这样
[00:51.960 --> 00:54.360] 然后我们这一期的主题
[00:54.360 --> 00:56.560] 就是起了一个星战里面的
[00:56.560 --> 00:59.560] 有星战味道的名字叫 Use the Flick It
[00:59.560 --> 01:01.560] 我们这一期主要会聊一下
[01:01.560 --> 01:04.560] Python的就是原代码的 Lint 相关的话题
[01:04.560 --> 01:06.560] 就是怎么检查代码风格
[01:06.560 --> 01:10.560] 然后主要的工具就是 Flick 8
[01:10.560 --> 01:12.760] 因为我们日常很多项目
[01:12.760 --> 01:14.960] 基本上现在用的都 Flick 8 比较多
[01:14.960 --> 01:16.560] 用 p1 Lint
[01:16.560 --> 01:18.560] pp8 这些应该比较少了
[01:18.560 --> 01:19.160] 对吧
[01:19.160 --> 01:20.960] Luke 要不你先介绍一下
[01:20.960 --> 01:23.760] 你平时的项目基本上都用什么 Lint 工具呢
[01:23.760 --> 01:28.360] 我的话自己的项目和目前工作的项目
[01:28.360 --> 01:29.960] 应该都是用的 Flick 8
[01:29.960 --> 01:32.360] 然后之前的话
[01:32.360 --> 01:35.960] 你在有一份用 Python 的工作里面用过 p1 Lint
[01:35.960 --> 01:38.960] 但是我觉得 p1 Lint 配置起来
[01:38.960 --> 01:41.360] 实在是太复杂太麻烦了
[01:41.360 --> 01:44.760] 我觉得如果你没有自己积累的配置文件
[01:44.760 --> 01:45.960] 从头开始配置的话
[01:45.960 --> 01:49.760] 肯定都得花个可能半个小时到一个小时
[01:49.760 --> 01:50.560] 这个样子
[01:50.560 --> 01:52.160] 至少都是这样这么长的时间
[01:52.160 --> 01:54.160] 就它选项实在是太多了
[01:54.160 --> 01:54.560] 行
[01:54.560 --> 01:56.360] 那我们先聊一下这些工具
[01:56.360 --> 01:57.960] 那么除了 p1 Lint
[01:57.960 --> 01:59.960] p p8 跟 Black 你用过吗
[01:59.960 --> 02:02.759] 我们现在也用 Black
[02:02.759 --> 02:05.360] 然后我们还会用有一个
[02:05.960 --> 02:07.960] 排序依赖的叫 Isot
[02:07.960 --> 02:11.359] 然后 Black 相当于是拿来format 代码
[02:11.359 --> 02:14.760] 然后 Isot 就是只是给 import 排个序
[02:14.760 --> 02:16.760] 就强迫症患者比较友好
[02:16.760 --> 02:18.359] 就如果你有很强的强迫症
[02:18.359 --> 02:20.760] 喜欢看到 import 被排序的话
[02:20.760 --> 02:24.160] Ok 那个 Isot 是一个 flick8 的插件对吧
[02:25.359 --> 02:28.359] 我不知道他有没有 flick8 的插件
[02:28.359 --> 02:29.760] 他好像也有 flick8 的插件
[02:29.760 --> 02:32.760] 但是他其实也可以自己单独用的
[02:32.760 --> 02:33.359] 这样子
[02:33.359 --> 02:33.959] Ok
[02:33.959 --> 02:36.760] 那就是你们 CI 里面有三个命令
[02:36.760 --> 02:37.760] 先看 Isot
[02:37.760 --> 02:38.959] 然后再 Black
[02:38.959 --> 02:39.959] 然后 flick8
[02:39.959 --> 02:41.760] 看一下这三个命令的
[02:41.959 --> 02:45.359] 退出的 exit code 是不是都是 0
[02:45.359 --> 02:45.760] 对吧
[02:45.760 --> 02:46.560] 如果都通过了
[02:46.560 --> 02:47.959] 那就这个 CI 就通过了
[02:47.959 --> 02:48.560] 是这样
[02:48.560 --> 02:51.760] 差不多是这样子
[02:51.760 --> 02:54.560] 我会有一个 makefile 把它们包装一下
[02:54.560 --> 02:56.960] 就比如说 make check style 之类的
[02:56.960 --> 02:59.160] 然后他就会先执行 Black
[02:59.160 --> 03:00.960] 然后检查代码的风格
[03:00.960 --> 03:01.960] 是不是被格式化了
[03:01.960 --> 03:04.960] 然后再执行 Isot 的检查
[03:04.960 --> 03:06.760] 就检查依赖是不是排序了
[03:06.760 --> 03:09.160] 我基本上只用 Black
[03:09.160 --> 03:12.560] 然后跟 flick8 Black 去把那个
[03:12.560 --> 03:14.160] 因为经过 Black 的文件
[03:14.160 --> 03:15.760] 它的格式基本上是统一的
[03:15.760 --> 03:19.359] 就是所有人 Black 的格式都是统一的
[03:19.359 --> 03:24.560] 那个 diff 里面就不会有额外的纯格式的 diff
[03:24.560 --> 03:24.959] 对吧
[03:24.959 --> 03:27.160] 然后用 flick8 来检查一些其他的
[03:27.160 --> 03:29.359] 之前用过 pivotint
[03:29.359 --> 03:30.760] 我记得 pivotint
[03:30.760 --> 03:32.760] 除了你刚刚说的那个配置复杂
[03:32.760 --> 03:35.160] 应该还有一个不如 flick8 好的地方
[03:35.160 --> 03:38.160] 就是他只检查你的风格
[03:38.160 --> 03:40.359] 就是你有没有用一些像 fileter
[03:40.359 --> 03:42.560] 他会告诉你不推荐用这个
[03:42.560 --> 03:45.960] 最好用那个列表生成式对吧
[03:45.960 --> 03:48.360] 然后 flick8 可能会提示你写的代码
[03:48.360 --> 03:49.760] 可能有潜在的逻辑错误
[03:49.760 --> 03:52.760] 比如说有个变量定义了没有使用
[03:52.760 --> 03:55.960] pivotint 我记得也能做很多语义上的检查
[03:55.960 --> 03:58.960] 比如说那个你用一个 bareexcept
[03:58.960 --> 04:01.360] 就是只写一个except 什么都不写
[04:01.360 --> 04:03.560] 他会把所有的错误码上到你
[04:03.560 --> 04:06.960] 然后这种他也可以帮你检查出来
[04:06.960 --> 04:08.960] 就我之前用 pivotint
[04:08.960 --> 04:12.560] 就是因为当时 flick8 也没有去研究
[04:12.560 --> 04:14.960] 然后也没有去找那个插件
[04:14.960 --> 04:16.960] 他自己是检测不了这种问题的
[04:16.960 --> 04:19.160] 然后就用了 pivotint
[04:19.160 --> 04:21.960] 然后现在发现的话就是
[04:21.960 --> 04:27.160] 其实 flick8 也有很多种可以检测你的语义的插件
[04:27.160 --> 04:29.560] 然后就直接用 flick8 就好了
[04:29.560 --> 04:32.760] 对我觉得 flick8 现在特别流行的一个原因
[04:32.760 --> 04:34.360] 就是他的那个插件系统
[04:34.360 --> 04:37.760] 就是他这个东西我感觉就跟那个
[04:37.760 --> 04:41.159] jongo 一样你在里面可以实现各种各样的检查
[04:41.159 --> 04:44.560] 对吧比如说 import 排序
[04:44.560 --> 04:47.360] 比如说你可以写一个插件
[04:47.360 --> 04:51.560] 让那个变量名字不能小于三个字母这种
[04:51.560 --> 04:57.159] 对对对然后前一段时间我还就找了一个那个
[04:57.159 --> 05:00.960] tuple unpack 的插件就相当于你
[05:00.960 --> 05:03.560] 比如说你的 tuple 超过四个
[05:03.560 --> 05:05.360] 他就会帮你检查出来
[05:05.360 --> 05:09.560] 因为有时候你如果一直往里面加 tuple 的参数
[05:09.560 --> 05:10.560] 就会变得很长
[05:10.560 --> 05:12.160] 然后很难阅读这种单词
[05:12.160 --> 05:14.960] 对对一个函数可以直接 return 一个
[05:14.960 --> 05:17.960] 比如十个二十几个的那个结果
[05:17.960 --> 05:20.160] 然后你用 tuple 来解剖开
[05:20.160 --> 05:22.360] 其实就比较理想的方式
[05:22.360 --> 05:27.360] 其实是用那个 name 的 tuple
[05:27.360 --> 05:29.360] 但是有时候写代码可能
[05:29.360 --> 05:31.360] 比如说写的比较急
[05:31.360 --> 05:35.360] 就没有注意这些细节就就写上去了
[05:35.360 --> 05:37.560] ok 那我们接着再聊一下
[05:37.560 --> 05:42.560] 就是在 ci 里面加入这一项一些 link 插件的好处吧
[05:42.560 --> 05:44.760] 我觉得首先一个就是
[05:44.760 --> 05:47.560] 可以帮你检查出来一些潜在的错误
[05:47.560 --> 05:50.560] 对吧就每次 ci 跑一遍
[05:50.560 --> 05:52.160] 如果挂了你肯定去修它
[05:52.160 --> 05:54.760] 我写代码的时候
[05:54.760 --> 05:59.560] 其实有很多问题都是 flick8 发现的
[05:59.560 --> 06:02.560] 因为 python 没有那个编译
[06:02.560 --> 06:06.560] 就很多比如说你写了一个错别字
[06:06.560 --> 06:09.560] 那 flick8 就可能就帮你检查出来
[06:09.560 --> 06:12.560] 对对对是这样子的
[06:12.560 --> 06:15.560] 然后因为我自己的话我用 IDE 多一点
[06:15.560 --> 06:19.560] 所以说可能就 IDE 会给你很多提示
[06:19.560 --> 06:21.560] 然后比如说编量引用了
[06:21.560 --> 06:23.560] 然后引用了但是没有定义之类的
[06:23.560 --> 06:25.560] 它会给你画个红线
[06:25.560 --> 06:28.560] 但是如果说不用编 IDE 的话
[06:28.560 --> 06:31.560] 其实就 flick8 就能帮你检查出来这些问题
[06:31.560 --> 06:37.560] 对那个 IDE 里面的检查是 IDE 自己实现吗
[06:37.560 --> 06:41.560] 应该是 IDE 自己实现的
[06:41.560 --> 06:43.560] 应该不是 flick8 的
[06:43.560 --> 06:45.560] 但是它也是兼容那种
[06:45.560 --> 06:49.560] 叫 python code style 的那些检查风格
[06:49.560 --> 06:54.560] 比如说有那种你写三个警号做注释
[06:54.560 --> 06:55.560] 它就会提示你
[06:55.560 --> 06:59.560] track code style 不提倡使用这种注释风格
[06:59.560 --> 07:02.560] ok ok 那 flick8 还没有这个检查
[07:02.560 --> 07:05.560] 他们这个 IDE 自己搞了这么一套东西
[07:05.560 --> 07:07.560] 又不开源我感觉挺浪费
[07:07.560 --> 07:10.560] 好像有一部分是开源的吧可能
[07:10.560 --> 07:12.560] 就比如说你用 pycharm
[07:12.560 --> 07:15.560] 然后它可能很多高级功能
[07:15.560 --> 07:18.560] 比如说模板啊 html 啊可能就是收费的
[07:18.560 --> 07:20.560] 然后你如果只是拿来写一点
[07:20.560 --> 07:21.560] 简单的 python 脚本
[07:21.560 --> 07:24.560] 其实应该是不收费的这样
[07:24.560 --> 07:28.560] ok 其实 vim 里面可以集成那个 flick8
[07:28.560 --> 07:30.560] 就是你写代码的时候
[07:30.560 --> 07:32.560] 比如说你安装了一个 flick8
[07:32.560 --> 07:34.560] 然后安装了一个 flick8 跟 isot
[07:34.560 --> 07:36.560] 假如说有什么插件的话
[07:36.560 --> 07:37.560] 然后你写代码的时候
[07:37.560 --> 07:39.560] 你写的那个 import 顺序不对
[07:39.560 --> 07:41.560] 你的 vim 里面可能也出来一些
[07:41.560 --> 07:43.560] 叉号啊之类的东西
[07:43.560 --> 07:45.560] 或者是标红色这种
[07:45.560 --> 07:47.560] 是也可以集成的
[07:47.560 --> 07:48.560] 对对对 vim 的话
[07:48.560 --> 07:51.560] 我记得有一个插件叫 fantastic
[07:51.560 --> 07:52.560] 是叫这个名字
[07:52.560 --> 07:55.560] 然后对他就是相当于会自动发现
[07:55.560 --> 07:56.560] 你装了那些 checker
[07:56.560 --> 07:58.560] 然后就自动用起来
[07:58.560 --> 07:59.560] 是的是的
[07:59.560 --> 08:01.560] 就我把这个东西已经换成那个 coc 了
[08:01.560 --> 08:03.560] 我感觉 coc 搞得特别好
[08:03.560 --> 08:04.560] fantastic 有个问题
[08:04.560 --> 08:06.560] 我记得他好像是同步的
[08:06.560 --> 08:08.560] 因为有很多 python 项目
[08:08.560 --> 08:11.560] 就会把整个文件写到一个 pi 文件里面
[08:11.560 --> 08:12.560] 比如说 black 对吧
[08:12.560 --> 08:13.560] black 里面
[08:13.560 --> 08:16.560] 就是就一个 black.pi 几千行
[08:16.560 --> 08:18.560] 然后每次假如说用那个 vim
[08:18.560 --> 08:20.560] 加那个 fantastic 打开的话
[08:20.560 --> 08:21.560] 就特别特别卡
[08:21.560 --> 08:22.560] 就一个文件几千行
[08:22.560 --> 08:23.560] 这也太可怕了吧
[08:23.560 --> 08:25.560] 我不知道他是哪里的风格
[08:25.560 --> 08:27.560] 就很多很多 python 项目
[08:27.560 --> 08:29.560] 都是整个项目就一个 pi 文件的
[08:29.560 --> 08:31.560] 我知道有很多那种比较小的
[08:31.560 --> 08:33.559] 就是比如说我上次看那个
[08:33.559 --> 08:34.559] flag8 的插件
[08:34.559 --> 08:36.559] 就是一个 pi 项目
[08:36.559 --> 08:39.559] 就只有一个刚刚 init py
[08:39.559 --> 08:41.559] 但是他那个项目可能也就
[08:41.559 --> 08:43.559] 不到两百行的代码
[08:43.559 --> 08:44.560] 这种其实就还好
[08:44.560 --> 08:47.560] 但是大的项目感觉就不太好
[08:47.560 --> 08:48.560] 这种放在一起
[08:48.560 --> 08:49.560] 是的
[08:49.560 --> 08:51.560] 我感觉其实我感觉那个
[08:51.560 --> 08:52.560] flag8 的插件
[08:52.560 --> 08:54.560] 大部分都是只有一个文件的
[08:54.560 --> 08:56.560] 写起来看起来都比较简单
[08:56.560 --> 08:57.560] 而且打开那个文件
[08:57.560 --> 08:59.560] 你就能知道他干的啥
[08:59.560 --> 09:00.560] 对对对是
[09:00.560 --> 09:02.560] 就我这几天照猫画虎
[09:02.560 --> 09:04.560] 看了一下那个
[09:04.560 --> 09:05.560] flag8 的插件怎么写
[09:05.560 --> 09:07.560] 因为我自己想写一个
[09:07.560 --> 09:10.560] 就是禁用点点 import 这种插件
[09:10.560 --> 09:13.560] 然后我就翻了一下他们的 manual
[09:13.560 --> 09:16.560] 然后就是他也其实是相当于有两种
[09:16.560 --> 09:18.560] 一种是那个函数的
[09:18.560 --> 09:19.560] 然后一种是基于累的
[09:19.560 --> 09:22.560] 累的就是他会给你一个 AST
[09:22.560 --> 09:24.560] 然后你去编你那个 AST
[09:24.560 --> 09:25.560] 然后找到你想要的节点
[09:25.560 --> 09:28.560] 然后就做一下判断就好了
[09:28.560 --> 09:31.560] 函数的我还没有怎么研究
[09:31.560 --> 09:33.560] 但是他那个好像可以自动给你提供
[09:33.560 --> 09:35.560] 很多的关于原代码的信息
[09:35.560 --> 09:37.560] 比如说函数啊
[09:37.560 --> 09:38.560] token啊之类的
[09:38.560 --> 09:40.560] 对对
[09:40.560 --> 09:41.560] 我大体看过
[09:41.560 --> 09:42.560] 但是其实我没写过
[09:42.560 --> 09:44.560] 一会我们再聊这个话题吧
[09:44.560 --> 09:45.560] 怎么写插件
[09:45.560 --> 09:47.560] 再回到 CI 这个问题
[09:47.560 --> 09:50.560] 我觉得那个就是整个团队里面
[09:50.560 --> 09:52.560] 比如说四个人开发同一个项目
[09:52.560 --> 09:54.560] 就每个人可能有自己的编辑器配置
[09:54.560 --> 09:55.560] 对吧
[09:55.560 --> 09:56.560] 有自己的 VM 配置
[09:56.560 --> 09:59.560] 你有自己的一些可能有代码喜好
[09:59.560 --> 10:01.560] 然后用这个 lint 的话
[10:01.560 --> 10:04.560] 可以统一相当一部分的规范
[10:04.560 --> 10:07.560] 而且把一个代码的那个风格吧
[10:07.560 --> 10:09.560] 就在团队里
[10:09.560 --> 10:11.560] 比如说我们规定四个人
[10:11.560 --> 10:12.560] 我们都这么写
[10:12.560 --> 10:15.560] 但是你就是这么说一下就很难维持
[10:15.560 --> 10:17.560] 但是假如你把这个规则加到 lint 里面
[10:17.560 --> 10:20.560] 每次不 check 这个代码就合不进去
[10:20.560 --> 10:24.560] 这样的话就可以用代码来实现这么一个约定
[10:24.560 --> 10:25.560] 对对对
[10:25.560 --> 10:26.560] 是的
[10:26.560 --> 10:29.560] 就是相当于其实你如果只是一个规定的话
[10:29.560 --> 10:30.560] 就你
[10:30.560 --> 10:32.560] 要么就是人肉去检查
[10:32.560 --> 10:33.560] 但是就一是重复劳动
[10:33.560 --> 10:35.560] 二是肯定会有遗漏嘛
[10:35.560 --> 10:38.560] 然后如果你用机器帮你检查
[10:38.560 --> 10:40.560] 就不会有这个问题嘛
[10:40.560 --> 10:42.560] 对就尤其是开源项目
[10:42.560 --> 10:44.560] 因为很多人来给你 TPR
[10:44.560 --> 10:45.560] 都是第1次嘛
[10:45.560 --> 10:49.560] 他们肯定不会看你写了那么一个长的文档
[10:49.560 --> 10:51.560] 说这个代码应该怎么写
[10:51.560 --> 10:52.560] 我们提倡用这个风格
[10:52.560 --> 10:53.560] 不提倡用这个风格
[10:53.560 --> 10:57.560] 那但假如说我你把它放在 lint 里面
[10:57.560 --> 11:00.560] 那他只要只要给你 TPR 就可以了
[11:00.560 --> 11:02.560] 然后他看一下哪些 lint 没有通过
[11:02.560 --> 11:04.560] 他再去一个一个的修改过来
[11:04.560 --> 11:05.560] 这样成本也比较低
[11:05.560 --> 11:06.560] 是的
[11:06.560 --> 11:07.560] 是的
[11:07.560 --> 11:10.560] 说起来那个就是你刚刚说那个风格的
[11:10.560 --> 11:12.560] 还有一个东西叫做 editor config
[11:12.560 --> 11:14.560] 就是你添加了之后
[11:14.560 --> 11:17.560] 然后如果是支持的编辑器
[11:17.560 --> 11:21.560] 他就会自动按那个风格去写你的代码
[11:21.560 --> 11:24.560] 比如说你的缩镜是用 tab 还是用 space
[11:24.560 --> 11:27.560] 然后一个缩镜是多少个空格啊这种
[11:27.560 --> 11:29.560] 然后还有画航服是什么风格啊这种
[11:29.560 --> 11:31.560] 他都可以帮你规定
[11:31.560 --> 11:34.560] 就相当于会有一个最基本的这种风格的
[11:34.560 --> 11:38.560] 不知道是不是这个是哪个编辑器提出来的吗
[11:38.560 --> 11:40.560] 因为我知道 vim 里面你可以在
[11:40.560 --> 11:44.560] 就是开头或者结尾写那个 set tab 等于 r 这种
[11:44.560 --> 11:46.560] 在文件里面写
[11:46.560 --> 11:49.560] 我不知道 vim 支持不支持这个 editor config
[11:49.560 --> 11:51.560] vim 应该是有一个插件我记得
[11:51.560 --> 11:55.560] 然后我也不知道这个是不是一个编辑器提出来的
[11:55.560 --> 11:57.560] 还是谁想出来的
[11:57.560 --> 11:59.560] 反正就是支持这个还挺多的
[11:59.560 --> 12:01.560] 可能 VS Code 也支持这个
[12:01.560 --> 12:03.560] 但是可能也是要装一个插件
[12:03.560 --> 12:06.560] 然后 IDEER 的话就直接就自带了
[12:06.560 --> 12:08.560] 我们还是说回 CI 吧
[12:08.560 --> 12:10.560] OK 说回 CI
[12:10.560 --> 12:14.560] 然后还有一个我觉得 pattern 里面特别好的一个东西是 black
[12:14.560 --> 12:17.560] 因为就是你即使都符合 flick 吧
[12:17.560 --> 12:20.560] 但是你可能就是函数在什么时候换行啊这些
[12:20.560 --> 12:23.560] 就是一个特别长的函数参数也比较多
[12:23.560 --> 12:24.560] 你怎么换行
[12:24.560 --> 12:28.560] 这种东西假如说别人也是第一次给你提项目的话
[12:28.560 --> 12:31.560] 他可能写的就是风格跟你不一样
[12:31.560 --> 12:34.560] 以后你改的话可能不小心就再给这个地方加个 diff
[12:34.560 --> 12:38.560] 然后 git commit 里面的信息就发现很多人改过这个文件
[12:38.560 --> 12:40.560] 但很多都是 format
[12:40.560 --> 12:42.560] 如果用 black 这种
[12:42.560 --> 12:44.560] 就是大家写的电脑就就一个风格
[12:44.560 --> 12:45.560] 然后我觉得挺好的
[12:45.560 --> 12:48.560] 但是我知道有很多人不喜欢这个
[12:48.560 --> 12:50.560] 他太强制了
[12:50.560 --> 12:53.560] 不知道你们怎么看 black 这个
[12:53.560 --> 12:56.560] 我觉得其实也挺好的吧
[12:56.560 --> 13:00.560] 因为其实 python 本身就还是有一个 PEP 8
[13:00.560 --> 13:05.560] PEP 8 上的一个官方比较强势的一个风格嘛
[13:05.560 --> 13:08.560] 然后 black 就相当于是把
[13:08.560 --> 13:11.560] 自动把你的代码切换到这个风格上面
[13:11.560 --> 13:12.560] 对对对
[13:12.560 --> 13:14.560] 但他真的是非常严格
[13:14.560 --> 13:16.560] 单引号跟双引号都会帮你控制
[13:16.560 --> 13:18.560] 而且我记得好像 black 8
[13:18.560 --> 13:21.560] black 好像没有什么那种
[13:21.560 --> 13:23.560] 很少有选项之类的
[13:23.560 --> 13:25.560] 就几乎你控制不了那个
[13:25.560 --> 13:27.560] flag format 出来的那个格式
[13:27.560 --> 13:29.560] 就他给你什么格式
[13:29.560 --> 13:31.560] 你就是什么格式
[13:31.560 --> 13:34.560] 你可以让他不去关心
[13:34.560 --> 13:36.560] 那个自主创造单引号还是双引号的
[13:36.560 --> 13:38.560] 但是我都没改window 默认
[13:38.560 --> 13:39.560] 其实black 有个坑
[13:39.560 --> 13:44.560] 我觉得就是他那个black后面要加一个
[13:44.560 --> 13:45.560] 你要防model的文件嘛
[13:45.560 --> 13:46.560] 一般都是black 点
[13:46.560 --> 13:47.560] 然后是刚刚check
[13:47.560 --> 13:50.560] 把这种一个句话放到ci里面
[13:50.560 --> 13:51.560] 对吧
[13:51.560 --> 13:52.560] 对
[13:52.560 --> 13:55.560] 就是我一开始搞一个项目的时候
[13:55.560 --> 13:57.560] 然后我没有加那个点嘛
[13:57.560 --> 13:58.560] 就black 刚刚check
[13:58.560 --> 14:01.560] 然后他的退出的那个exit code
[14:01.560 --> 14:03.560] 竟然是0不是1
[14:03.560 --> 14:04.560] 就不会提示你
[14:04.560 --> 14:06.560] 你这个没有输入任何文件
[14:06.560 --> 14:08.560] 然后就导致我写了两三个月的代码
[14:08.560 --> 14:10.560] 我一直觉得自己特别牛
[14:10.560 --> 14:11.560] 每次写出来的代码
[14:11.560 --> 14:12.560] 直接就能通过检查
[14:12.560 --> 14:14.560] 就什么都不用改
[14:14.560 --> 14:16.560] 后来发现他根本就没有跑
[14:16.560 --> 14:19.560] 感觉这个应该去给官方提个一手
[14:19.560 --> 14:22.560] 就是这种应该还是算错误的
[14:22.560 --> 14:24.560] 对我也觉得是
[14:24.560 --> 14:27.560] 应该不应该用0来退出的
[14:27.560 --> 14:32.560] 然后我们再从ci说到
[14:32.560 --> 14:35.560] 其他语言的一些lint的工具
[14:35.560 --> 14:38.560] 来谈谈其他语言的lint吧
[14:38.560 --> 14:40.560] 我不知道你们写不写其他语言
[14:40.560 --> 14:42.560] 其他语言的话
[14:42.560 --> 14:44.560] 我会写一些gs
[14:44.560 --> 14:47.560] 但是我的gs还是那种很原始的
[14:47.560 --> 14:49.560] 就是一堆文件
[14:49.560 --> 14:51.560] 然后丢着丢给静态服务器
[14:51.560 --> 14:53.560] 没有build的那种
[14:53.560 --> 14:56.560] 所以说也没有用什么lint之类的
[14:56.560 --> 14:59.560] 就是gs有一个eslint
[14:59.560 --> 15:02.560] 这个他的检查还是相当丰富的
[15:02.560 --> 15:04.560] 因为我gs也比较菜
[15:04.560 --> 15:06.560] 我每次写前三项目eslint
[15:06.560 --> 15:08.560] 就会告诉我几百个错误
[15:08.560 --> 15:11.560] 我好像都直接没有用eslint
[15:11.560 --> 15:12.560] 我就不check了
[15:12.560 --> 15:16.560] 因为相当于是不太重要的内部项目
[15:16.560 --> 15:18.560] 就也没有那么高的要求
[15:18.560 --> 15:22.560] 就可能就看着ID的提示就改就好了
[15:22.560 --> 15:24.560] 就不用单独装lint
[15:24.560 --> 15:27.560] 而且主要是现在也只有我自己在写
[15:27.560 --> 15:29.560] 我的那个
[15:29.560 --> 15:33.560] 我的那个vim其实也是用了插件
[15:33.560 --> 15:38.560] 所以他也是eslint来告诉vim来提示哪里有错误的
[15:38.560 --> 15:41.560] 那你们写其他的语言
[15:41.560 --> 15:43.560] 比如说还有什么别的语言用lint吗
[15:43.560 --> 15:46.560] gs除了eslint还有一个叫pretty
[15:46.560 --> 15:49.560] 也是像black一样给你格式化代码的
[15:49.560 --> 15:51.560] 因为我们的内部的前三项目
[15:51.560 --> 15:53.560] 都是用公司的那个开发平台
[15:53.560 --> 15:55.560] 他会帮你创建好模式
[15:55.560 --> 15:58.560] 然后那个ci的配置也都帮你生成好
[15:58.560 --> 16:02.560] 所以基本上lint都是自己带的
[16:02.560 --> 16:04.560] 然后其他语言在公司里写java
[16:04.560 --> 16:07.560] 但是我们java的那个lint是内部的工具
[16:07.560 --> 16:09.560] 我不知道外面用什么
[16:09.560 --> 16:16.560] 上阿里的那个不是有一套java的开源的code style的那个东西吗
[16:16.560 --> 16:19.560] 好像是也有开源的checker吧
[16:19.560 --> 16:20.560] 那个是文档吧
[16:20.560 --> 16:21.560] 那个也是工具吗
[16:21.560 --> 16:25.560] 我记得好像后来也出了一个java的checker
[16:25.560 --> 16:27.560] 就是根据那个风格指南来检查的
[16:27.560 --> 16:33.560] OK那应该可能我们内部的用也是跟开源的差不多
[16:33.560 --> 16:35.560] 应该是我估计
[16:35.560 --> 16:37.560] 应该是自带的对吧
[16:37.560 --> 16:40.560] 对对对我觉得go语言这点真的是特别好
[16:40.560 --> 16:43.560] 就相当于其实现在这一元有那些formatter
[16:43.560 --> 16:46.560] 相当于其实也是因为go就开始
[16:46.560 --> 16:49.560] 直接把formatter带到了那个编译器里面
[16:49.560 --> 16:54.560] 就直接goformatter就直接跟那个go就绑并了
[16:54.560 --> 16:56.560] 也是它带起了这个风气
[16:56.560 --> 16:59.560] 然后现在包括像python啊
[16:59.560 --> 17:00.560] 然后rust啊
[17:00.560 --> 17:04.560] 然后各种新的语言都会自带这个formatter这个东西
[17:04.560 --> 17:09.560] 对我觉得其实这个事情也是官方来做比较好
[17:09.560 --> 17:12.560] 因为其他第三方来做这个事情的话
[17:12.560 --> 17:14.560] 可能多少会带点私户
[17:14.560 --> 17:18.560] 对就很容易感觉会有社区分裂的这种风险
[17:18.560 --> 17:21.560] 其他的语言go的linter的话
[17:21.560 --> 17:23.560] 我不知道你们写不写go
[17:23.560 --> 17:26.560] 就是他们之前有一个叫go metalinter
[17:26.560 --> 17:30.560] 相当于是把go的那些也有点类似于flake8这种
[17:30.560 --> 17:32.560] 就把其他的linter打包
[17:32.560 --> 17:33.560] 然后一起跑
[17:33.560 --> 17:37.560] 然后现在的话好像是有一个叫golang-ci-linter的
[17:37.560 --> 17:42.560] 就相当于是用kud的形式把其他的linter集成了进来
[17:42.560 --> 17:46.560] 就会比原来的那个go metalinter要简单一点
[17:46.560 --> 17:49.560] 也不是简单一点就是开销会小一点
[17:49.560 --> 17:53.560] 因为它可以复用很多比如说path之类的步骤
[17:53.560 --> 17:56.560] 可能是然后我就会快很多这样子
[17:56.560 --> 18:00.560] 你说的这个复用就是意思是我可以自己再写一个
[18:00.560 --> 18:01.560] 其他的linter吗
[18:01.560 --> 18:03.560] 对对对
[18:03.560 --> 18:05.560] 其实go也是这种linter
[18:05.560 --> 18:07.560] 它也是这种生态很散的
[18:07.560 --> 18:12.560] 就不像python有一个flake8这种很强势的kud
[18:12.560 --> 18:18.560] 它就是可能比如说我自己想写一个linter
[18:18.560 --> 18:19.560] 然后就写一个
[18:19.560 --> 18:22.560] 然后官方可能提供了一些技术组件来
[18:22.560 --> 18:24.560] 技术的kud来帮你解析go的源码
[18:24.560 --> 18:26.560] 然后去做一些path
[18:26.560 --> 18:27.560] 然后语音解析之类的
[18:27.560 --> 18:28.560] 麻烦类型之类的
[18:28.560 --> 18:31.560] 然后你就封装一下这些包
[18:31.560 --> 18:34.560] 然后包成一个kud或者是一个binary
[18:34.560 --> 18:36.560] 然后就丢给其他人用就好了
[18:36.560 --> 18:39.560] 然后那个golang-ci-linter可能就是
[18:39.560 --> 18:42.560] 上来把这些其他人写的linter再import进来
[18:42.560 --> 18:46.560] 然后他就去统一的做这种path之类的工作
[18:46.560 --> 18:48.560] 按我的理解可能是这样子的
[18:48.560 --> 18:51.560] 那最后跑的时候是一个binary还是两个binary
[18:51.560 --> 18:54.560] 比如说你要检查三种事情的话
[18:54.560 --> 18:56.560] 你是跑一个命令像flake8一样
[18:56.560 --> 18:59.560] 还是说要运行三个
[18:59.560 --> 19:04.560] 最后的话如果你用那个golang-ci-linter的话
[19:04.560 --> 19:05.560] 其实就最后就一个binary了
[19:05.560 --> 19:08.560] 上来把这些binary都打到一个单文件里面
[19:08.560 --> 19:11.560] 然后把library打到一个单文件里面
[19:11.560 --> 19:13.560] 你就跑那一个binary
[19:13.560 --> 19:16.560] 然后指定你要开的linter和关闭的linter
[19:16.560 --> 19:19.560] 然后他就会自动用那些linter去做检查
[19:19.560 --> 19:21.560] 也不需要你去再安装那些linter了
[19:21.560 --> 19:23.560] OK,那我们继续再聊一下
[19:23.560 --> 19:26.560] 我们用过的一些flake8的插件
[19:26.560 --> 19:28.560] 我现在回忆起来的不是很多
[19:28.560 --> 19:32.560] 但是有一个我比较喜欢的是flake8 print
[19:32.560 --> 19:35.560] 就是它会检查你代码里面有没有出现过print
[19:35.560 --> 19:37.560] 因为我们可能debug的时候加了一些
[19:37.560 --> 19:38.560] 然后你删掉了
[19:38.560 --> 19:40.560] 这个对我自己挺有用的
[19:40.560 --> 19:45.560] 我觉得一般这个有两种你要加的linter
[19:45.560 --> 19:47.560] 第一种是你自己经常犯的错误
[19:47.560 --> 19:49.560] 然后你想用它来提醒自己
[19:49.560 --> 19:53.560] 第二种是用来规范团队的一些约定
[19:53.560 --> 19:54.560] 对对对
[19:54.560 --> 19:58.560] 我想了一下我用过比较好用的
[19:58.560 --> 20:02.560] 好像是有一个叫flake8 bugbear的这个东西
[20:02.560 --> 20:06.560] 它会帮你检查一些就很容易犯的那种pattern的错误
[20:06.560 --> 20:09.560] 比如说你用一个mutable的default argument
[20:09.560 --> 20:13.560] 比如说你用一个列表作为默认参数这种
[20:13.560 --> 20:15.560] 其实可能大家都知道这个问题
[20:15.560 --> 20:17.560] 但是有时候一不小心就写上去了
[20:17.560 --> 20:19.560] 然后也没有注意到
[20:19.560 --> 20:22.560] 然后这种其实就挺有帮助的
[20:22.560 --> 20:25.560] 然后好像其他的就没有什么
[20:25.560 --> 20:28.560] 就主要还是看个人喜好吧
[20:28.560 --> 20:31.560] 就比如说我之前的有同事喜欢
[20:31.560 --> 20:33.560] 他自己写了个checker
[20:33.560 --> 20:37.560] 就是会检查你的每一行突度或者fixme
[20:37.560 --> 20:40.560] 后面会有标注这个是谁写的这样
[20:40.560 --> 20:44.560] 然后就相当于会知道这个到底是谁标注的
[20:44.560 --> 20:45.560] 去记录的
[20:45.560 --> 20:47.560] OK说到这个我想跑个题
[20:47.560 --> 20:49.560] 我之前有一个想法就是
[20:49.560 --> 20:52.560] 写一个GitHub的那个应用
[20:52.560 --> 20:55.560] 就是说你每次push代码
[20:55.560 --> 20:57.560] 你如果代码里面有一个突度的话
[20:57.560 --> 20:59.560] 它比如说合并的时候
[20:59.560 --> 21:01.560] 自动就创建出来一些衣数
[21:01.560 --> 21:03.560] 说这个突度是什么
[21:03.560 --> 21:06.560] 然后谁开的在哪个commit里面开的
[21:06.560 --> 21:09.560] 然后假如下次你提高代码
[21:09.560 --> 21:10.560] 把这个突度删掉的话
[21:10.560 --> 21:14.560] 就自动的再去把这个衣数给关掉
[21:14.560 --> 21:15.560] 然后引用过来
[21:15.560 --> 21:16.560] 那这样的话
[21:16.560 --> 21:19.560] 这个代码里面的突度跟fixme之类的
[21:19.560 --> 21:20.560] 都可以统计了
[21:20.560 --> 21:23.560] 好像是个挺不错的主意
[21:23.560 --> 21:25.560] 我觉得其实可以写一个
[21:25.560 --> 21:28.560] 对这样就比较代码的diff
[21:28.560 --> 21:30.560] 然后看里面的注释就可以了
[21:30.560 --> 21:33.560] 对这种其实
[21:33.560 --> 21:35.560] 我记得是有linter是可以检查的
[21:35.560 --> 21:37.560] 但是集成到GitHub的
[21:37.560 --> 21:40.560] 好像是没有看到过这种
[21:40.560 --> 21:42.560] 对就用flick8的linter
[21:42.560 --> 21:46.560] 比如说然后再加一个GitHub的API
[21:46.560 --> 21:49.560] 对开衣数关衣数肯定会有的
[21:49.560 --> 21:50.560] 说到这个
[21:50.560 --> 21:53.560] 其实我们就是上一家公司
[21:53.560 --> 21:55.560] 是有一个这么两样操作
[21:55.560 --> 21:56.560] 我觉得非常好
[21:56.560 --> 21:57.560] 可以分享一下
[21:57.560 --> 22:01.560] 就是我们也有一些算是技术债吧
[22:01.560 --> 22:02.560] 就是有很多代码
[22:02.560 --> 22:04.560] 然后我们之前也是没有用flick8
[22:04.560 --> 22:06.560] 你假如说你用flick8的话
[22:06.560 --> 22:10.560] 那这个代码可能有成百上千个错误爆出来
[22:10.560 --> 22:13.560] 那第一次集成到flick8是特别困难的
[22:13.560 --> 22:17.560] 所以我们当时就写了一个简单的命令
[22:17.560 --> 22:20.560] 就是flick8后面不是可以跟一个检查
[22:20.560 --> 22:21.560] 那些文件吗
[22:21.560 --> 22:23.560] 我们就git diff
[22:23.560 --> 22:26.560] 就是只检查这个PR里面出现过的
[22:26.560 --> 22:27.560] 那个文件
[22:27.560 --> 22:28.560] 然后其他的都不检查
[22:28.560 --> 22:30.560] 这样的话你去修改一个文件的话
[22:30.560 --> 22:33.560] 你就必须先把他的那个linter给修好
[22:33.560 --> 22:34.560] 然后你再修改
[22:34.560 --> 22:39.560] 这样的话逐渐的去修改以前的代码库
[22:39.560 --> 22:40.560] 而且跑得好好的代码
[22:40.560 --> 22:42.560] 其实他跑得好好的
[22:42.560 --> 22:43.560] 你也不需要改
[22:43.560 --> 22:45.560] 我觉得这样迁移式
[22:45.560 --> 22:46.560] 大家可以参考一下
[22:46.560 --> 22:48.560] 这个是个挺好的主意
[22:48.560 --> 22:52.560] 其实因为我记得好像我之前加给那种
[22:52.560 --> 22:55.560] 就不是新项目加flick8的时候
[22:55.560 --> 22:59.560] 一般都是可能先去把那些
[22:59.560 --> 23:02.560] 风险比较低的error给关掉
[23:02.560 --> 23:04.560] 比如说什么多余的import
[23:04.560 --> 23:07.560] 然后还有什么那种
[23:07.560 --> 23:08.560] 还有什么来着
[23:08.560 --> 23:09.560] 反正就是一些就相当于
[23:09.560 --> 23:10.560] 可能只是样式的
[23:10.560 --> 23:11.560] 没有什么太大风险的
[23:11.560 --> 23:13.560] 然后我就把这error关掉
[23:13.560 --> 23:14.560] 然后我就再去跑
[23:14.560 --> 23:16.560] 跑完了再去fix一次
[23:16.560 --> 23:19.560] 然后再去提交上去
[23:19.560 --> 23:20.560] 是这样子
[23:20.560 --> 23:21.560] 但是这样的话
[23:21.560 --> 23:23.560] 有个问题就是那些关掉的error
[23:23.560 --> 23:25.560] 如果你不去再去重勾
[23:25.560 --> 23:27.560] 可能你就永远都把它关掉了
[23:27.560 --> 23:29.560] 就真的再也不会打开了
[23:29.560 --> 23:31.560] 我现在项目好像就这样子
[23:31.560 --> 23:33.560] 就有一些error到现在都没有打开
[23:33.560 --> 23:36.560] 我之前在那个内网看过一个帖子
[23:36.560 --> 23:38.560] 就是讲那个有个配置文件
[23:38.560 --> 23:39.560] 它末尾有一个空格
[23:39.560 --> 23:41.560] 这个空格引发了一个比较
[23:41.560 --> 23:43.560] 比较tricky的一个错误
[23:43.560 --> 23:45.560] 这个其实末尾的空格
[23:45.560 --> 23:47.560] 是完全可以检查出来的
[23:47.560 --> 23:50.560] 对对对是的
[23:50.560 --> 23:53.560] 末尾的空格这个其实
[23:53.560 --> 23:55.560] 那个editor config有专门一个选项
[23:55.560 --> 23:58.560] 叫做trim trailing byte space
[23:58.560 --> 24:00.560] 就是帮你自动帮你把末尾的空格给删掉
[24:00.560 --> 24:02.560] 然后这种其实
[24:02.560 --> 24:03.560] 如果你用editor config
[24:03.560 --> 24:05.560] 就不会有这种问题
[24:05.560 --> 24:06.560] 不过有一些语言
[24:06.560 --> 24:09.560] 有一些语言末尾的空格是有用的吗
[24:09.560 --> 24:11.560] 对就markdown的那个
[24:11.560 --> 24:13.560] 末尾的空格是有语意的
[24:13.560 --> 24:15.560] 就你如果跟两个空格
[24:15.560 --> 24:16.560] 它会帮你就换行
[24:16.560 --> 24:19.560] 而不是自动帮你续上
[24:19.560 --> 24:21.560] 这个是会比较坑
[24:21.560 --> 24:22.560] 其他里面好像没有
[24:22.560 --> 24:23.560] 我不知道
[24:23.560 --> 24:25.560] 这个我之前不知道
[24:25.560 --> 24:26.560] 第一次听说
[24:26.560 --> 24:27.560] 你可以试一下
[24:27.560 --> 24:28.560] ok ok
[24:28.560 --> 24:31.560] 就python里面末尾的空格是绝对没有用的
[24:31.560 --> 24:32.560] 对吧
[24:32.560 --> 24:34.560] 甚至那个对对对注视里面
[24:34.560 --> 24:35.560] 那个末尾空格
[24:35.560 --> 24:37.560] 它都会提示你
[24:37.560 --> 24:38.560] 其实挺好的
[24:38.560 --> 24:39.560] 就自动把它删掉就好
[24:39.560 --> 24:41.560] 没有必要在末尾
[24:41.560 --> 24:43.560] 给一些没有意义的空格
[24:43.560 --> 24:44.560] 对
[24:44.560 --> 24:46.560] 其实还有一个好用的东西
[24:46.560 --> 24:47.560] 我感觉
[24:47.560 --> 24:49.560] 现在就缺这么一个东西
[24:49.560 --> 24:51.560] 我们之前那个公司
[24:51.560 --> 24:53.560] lint是就是ci是自己写的
[24:53.560 --> 24:56.560] 然后我们有个大神
[24:56.560 --> 24:57.560] 搞了一个非常好的东西
[24:57.560 --> 24:59.560] 就是比如说flick8
[24:59.560 --> 25:01.560] 你检查出来哪一行有问题
[25:01.560 --> 25:02.560] 一般会打到日志里
[25:02.560 --> 25:05.560] 但是它的那个bot可以就直接去这一行
[25:05.560 --> 25:06.560] 给你留一个评论
[25:06.560 --> 25:08.560] 说这一行出现了什么问题
[25:08.560 --> 25:09.560] 这样的话
[25:09.560 --> 25:11.560] 你看diff里面就特别方便
[25:11.560 --> 25:12.560] 你懂我意思吗
[25:12.560 --> 25:13.560] 就是你看好的
[25:13.560 --> 25:14.560] 对你看diff的时候
[25:14.560 --> 25:16.560] 就一个bot给你留各种各样的评论
[25:16.560 --> 25:19.560] 说就是flick8的那个问题
[25:19.560 --> 25:23.560] 就相当于它其实是解析了flick8的输出
[25:23.560 --> 25:25.560] 然后调了一下
[25:25.560 --> 25:27.560] 那个可能代码管理的API
[25:27.560 --> 25:28.560] 比如说github
[25:28.560 --> 25:31.560] 然后是的是这种创建了一堆评论
[25:31.560 --> 25:32.560] 挺好的
[25:32.560 --> 25:33.560] 这种可以
[25:33.560 --> 25:34.560] 其实可以写一个
[25:34.560 --> 25:36.560] 对这个而且是可以跟踪的
[25:36.560 --> 25:37.560] 你假如你改了一个
[25:37.560 --> 25:40.560] 你可以直接把这个change request给关掉
[25:40.560 --> 25:42.560] 对对对
[25:42.560 --> 25:43.560] 可能也有这样的app
[25:43.560 --> 25:46.560] 但是我好像没在github上见有人用过
[25:46.560 --> 25:47.560] 如果没有的话
[25:47.560 --> 25:50.560] 我感觉可以尝试再搞一个github上面的
[25:50.560 --> 25:53.560] 我感觉这个确实也可以拿去写一个项目
[25:53.560 --> 25:57.560] 就给github和github做这种评论的bot
[25:57.560 --> 25:58.560] OK
[25:58.560 --> 26:00.560] 我们接着再来聊一下
[26:00.560 --> 26:02.560] 这个flick8常用的用法
[26:02.560 --> 26:04.560] 一般我们都刚刚说了
[26:04.560 --> 26:05.560] 加到CI里面
[26:05.560 --> 26:07.560] 然后说了
[26:07.560 --> 26:10.560] 跟集成到编机器里面
[26:10.560 --> 26:12.560] 这样可以最早的发现错误
[26:12.560 --> 26:17.560] 然后应该有一些人会喜欢把它加到pre-commit里面
[26:18.560 --> 26:21.560] 对我会把它加到pre-commit里面
[26:21.560 --> 26:23.560] 但是我不太喜欢这个pre-commit
[26:23.560 --> 26:25.560] 我希望就是git commit敲下去
[26:25.560 --> 26:27.560] 我就开始写commit信息了
[26:27.560 --> 26:29.560] 不想等一段时间
[26:29.560 --> 26:31.560] 因为你在编机器里面写
[26:31.560 --> 26:32.560] 它是异步的
[26:32.560 --> 26:33.560] 你不用等
[26:33.560 --> 26:35.560] 然后你把它提交到CI上去
[26:35.560 --> 26:36.560] 你可以去干别的事情
[26:36.560 --> 26:37.560] 其实也不算等
[26:37.560 --> 26:39.560] 但pre-commit
[26:39.560 --> 26:41.560] 就是你要看着那个命令行
[26:41.560 --> 26:43.560] 那么短的时间
[26:43.560 --> 26:45.560] 你又不能切出去搞别的
[26:45.560 --> 26:48.560] 我就觉得不太喜欢pre-commit
[26:48.560 --> 26:50.560] 还有一个hook好像叫post-commit
[26:50.560 --> 26:53.560] 但是我不知道这个能不能拿来做CI
[26:53.560 --> 26:55.560] 我自己的做法
[26:55.560 --> 26:57.560] 现在是就不会直接去跑
[26:57.560 --> 27:00.560] 整个repo的check
[27:00.560 --> 27:03.560] 我只会跑这次变更过的那几个文件的check
[27:03.560 --> 27:05.560] 然后这样的话就快很多
[27:05.560 --> 27:08.560] 因为我之前是直接跑的
[27:08.560 --> 27:09.560] 整个repo的
[27:09.560 --> 27:11.560] 然后我发现跑一次要巨慢
[27:11.560 --> 27:12.560] 要十多秒钟
[27:12.560 --> 27:14.560] 就特别打断工作节奏
[27:14.560 --> 27:17.560] 后来我就warp了一下这个脚本
[27:17.560 --> 27:18.560] 对
[27:18.560 --> 27:20.560] 可以写成
[27:20.560 --> 27:22.560] 也是那个trick
[27:22.560 --> 27:25.560] flake8然后dollar
[27:25.560 --> 27:26.560] 然后开一个子命令
[27:26.560 --> 27:27.560] 对吧
[27:27.560 --> 27:29.560] give diff name only
[27:29.560 --> 27:30.560] 对
[27:30.560 --> 27:31.560] OK
[27:31.560 --> 27:34.560] 我们刚刚提到了flake8的输出
[27:34.560 --> 27:35.560] 是一个格式化的
[27:35.560 --> 27:36.560] 对吧
[27:36.560 --> 27:39.560] 一般都是一个error name
[27:39.560 --> 27:41.560] 就是比如说e多少多少
[27:41.560 --> 27:43.560] 然后这一个详细的信息
[27:43.560 --> 27:45.560] 这个应该是这样子的
[27:45.560 --> 27:48.560] 然后我可以分享一个技巧
[27:48.560 --> 27:50.560] 其实它对新手来说
[27:50.560 --> 27:52.560] 我记得之前写代码的时候
[27:52.560 --> 27:54.560] 很多错误
[27:54.560 --> 27:56.560] 我都是看不太懂
[27:56.560 --> 27:58.560] 然后你如果看不太懂
[27:58.560 --> 28:01.560] 你可以直接拿那个google来搜索
[28:01.560 --> 28:02.560] 这个错误号码
[28:02.560 --> 28:04.560] 然后后面你就说flake8
[28:04.560 --> 28:05.560] 加一个错误号码
[28:05.560 --> 28:08.560] 这样的话基本上都能打开一个详细的页面
[28:08.560 --> 28:10.560] 就介绍为什么这个错误会存在
[28:10.560 --> 28:11.560] 应该怎么改
[28:11.560 --> 28:12.560] 对对对
[28:12.560 --> 28:14.560] 我记得是有一个这么一个页面
[28:14.560 --> 28:16.560] 就好像在flake8文档里面
[28:16.560 --> 28:17.560] 对
[28:16.560 --> 28:18.560] 但是其实有一些错
[28:18.560 --> 28:21.560] 插件也是可以自定义错误号码的
[28:21.560 --> 28:23.560] 但是这个我没写过
[28:23.560 --> 28:24.560] 我不知道这个有没有什么规定
[28:24.560 --> 28:27.560] 是不是说你随便定义一个错误码
[28:27.560 --> 28:28.560] 加数字就可以了
[28:28.560 --> 28:31.560] 我前两天看好像是这样子的
[28:31.560 --> 28:34.560] 就是它会比如说你有一个x
[28:34.560 --> 28:36.560] 它好像就会把所有的x开头的
[28:36.560 --> 28:37.560] 当成一个
[28:37.560 --> 28:42.560] 它会注册一个错误码到flake8的系统里面
[28:42.560 --> 28:43.560] 然后比如说你写x
[28:43.560 --> 28:45.560] 它就会认为你这个插件里面
[28:45.560 --> 28:47.560] 包含有x开头的这样子
[28:47.560 --> 28:48.560] 好像是这样
[28:48.560 --> 28:50.560] 用entry point对吧
[28:50.560 --> 28:51.560] 对对对
[28:51.560 --> 28:52.560] OK
[28:52.560 --> 28:54.560] 然后如果说你要输出的话
[28:54.560 --> 28:57.560] 它就会自动帮你输出成你注册的那个错误码
[28:57.560 --> 29:00.560] 比如说你注册成imp001
[29:00.560 --> 29:02.560] 然后它就会输出成imp001
[29:02.560 --> 29:06.560] 然后就是你返回给flake8的那个错误信息这样子
[29:06.560 --> 29:06.560] OK
[29:06.560 --> 29:11.560] 那我们就进入到就是写flake8插件上这个话题吧
[29:11.560 --> 29:13.560] 要不你来介绍一下
[29:13.560 --> 29:15.560] 怎么就是什么流程吧
[29:15.560 --> 29:18.560] 就是这个flake8插件运行起来是什么原理
[29:18.560 --> 29:20.560] 然后去写一个插件的话
[29:20.560 --> 29:21.560] 需要去学习什么
[29:21.560 --> 29:25.560] 我其实也没有什么特别深入的研究
[29:25.560 --> 29:26.560] 就是简单的看了一下
[29:26.560 --> 29:28.560] 因为我前两天不是想写吗
[29:28.560 --> 29:30.560] 然后就是就刚刚说的
[29:30.560 --> 29:32.560] 它其实是有两种格式
[29:32.560 --> 29:34.560] 一种是一个你定一个函数
[29:34.560 --> 29:37.560] 然后接受一些特定的名字的参数
[29:37.560 --> 29:40.560] 然后它就flake8就会去inspect
[29:40.560 --> 29:42.560] 你那个函数的参数的名字
[29:42.560 --> 29:44.560] 然后去自动把对应的参数传给你
[29:44.560 --> 29:45.560] 比如说它的行号啊
[29:45.560 --> 29:48.560] 或者是它的那个代码的token啊
[29:48.560 --> 29:49.560] 然后这些
[29:49.560 --> 29:56.560] 然后你就比如说你要去解析那个什么注释
[29:56.560 --> 29:58.560] 比如说你要一行去看注释
[29:58.560 --> 30:00.560] 然后你就可以传一个physical line
[30:00.560 --> 30:03.560] 然后它就会把代码一行一行的传给你
[30:03.560 --> 30:04.560] 然后你在里面做检查
[30:04.560 --> 30:05.560] 如果发现有错误的话
[30:05.560 --> 30:09.560] 你就去发挥给那个flake8
[30:09.560 --> 30:10.560] 它就会自动帮你显示出来
[30:10.560 --> 30:14.560] 然后如果是另外一种就是class based的话
[30:14.560 --> 30:17.560] 它就是直接把那个代码解析好了
[30:17.560 --> 30:19.560] 解析成就用pattern的那个ast的模组
[30:19.560 --> 30:20.560] 解析好了解析给你
[30:20.560 --> 30:24.560] 然后你就去用ast work编译就好了
[30:24.560 --> 30:27.560] 你刚刚说那个函数的是
[30:27.560 --> 30:29.560] 比如说你要求解析注释
[30:29.560 --> 30:30.560] 然后它就把所有的注释
[30:30.560 --> 30:33.560] 只传注释一行一行给你这样吗
[30:33.560 --> 30:34.560] 没有没有没有
[30:34.560 --> 30:36.560] 它是有很多参数
[30:36.560 --> 30:37.560] 有一个叫physical line的
[30:37.560 --> 30:40.560] 这个应该就是你代码上的物理的行
[30:40.560 --> 30:42.560] 然后比如说你代
[30:42.560 --> 30:44.560] 你参数有一个参数名叫physical line
[30:44.560 --> 30:46.560] 它就会把一行一行的传给你
[30:46.560 --> 30:48.560] 它有一个行叫logical line
[30:48.560 --> 30:50.560] 应该是按我的理解应该是那个
[30:50.560 --> 30:52.560] 就是它逻辑上的一行
[30:52.560 --> 30:53.560] 就比如说你用续行了之后
[30:53.560 --> 30:56.560] 它其实物理上是有两行嘛
[30:56.560 --> 30:57.560] 就有一个杠
[30:57.560 --> 30:58.560] 比如说杠n这样
[30:58.560 --> 31:00.560] 但是逻辑上其实它还是一行的这样子
[31:00.560 --> 31:02.560] 这是我的理解
[31:02.560 --> 31:05.560] 我没有去跑过那个logical line的参数
[31:05.560 --> 31:06.560] OK
[31:06.560 --> 31:08.560] 那我有一个问题
[31:08.560 --> 31:09.560] 那假如说
[31:09.560 --> 31:11.560] 比如说我现在想写一个flick8插件
[31:11.560 --> 31:14.560] 然后就强制那个代码注释里面
[31:14.560 --> 31:15.560] 不能出现fwords
[31:15.560 --> 31:17.560] 不能出现脏话
[31:17.560 --> 31:18.560] 那假如说
[31:18.560 --> 31:21.560] 就是假如说现在有一个这样的字符串
[31:21.560 --> 31:23.560] 那a等于三个引号
[31:23.560 --> 31:24.560] 然后到换行了
[31:24.560 --> 31:26.560] 就是井号
[31:26.560 --> 31:28.560] 然后三个引号
[31:28.560 --> 31:30.560] 就是说它这一行虽然是井号开头
[31:30.560 --> 31:31.560] 但是它在字符串里面
[31:31.560 --> 31:33.560] 那那个physical line
[31:33.560 --> 31:35.560] 这样好像看不出来吧
[31:36.560 --> 31:37.560] 对对对
[31:37.560 --> 31:39.560] 所以它还有一个参数叫tokens
[31:39.560 --> 31:41.560] tokens它就相当于是已经帮你解析了
[31:41.560 --> 31:43.560] 就比如说你这个是注释
[31:43.560 --> 31:45.560] 那个是什么
[31:45.560 --> 31:47.560] 比如说是一个
[31:47.560 --> 31:49.560] 我也不知道它tokens里面有什么
[31:49.560 --> 31:50.560] 还有一些
[31:50.560 --> 31:55.560] 比如说是叫表达式之类的
[31:55.560 --> 31:56.560] 比如说函数定义之类这种
[31:56.560 --> 31:59.560] 可能就是tokens里面能够取到的
[32:00.560 --> 32:02.560] 因为我其实不太清楚
[32:02.560 --> 32:05.560] 它path之后会有一些什么样的结构
[32:05.560 --> 32:07.560] 就我用过的好像就只有那个
[32:07.560 --> 32:11.560] 叫comment这个结构
[32:11.560 --> 32:14.560] 然后它就会把comment的string给你这样
[32:14.560 --> 32:15.560] ok
[32:15.560 --> 32:17.560] 这个应该是更实用一点
[32:17.560 --> 32:21.560] 这个它是一起给你的还是单个给你的
[32:21.560 --> 32:23.560] 就假如说我只处理comment的话
[32:23.560 --> 32:25.560] 是不是我需要写个if
[32:25.560 --> 32:28.560] 就是如果token的名字不是comment的话
[32:28.560 --> 32:29.560] 就直接忽略掉
[32:29.560 --> 32:30.560] 然后只处理token
[32:30.560 --> 32:31.560] 对对对
[32:31.560 --> 32:34.560] 那这样写的其实挺简单的
[32:34.560 --> 32:36.560] 就你要去判断你需要
[32:36.560 --> 32:38.560] 它会把所有token都给你
[32:38.560 --> 32:40.560] 然后你判断你需要哪些token
[32:40.560 --> 32:41.560] 然后过滤出来
[32:41.560 --> 32:43.560] 然后再去做逻辑就好了
[32:43.560 --> 32:45.560] 然后另外一种就是那个
[32:45.560 --> 32:47.560] 基于那种class的
[32:47.560 --> 32:50.560] 然后比如说我之前说那个
[32:50.560 --> 32:51.560] 做import的那个
[32:51.560 --> 32:53.560] 它就是你用ast
[32:53.560 --> 32:56.560] 然后它会给你一个抽象语法数
[32:56.560 --> 32:57.560] 然后你去便利
[32:57.560 --> 32:59.560] 比如说你去因为它是一个数
[32:59.560 --> 33:02.560] 你要就一个节点一个节点走
[33:02.560 --> 33:03.560] 然后比如说你走到这个节点
[33:03.560 --> 33:05.560] 看一下这个节点是不是一个import
[33:05.560 --> 33:08.560] 或者是fromimport的这种就语句
[33:08.560 --> 33:09.560] 然后如果是的话
[33:09.560 --> 33:11.560] 你就去再去判断它的fromimport
[33:11.560 --> 33:12.560] 前面有几个level
[33:12.560 --> 33:13.560] 就那个点的数量
[33:13.560 --> 33:16.560] 如果比如说你大于两个
[33:16.560 --> 33:18.560] 然后你就不允许它使用这样子
[33:18.560 --> 33:20.560] 这个挺好的
[33:20.560 --> 33:22.560] 我们之前有个项目
[33:22.560 --> 33:24.560] 就是python写的
[33:24.560 --> 33:26.560] 但是其实大家之前都是写java的
[33:26.560 --> 33:29.560] 所以他们那个import就写的巨长
[33:29.560 --> 33:30.560] 你懂吗
[33:30.560 --> 33:33.560] 就那个点都是六七个级别的
[33:33.560 --> 33:35.560] 然后他们的那个python
[33:35.560 --> 33:38.560] python的路径就写.com
[33:38.560 --> 33:40.560] 点什么点什么
[33:40.560 --> 33:42.560] 就是java那种package的方式
[33:42.560 --> 33:44.560] 就好奇怪啊
[33:44.560 --> 33:45.560] 这种对
[33:45.560 --> 33:48.560] 我之前看过一个那个
[33:48.560 --> 33:54.560] 就是检查rise的一个flick bar的插件
[33:54.560 --> 33:57.560] 好像是你如果catch了
[33:57.560 --> 33:59.560] 直接啥都不做rise出来的话
[33:59.560 --> 34:00.560] 它会给你检查出来
[34:00.560 --> 34:02.560] 这种应该也是estbase
[34:02.560 --> 34:05.560] 对对对这种应该是estbase
[34:05.560 --> 34:07.560] 其实两种都挺多的
[34:07.560 --> 34:09.560] 比如说像我刚开始说的那个
[34:09.560 --> 34:12.560] 变量名的字数不能少于三个
[34:12.560 --> 34:16.560] 这种应该是那个直接写一个
[34:16.560 --> 34:17.560] 处理token就可以了
[34:17.560 --> 34:18.560] 对吧只要是变量名
[34:18.560 --> 34:21.560] 我就对我就检查一下
[34:21.560 --> 34:25.560] 它的呃代码的那个字数是不是少于三
[34:25.560 --> 34:28.560] 但在token的层面应该是
[34:28.560 --> 34:30.560] 他不知道这个是一个变量
[34:30.560 --> 34:32.560] 还是一个什么函数
[34:32.560 --> 34:34.560] 或者是一个什么其他的东西吧
[34:34.560 --> 34:35.560] 按我的理解
[34:35.560 --> 34:37.560] 就如果说你要知道
[34:37.560 --> 34:40.560] 这个是一个sign expression的话
[34:40.560 --> 34:43.560] 你要还是要拿到ast那一层才能知道
[34:43.560 --> 34:46.560] 嗯对这个也是
[34:46.560 --> 34:50.560] 你也可以把一个函数传递给一个变量
[34:50.560 --> 34:53.560] 对对对那这个其实更复杂一点
[34:53.560 --> 34:56.560] 就反正还是要看你想做的东西
[34:56.560 --> 34:59.560] 但是有很多东西其实你也是很难做的
[34:59.560 --> 35:01.560] 因为pattern实在是太动态了
[35:01.560 --> 35:05.560] 就你要做复杂一点的语音分析就特别麻烦
[35:05.560 --> 35:09.560] 对然后刚那个ast based的有个问题
[35:09.560 --> 35:11.560] 就是就相当于他其实解析了之后嘛
[35:11.560 --> 35:13.560] 然后你就是拿不到comment的
[35:13.560 --> 35:18.560] 如果你想处理comment就一定得用那个token based的
[35:18.560 --> 35:20.560] 就还是用函数的那种方式去解析
[35:20.560 --> 35:24.560] 就因为他那个ast我前两天翻了一下
[35:24.560 --> 35:26.560] 他那个里面根本就没有comment的这种节点
[35:26.560 --> 35:31.560] 嗯啊因为那个他处理过一遍
[35:31.560 --> 35:33.560] 那个已经没了对吧
[35:33.560 --> 35:37.560] 到ast的时候是不是注视已经被忽略了
[35:38.560 --> 35:39.560] 对是的
[35:39.560 --> 35:43.560] 然后那个instagram有个库好像叫libcst
[35:43.560 --> 35:47.560] 然后他是会给你发一个concrete的syntax tree
[35:47.560 --> 35:49.560] 然后这个里面好像是包含的有注视
[35:49.560 --> 35:52.560] 但是我自己没有遇到那么复杂的场景
[35:52.560 --> 35:54.560] 所以说也没有去用过这个库
[35:54.560 --> 35:56.560] 就看了一下他介绍
[35:56.560 --> 35:58.560] 那你如果用这个库的话
[35:58.560 --> 36:01.560] 是不是意味着flick8的那个框架就不能用了
[36:01.560 --> 36:04.560] 因为你要把他那个ast解析给换掉
[36:04.560 --> 36:06.560] 对应该是这样子的
[36:06.560 --> 36:09.560] 你要相当于是要自己去看掉那个库
[36:09.560 --> 36:12.560] 或者是自己去做一些基本的操作
[36:12.560 --> 36:15.560] 就相当于你要整个框架都要重新来了
[36:15.560 --> 36:16.560] OK
[36:16.560 --> 36:20.560] 我想问一下你们是怎么用这个ci的
[36:20.560 --> 36:22.560] 我们的ci
[36:22.560 --> 36:24.560] 其实我可以介绍一下那个java
[36:24.560 --> 36:30.560] java其实我们的ci是那个开发平台自己定的
[36:30.560 --> 36:32.560] 就是他事先定好了几种
[36:32.560 --> 36:35.560] 那个他的亚往是事先写好的吧
[36:35.560 --> 36:36.560] 当然你也可以自己写
[36:36.560 --> 36:38.560] 然后基本上都是前面
[36:38.560 --> 36:42.560] 首先看你编译能不能过
[36:42.560 --> 36:44.560] 看你那个代码风格有没有问题
[36:44.560 --> 36:48.560] 然后再看你有没有安全漏洞
[36:48.560 --> 36:50.560] 这三个扫描是最前面的
[36:50.560 --> 36:53.560] 安全漏洞就比如说你用了一个有问题的fastjson版本
[36:53.560 --> 36:54.560] 他就会挂掉
[36:54.560 --> 36:56.560] 然后就后面就是
[36:56.560 --> 36:57.560] 这个还挺好的
[36:57.560 --> 36:59.560] 对这三个过了
[36:59.560 --> 37:02.560] 然后就是代码review跟单元测试
[37:02.560 --> 37:04.560] 然后再过了就是可以合并了
[37:04.560 --> 37:06.560] 然后review过了就合并
[37:06.560 --> 37:09.560] 合并完了就再跑集成测试
[37:09.560 --> 37:11.560] 然后部署到开发机器上
[37:11.560 --> 37:12.560] 这个是自动推的
[37:12.560 --> 37:14.560] 假如说你已经申请过的话
[37:14.560 --> 37:15.560] 是这样
[37:15.560 --> 37:17.560] 那相当于你们这个ci就不仅仅是
[37:17.560 --> 37:20.560] 简单的检查代码这样子
[37:20.560 --> 37:23.560] 就还会去帮你做一些自动部署的过程
[37:23.560 --> 37:25.560] cd上的有点这种风格
[37:25.560 --> 37:26.560] 对对
[37:26.560 --> 37:29.560] 但其实你像GitHub的action的话
[37:29.560 --> 37:30.560] 你也可以做这种事情
[37:30.560 --> 37:31.560] 对吧
[37:31.560 --> 37:32.560] 对对对就开源的
[37:32.560 --> 37:35.560] 其实你自己还是选择很多
[37:35.560 --> 37:36.560] 但是公司层面的
[37:36.560 --> 37:38.560] 有时候就不一定有这些选择
[37:38.560 --> 37:39.560] 就对
[37:39.560 --> 37:42.560] 我感觉就是开源上的ci
[37:42.560 --> 37:44.560] 很少有公司会做到他那么好
[37:44.560 --> 37:46.560] 像CircleCI啊
[37:46.560 --> 37:47.560] Travis啊
[37:47.560 --> 37:49.560] 这些公司还有新兴的一些ci
[37:49.560 --> 37:51.560] 他们都拿这个来赚钱
[37:51.560 --> 37:53.560] 说明这个市场是很大的
[37:53.560 --> 37:55.560] 很少有公司专门去做这个
[37:55.560 --> 37:57.560] 第一个是精力太大了
[37:57.560 --> 37:58.560] 要耗费的精力
[37:58.560 --> 37:59.560] 然后维护成本也很大
[37:59.560 --> 38:00.560] 是的
[38:00.560 --> 38:03.560] 而且就是非常影响开发效率的一个事情
[38:03.560 --> 38:05.560] 像我们现在就只有ci
[38:05.560 --> 38:06.560] 而且是我们自己搭的
[38:06.560 --> 38:08.560] 没有公司层面的ci
[38:08.560 --> 38:12.560] 然后ci里面也没有办法去跑那种自动部署
[38:12.560 --> 38:15.560] 因为我们的自动部署就部署系统
[38:15.560 --> 38:17.560] 可能权限还是挺严格的
[38:17.560 --> 38:19.560] 然后也没有办法去两个环境直接连通
[38:19.560 --> 38:22.560] 然后所以说你就只能去跑完了
[38:22.560 --> 38:23.560] 然后merge
[38:23.560 --> 38:24.560] 然后再手动部署
[38:24.560 --> 38:25.560] ok
[38:25.560 --> 38:28.560] 你们有gitlab吗
[38:28.560 --> 38:31.560] gitlab的那个runner也挺好用的
[38:31.560 --> 38:34.560] 其实我们现在是就是用的gitlab
[38:34.560 --> 38:37.560] 然后runner是我们组自己搭的
[38:37.560 --> 38:38.560] 不是公司层面提供的
[38:38.560 --> 38:42.560] 然后我们就就是用gitlab runner来跑这个ci
[38:42.560 --> 38:44.560] 然后这个用起来是挺爽的
[38:45.560 --> 38:46.560] 对
[38:46.560 --> 38:48.560] 我之前是
[38:48.560 --> 38:50.560] 我们之前其实有一个python项目
[38:50.560 --> 38:52.560] 我刚刚讲的因为是java的嘛
[38:52.560 --> 38:56.560] 我们公司的python设施还不是那么完善
[38:56.560 --> 38:57.560] 就是说你合并之后
[38:57.560 --> 38:59.560] 它也不能帮你自动部署这些
[38:59.560 --> 39:03.560] 因为它那个部署系统可能也跟java的一套编译
[39:03.560 --> 39:07.560] 跟我们内部的一些技术框架集成了
[39:07.560 --> 39:09.560] 但是我搞了一个东西特别好玩
[39:09.560 --> 39:15.560] 就是我在那个开发机器上写了一个systemd的一个服务
[39:15.560 --> 39:19.560] 那个服务就是用nc监听一个端口
[39:19.560 --> 39:24.560] 然后nc就是你可以让它收到一个连接
[39:24.560 --> 39:26.560] 然后那个连接端口发送完了之后
[39:26.560 --> 39:27.560] 这个nc就退出了嘛
[39:28.560 --> 39:29.560] 对
[39:29.560 --> 39:34.560] 然后nc那个用pipeline来再搞到一个脚本里去
[39:34.560 --> 39:37.560] 就是这个nc一旦执行完了我就跑这个脚本
[39:37.560 --> 39:38.560] 然后这个脚本都跑完了
[39:38.560 --> 39:42.560] 那systemd就知道你这个服务现在没有起
[39:42.560 --> 39:45.560] 它隔5秒钟就会重新把你这个服务拉起来
[39:45.560 --> 39:49.560] 所以说这个相当于是做了一个自动部署
[39:49.560 --> 39:50.560] 对对
[39:50.560 --> 39:52.560] 我在机上做好了自动部署
[39:52.560 --> 39:55.560] 然后我只要在ci里面就是所有的检查都通过了
[39:55.560 --> 39:56.560] 我写一个curl
[39:56.560 --> 39:58.560] 就是所有检查都通过了
[39:58.560 --> 39:59.560] 我就跑这个curl
[39:59.560 --> 40:01.560] 然后这个curl就通知这个机器你要部署
[40:01.560 --> 40:02.560] 然后它就自动部署
[40:02.560 --> 40:03.560] 部署完了
[40:03.560 --> 40:05.560] 然后systemd再起来再监听
[40:06.560 --> 40:08.560] 这样其实能用
[40:08.560 --> 40:10.560] 挺简单的挺好用的
[40:10.560 --> 40:11.560] 对非常简单
[40:11.560 --> 40:14.560] 就一个systemd的脚本
[40:14.560 --> 40:17.560] 然后做的更多的一点事情
[40:17.560 --> 40:18.560] 就是在那个sh里面
[40:18.560 --> 40:20.560] 我写了一个叮叮的机器人
[40:20.560 --> 40:22.560] 其实也是一个curl
[40:22.560 --> 40:27.560] 就是看这个机器这次部署跟上一次部署
[40:27.560 --> 40:28.560] 有哪些git commit
[40:28.560 --> 40:30.560] 然后commit都写了什么
[40:30.560 --> 40:33.560] 这个部署的结果是成功还是失败了
[40:33.560 --> 40:34.560] 就是失败了
[40:34.560 --> 40:35.560] 你要去机器上看一下
[40:35.560 --> 40:36.560] 但是消息总会发出来的
[40:36.560 --> 40:40.560] 如果说你们是服务单的项目
[40:40.560 --> 40:44.560] 它可能比如说你去restart了
[40:44.560 --> 40:46.560] 然后它正在restart
[40:46.560 --> 40:48.560] 但它没有起起来这种
[40:48.560 --> 40:51.560] 你怎么去判断它到底是成功了还是失败了呢
[40:51.560 --> 40:54.560] 还是说你是去判断它监听端口的这个情况
[40:55.560 --> 40:56.560] OK
[40:56.560 --> 40:58.560] 这个就是简单的服务
[40:58.560 --> 40:59.560] 可能对它做很多监控
[40:59.560 --> 41:00.560] 因为这是开发机上
[41:00.560 --> 41:02.560] 线上我们环境也是隔离的
[41:02.560 --> 41:03.560] 也不让这么搞
[41:03.560 --> 41:05.560] 对
[41:05.560 --> 41:07.560] 就是我合并代码
[41:07.560 --> 41:08.560] 我肯定预期
[41:08.560 --> 41:11.560] 我们那个开发群有一个bot会说句话
[41:11.560 --> 41:12.560] 那他没说的话
[41:12.560 --> 41:13.560] 肯定是挂了
[41:13.560 --> 41:15.560] 我就去机器上看一下
[41:15.560 --> 41:17.560] 有这种情况
[41:17.560 --> 41:18.560] 有这种情况
[41:19.560 --> 41:20.560] 是的是的
[41:20.560 --> 41:22.560] 就有时候你改了代码
[41:22.560 --> 41:23.560] 就跑完一切都好
[41:23.560 --> 41:25.560] 但是到了机器上就是起不起来
[41:25.560 --> 41:26.560] 对对
[41:26.560 --> 41:27.560] 然后很有意思
[41:27.560 --> 41:29.560] 我们之前有一些安全系统
[41:29.560 --> 41:30.560] 它会扫你的端口
[41:30.560 --> 41:33.560] 看你是不是暴露了一些有问题的服务
[41:33.560 --> 41:34.560] 危险的服务
[41:34.560 --> 41:37.560] 没有健全的API之类的
[41:37.560 --> 41:41.560] 然后它有的时候会用你之前的请求给你重放
[41:41.560 --> 41:45.560] 然后我们那个接口没有做健全
[41:45.560 --> 41:47.560] 就导致它扫一次我们部署一次
[41:47.560 --> 41:48.560] 扫一次我们部署一次
[41:48.560 --> 41:50.560] 其实你可以判断一下
[41:50.560 --> 41:52.560] 就commit号
[41:52.560 --> 41:53.560] 如果commit号没变
[41:53.560 --> 41:55.560] 你就不去更新它就好
[41:55.560 --> 41:56.560] 对对
[41:55.560 --> 41:57.560] 我后来在NC里面加了点东西
[41:57.560 --> 41:59.560] 就是那个curl的请求里面
[41:59.560 --> 42:00.560] 加了一点token
[42:00.560 --> 42:03.560] 然后NC可以把受到请求给pipeline
[42:03.560 --> 42:04.560] 给之后的进程
[42:04.560 --> 42:06.560] 后面的进程检查一下
[42:06.560 --> 42:08.560] 是可以阻挡掉的
[42:08.560 --> 42:14.560] 其实我感觉是把那个CD的过程
[42:14.560 --> 42:16.560] 其实也没有严格区分的CI CD
[42:16.560 --> 42:19.560] 我感觉把CD的过程放到那个
[42:19.560 --> 42:20.560] 这个怎么说呢
[42:20.560 --> 42:22.560] 就放到那个CI里面自动跑
[42:22.560 --> 42:25.560] 这样是其实真的很爽
[42:25.560 --> 42:28.560] 我之前搞了个命令行的项目
[42:28.560 --> 42:29.560] iRedis
[42:29.560 --> 42:31.560] 因为这个就是一个命令行的工具
[42:31.560 --> 42:32.560] 它不是酷
[42:32.560 --> 42:33.560] 不需要向后兼容
[42:33.560 --> 42:36.560] 所以我希望就是有人给我提了一个
[42:36.560 --> 42:37.560] 一数把它修了
[42:37.560 --> 42:39.560] 那所有的用户就能立即去用到
[42:39.560 --> 42:41.560] 我这个fix
[42:41.560 --> 42:43.560] 就是它不需要等很久
[42:43.560 --> 42:46.560] 所以我就把这个发布的这个环节
[42:46.560 --> 42:49.560] 就是把这个打包上传到Pipeline
[42:49.560 --> 42:51.560] 这样一些东西全都放到CI里面做
[42:51.560 --> 42:53.560] 所以我每次发布只要做一个事情
[42:53.560 --> 42:55.560] 就是在master上面打一个tag
[42:55.560 --> 42:57.560] 它发现master上面多了一个tag
[42:57.560 --> 42:59.560] 它就会自动就把这个新的包
[42:59.560 --> 43:01.560] 给传到Pipeline上去
[43:01.560 --> 43:02.560] 对对对
[43:02.560 --> 43:04.560] 其实就是比较理想化的
[43:04.560 --> 43:05.560] 这种自动构建
[43:05.560 --> 43:07.560] 然后自动发布的流程
[43:07.560 --> 43:08.560] 对
[43:08.560 --> 43:09.560] 就我每次发布
[43:09.560 --> 43:10.560] 我只要打个tag就可以了
[43:10.560 --> 43:12.560] 这样就导致发布可以非常频繁
[43:12.560 --> 43:14.560] 然后有一个保证就是
[43:14.560 --> 43:16.560] 你的那个单元测试
[43:16.560 --> 43:17.560] 跟集成测试要完善
[43:17.560 --> 43:18.560] 对吧
[43:18.560 --> 43:19.560] 你要保证平衡的发布
[43:19.560 --> 43:20.560] 你要保证测试完善
[43:20.560 --> 43:21.560] 对吧
[43:21.560 --> 43:22.560] 不要break人家代码
[43:22.560 --> 43:24.560] 也不要break你用户的东西嘛
[43:24.560 --> 43:25.560] 对
[43:25.560 --> 43:27.560] 我只要merge了我就敢发布
[43:27.560 --> 43:29.560] 其实我写的测试是挺多的
[43:29.560 --> 43:31.560] 应该有几百个
[43:31.560 --> 43:33.560] 就包括命令行
[43:33.560 --> 43:34.560] 纯命令行测试
[43:34.560 --> 43:36.560] 跟单元测试都有很多
[43:36.560 --> 43:38.560] 所以现在基本上只要和了
[43:38.560 --> 43:39.560] 只要CI逃过了
[43:39.560 --> 43:41.560] 我就可以发布
[43:41.560 --> 43:43.560] 这样还是开发代码挺爽的
[43:43.560 --> 43:44.560] 但是在公司里很少会
[43:44.560 --> 43:46.560] 做到这么一个程度
[43:46.560 --> 43:49.560] 公司的话就相当于
[43:49.560 --> 43:51.560] 很多基础设施可能就
[43:51.560 --> 43:54.560] 不太能够配合你这样玩
[43:54.560 --> 43:55.560] 对
[43:55.560 --> 43:56.560] 这个是一个
[43:56.560 --> 43:57.560] 另外代码的质量
[43:57.560 --> 43:58.560] 业务搞得紧
[43:58.560 --> 43:59.560] 你不可能给你
[43:59.560 --> 44:01.560] 太多时间写测试
[44:01.560 --> 44:03.560] 很多我们都是
[44:03.560 --> 44:05.560] 很多时候我们发布都得
[44:05.560 --> 44:06.560] 先发一台机器
[44:06.560 --> 44:08.560] 然后人工验证一下
[44:08.560 --> 44:10.560] 某个功能是不是OK
[44:10.560 --> 44:13.560] 没问题的话我们再继续发
[44:13.560 --> 44:15.560] 就这种完全
[44:15.560 --> 44:16.560] 差不多
[44:16.560 --> 44:18.560] 公司很少有项目让你
[44:18.560 --> 44:21.560] 自信的合并就敢发布的
[44:22.560 --> 44:23.560] 我们也是
[44:23.560 --> 44:25.560] 现在发布的是
[44:25.560 --> 44:27.560] 先人工灰度一部分机器
[44:27.560 --> 44:28.560] 然后发布完了
[44:28.560 --> 44:30.560] 再发布另外一部分机器
[44:30.560 --> 44:31.560] 然后就全部上线
[44:31.560 --> 44:33.560] 这种人工验证
[44:33.560 --> 44:34.560] 其实也挺不爽的
[44:34.560 --> 44:36.560] 每次改东西你都没
[44:36.560 --> 44:38.560] 没信心会不会给你其他东西
[44:38.560 --> 44:39.560] 说到底
[44:39.560 --> 44:40.560] 其实写测试
[44:40.560 --> 44:42.560] 收益还是挺大的
[44:42.560 --> 44:43.560] 车门也大一些
[44:43.560 --> 44:45.560] 就还是看
[44:45.560 --> 44:47.560] 业务的类型
[44:47.560 --> 44:50.560] 可能稳定的项目确实是
[44:50.560 --> 44:52.560] 写测试收益会比较大
[44:52.560 --> 44:53.560] 对
[44:54.560 --> 44:56.560] 你还有其他什么想聊的吗
[44:56.560 --> 44:57.560] 嗯
[44:57.560 --> 44:59.560] Git的hook要不要聊一下
[44:59.560 --> 45:01.560] OK可以啊
[45:01.560 --> 45:02.560] 这是我用的少
[45:02.560 --> 45:03.560] 你可以聊一下
[45:03.560 --> 45:04.560] 就我自己的话
[45:04.560 --> 45:06.560] 相当于是用一个叫
[45:06.560 --> 45:08.560] Git hooks的一个库
[45:08.560 --> 45:09.560] 它会
[45:09.560 --> 45:11.560] 它其实就是把那个就Git
[45:11.560 --> 45:12.560] 首先我们说一下
[45:12.560 --> 45:13.560] Git的hook吧
[45:13.560 --> 45:14.560] 就Git
[45:14.560 --> 45:16.560] 它其实有一些hook
[45:16.560 --> 45:17.560] 比如说你在提交之前
[45:17.560 --> 45:18.560] 提交之后
[45:18.560 --> 45:20.560] 然后push之前这样子
[45:20.560 --> 45:22.560] 就它会去运行你
[45:22.560 --> 45:23.560] 点Git
[45:23.560 --> 45:24.560] 然后Git hooks
[45:24.560 --> 45:26.560] 然后下面的一些share脚本
[45:26.560 --> 45:28.560] 然后默认的脚本里面都是空的
[45:28.560 --> 45:29.560] 对
[45:29.560 --> 45:31.560] 然后如果你去安装自己的hook的话
[45:31.560 --> 45:33.560] 它就可以帮你去执行一些命令
[45:33.560 --> 45:35.560] 然后我用的那个就相当于是
[45:35.560 --> 45:37.560] 你可以去dai repo里面
[45:37.560 --> 45:39.560] 放一些你自己的脚本
[45:39.560 --> 45:41.560] 然后它会去帮你注册进去
[45:41.560 --> 45:43.560] 然后去帮你去执行这样子
[45:43.560 --> 45:45.560] 然后就因为做CI嘛
[45:45.560 --> 45:48.560] 其实你很多时候还是想要
[45:48.560 --> 45:50.560] 反应就反馈更快一点
[45:50.560 --> 45:52.560] 比如说你代码的问题了
[45:52.560 --> 45:55.560] 然后你就加到pre commit里面
[45:55.560 --> 45:58.560] 然后这样子就会很快地知道
[45:58.560 --> 45:59.560] 哪个地方有问题
[45:59.560 --> 46:01.560] 就不用比如说push上去
[46:01.560 --> 46:03.560] 然后等到你的runner开始跑
[46:03.560 --> 46:04.560] 然后跑了
[46:04.560 --> 46:06.560] 然后发现这里有个错误
[46:06.560 --> 46:08.560] 就反馈时间很长了这样
[46:08.560 --> 46:10.560] 对也可以避免丢人对吧
[46:10.560 --> 46:13.560] 我有时候把那些就是点ds-
[46:13.560 --> 46:15.560] 什么那个Mac的founder
[46:15.560 --> 46:17.560] 给你加的那个隐藏文件
[46:17.560 --> 46:18.560] 给push上去
[46:18.560 --> 46:19.560] 就感觉挺丢人的
[46:19.560 --> 46:22.560] 那个可以直接ignore掉就好了
[46:22.560 --> 46:23.560] 对
[46:23.560 --> 46:25.560] 我的意思是你克隆别人的项目
[46:25.560 --> 46:26.560] 像tgrpr
[46:26.560 --> 46:27.560] 但他的没ignore
[46:27.560 --> 46:30.560] 对你可以在git的全局的ignore里面写
[46:30.560 --> 46:32.560] 对对对是的
[46:32.560 --> 46:34.560] 然后还有一个python的项目
[46:34.560 --> 46:35.560] 也叫pre commit
[46:35.560 --> 46:37.560] 但他那个好像就是
[46:37.560 --> 46:40.560] 他上面有一个很比较完善的社区
[46:40.560 --> 46:43.560] 然后有很多人写好了各种语言的hook
[46:43.560 --> 46:45.560] 然后他就你装了那个
[46:45.560 --> 46:46.560] 他就会自动帮你跑
[46:46.560 --> 46:48.560] 你刚刚说的那个githooks
[46:48.560 --> 46:50.560] 那个库就是这个吗
[46:50.560 --> 46:53.560] 不是githooks是另外一个binary
[46:53.560 --> 46:54.560] 是一个勾写的binary
[46:54.560 --> 46:56.560] 然后他相当于只是帮你
[46:56.560 --> 46:58.560] 就启动一下你自己定义的hook
[46:58.560 --> 46:59.560] 这样子
[46:59.560 --> 47:01.560] 而这个库的作用是啥呢
[47:03.560 --> 47:05.560] 这个应该是一个application
[47:05.560 --> 47:06.560] 就是一个应用
[47:06.560 --> 47:07.560] 它其实就是相当于
[47:07.560 --> 47:08.560] 比如说你在tomkool里面
[47:08.560 --> 47:11.560] 可以有一个githooks的文件夹
[47:11.560 --> 47:15.560] 然后下面比如说你有一个githooks-pre
[47:15.560 --> 47:18.560] 呈现-commit这样一个文件夹
[47:18.560 --> 47:19.560] 然后里面的
[47:19.560 --> 47:22.560] 比如说有一些share script
[47:22.560 --> 47:24.560] 然后你只要是带有可执行权限的
[47:24.560 --> 47:27.560] 他就会自动在pre commit的时候
[47:27.560 --> 47:29.560] 帮你去执行这里面的脚本
[47:29.560 --> 47:30.560] 去帮你做检查
[47:30.560 --> 47:34.560] 就相当于你可以很方便的把那些检查
[47:34.560 --> 47:35.560] 写到脚本里面
[47:35.560 --> 47:37.560] 然后让他去自动帮你执行这样子
[47:37.560 --> 47:39.560] 我还是不太明白
[47:39.560 --> 47:41.560] 这个不是git原生的功能吗
[47:41.560 --> 47:43.560] 你直接写到那个文件夹下面都可以
[47:43.560 --> 47:48.560] git原生的那个.githooks
[47:48.560 --> 47:51.560] 那个好像不能直接提到仓库里面管理吧
[47:51.560 --> 47:52.560] 对对对
[47:52.560 --> 47:53.560] 因为
[47:53.560 --> 47:54.560] 是的
[47:54.560 --> 47:56.560] 它那个是相当于是你在
[47:56.560 --> 47:58.560] 根目录下面有一个githooks的文件夹
[47:58.560 --> 48:01.560] 然后你提交到里面的东西都可以提交
[48:01.560 --> 48:03.560] 这样的话所有人都是一样的
[48:04.560 --> 48:05.560] 对对对
[48:05.560 --> 48:07.560] 然后你只需要装一下这个工具就可以
[48:07.560 --> 48:10.560] 直接所有人都有check了
[48:10.560 --> 48:15.560] OK然后可以把这个库写到那个dv的e-line
[48:15.560 --> 48:16.560] 里面去对吧
[48:16.560 --> 48:18.560] 这样装那个pytex什么的都会一起装上
[48:19.560 --> 48:20.560] 对
[48:20.560 --> 48:21.560] 差不多是这样子
[48:21.560 --> 48:23.560] 但是我还有一点不明白
[48:23.560 --> 48:26.560] 就是它是怎么运行这个工具的
[48:26.560 --> 48:28.560] 因为我的那个git
[48:28.560 --> 48:31.560] 就是官方的git下面的pre-commit还是空的
[48:34.560 --> 48:37.560] 它需要你在就创建这个repo之后
[48:37.560 --> 48:38.560] 或者是克隆下来之后
[48:38.560 --> 48:40.560] 执行一个安装
[48:40.560 --> 48:42.560] 就它会把那些hooks全部替换成它自己
[48:42.560 --> 48:45.560] 然后它就会你去commit的时候
[48:45.560 --> 48:47.560] 它就会就执行它自己的这个命令
[48:47.560 --> 48:49.560] 然后去帮你跑那些东西
[48:50.560 --> 48:52.560] OK它是安装的时候替换的
[48:52.560 --> 48:53.560] 对对对
[48:53.560 --> 48:54.560] 它相当于有一个
[48:54.560 --> 48:57.560] 它会让你执行一个githooks install的
[48:57.560 --> 48:58.560] 这么一个步骤
[48:58.560 --> 49:00.560] 那这个还挺好的
[49:00.560 --> 49:02.560] 然后其他的
[49:02.560 --> 49:04.560] 我找了几个仓库
[49:04.560 --> 49:07.560] 一个是awesome-flake-extensions
[49:07.560 --> 49:09.560] 这上面就是一个awesome的仓库
[49:09.560 --> 49:11.560] 里面有很多flakebar的插件
[49:11.560 --> 49:14.560] 然后github官方有一个topic是叫flakebar
[49:14.560 --> 49:17.560] 应该也收录了一些flakebar的相关的
[49:17.560 --> 49:19.560] 艺术项目之类的
[49:19.560 --> 49:22.560] 我看了一下这个里面的插件还挺多的
[49:22.560 --> 49:24.560] 就各种方面都有
[49:24.560 --> 49:27.560] 连帮你检查那个license都有
[49:27.560 --> 49:28.560] 对
[49:28.560 --> 49:30.560] 检查那个copyright的都有
[49:30.560 --> 49:33.560] 还有一个有意思的项目是
[49:33.560 --> 49:36.560] 帮你在不同的工具下面
[49:36.560 --> 49:39.560] 检查保持一致的那个lint配置
[49:39.560 --> 49:41.560] 这个还有点意思
[49:41.560 --> 49:43.560] 就它叫litpick
[49:43.560 --> 49:45.560] 对还挺多的
[49:45.560 --> 49:47.560] 还有一些魔法的
[49:47.560 --> 49:49.560] 比如说这个flakebar-bugbear
[49:49.560 --> 49:50.560] 可以自动找到
[49:50.560 --> 49:52.560] 看起来像bug的东西
[49:52.560 --> 49:53.560] 对对对
[49:53.560 --> 49:56.560] 这个是我觉得还挺好用的一个插件
[49:56.560 --> 49:58.560] 竟然是pycqa的
[49:58.560 --> 50:00.560] 相当于是准官方的
[50:00.560 --> 50:01.560] 对
[50:01.560 --> 50:03.560] 我以前都没有用过
[50:03.560 --> 50:06.560] 还有一个是帮你检查fake的
[50:06.560 --> 50:09.560] 现在有那个usedby
[50:09.560 --> 50:10.560] 就是Github页面上
[50:10.560 --> 50:14.560] 我已经在这个bugbear上发现你了
[50:14.560 --> 50:20.560] 我都忘了我是在哪用了这个东西
[50:20.560 --> 50:21.560] black
[50:21.560 --> 50:22.560] 就是你fork了black
[50:22.560 --> 50:24.560] 这个black用了这个
[50:24.560 --> 50:26.560] 是的
[50:26.560 --> 50:29.560] 我们一般这边会有一个推荐环节
[50:29.560 --> 50:30.560] 你有什么要推荐的吗
[50:30.560 --> 50:36.560] 我想的是推荐一个测试的库
[50:36.560 --> 50:37.560] hypothesis
[50:37.560 --> 50:40.560] 就是一个property-based testing的库
[50:40.560 --> 50:45.560] 它相当于是你去描述你代码的属性
[50:45.560 --> 50:49.560] 然后它去自动帮你生成一些数据去做测试
[50:49.560 --> 50:51.560] 比如说你写了一个站
[50:51.560 --> 50:54.560] 然后你就可以描述它
[50:54.560 --> 50:56.560] 你出站的顺序和入站的顺序是相反的
[50:56.560 --> 50:59.560] 然后它就可以自动帮你生成各种数据
[50:59.560 --> 51:01.560] 去测试你的站
[51:01.560 --> 51:03.560] 是不是符合这个不变量
[51:03.560 --> 51:05.560] 就不变性
[51:05.560 --> 51:07.560] 然后它就相当于是你写一个测试
[51:07.560 --> 51:12.560] 就可以会有很多个那种测试用力冒出来
[51:12.560 --> 51:15.560] 然后如果说你发现了一个不满足这个属性的
[51:15.560 --> 51:18.560] 它就会自动帮你停在测试上面
[51:18.560 --> 51:20.560] 然后你就可以去看测试
[51:20.560 --> 51:21.560] 为什么没有这个属性
[51:21.560 --> 51:23.560] 为什么没有被满足
[51:23.560 --> 51:24.560] 我觉得这个是
[51:24.560 --> 51:30.560] 如果你要写一些比较良好定义的一些逻辑的话
[51:30.560 --> 51:32.560] 就用这个测试起来
[51:32.560 --> 51:37.560] 就可以减少很多手写测试的这种需求
[51:37.560 --> 51:38.560] 对
[51:38.560 --> 51:41.560] 你应该也是在用这个酷逻辑的
[51:41.560 --> 51:43.560] 我都没有听说过
[51:43.560 --> 51:44.560] 我是第一次听说
[51:44.560 --> 51:49.560] 我之前教过一个叫Factory Boy
[51:49.560 --> 51:51.560] 就是它帮你生成测试的model
[51:51.560 --> 51:53.560] 根据你的model定义生成测试的数据
[51:53.560 --> 51:55.560] 不知道是不是类似这种
[51:55.560 --> 51:57.560] 有点类似
[51:57.560 --> 51:58.560] 但是不太一样
[51:58.560 --> 52:04.560] 它这个相当于是你去描述它的代码的逻辑
[52:04.560 --> 52:08.560] 就比如说你说A加B等于B加A这种逻辑
[52:08.560 --> 52:11.560] 然后它就帮你生成两个整数A和B
[52:11.560 --> 52:13.560] 然后去验证你对所有的整数
[52:13.560 --> 52:15.560] 你这个逻辑的成立
[52:15.560 --> 52:16.560] 然后如果有不成立
[52:16.560 --> 52:18.560] 它就把这个case给你写出来
[52:18.560 --> 52:20.560] 然后你就去检查就好了
[52:20.560 --> 52:23.560] 我有点不明白
[52:23.560 --> 52:25.560] 这不是要把代码再写第二遍吗
[52:25.560 --> 52:30.560] 你是说用它的项目的定义的一些语言来描述
[52:30.560 --> 52:33.560] 就相当于你要去用一个比较抽象的语言
[52:33.560 --> 52:37.560] 把你的代码里面的一些就不变性给描述出来
[52:37.560 --> 52:40.560] 然后它就会自动帮你去测试这个不变性
[52:40.560 --> 52:42.560] OK那它生成的测试数据
[52:42.560 --> 52:44.560] 比如说我今天跑跟明天跑
[52:44.560 --> 52:46.560] 用的测试数据是一样的吗
[52:46.560 --> 52:48.560] 不是一样的
[52:48.560 --> 52:51.560] 它会自动去做random
[52:51.560 --> 52:55.560] 但是它会去根据你的测试的这个结果
[52:55.560 --> 52:58.560] 去把那个测试集合给缩小
[52:58.560 --> 53:00.560] 然后逐渐去找出一个
[53:00.560 --> 53:03.560] 可能会让你测试失败的这个例子
[53:03.560 --> 53:06.560] 那有没有可能就是这一次测试通过了
[53:06.560 --> 53:07.560] 下一次再跑
[53:07.560 --> 53:09.560] 它可能就找到了一个错误的例子
[53:09.560 --> 53:10.560] 有可能
[53:10.560 --> 53:11.560] 如果说你的
[53:11.560 --> 53:13.560] 比如说你的样本空间实在是太大了
[53:13.560 --> 53:17.560] 然后它就可能跑一次就可能找不完
[53:17.560 --> 53:20.560] 但是如果说你有比较完善的CI
[53:20.560 --> 53:23.560] 它就可能会用不同的值反复的测试
[53:23.560 --> 53:26.560] 然后会帮你最后还是会把这个bug找出来
[53:26.560 --> 53:29.560] OK
[53:29.560 --> 53:32.560] 我之前有一个想写一个东西
[53:32.560 --> 53:35.560] 就是转那个CronType
[53:35.560 --> 53:38.560] 因为CronType是它会按照服务器的时序来跑
[53:38.560 --> 53:39.560] 那就有个问题
[53:39.560 --> 53:42.560] 就是你要把你比如你服务器都是用的
[53:42.560 --> 53:46.560] UTC那个加零的那个时序
[53:46.560 --> 53:47.560] 就是内容时序
[53:47.560 --> 53:50.560] 但是我们笔记本电脑上是UTC加%
[53:50.560 --> 53:52.560] 就是我们日常生活的时间是这个
[53:52.560 --> 53:53.560] 那你要把它放过去
[53:53.560 --> 53:55.560] 你可能要写一个
[53:55.560 --> 53:58.560] 就是在脑袋里做一个这样转换
[53:58.560 --> 54:00.560] 我本来想写一个自动转换的这个库
[54:00.560 --> 54:04.560] 然后就有很多的这个Corner Case需要测试
[54:04.560 --> 54:07.560] 比如说每个月的30号
[54:07.560 --> 54:11.560] 那你经过这么一个时序的转换
[54:11.560 --> 54:14.560] 那那个CronType可能就有很多要变的东西
[54:14.560 --> 54:15.560] 所以我当时测试
[54:15.560 --> 54:17.560] 我就想找一个这样的东西来测试
[54:17.560 --> 54:19.560] 就是我告诉他结果应该是什么
[54:19.560 --> 54:22.560] 他自动去寻找这个日期转过来
[54:22.560 --> 54:23.560] 对不对
[54:23.560 --> 54:24.560] 这个日期这样转过来
[54:24.560 --> 54:25.560] 对不对
[54:25.560 --> 54:26.560] 我感觉这个好像就蛮有需求的
[54:26.560 --> 54:27.560] 对对对
[54:27.560 --> 54:29.560] 就有点像这种性质的
[54:29.560 --> 54:30.560] 其实
[54:30.560 --> 54:32.560] 但后来那个库我都没有开始写
[54:32.560 --> 54:33.560] 我感觉好难
[54:33.560 --> 54:37.560] 就是你那个Clock.sh那个项目吗
[54:37.560 --> 54:38.560] 是的
[54:38.560 --> 54:40.560] 因为我想让所有的用户
[54:40.560 --> 54:42.560] 按照他们自己的生活的时序来定义
[54:42.560 --> 54:43.560] CronType就好了
[54:43.560 --> 54:47.560] 但是我所有服务器都是跑在那个中央时区的
[54:47.560 --> 54:48.560] 都是一样的
[54:48.560 --> 54:51.560] 不然的话代码逻辑太复杂了
[54:51.560 --> 54:54.560] 但其实写这个转换是比较复杂的
[54:54.560 --> 54:58.560] 比如说一个用户写了每个月的2月29号
[54:58.560 --> 55:00.560] 凌晨1点来跑
[55:00.560 --> 55:02.560] 那你要转换成另一个时区
[55:02.560 --> 55:03.560] 那他可能变
[55:03.560 --> 55:06.560] 就你要考虑有没有29号的问题
[55:06.560 --> 55:07.560] 对吧
[55:07.560 --> 55:08.560] 对对对
[55:08.560 --> 55:09.560] 是的
[55:09.560 --> 55:10.560] 对
[55:10.560 --> 55:14.560] 而且在他那个时区29号1点
[55:14.560 --> 55:20.560] 那你可能在中央时区要是在3月1号的某一个点
[55:20.560 --> 55:22.560] 这样你可能把它跨了一天
[55:22.560 --> 55:23.560] 其实挺复杂的
[55:23.560 --> 55:24.560] 是的
[55:24.560 --> 55:25.560] 是的
[55:25.560 --> 55:27.560] 所以就就没有搞成
[55:27.560 --> 55:29.560] 我本来我去搜了一下
[55:29.560 --> 55:31.560] 其实任何语言好像都没有一个这样的库
[55:31.560 --> 55:35.560] 感觉这个逻辑实在是有点太复杂了
[55:35.560 --> 55:38.560] 而且改一下需求就能够很简单解决的
[55:38.560 --> 55:40.560] 就没有必要去搞那么复杂
[55:40.560 --> 55:42.560] 怎么改一下需求
[55:42.560 --> 55:45.560] 就你不是说直接按那个
[55:45.560 --> 55:46.560] 好像不行
[55:46.560 --> 55:49.560] 你现在是按那个还是按服务器时区跑的
[55:49.560 --> 55:51.560] 对对还是服务器时区跑的
[55:51.560 --> 55:53.560] 用户需要自己来转
[55:53.560 --> 55:55.560] 把这个给我甩给用户了
[55:55.560 --> 55:56.560] 是的
[55:56.560 --> 55:57.560] 对
[55:57.560 --> 56:01.560] 比如说他就是正常定义一个2月的1号来跑
[56:01.560 --> 56:06.560] 那我可能又要根据需要把它转成1月31号
[56:06.560 --> 56:09.560] 那这样的Chrome type里面有两个字段都需要去改
[56:09.560 --> 56:11.560] 是的
[56:11.560 --> 56:12.560] 对这个就相当于
[56:12.560 --> 56:14.560] 而且时区这个还有点
[56:14.560 --> 56:15.560] 是的
[56:15.560 --> 56:17.560] 而且时区这个还有点复杂
[56:17.560 --> 56:20.560] 就是比如说他有可能会有下令时
[56:20.560 --> 56:23.560] 这种就中间有一个时间可能就根本就没有
[56:23.560 --> 56:26.560] 而且这个Chrome type表达式经过时区的转换
[56:26.560 --> 56:31.560] 有可能就不是一个不是一个表达式了
[56:31.560 --> 56:32.560] 就比如说
[56:32.560 --> 56:33.560] 对
[56:33.560 --> 56:37.560] 就是某一号的早凌晨1点到8点来跑
[56:37.560 --> 56:41.560] 那你转换过一个可能就一个Chrome type需要是
[56:41.560 --> 56:44.560] 10点到24点
[56:44.560 --> 56:46.560] 然后另一个就是0点到6点
[56:46.560 --> 56:48.560] 可能转出来这么一个区间
[56:48.560 --> 56:49.560] 对
[56:49.560 --> 56:50.560] 是的
[56:50.560 --> 56:52.560] 就相当于一个Chrome type表达式
[56:52.560 --> 56:54.560] 已经描述不了这个逻辑了
[56:54.560 --> 56:55.560] 对
[56:55.560 --> 56:58.560] 所以所以我这技术上也可以搞
[56:58.560 --> 57:01.560] 我就打算把他这个任务定义给拆成两个
[57:01.560 --> 57:02.560] 两种任务
[57:02.560 --> 57:03.560] 就相当于
[57:03.560 --> 57:05.560] 但是这个做的事情是一模一样的
[57:05.560 --> 57:06.560] 这样的话
[57:06.560 --> 57:10.560] 这两个每一个就是命中了都会去跑
[57:10.560 --> 57:11.560] 其实可以实现
[57:11.560 --> 57:12.560] 是的
[57:12.560 --> 57:15.560] 总之回到测试上这个问题
[57:15.560 --> 57:18.560] 就这种情况是非常适合用这个测试的
[57:18.560 --> 57:22.560] 一而还有一种就是那种时区转换的库
[57:22.560 --> 57:26.560] 像Pendulum或者Arrow这种时区转换
[57:26.560 --> 57:30.560] 特别适合用这种来生成数据测
[57:30.560 --> 57:31.560] 对
[57:31.560 --> 57:36.560] 就你其实只要能够写出一个比较general的
[57:36.560 --> 57:37.560] 就一个属性的话
[57:37.560 --> 57:40.560] 其实就可以用这种库来测
[57:40.560 --> 57:43.560] 这个好像最早是Haskell提出来的一个东西
[57:43.560 --> 57:47.560] 然后但是现在好像各个语言里面都有这种库
[57:47.560 --> 57:49.560] 感觉是比较适合测算法
[57:49.560 --> 57:51.560] 不太适合测业务逻辑
[57:51.560 --> 57:55.560] 业务逻辑确实就太复杂了
[57:55.560 --> 57:58.560] 就没有一个特别特别那个具体
[57:58.560 --> 58:00.560] 就特别统一的逻辑
[58:00.560 --> 58:01.560] 对
[58:01.560 --> 58:05.560] 而且业务逻辑其实痛点是你找出来一个case
[58:05.560 --> 58:06.560] 能够跑完
[58:06.560 --> 58:08.560] 就是你需要什么数据
[58:08.560 --> 58:10.560] 然后就需要什么配置
[58:10.560 --> 58:11.560] 这样一些
[58:11.560 --> 58:14.560] 整个算法逻辑是非常简单的
[58:14.560 --> 58:19.560] 那我这边的话就拿那个Flick8的
[58:19.560 --> 58:21.560] 那个awesome仓库来当推荐就好了
[58:21.560 --> 58:24.560] 大家如果可以去看看有没有什么有意思的插件
[58:24.560 --> 58:27.560] 或者要学习自己写一个的话
[58:27.560 --> 58:28.560] 可以参考里面的代码
[58:28.560 --> 58:32.560] 其实Flick8的插件代码都是非常简单的
[58:32.560 --> 58:34.560] 你只要看一下它的官方文档
[58:34.560 --> 58:35.560] 怎么写一个插件
[58:35.560 --> 58:36.560] 然后你再看几个插件
[58:36.560 --> 58:37.560] 它们是怎么实现的
[58:37.560 --> 58:38.560] 基本上就可以了
[58:38.560 --> 58:39.560] 对对对
[58:39.560 --> 58:41.560] 其实直接照着一个插件
[58:41.560 --> 58:42.560] 照着个槽
[58:42.560 --> 58:44.560] 说不定还更快一点
[58:44.560 --> 58:45.560] 对
[58:45.560 --> 58:47.560] 就像那个突破解剖
[58:47.560 --> 58:49.560] 那个也就40来
[58:49.560 --> 58:51.560] 特别特别简单
[58:51.560 --> 58:52.560] 好
[58:52.560 --> 58:55.560] 那我们今天的节目就到这里
[58:55.560 --> 58:56.560] 感谢大家的收听
[58:56.560 --> 58:59.560] 这期就主要我跟Luke两个人介绍了一下
[58:59.560 --> 59:00.560] Python的Flick8
[59:00.560 --> 59:04.560] 以及Link相关的一些实践和用处
[59:04.560 --> 59:06.560] 希望对大家有用
[59:06.560 --> 59:08.560] 那我们下期再见
[59:08.560 --> 59:28.560] 拜拜
