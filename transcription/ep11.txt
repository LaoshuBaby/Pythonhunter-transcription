[00:00.000 --> 00:18.000] 【红姐和中科院的故事】
[00:18.000 --> 00:21.000] 欢迎大家来到补书者说第11期
[00:21.000 --> 00:24.600] 这期我们请到了红姐
[00:24.600 --> 00:27.200] 来聊一下之前比较火的话题
[00:27.200 --> 00:31.800] 就是中科院做的一个叫做木兰的编程语言
[00:31.800 --> 00:34.600] 我们先请红姐来介绍一下自己
[00:34.600 --> 00:37.400] 要介绍自己啊这个
[00:37.400 --> 00:39.800] 要的要的
[00:39.800 --> 00:42.300] 就我说一下我的concept
[00:42.300 --> 00:46.300] 我专业是搞这个程序语言
[00:46.300 --> 00:50.000] 然后做编译器也是我们实验室的一个主题之一
[00:50.000 --> 00:53.200] 然后我个人呢对python比较有些了解
[00:53.200 --> 00:56.300] 就是在python里面写了比较多编译器
[00:56.300 --> 00:58.000] 比较多编译器工具
[00:58.000 --> 01:01.400] 就是对这个木兰有一些就是说
[01:01.400 --> 01:03.800] 比较有一些看法吧
[01:03.800 --> 01:06.300] 然后我个人呢也觉得是比较能够理解
[01:06.300 --> 01:07.800] 他作者他的意图
[01:07.800 --> 01:09.899] 他写出来的东西他的
[01:09.899 --> 01:11.800] 他在里面做了什么东西
[01:11.800 --> 01:13.700] 可能很多人不是太清楚
[01:13.700 --> 01:16.400] 所以今天我想讲一下就这个东西
[01:16.400 --> 01:18.800] 就木兰也不能说他
[01:18.800 --> 01:20.400] 不能那样黑他
[01:20.400 --> 01:23.300] 就是我是这样一个态度的
[01:23.300 --> 01:27.399] ok好那然后我们今天另外一位主持是Mangelsaka
[01:27.399 --> 01:28.899] 然后给大家打个招呼
[01:28.899 --> 01:29.899] 哈喽大家好
[01:29.899 --> 01:30.899] 我是Mangelsaka
[01:30.899 --> 01:33.300] 然后这应该是我新年第一期节目
[01:33.300 --> 01:35.800] 然后刚刚从音乐坛出来的
[01:35.800 --> 01:38.700] 我现在真是憔悴的坐在凳子前
[01:38.700 --> 01:41.400] 最后给大家做一个提醒
[01:41.400 --> 01:45.000] 双黄连口服液并不能真正的预防那个武汉肺炎
[01:45.000 --> 01:47.100] 请大家不要再抢购了
[01:47.100 --> 01:50.200] 但是学习python是可以预防的
[01:50.200 --> 01:52.000] 双黄连都脱销了现在
[01:52.000 --> 01:54.400] 然后在进入主题之前
[01:54.400 --> 01:58.200] 我们先就是问一下宏杰
[01:58.200 --> 02:00.600] 你是怎么开始学习编程
[02:00.600 --> 02:02.500] 包括学习python的这样一个过程吧
[02:02.500 --> 02:06.200] 然后也是因为这个问题我们每次也都会问
[02:06.200 --> 02:07.600] 这个问题啊
[02:07.600 --> 02:09.199] 这个问题真的问过吗
[02:09.199 --> 02:12.900] 之前好像都问了的
[02:12.900 --> 02:16.200] 那我有给你们讲过我看刀剑神域吗
[02:16.200 --> 02:17.600] 嗯好像没有
[02:17.600 --> 02:18.500] 没有吗
[02:18.500 --> 02:20.000] 那可能是之前讲的不细吧
[02:20.000 --> 02:23.800] 就是因为这个问题以前在学校采访的时候
[02:23.800 --> 02:25.800] 他们也问过我
[02:25.800 --> 02:27.900] 就是是这样的
[02:27.900 --> 02:31.800] 因为我大学前我是打算学纯术嘛
[02:31.800 --> 02:37.100] 然后但是在那个就是上大学的一个暑假
[02:37.100 --> 02:38.700] 然后我看刀剑神域
[02:38.700 --> 02:44.400] 就是现在这之前B站在放的那个underworld片
[02:44.400 --> 02:45.600] 就刚好是那一段
[02:45.600 --> 02:47.600] 然后当里面剧情要超前一些
[02:47.600 --> 02:50.700] 就是说人工智能它还真的来到现实世界
[02:50.700 --> 02:53.100] 就是通过一个机器人的身体
[02:53.100 --> 02:54.100] 那个时候我比较触动
[02:54.100 --> 02:56.000] 然后就想学人工智能
[02:56.000 --> 02:58.500] 然后大一的时候我就DJ
[02:58.500 --> 03:01.299] 反正就是上编程课觉得很有意思
[03:01.299 --> 03:04.400] 然后就比较费心往事
[03:04.400 --> 03:07.400] 然后大一下的时候被推荐到就是
[03:07.400 --> 03:10.700] 那个计算机院那边的实验室去做生物心理学
[03:10.700 --> 03:13.600] 然后能学一些技术学习相关的东西
[03:13.600 --> 03:15.299] 但后来就大二的时候
[03:15.300 --> 03:18.200] 觉得感觉这个东西写不出来
[03:18.200 --> 03:21.400] 这个人是做不出来的
[03:21.400 --> 03:24.100] 然后但是同时又觉得就是
[03:24.100 --> 03:27.100] 因为当时培养了比较多的这个python的技能嘛
[03:27.100 --> 03:29.900] 其实当时还有很多CI家或者MATLAB之类的
[03:29.900 --> 03:31.300] 也比较熟
[03:31.300 --> 03:33.900] 然后拿了一些名次拿一些奖
[03:33.900 --> 03:35.600] 你不是之前是数学专业吗
[03:35.600 --> 03:39.200] 然后但是你没有编程课是吗
[03:39.200 --> 03:40.100] 就我感觉吧
[03:40.100 --> 03:42.000] 我不知道你们那边是什么情况
[03:42.000 --> 03:47.900] 但是很多一些就是别的非CS或者通信专业开的这种编程课
[03:47.900 --> 03:49.700] 很多人就直接水过去了
[03:49.700 --> 03:51.200] 然后也不是特别认真对待
[03:51.200 --> 03:54.800] 然后这个课程的就是代码量也不会很大
[03:54.800 --> 03:57.600] 但是好像你当时应该并不是这个情况
[03:57.600 --> 04:01.000] 是的我和应该说大一的时候
[04:01.000 --> 04:04.000] 指的我反正就是这其实挺夸张的嘛
[04:04.000 --> 04:08.400] 就是说如果中午如果早上有编程的上机课
[04:08.400 --> 04:10.500] 那么午饭就不吃了这类种
[04:10.500 --> 04:13.000] 然后下午的话晚饭就不吃了
[04:13.000 --> 04:14.600] 我跟那老师这个关系打挺好的
[04:14.600 --> 04:16.600] 就他天天他看我怎么在这
[04:16.600 --> 04:18.500] 然后我就我就跟他聊嘛
[04:18.500 --> 04:20.500] 然后让我印象很深刻的是
[04:20.500 --> 04:23.400] 我跟老师讨论出很多比较怪CI家的东西
[04:23.400 --> 04:26.600] 比方说那个就是因为当时一直不理解
[04:26.600 --> 04:27.600] 就是缓冲区嘛
[04:27.600 --> 04:32.200] 然后然后打印一个换行服和打印一个N抖是不一样的
[04:32.200 --> 04:35.000] 这种东西对反正就觉得老师挺厉害
[04:35.000 --> 04:37.200] 然后和他交流很多
[04:37.200 --> 04:39.400] 就是在那样的一种情况下吧
[04:39.400 --> 04:41.299] 反正发生了挺多事
[04:41.299 --> 04:43.299] 就觉得越来越有动力嘛
[04:43.299 --> 04:46.099] 就是那种因为不只是说有有梦想就行
[04:46.099 --> 04:49.099] 就肯定还是要有人给你这种前进的认可
[04:49.099 --> 04:51.000] 对吧就是你会觉得哎
[04:51.000 --> 04:52.500] 我学这个东西好像挺厉害的
[04:52.500 --> 04:53.900] 对还有就是哦
[04:53.900 --> 04:56.400] 不只是还要就是说确实跟兴趣有关系
[04:56.400 --> 04:59.599] 就是虽然当时跟人工智能没有半点没有半毛钱关系
[04:59.599 --> 05:03.700] 但是因为我们当时学高数码高学高带和数分
[05:03.700 --> 05:07.099] 然后里面的很多的东西都可以去用编程训模拟
[05:07.100 --> 05:09.700] 比方说第一节课我就写了写了积分
[05:09.700 --> 05:12.900] 然后写了那个矩阵的相乘就这种东西
[05:12.900 --> 05:15.600] 就觉得哎好像数学学东西这边也可以用上
[05:15.600 --> 05:17.600] 然后觉得挺挺有意思
[05:17.600 --> 05:24.400] 对然后就是他兴趣是会不停的去促进你往再往前学习的嘛
[05:24.400 --> 05:26.100] 对吧我还挺好奇积分
[05:26.100 --> 05:29.800] 你是怎么用编程模拟的或者说你的输入是什么
[05:29.800 --> 05:32.500] 他就是一个式子加一个就是积分源嘛
[05:32.500 --> 05:35.500] 对吧delta x这种很简单的那种没有
[05:35.500 --> 05:37.600] 没有那种就是误差项估计
[05:37.600 --> 05:38.900] 就单纯是对吧
[05:38.900 --> 05:41.800] 我从哪个区间开始到哪个区间一个定积分
[05:43.200 --> 05:46.300] 哦我还以为你是会我还以为你是弄了一个数字的吗
[05:46.300 --> 05:48.600] 弄了一个sdl之类的
[05:48.600 --> 05:51.200] 对那种那种其实反而并不好玩
[05:51.200 --> 05:55.200] 我说实话就是如果你不了解整个算法的话
[05:55.200 --> 05:57.800] 反而没有就是说定积分这么简单的好玩
[05:57.800 --> 06:00.800] okok其实我有个问题啊
[06:00.800 --> 06:04.700] 就是因为我看到其实红姐刚才就说是自己在大学和
[06:04.700 --> 06:08.700] monisha那个学了很多关于就是编程语言和编程原理的
[06:08.700 --> 06:10.400] 编译原理相关的东西
[06:10.400 --> 06:12.700] 而我们知道就是说是
[06:12.700 --> 06:14.800] 第一个是对于很多CS的学生来说
[06:14.800 --> 06:16.900] 编译原理这种课就直接睡过去
[06:16.900 --> 06:20.099] 第二个可能说对于很多非科班的转行同学来说
[06:20.099 --> 06:21.599] 他们没学过编译原理
[06:21.599 --> 06:25.200] 然后也会觉得这个东西是很没有用处的一个东西
[06:25.200 --> 06:27.700] 其实我想问一下请教一下红姐
[06:27.700 --> 06:31.700] 就是说您觉得的话对于编译原理这个东西的话
[06:31.700 --> 06:35.200] 对于一个在计算机领域这一行
[06:35.200 --> 06:38.200] 就是说工作的人或者说有兴趣的人
[06:38.200 --> 06:41.700] 你觉得对于他们的意义来说是什么样子
[06:41.700 --> 06:43.700] 或者说学了有什么好处
[06:43.700 --> 06:47.200] 我觉得吧这个东西
[06:47.200 --> 06:51.700] 其实这个问题还挺挺挺挺难的
[06:51.700 --> 06:55.700] 就是很难去说一个具体的好处吧
[06:55.700 --> 07:02.700] 就是说偶尔会有那种就是需要造DSL的场景
[07:02.700 --> 07:06.700] 比方说你觉得这个代码好像你在语言里写出来怎么都会有语
[07:06.700 --> 07:09.700] 然后有些是管理的时候会有些不方便
[07:09.700 --> 07:11.700] 然后这个时候可能自动生成会好一些
[07:11.700 --> 07:16.700] 但这种情况相对来说大公司协作的时候会比较少
[07:16.700 --> 07:20.700] 所以我觉得意义大概就是说
[07:20.700 --> 07:23.200] 多半来说是一种冲人上的意义吧
[07:23.200 --> 07:25.700] 就是学新知识的一种感觉吧
[07:25.700 --> 07:27.200] 我刚刚其实还有个问题
[07:27.200 --> 07:32.200] 就是说像洪坚你是没有在大学之前接触过编程的吗
[07:32.200 --> 07:35.200] 还是有但是
[07:35.200 --> 07:38.200] 这个很尴尬就是
[07:38.200 --> 07:40.200] 以前我是有他们学
[07:40.200 --> 07:42.200] 我是学物理计算的
[07:42.200 --> 07:44.200] 我不是学信息的
[07:44.200 --> 07:46.200] 但是我同学给我介绍过
[07:46.200 --> 07:48.200] 他们给我介绍HelloTar
[07:48.200 --> 07:50.200] 好像是这个吧
[07:50.200 --> 07:51.700] 然后我当时解出来了
[07:51.700 --> 07:53.200] 然后我觉得地规挺好玩的
[07:53.200 --> 07:54.200] 但是我也没有细想
[07:54.200 --> 07:56.200] 我没觉得这个东西很有意思
[07:56.200 --> 07:58.200] 我当时就不觉得它很有意思你知道吗
[07:58.200 --> 07:59.200] 就我没有觉得它这个东西
[07:59.200 --> 08:01.200] 我甚至就觉得数学是最高级的
[08:01.200 --> 08:04.200] 就是你知道就是那种学生
[08:04.200 --> 08:08.200] 都有那种就是追求什么比较高的东西的那种感觉
[08:08.200 --> 08:11.200] 就不会觉得编程怎么有吸引力
[08:11.200 --> 08:14.200] 就确实还是看到刀剑神域之后
[08:14.200 --> 08:17.200] 就是才有那种兴趣的
[08:17.200 --> 08:20.200] 这是一个事实
[08:20.200 --> 08:23.200] 感觉刀剑神域终于做了一件好事了
[08:23.200 --> 08:27.200] 虽然是个很槽点很多的片子
[08:27.200 --> 08:29.200] 但是从这个意义上说还是很有意义的
[08:29.200 --> 08:34.200] 我觉得刀剑神域剧组应该给我们打五毛钱的广告费
[08:34.200 --> 08:36.200] 其实我没有看过刀剑神域
[08:36.200 --> 08:37.200] 我完全没看过
[08:37.200 --> 08:38.200] 我只看过别人喷他
[08:38.200 --> 08:40.200] 我也没看过
[08:40.200 --> 08:43.200] 我个人的话其实也建议就是说
[08:43.200 --> 08:45.200] 因为小说和动画差比较多
[08:45.200 --> 08:47.200] 个人还是推荐如果看动画的话
[08:47.200 --> 08:49.200] 就只看第一季的前十二集吧
[08:49.200 --> 08:52.200] 不要再往下看了
[08:52.200 --> 08:54.200] OK
[08:54.200 --> 08:56.200] 那我们来把话题切
[08:56.200 --> 09:00.200] 要不然来我们直接就切换到木兰上面吧
[09:00.200 --> 09:01.200] 是
[09:01.200 --> 09:04.200] 然后对我们今天是要聊一下木兰
[09:04.200 --> 09:09.200] 那么可能有些听众朋友还没有听说过
[09:09.200 --> 09:10.200] 但是木兰的话
[09:10.200 --> 09:14.200] 他是之前中科院计算所下面的一个
[09:14.200 --> 09:17.200] 好像是一个副研究员开的公司
[09:17.200 --> 09:19.200] 里面搞的一个编程语言
[09:19.200 --> 09:22.200] 然后这个语言在大概一月份的时候
[09:22.200 --> 09:24.200] 就是发布出来
[09:24.200 --> 09:29.200] 然后当时科学网上是有一篇宣传文章
[09:29.200 --> 09:30.200] 然后发布出来
[09:30.200 --> 09:32.200] 因为他吹的非常厉害
[09:32.200 --> 09:34.200] 就引起了轩然大波
[09:34.200 --> 09:36.200] 然后大家都开始讨论
[09:36.200 --> 09:39.200] 然后最后最后发生的事情呢
[09:39.200 --> 09:43.200] 就是说计算所也是我的算是母所吧
[09:43.200 --> 09:49.200] 就认定说这个宣传是有很多夸大其词的地方
[09:49.200 --> 09:51.200] 然后相当于给这个人做了一些处罚
[09:51.200 --> 09:54.200] 比如说他三年之内不能晋升
[09:54.200 --> 09:55.200] 还是多少年
[09:55.200 --> 09:56.200] 五年
[09:56.200 --> 09:57.200] 五年是吗
[09:57.200 --> 09:59.200] 对然后总是就是有些处罚
[09:59.200 --> 10:01.200] 他发了一个非常详细的说明
[10:01.200 --> 10:04.200] 就觉得这个处理还是不错的
[10:04.200 --> 10:07.200] 但是我们今天会更多就是从基础角度
[10:07.200 --> 10:10.200] 来解读一下木兰这门语言
[10:10.200 --> 10:12.200] 包括其他一些相关的东西
[10:12.200 --> 10:15.200] 那就请宏杰开始吧
[10:15.200 --> 10:17.200] 你可以先大概介绍一下
[10:17.200 --> 10:18.200] 就从有浅入深
[10:18.200 --> 10:20.200] 然后让我们听众有一个比较好了解
[10:20.200 --> 10:21.200] 对
[10:21.200 --> 10:22.200] 其实这个事情的话
[10:22.200 --> 10:24.200] 因为我现在没有
[10:24.200 --> 10:25.200] 我也没有准备他
[10:25.200 --> 10:26.200] 我们就先说一下
[10:26.200 --> 10:28.200] 就木兰他到底做了什么吧
[10:28.200 --> 10:31.200] 就说因为现在我们看到知乎上很多地方
[10:31.200 --> 10:33.200] 他们在黑这个木兰
[10:33.200 --> 10:35.200] 就是这个黑是没有问题
[10:35.200 --> 10:38.200] 就是说这种主要的态度是没有问题的
[10:38.200 --> 10:40.200] 就说他确实是明不符实
[10:40.200 --> 10:41.200] 这点是可以确定的
[10:41.200 --> 10:43.200] 但是我看出上很多说法是
[10:43.200 --> 10:45.200] 他就是个套壳拍子
[10:45.200 --> 10:47.200] 这个说法肯定是有问题的
[10:47.200 --> 10:49.200] 我今天首先要讲的就是这一点
[10:49.200 --> 10:51.200] 这点是要给他反驳的
[10:51.200 --> 10:54.200] 木兰其实他到底他是有什么语言特性
[10:54.200 --> 10:55.200] 其实我们要关注一下
[10:55.200 --> 10:57.200] 就是他的他做了两个事情
[10:57.200 --> 10:59.200] 我觉得是比较有意思的
[10:59.200 --> 11:02.200] 就说如果他不他不拿出来乱吹的话
[11:02.200 --> 11:03.200] 他post到github上
[11:03.200 --> 11:05.200] 然后让大家看把这个事情说出来
[11:05.200 --> 11:07.200] 是可能会得到一定赞赏的
[11:07.200 --> 11:08.200] 对
[11:08.200 --> 11:13.200] 第一个事情是这个多行lambda
[11:13.200 --> 11:16.200] 这个你跟我提过好多次
[11:16.200 --> 11:17.200] 对对对
[11:17.200 --> 11:20.200] 就是他的lambda是可以是
[11:20.200 --> 11:22.200] 他的返回值是可以是个block的
[11:22.200 --> 11:24.200] 他具体做法就是
[11:24.200 --> 11:26.200] 其实他的做法特别简单
[11:26.200 --> 11:30.200] 这这只是说怎么说
[11:30.200 --> 11:33.200] 这个技术上叫叫叫lambda lifting
[11:33.200 --> 11:37.200] 就是说把一个lambda给提升到更更上层的作用
[11:37.200 --> 11:41.200] 一般说是全局作用域变成一个普通的函数
[11:41.200 --> 11:44.200] 但是实际上他在处理的时候
[11:44.200 --> 11:46.200] 因为我我我也没有特别认真看
[11:46.200 --> 11:49.200] 就是虽然我确实大概一眼能看懂他代码
[11:49.200 --> 11:50.200] 他代码确实很简单
[11:50.200 --> 11:53.200] 但是他的这个他的内容
[11:53.200 --> 11:55.200] 就说把lambda变成一个全局函数
[11:55.200 --> 11:56.200] 还是一个局部函数
[11:56.200 --> 11:59.200] 我不这会儿不太记得清楚了
[11:59.200 --> 12:01.200] 然后他用的这个东西
[12:01.200 --> 12:05.200] 就是把lambda给做一个标号
[12:05.200 --> 12:08.200] 就说比方说我这边出现了第一个代block lambda
[12:08.200 --> 12:12.200] 他其实是我们会提升到某个作用的第一个函数
[12:12.200 --> 12:15.200] 然后当你调在这使用一个lambda的时候
[12:15.200 --> 12:17.200] 其实你是去引用那个名字
[12:17.200 --> 12:21.200] 可以想到类似于做了一些code transform是吧
[12:21.200 --> 12:24.200] 就是其实他在他的底层并不是一个lambda
[12:24.200 --> 12:25.200] 对对对
[12:25.200 --> 12:28.200] 但实际上本身lambda在字节码层面也是一个
[12:28.200 --> 12:30.200] 也是个普通的函数而已
[12:30.200 --> 12:31.200] 这个其实没什么
[12:31.200 --> 12:32.200] 但问题是在于
[12:32.200 --> 12:35.200] 这个东西这个技术本身是要lambda lifting
[12:35.200 --> 12:38.200] 但是他失去了所有的这个技术重要的部分
[12:38.200 --> 12:41.200] 因为在python里面他没有做scoping的分析
[12:41.200 --> 12:44.200] 就是他不需要去做这个
[12:44.200 --> 12:46.200] 不需要去分析有什么变量是自由变量
[12:46.200 --> 12:48.200] 有什么变量是局部变量
[12:48.200 --> 12:51.200] 这个自由变量和局部变量不需要我解释吧
[12:51.200 --> 12:52.200] 对吧
[12:52.200 --> 12:53.200] 嗯
[12:53.200 --> 12:56.200] 这一个技术他是没有必要做的
[12:56.200 --> 12:59.200] 他只是简单的做一个lambda
[12:59.200 --> 13:03.200] 虽然他实现了大家觉得是痛点的多行lambda
[13:03.200 --> 13:04.200] 这是第一点
[13:04.200 --> 13:05.200] 其实等一下
[13:05.200 --> 13:06.200] 洪杰我对不起我打断一下
[13:06.200 --> 13:10.200] 其实我觉得可能还是需要给我们的听众朋友们解释一下
[13:10.200 --> 13:11.200] 什么是自由变量
[13:11.200 --> 13:12.200] 什么是局部变量
[13:12.200 --> 13:15.200] 还要解释一下什么是多行lambda
[13:15.200 --> 13:16.200] 对
[13:16.200 --> 13:17.200] ok
[13:17.200 --> 13:18.200] 首先多行lambda是什么
[13:18.200 --> 13:19.200] 这是一个问题
[13:19.200 --> 13:23.200] 就是就在python里面你去写这个lambda表达式
[13:23.200 --> 13:26.200] 你的表达式只能是一个单一个简单的表达式
[13:26.200 --> 13:29.200] 它里面不能去组合
[13:29.200 --> 13:32.200] 不能够说里面去有python的with语句
[13:32.200 --> 13:34.200] 不能有python的class的定义
[13:34.200 --> 13:37.200] 不能有这个
[13:37.200 --> 13:42.200] 很难去说写出多个语句的组合
[13:42.200 --> 13:44.200] 或者说在里面进行复制
[13:44.200 --> 13:47.200] 这些都是在lambda的表达式的里面去做不到的
[13:47.200 --> 13:49.200] 然后多行lambda呢
[13:49.200 --> 13:51.200] 就是说在里面函数的返回
[13:51.200 --> 13:57.200] 这个lambda的这个函数体它可以是一串语句
[13:57.200 --> 13:59.200] 也就是说跟普通的函数一样了
[13:59.200 --> 14:00.200] 对
[14:00.200 --> 14:02.200] 这一点为什么python不支持
[14:02.200 --> 14:07.200] 是因为完全是因为语法层面上是不容易实现的
[14:07.200 --> 14:08.200] 它的实现
[14:08.200 --> 14:09.200] 它的这种字节码
[14:09.200 --> 14:12.200] 比如说它的编译上是很简单的
[14:12.200 --> 14:14.200] 但是因为python是缩近的
[14:14.200 --> 14:15.200] 对吧
[14:15.200 --> 14:18.200] 当我们在写一个多行的表达式的时候
[14:18.200 --> 14:19.200] 你其实很难判断
[14:19.200 --> 14:20.200] 对吧
[14:20.200 --> 14:21.200] 你想一下这个
[14:21.200 --> 14:22.200] 是这样一个问题
[14:22.200 --> 14:23.200] 对
[14:23.200 --> 14:26.200] 这完全这是完全非技术的
[14:26.200 --> 14:30.200] 完全是一个设计的取舍的问题
[14:30.200 --> 14:31.200] 对
[14:31.200 --> 14:36.200] 然后我们就说一下这个自由变量和局部变量
[14:36.200 --> 14:37.200] 自由变量的话
[14:37.200 --> 14:40.200] 就是说这个函数
[14:40.200 --> 14:44.200] 它的函数体里面会引用到函数体外部的变量
[14:44.200 --> 14:50.200] 这个外部是包括了
[14:50.200 --> 14:51.200] 不包括它的参数
[14:51.200 --> 14:53.200] 就是参数是属于内部的变量
[14:53.200 --> 14:56.200] 然后这个叫自由变量
[14:56.200 --> 15:00.200] 也就是说自由变量其实就包括全局的和
[15:00.200 --> 15:02.200] 就是它的更外层的
[15:02.200 --> 15:08.200] 不管叫frame或者叫enclosing scope之类的
[15:08.200 --> 15:09.200] 对
[15:09.200 --> 15:11.200] 但是实际上在python里面
[15:11.200 --> 15:13.200] 虽然说全局变量也是
[15:13.200 --> 15:15.200] 理论上来说也是自由变量
[15:15.200 --> 15:17.200] 但实际上它在处理的时候
[15:17.200 --> 15:18.200] 是没有当作自由变量处理的
[15:18.200 --> 15:20.200] 因为全局变量全局都可以访问
[15:20.200 --> 15:23.200] 我不需要单独为它去分配空间
[15:23.200 --> 15:24.200] 所以它处理
[15:24.200 --> 15:26.200] 它在理论上是一个东西
[15:26.200 --> 15:30.200] 但实际操作上它会python会把全局和
[15:30.200 --> 15:32.200] 普通的线套函数的自由变量给分开
[15:32.200 --> 15:33.200] 对
[15:33.200 --> 15:34.200] 全局是通过字典直接查
[15:34.200 --> 15:36.200] 从全局有一个大的字典里面
[15:36.200 --> 15:37.200] 它从里面查
[15:37.200 --> 15:39.200] 然后自由变量的话
[15:39.200 --> 15:40.200] 它是放到
[15:40.200 --> 15:41.200] 它是类似于局部变量
[15:41.200 --> 15:44.200] 它会在函数创建的时候
[15:44.200 --> 15:46.200] 把这个东西塞到函数里面去
[15:46.200 --> 15:48.200] 然后当你去执行函数的时候
[15:48.200 --> 15:51.200] 它会从对应的位置去访问那个
[15:51.200 --> 15:55.200] 就像一个tuple
[15:55.200 --> 15:56.200] 你可以想
[15:56.200 --> 15:58.200] 一个函数里面
[15:58.200 --> 15:59.200] 它用了很多自由变量
[15:59.200 --> 16:02.200] 那它其实会在某个地方存一个tuple
[16:02.200 --> 16:03.200] 对
[16:03.200 --> 16:04.200] 这个其实比较细节
[16:04.200 --> 16:05.200] 如果听众们感兴趣的话
[16:05.200 --> 16:06.200] 可以看一下
[16:06.200 --> 16:07.200] 这段我之前也看过
[16:07.200 --> 16:08.200] 对
[16:08.200 --> 16:09.200] 这个其实在
[16:09.200 --> 16:10.200] 如果学数学的朋友
[16:10.200 --> 16:11.200] 可以看一下
[16:11.200 --> 16:13.200] 在命题逻辑里面
[16:13.200 --> 16:14.200] 其实也有这些东西
[16:14.200 --> 16:15.200] 对
[16:15.200 --> 16:16.200] 是一个意思
[16:16.200 --> 16:17.200] 完全是一个意思
[16:17.200 --> 16:18.200] 然后我们就说
[16:18.200 --> 16:19.200] 局部变量就是说
[16:19.200 --> 16:20.200] 就是局部变量
[16:20.200 --> 16:21.200] 就是局部定义的变量
[16:21.200 --> 16:22.200] 这就OK
[16:22.200 --> 16:23.200] 就是这个意思
[16:23.200 --> 16:24.200] 那什么叫局部呢
[16:24.200 --> 16:25.200] 就是这个局部
[16:25.200 --> 16:27.200] 其实我觉得这个名字
[16:27.200 --> 16:29.200] 还是挺有奇异的
[16:29.200 --> 16:30.200] 因为它这个
[16:30.200 --> 16:32.200] 因为确实
[16:32.200 --> 16:34.200] 因为局部本来就不是它的英文名
[16:34.200 --> 16:36.200] 它的英文名应该叫bond
[16:36.200 --> 16:37.200] 就是绑定的变量
[16:37.200 --> 16:38.200] 就是说
[16:38.200 --> 16:39.200] 对
[16:39.200 --> 16:40.200] 是在这边
[16:40.200 --> 16:42.200] 是在有界的
[16:42.200 --> 16:43.200] 有界的变量
[16:43.200 --> 16:44.200] 或者说
[16:44.200 --> 16:46.200] 它是函数定义的时候
[16:46.200 --> 16:49.200] 你如果把passing的函数的创建
[16:49.200 --> 16:50.200] 每一个
[16:50.200 --> 16:51.200] 当做一个边界
[16:51.200 --> 16:52.200] 对吧
[16:52.200 --> 16:53.200] 你创建个函数
[16:53.200 --> 16:54.200] 这个函数是一个边界
[16:54.200 --> 16:56.200] 它里面的那些东西
[16:56.200 --> 16:59.200] 就是在这一层里面
[16:59.200 --> 17:01.200] 这个有点麻烦
[17:01.200 --> 17:02.200] 就是说
[17:02.200 --> 17:03.200] 假如说你的函数
[17:03.200 --> 17:04.200] 不是现套函数的话
[17:04.200 --> 17:05.200] 那这里面全都是
[17:05.200 --> 17:07.200] 一个区域
[17:07.200 --> 17:10.200] 在这个区域里面
[17:10.200 --> 17:11.200] 新创建的变量
[17:11.200 --> 17:12.200] 叫做bond variable
[17:12.200 --> 17:14.200] 所以它总之就是有一个这种
[17:14.200 --> 17:17.200] 很明确的一个作用域
[17:17.200 --> 17:18.200] 对吧
[17:18.200 --> 17:19.200] 就是说你在这个作用域之外
[17:19.200 --> 17:20.200] 你就没有办法访问了
[17:20.200 --> 17:21.200] 那差不多就是
[17:21.200 --> 17:22.200] 对
[17:22.200 --> 17:23.200] 我们这边可以再提一句
[17:23.200 --> 17:24.200] 就很多人在hey python说
[17:24.200 --> 17:25.200] python是动态作用域
[17:25.200 --> 17:27.200] 这个话是纯粹乱说
[17:27.200 --> 17:30.200] python是非常严格的
[17:30.200 --> 17:31.200] 此法作用域
[17:31.200 --> 17:32.200] 它的所有作用域
[17:32.200 --> 17:33.200] 都是静态确定的
[17:33.200 --> 17:35.200] 这个很多人在乱说
[17:35.200 --> 17:37.200] 我觉得他们已经
[17:37.200 --> 17:38.200] 对吧
[17:38.200 --> 17:40.200] 我们这个就不评论
[17:40.200 --> 17:41.200] 对对对
[17:41.200 --> 17:42.200] 这个我们不扯远了
[17:42.200 --> 17:43.200] 好吧
[17:43.200 --> 17:44.200] 那然后你刚才说有两个优点
[17:44.200 --> 17:46.200] 然后第二个优点是什么
[17:46.200 --> 17:47.200] 第二个优点
[17:47.200 --> 17:48.200] 其实我们大家知道
[17:48.200 --> 17:49.200] 在python里面定义
[17:49.200 --> 17:51.200] 它的运算符的时候
[17:51.200 --> 17:54.200] 我们会写很多的下滑线
[17:54.200 --> 17:55.200] 对吧
[17:55.200 --> 17:56.200] 下滑线下滑线
[17:56.200 --> 17:58.200] 你说那个equal
[17:58.200 --> 18:00.200] 然后larger than之类的吗
[18:00.200 --> 18:01.200] 对
[18:01.200 --> 18:03.200] 然后它做什么事呢
[18:03.200 --> 18:06.200] 我想一下CI++的operator定义
[18:06.200 --> 18:07.200] 对吧
[18:07.200 --> 18:08.200] operator
[18:08.200 --> 18:09.200] 然后写它的那个符号名
[18:09.200 --> 18:11.200] 然后给它的参数
[18:11.200 --> 18:14.200] 然后这个木兰的作者
[18:14.200 --> 18:17.200] 他也在python里面做这件事
[18:17.200 --> 18:18.200] 就是等于说
[18:18.200 --> 18:22.200] 其实是完全非常travel的一个过程
[18:22.200 --> 18:23.200] 就是说你是
[18:23.200 --> 18:25.200] 我们现在写一个operator
[18:25.200 --> 18:26.200] 然后加
[18:26.200 --> 18:27.200] 然后括号
[18:27.200 --> 18:28.200] AB
[18:28.200 --> 18:29.200] 那么我就
[18:29.200 --> 18:30.200] 这个东西
[18:30.200 --> 18:32.200] 它的左边那个值是谁
[18:32.200 --> 18:33.200] 是哪个class
[18:33.200 --> 18:34.200] 它边标好是哪个class
[18:34.200 --> 18:36.200] 那我就把这个值给
[18:36.200 --> 18:37.200] 我就在这个class里面去set
[18:37.200 --> 18:39.200] 一个像它的add方法
[18:39.200 --> 18:43.200] 去定义operator和定义一个add
[18:43.200 --> 18:45.200] 你觉得就是
[18:45.200 --> 18:46.200] 这两个比方中有优劣之分吗
[18:46.200 --> 18:48.200] 还是说
[18:48.200 --> 18:50.200] 我觉得好处是在于
[18:50.200 --> 18:52.200] 你不需要知道这个
[18:52.200 --> 18:53.200] 魔法方法
[18:53.200 --> 18:55.200] 就是像写
[18:55.200 --> 18:56.200] 在里面写一个method
[18:56.200 --> 18:58.200] 需要写下滑线这种
[18:58.200 --> 18:58.200] 对吧
[18:58.200 --> 18:59.200] 它可能比较直观
[18:59.200 --> 19:01.200] 但实际上是很平凡的一个东西
[19:01.200 --> 19:03.200] 就说实话
[19:03.200 --> 19:05.200] 我个人觉得价值不大
[19:05.200 --> 19:07.200] 但也算它的
[19:07.200 --> 19:08.200] 它为数不多的优点吧
[19:08.200 --> 19:09.200] 对
[19:09.200 --> 19:11.200] 那它这个就是
[19:11.200 --> 19:13.200] 它这个operator overload的话
[19:13.200 --> 19:15.200] 就是那个的话
[19:15.200 --> 19:18.200] 它是只支持那几种基本的
[19:18.200 --> 19:21.200] 还是说它里面的数值操作符
[19:21.200 --> 19:23.200] 或还有位操作符
[19:23.200 --> 19:25.200] 它都支持这样的
[19:25.200 --> 19:27.200] 它应该是都写完了
[19:27.200 --> 19:28.200] 它写了很多
[19:28.200 --> 19:31.200] OK
[19:31.200 --> 19:32.200] 对
[19:32.200 --> 19:33.200] 如果没记错的话
[19:33.200 --> 19:35.200] 他说这个是那种
[19:35.200 --> 19:36.200] 一开始
[19:36.200 --> 19:37.200] 就是说他实际上
[19:37.200 --> 19:39.200] 不考虑他那些虚假宣传
[19:39.200 --> 19:40.200] 他这个是比较
[19:40.200 --> 19:43.200] 支持那种教学方面的语言
[19:43.200 --> 19:43.200] 对吧
[19:43.200 --> 19:44.200] 好像是这么说
[19:44.200 --> 19:45.200] 对
[19:45.200 --> 19:46.200] 我觉得其实也没
[19:46.200 --> 19:47.200] 他说教学语言
[19:47.200 --> 19:49.200] 教学语言这个东西本身没问题
[19:49.200 --> 19:54.200] 因为确实也有简化一些
[19:54.200 --> 19:56.200] 确实也有简化一些东西
[19:56.200 --> 20:00.200] 但你真的要拿出来
[20:00.200 --> 20:01.200] 把后面
[20:01.200 --> 20:02.200] 他不是宣传有三条吗
[20:02.200 --> 20:03.200] 后面什么物联网什么的
[20:03.200 --> 20:04.200] 对
[20:04.200 --> 20:06.200] 虚假宣传的就是这个部分
[20:06.200 --> 20:07.200] 这部分是虚假
[20:07.200 --> 20:08.200] 我感觉特搞笑
[20:08.200 --> 20:09.200] 但本身就是
[20:09.200 --> 20:11.200] 即使他不做虚假宣传
[20:11.200 --> 20:13.200] 我觉得这个技术也很难
[20:13.200 --> 20:15.200] 你很难去把它
[20:15.200 --> 20:17.200] 说是什么国家的创新
[20:17.200 --> 20:19.200] 因为这个确实还是有点掉价
[20:19.200 --> 20:21.200] 这个没有什么说的
[20:21.200 --> 20:23.200] 包括他用的技术也是相当落后的
[20:23.200 --> 20:24.200] 他在用
[20:24.200 --> 20:27.200] 他写了1400多行POY
[20:27.200 --> 20:30.200] 这个其实有点问题
[20:30.200 --> 20:33.200] 其实我想就是说
[20:33.200 --> 20:36.200] 可能你需要去给听众们
[20:36.200 --> 20:37.200] 包括我们一个
[20:37.200 --> 20:38.200] 就是这种宏观的概念
[20:38.200 --> 20:43.200] 就是说木兰他到底是和Python的关系是什么
[20:43.200 --> 20:47.200] 或者说他是怎么被最后transform成Python的代码来执行的
[20:47.200 --> 20:50.200] 我们先把这个流程来梳理一下
[20:50.200 --> 20:52.200] 就给观众一个概念
[20:52.200 --> 20:55.200] 要说他和Python的关系的话
[20:55.200 --> 20:57.200] 首先不是换皮Python
[20:57.200 --> 20:58.200] 因为多了新的语言特性
[20:58.200 --> 21:00.200] 确实有自己的东西
[21:00.200 --> 21:03.200] 但是为什么大家会有人提出这样观点
[21:03.200 --> 21:06.200] 也不是空穴来风的
[21:06.200 --> 21:09.200] 因为他是编译到Python的AST
[21:09.200 --> 21:10.200] 不是他是Path
[21:10.200 --> 21:11.200] 说错了不好意思可恶
[21:11.200 --> 21:13.200] 他Path到Python的AST
[21:13.200 --> 21:15.200] 这个其实怎么说呢
[21:15.200 --> 21:17.200] 我做了个实验
[21:17.200 --> 21:20.200] 因为大家可能主要是知道
[21:20.200 --> 21:22.200] 就是我做了个实验
[21:22.200 --> 21:24.200] 我用了三个小时零二十八分钟
[21:24.200 --> 21:27.200] 实现一个和他的语言特性等价的
[21:27.200 --> 21:28.200] 可能还多了一些的
[21:28.200 --> 21:30.200] 我不想说明什么问题
[21:30.200 --> 21:34.200] 我想说这种Path到Python的AST的做法
[21:34.200 --> 21:37.200] 其实是相对来说是比较简单的
[21:37.200 --> 21:40.200] 而且在这之前其实有很多人做过
[21:40.200 --> 21:43.200] 大家如果可以查一下Python有些
[21:43.200 --> 21:46.200] 就是SQL的DSL
[21:46.200 --> 21:47.200] 就是说你写Python代码
[21:47.200 --> 21:49.200] 然后编译成SQL语句这种
[21:49.200 --> 21:51.200] 这种东西是存在的
[21:51.200 --> 21:53.200] 他们也是这样做的
[21:53.200 --> 21:57.200] 然后还有就是说这个HY语言
[21:57.200 --> 21:59.200] 就是Python中的一个Lisp的方言
[21:59.200 --> 22:01.200] 他们也是编译到
[22:01.200 --> 22:03.200] 他们也是先
[22:03.200 --> 22:05.200] 对他们Path是完全不一样的
[22:05.200 --> 22:08.200] 但是他们会最后编译到Python的AST
[22:08.200 --> 22:11.200] 然后再去编译成这个Code Object
[22:11.200 --> 22:13.200] 但是他们里面会有新东西
[22:13.200 --> 22:16.200] 就是他们会支持Lisp中的语言特性
[22:16.200 --> 22:18.200] Python只是作为一个普通的后端而已
[22:18.200 --> 22:22.200] 就和他们这个编译到AST和生成Python的代码
[22:22.200 --> 22:23.200] 是没有什么差别的
[22:23.200 --> 22:25.200] 这个我们会认为他说
[22:25.200 --> 22:27.200] 我们会认为他有自己的东西
[22:27.200 --> 22:28.200] 因为他不是说他的
[22:28.200 --> 22:30.200] 他有自己的分析步骤
[22:30.200 --> 22:32.200] 有自己的分析的过程
[22:32.200 --> 22:34.200] 但是木兰是没有的
[22:34.200 --> 22:35.200] 木兰就是
[22:35.200 --> 22:37.200] 木兰也不能说没有对吧
[22:37.200 --> 22:39.200] 有一个Lambda的这个Numbering
[22:39.200 --> 22:43.200] 那我其实我想问一个东西
[22:43.200 --> 22:46.200] 就是说是就刚才你说是木兰
[22:46.200 --> 22:48.200] 如果说是要说你因为我刚红记
[22:48.200 --> 22:51.200] 你说是要说木兰是一个套皮的Python
[22:51.200 --> 22:54.200] 这个是有一点就是说是不太OK的
[22:54.200 --> 22:56.200] 那么我其实想问一下
[22:56.200 --> 22:59.200] 在你们学界怎么样去判断一个语言
[22:59.200 --> 23:01.200] 是否是套皮的另外一门语言的
[23:01.200 --> 23:05.200] 这样一个这样一个Value的标准是什么
[23:05.200 --> 23:07.200] 首先我想说这个标准
[23:07.200 --> 23:09.200] 我没有听到过
[23:09.200 --> 23:12.200] 这个因为大家也没讨论这个事情
[23:12.200 --> 23:13.200] 所谓套皮这个事情
[23:13.200 --> 23:15.200] 而且应该很少见的
[23:15.200 --> 23:18.200] 所以并没有什么说标准的定义
[23:18.200 --> 23:20.200] 但是这是作为
[23:20.200 --> 23:22.200] 就是说你有相当一部分经验
[23:22.200 --> 23:24.200] 你确实有看过很多文章
[23:24.200 --> 23:25.200] 有了解一些背景知识
[23:25.200 --> 23:26.200] 你会觉得
[23:26.200 --> 23:28.200] 就是说什么样的工作
[23:28.200 --> 23:31.200] 它是相对来说接近抄袭
[23:31.200 --> 23:32.200] 什么样的工作
[23:32.200 --> 23:34.200] 它相对来说接近创新
[23:34.200 --> 23:35.200] 这里面什么
[23:35.200 --> 23:37.200] 怎么样去判断有没有自己的东西
[23:37.200 --> 23:38.200] 对吧
[23:38.200 --> 23:40.200] 如果说你只有一个Parser
[23:40.200 --> 23:42.200] 你里面是没有说
[23:42.200 --> 23:44.200] 你的程序没有经过
[23:44.200 --> 23:46.200] 千里冰封有句话说得很好
[23:46.200 --> 23:48.200] 经过非凡的变化
[23:48.200 --> 23:49.200] 就是说对对
[23:49.200 --> 23:50.200] 这句话是
[23:50.200 --> 23:52.200] 这句话说起来很很很很中二
[23:52.200 --> 23:54.200] 但是它确实揭示了某种本质
[23:54.200 --> 23:57.200] 就是说你的你的程序里的变换
[23:57.200 --> 24:00.200] 这个本身它不是简单的一一映射
[24:00.200 --> 24:02.200] 他不是说我看到这个东西
[24:02.200 --> 24:05.200] 然后我可以直接说
[24:05.200 --> 24:06.200] 这这部分是这一部分
[24:06.200 --> 24:08.200] 这部分是这一部分连线连起来
[24:08.200 --> 24:10.200] OK这样做
[24:10.200 --> 24:12.200] 我不能简单的这样做
[24:12.200 --> 24:13.200] 而是说我这样连线
[24:13.200 --> 24:16.200] 它里面会经过某种会附带着某种
[24:16.200 --> 24:18.200] 可能说是状态的变化
[24:18.200 --> 24:22.200] 会不同的地方会有看似相同的地方
[24:22.200 --> 24:24.200] 可能会在不同的出现的位置
[24:24.200 --> 24:26.200] 产生不同的效果
[24:26.200 --> 24:30.200] 不知道这个话可能有点有点vague
[24:30.200 --> 24:33.200] 或者说这个其实是从
[24:33.200 --> 24:37.200] 难度这个角度给的一种标准
[24:37.200 --> 24:41.200] 还是或者这个难度是一方面
[24:41.200 --> 24:44.200] 但是你是否就是有自己的东西
[24:44.200 --> 24:45.200] 这是另一方面
[24:45.200 --> 24:47.200] 假如说我说他
[24:47.200 --> 24:51.200] 像我们说他这个多哈拉姆达这个东西做了一个
[24:51.200 --> 24:52.200] 然后他又很简单
[24:52.200 --> 24:54.200] 所以我们觉得他不够好
[24:54.200 --> 24:57.200] 但如果说他像这样一个多哈拉姆达东西
[24:57.200 --> 24:58.200] 虽然就算很简单
[24:58.200 --> 24:59.200] 他做了100个
[24:59.200 --> 25:01.200] 那会觉得你这个可以
[25:01.200 --> 25:02.200] 这个东西好像还还行
[25:02.200 --> 25:04.200] 你要是有那么一个东西
[25:04.200 --> 25:07.200] 他真的是这个人
[25:07.200 --> 25:08.200] 别人之前没有想到的
[25:08.200 --> 25:09.200] 没没人做过的
[25:09.200 --> 25:11.200] 那会觉得你这个东西
[25:11.200 --> 25:12.200] 对吧
[25:12.200 --> 25:13.200] 说不定还能发文章
[25:13.200 --> 25:14.200] 对吧
[25:14.200 --> 25:17.200] 这是我觉得这是很很自然的一个见解
[25:17.200 --> 25:18.200] 你觉得呢
[25:18.200 --> 25:21.200] 我理解就是说难度
[25:21.200 --> 25:24.200] 然后以及工作量上来来做一个这种评判
[25:24.200 --> 25:26.200] 其实也没有一个统一的标准
[25:26.200 --> 25:27.200] 还有一个就是feature
[25:27.200 --> 25:28.200] 就是feature
[25:28.200 --> 25:30.200] 特性上来评估对吧
[25:30.200 --> 25:33.200] 对对这也是很重要的
[25:33.200 --> 25:35.200] 其实我觉得
[25:35.200 --> 25:37.200] 就是可能我们
[25:37.200 --> 25:39.200] 有时候聊的时候就会陷入一些细节
[25:39.200 --> 25:43.200] 但是但是就比如说可能
[25:43.200 --> 25:46.200] 像如果我是一个就是我是一个
[25:46.200 --> 25:47.200] 我是一个外行
[25:47.200 --> 25:50.200] 或者说我是一个就是编程的初学者
[25:50.200 --> 25:53.200] 我应该去怎么理解
[25:53.200 --> 25:57.200] 就是说木兰变变成python
[25:57.200 --> 25:59.200] 最后执行的这样一个过程
[25:59.200 --> 26:00.200] 或者说比如说
[26:00.200 --> 26:02.200] 比如说他的path是
[26:02.200 --> 26:04.200] 他这个本身是怎么pass
[26:04.200 --> 26:06.200] 就是说他用来执行
[26:06.200 --> 26:09.200] 就是passer他到底是用python写的呢
[26:09.200 --> 26:11.200] 还是说是用什么语言写的
[26:11.200 --> 26:15.200] 然后最后他是就是他的这个ast是
[26:15.200 --> 26:17.200] 最后变成了一个什么形式
[26:17.200 --> 26:20.200] 然后他有没有是直接变成字节码的
[26:20.200 --> 26:22.200] 还是说他会就是生成code呢
[26:22.200 --> 26:25.200] 这个我们觉得可以就讲得更细致一点
[26:25.200 --> 26:27.200] 对这个要讲得细致一点
[26:27.200 --> 26:28.200] 没问题啊
[26:28.200 --> 26:31.200] 这个我们可以先说一下python是怎么的
[26:31.200 --> 26:32.200] python的话
[26:32.200 --> 26:34.200] 它的编译器是c写的
[26:34.200 --> 26:37.200] 然后他是接受这个源代码
[26:37.200 --> 26:40.200] 然后pass成这个python的ast
[26:40.200 --> 26:41.200] 然后python的ast的话
[26:41.200 --> 26:42.200] 是在python标准库中
[26:42.200 --> 26:44.200] 是有给出的数据结构
[26:44.200 --> 26:45.200] 它是一些数据结构
[26:45.200 --> 26:48.200] 然后这个ast经过python的compile函数
[26:48.200 --> 26:50.200] 也是个类似的东西
[26:50.200 --> 26:51.200] 然后给一些flag
[26:51.200 --> 26:53.200] 然后可以变成一个字节码
[26:53.200 --> 26:55.200] 这个字节码就是我们
[26:55.200 --> 26:57.200] 他一个python文件
[26:57.200 --> 26:59.200] 会形成一个大的字节码
[26:59.200 --> 27:01.200] 这个是模块的字节码
[27:01.200 --> 27:03.200] 然后执行它就等于执行这个模块
[27:03.200 --> 27:05.200] 那我们再说木兰是什么样的呢
[27:05.200 --> 27:10.200] 木兰用ply在python里面写了一个passer
[27:10.200 --> 27:11.200] 然后这个passer
[27:11.200 --> 27:14.200] 他把astpass成python的ast
[27:14.200 --> 27:16.200] 然后中间做了两个变换
[27:16.200 --> 27:20.200] 一个是这个多好lambda
[27:20.200 --> 27:22.200] 一个是这个operator的重载
[27:22.200 --> 27:24.200] 这两个变换
[27:24.200 --> 27:27.200] 然后变成跟python一模一样的ast
[27:27.200 --> 27:30.200] 那他这个ast其实也是在他的
[27:30.200 --> 27:32.200] 就像他起了一个python进程
[27:32.200 --> 27:35.200] 然后有一些木兰的语言的
[27:35.200 --> 27:39.200] 就是pythonast的object
[27:39.200 --> 27:44.200] 他代表的是那段原来的木兰的代码
[27:44.200 --> 27:45.200] 是这个意思吗
[27:45.200 --> 27:46.200] 对是这个意思
[27:46.200 --> 27:48.200] 然后他拿了这个ast跟python一样的
[27:48.200 --> 27:51.200] 送进这个compile函数
[27:51.200 --> 27:53.200] python内置的compile函数
[27:53.200 --> 27:55.200] 然后直接执行
[27:55.200 --> 27:56.200] 他其实还
[27:56.200 --> 27:57.200] 其实如果我是他的话
[27:57.200 --> 27:59.200] 我可能会生成一个
[27:59.200 --> 28:01.200] 就跟python一样的pyc文件吧
[28:01.200 --> 28:02.200] 因为这样的话
[28:02.200 --> 28:04.200] 和python互调用就很好
[28:04.200 --> 28:05.200] 他没有做这件事
[28:05.200 --> 28:07.200] 他是直接执行的code object
[28:07.200 --> 28:09.200] 其实我人都看傻了
[28:09.200 --> 28:11.200] 这点因为他可以免费的
[28:11.200 --> 28:13.200] 获得和python完全
[28:13.200 --> 28:15.200] 无二的这种交互能力
[28:15.200 --> 28:18.200] 但他就在那里直接把他执行的
[28:18.200 --> 28:21.200] 这会导致两个问题
[28:21.200 --> 28:22.200] 第一个问题是
[28:22.200 --> 28:23.200] 没法和python互调用
[28:23.200 --> 28:24.200] 第二个问题是
[28:24.200 --> 28:26.200] 没法简单和python互调用
[28:26.200 --> 28:27.200] 第二个问题是
[28:27.200 --> 28:30.200] 他每次执行一个源码
[28:30.200 --> 28:32.200] 他都需要去编译它
[28:32.200 --> 28:34.200] 但编译完又直接执行的
[28:34.200 --> 28:35.200] 就没有一个catch过程
[28:35.200 --> 28:37.200] 也就是说他如果代码量很大的话
[28:37.200 --> 28:39.200] 他不停的重新执行
[28:39.200 --> 28:41.200] 重新pass重新执行
[28:41.200 --> 28:42.200] 他等于说
[28:42.200 --> 28:44.200] 很多时间会浪费在这个pass上
[28:44.200 --> 28:46.200] 当然我们也不讨论
[28:46.200 --> 28:48.200] 因为他这个东西不可能使用的
[28:48.200 --> 28:50.200] 他里面他写东西都很不如办
[28:50.200 --> 28:51.200] 我不知道你们有没有看过
[28:51.200 --> 28:52.200] 就是他的
[28:52.200 --> 28:55.200] 就是说木兰官方提供的编程环境
[28:55.200 --> 28:56.200] 到底是怎么样
[28:56.200 --> 28:57.200] 因为他那个
[28:57.200 --> 28:59.200] 就是文件是一个exe
[28:59.200 --> 29:01.200] 然后我在Mac上没有办法执行
[29:01.200 --> 29:03.200] 就是说比如说你下下来
[29:03.200 --> 29:05.200] 然后执行之后是个什么样子
[29:05.200 --> 29:09.200] 他那个我这边看到是一个是一个repel
[29:09.200 --> 29:12.200] 然后就是双击一个是一个repel
[29:12.200 --> 29:13.200] 然后的话你在里面
[29:13.200 --> 29:15.200] 就是跟python的repel类似的
[29:15.200 --> 29:18.200] 然后后面大家有那个打包
[29:18.200 --> 29:19.200] 有解包的把它解出来
[29:19.200 --> 29:23.200] 其实就是个那个pyinstaller
[29:23.200 --> 29:25.200] 那个installer的打包的文件
[29:25.200 --> 29:26.200] 然后对他就是
[29:26.200 --> 29:27.200] 其实就相当于是
[29:27.200 --> 29:29.200] 把一个完整的python虚拟机
[29:29.200 --> 29:31.200] 加上其他的依赖库给打包进去了
[29:31.200 --> 29:34.200] 他没有办法就是说我写一个文件
[29:34.200 --> 29:37.200] 比如说叫test.mulan
[29:37.200 --> 29:39.200] 然后用这个binary来执行
[29:39.200 --> 29:41.200] 这个他难道不支持吗
[29:41.200 --> 29:42.200] 这个我还真没试过
[29:42.200 --> 29:44.200] 他可以他支持
[29:44.200 --> 29:45.200] 他是支持没问题
[29:45.200 --> 29:49.200] 但是支持虽然支持
[29:49.200 --> 29:52.200] 我刚才说了两个问题
[29:52.200 --> 29:54.200] 第一个是不停的pass
[29:54.200 --> 29:55.200] 没法catch
[29:55.200 --> 29:57.200] 第二个是没法和python互调用
[29:57.200 --> 29:59.200] 第三个我还想再加一点
[29:59.200 --> 30:01.200] 因为他本身是python项目
[30:01.200 --> 30:03.200] 他就是installer进去
[30:03.200 --> 30:04.200] 你其实可以执行的
[30:04.200 --> 30:05.200] 你python可以执行的
[30:05.200 --> 30:06.200] 你去查一下网上
[30:06.200 --> 30:08.200] 他们有那个立项的语言码
[30:08.200 --> 30:10.200] 然后下下来就可以执行的
[30:10.200 --> 30:13.200] 那他自己比如说这个
[30:13.200 --> 30:15.200] 木兰的我就说我用木兰做一个项目
[30:15.200 --> 30:16.200] 然后我能一个文件里
[30:16.200 --> 30:18.200] 能import另外一个文件吗
[30:18.200 --> 30:21.200] 就是他这套他也就是
[30:21.200 --> 30:22.200] 他有做是吧
[30:22.200 --> 30:23.200] 他是直接用的python吗
[30:23.200 --> 30:25.200] 还是怎么样
[30:25.200 --> 30:26.200] 这个其实我没看
[30:26.200 --> 30:28.200] 但是我们马上可以看一下
[30:28.200 --> 30:30.200] 让我马上看一下
[30:30.200 --> 30:32.200] 其实我有个问题
[30:32.200 --> 30:35.200] 就是就比如说像是cpython这种
[30:35.200 --> 30:37.200] 这种就是说是就是python的
[30:37.200 --> 30:38.200] 那个最主要的
[30:38.200 --> 30:40.200] 那个最主要的一个版本吧
[30:40.200 --> 30:42.200] 然后就是cpython的话
[30:42.200 --> 30:44.200] 他是提供了capi和就是
[30:44.200 --> 30:46.200] 是他基准的c
[30:46.200 --> 30:48.200] 或者说其他语言交互的一个能力
[30:48.200 --> 30:49.200] 像木兰的话
[30:49.200 --> 30:50.200] 就像你刚才说的
[30:50.200 --> 30:52.200] 他有没有提供的
[30:52.200 --> 30:54.200] 比如说叫做python API
[30:54.200 --> 30:57.200] 来提供和python这一套交互的能力
[30:57.200 --> 30:58.200] 我刚刚看了
[30:58.200 --> 31:00.200] 他就是完全是python
[31:00.200 --> 31:01.200] 他import
[31:01.200 --> 31:03.200] 对对import
[31:03.200 --> 31:04.200] 跟OK
[31:04.200 --> 31:05.200] 全都可以调用python的
[31:05.200 --> 31:07.200] 但是是否能调木兰自己的
[31:07.200 --> 31:08.200] 这个import
[31:08.200 --> 31:09.200] 就是木兰自己扩自己
[31:09.200 --> 31:10.200] 我还不太清楚
[31:10.200 --> 31:12.200] 但是扩python是没有问题的
[31:12.200 --> 31:14.200] 也就是说直接是import就可以了
[31:14.200 --> 31:15.200] 对吧
[31:15.200 --> 31:16.200] 对对
[31:16.200 --> 31:17.200] 那我这里对
[31:17.200 --> 31:18.200] 那我这里有个问题
[31:18.200 --> 31:19.200] python的语言
[31:19.200 --> 31:22.200] 其实和那个和木兰
[31:22.200 --> 31:24.200] 他们的语就是语法上面是具体上
[31:24.200 --> 31:26.200] 还是有细微的差别的话
[31:26.200 --> 31:28.200] 如果说我直接在木兰里面去import
[31:28.200 --> 31:29.200] 掉python的话
[31:29.200 --> 31:32.200] 那这样会会有其他问题吗
[31:32.200 --> 31:34.200] 这个不会有问题啊
[31:34.200 --> 31:35.200] 其实他本身
[31:35.200 --> 31:38.200] 他并没有什么不得了的差别
[31:38.200 --> 31:40.200] 你想一下这个
[31:40.200 --> 31:41.200] 他其实就是说
[31:41.200 --> 31:43.200] 有个评价
[31:43.200 --> 31:46.200] 就是说他把换行变成打过号
[31:46.200 --> 31:48.200] 这个不能说全是这样
[31:48.200 --> 31:52.200] 但是语法上主要差别可能的确如此
[31:52.200 --> 31:54.200] 那我其实还是
[31:54.200 --> 31:56.200] 就比如说你说是木兰
[31:56.200 --> 31:58.200] 是他其实是直接importpython的
[31:58.200 --> 31:59.200] 对吧
[31:59.200 --> 32:00.200] 那比如说我在木兰
[32:00.200 --> 32:01.200] 就比如说我在repo里面
[32:01.200 --> 32:02.200] 他支持多行的lambda
[32:02.200 --> 32:04.200] 我import了一个python
[32:04.200 --> 32:06.200] 然后比如说是map这种
[32:06.200 --> 32:07.200] 然后他只是一个单行的
[32:07.200 --> 32:08.200] 然后我传了一个map
[32:08.200 --> 32:09.200] 到一个多行的lambda
[32:09.200 --> 32:11.200] 到map里面去
[32:11.200 --> 32:14.200] 这个时候他会出现问题吗
[32:14.200 --> 32:15.200] 不会出现问题
[32:15.200 --> 32:16.200] 刚才你们
[32:16.200 --> 32:17.200] 刚才我已经解释了
[32:17.200 --> 32:18.200] 他的多行lambda
[32:18.200 --> 32:20.200] 其实本身他会变成函数
[32:20.200 --> 32:21.200] 他会在编译的时候
[32:21.200 --> 32:22.200] lambda过去
[32:22.200 --> 32:25.200] 把正常的一个lambda变
[32:25.200 --> 32:28.200] 把一个多行lambda变成一个正常的函数
[32:28.200 --> 32:30.200] 然后再使用lambda的位置
[32:30.200 --> 32:32.200] 把那个函数名字传过来
[32:32.200 --> 32:33.200] ok
[32:33.200 --> 32:34.200] 也就是说其实如果说
[32:34.200 --> 32:36.200] 是他import了python的core
[32:36.200 --> 32:38.200] 然后的话在中间这个时候
[32:38.200 --> 32:39.200] 还是会有一个code transform
[32:39.200 --> 32:40.200] 对吧
[32:40.200 --> 32:43.200] 不会他已经
[32:43.200 --> 32:46.200] 等一下你说的是python掉木兰是吧
[32:46.200 --> 32:47.200] 不是木兰掉python
[32:47.200 --> 32:50.200] 那他import过来的话
[32:50.200 --> 32:51.200] 不会他是import过来的话
[32:51.200 --> 32:53.200] 他这个是纯运行时的
[32:53.200 --> 32:55.200] 你是不用考虑这个事情的
[32:55.200 --> 32:56.200] 你想一下
[32:56.200 --> 32:57.200] 对你是纯运行时
[32:57.200 --> 32:59.200] 对你的对象就是对吧
[32:59.200 --> 33:00.200] 因为他们的实行环境
[33:00.200 --> 33:02.200] 都是python的这个解释环境
[33:02.200 --> 33:04.200] 他编译器的话
[33:04.200 --> 33:05.200] 只是说把自己
[33:05.200 --> 33:07.200] 自己这个源码文件里面处理了
[33:07.200 --> 33:09.200] 他那边过来的函数对象
[33:09.200 --> 33:11.200] 还是普通的python函数对象
[33:11.200 --> 33:13.200] 木兰自己运行时的
[33:13.200 --> 33:14.200] 他自己的函数
[33:14.200 --> 33:15.200] 他在运行时也是普通的函数
[33:15.200 --> 33:16.200] python函数
[33:16.200 --> 33:18.200] OK我明白了
[33:18.200 --> 33:20.200] 对反正他就是一个
[33:20.200 --> 33:22.200] 就是个源文件是吧
[33:22.200 --> 33:24.200] 然后你把它去pass一下
[33:24.200 --> 33:25.200] 然后就变成python了
[33:25.200 --> 33:27.200] 对其实你可以想一下
[33:27.200 --> 33:29.200] 对吧因为我做的实验也是这样
[33:29.200 --> 33:32.200] 就是完全看起来和python不大像的一个语言
[33:32.200 --> 33:35.200] 其实他本身还是编译到完全一样的python LST
[33:35.200 --> 33:37.200] 你就可以平凡对应他们
[33:37.200 --> 33:38.200] 看一下好像不一样
[33:38.200 --> 33:40.200] 只是一个心理作用
[33:40.200 --> 33:41.200] 对吧
[33:41.200 --> 33:43.200] 能写一个多哈拉木达
[33:43.200 --> 33:45.200] 能写个快语之余
[33:45.200 --> 33:46.200] 其实只是个心理作用
[33:46.200 --> 33:47.200] 因为他本身
[33:47.200 --> 33:48.200] 因为大家都图灵完备
[33:48.200 --> 33:50.200] 对吧我只要做一些比较简单的transform
[33:50.200 --> 33:52.200] 一样可以让他们一一对应起来
[33:52.200 --> 33:53.200] 对
[33:53.200 --> 33:56.200] 感觉如果他做一个这种python matching的话
[33:56.200 --> 33:58.200] 你对这个语言的评价就会很高
[33:58.200 --> 34:00.200] 不会不会并不会
[34:00.200 --> 34:02.200] 相信我因为第一点是
[34:02.200 --> 34:04.200] 我现在对python matching的品位比较高
[34:04.200 --> 34:06.200] 我现在是基于12年那篇
[34:06.200 --> 34:08.199] Reckitt的文文
[34:08.199 --> 34:11.199] 我必须要实现可扩展的python matching
[34:11.199 --> 34:13.199] 不然的话我会认为他是纳西
[34:13.199 --> 34:14.199] 好吧
[34:14.199 --> 34:16.199] 还有就是性能确实有问题
[34:16.199 --> 34:18.199] 现在的话python matching
[34:18.199 --> 34:20.199] 我想多说一句啊
[34:20.199 --> 34:23.199] python的虚拟机是支持很快速的python matching的
[34:23.199 --> 34:26.199] 这个事情是Bluetooth跟我讲的
[34:26.199 --> 34:29.199] 是python的虚拟机上是有这个
[34:29.199 --> 34:30.199] 间接跳转的一个功能的
[34:30.199 --> 34:32.199] 就是说根据一个值
[34:32.199 --> 34:34.199] 跳到对应的这个label
[34:34.199 --> 34:35.199] 和c一模一样对吧
[34:35.199 --> 34:37.199] c的话可能不支持这个
[34:37.199 --> 34:40.199] 它是一个叫label as value的一个优化
[34:40.199 --> 34:42.199] python算是现在在3.6以后
[34:42.199 --> 34:44.199] 至少在3.6以后是支持的
[34:44.199 --> 34:46.199] 所以说如果没有人用这个实现python matching
[34:46.199 --> 34:48.199] 这个就是switch
[34:48.199 --> 34:49.199] 这个是真正的switch
[34:49.199 --> 34:51.199] 如果大家不用这个实现python matching
[34:51.199 --> 34:53.199] 那我会觉得不行
[34:53.199 --> 34:54.199] 对
[34:54.199 --> 34:59.200] 那看来还是就是感觉就是怎么说
[34:59.200 --> 35:02.200] 研究编程语言的人肯定还是会对这种
[35:02.200 --> 35:05.200] 就是一个语言的要
[35:05.200 --> 35:08.200] 就有一定的要求或者说品位吧
[35:08.200 --> 35:10.200] 对
[35:10.200 --> 35:12.200] 也不一定
[35:12.200 --> 35:15.200] 我其实想插一个题外话
[35:15.200 --> 35:18.200] 就是说其实我其实我很好奇
[35:18.200 --> 35:20.200] 就像你们就是说研究编程语言的人
[35:20.200 --> 35:22.200] 具体就是说平时的日常
[35:22.200 --> 35:24.200] 或者就是说是主要研究的方向
[35:24.200 --> 35:25.200] 具体会是什么样的东西
[35:25.200 --> 35:28.200] 因为其实大家我觉得编程语言这门
[35:28.200 --> 35:29.200] 就是说是分支的话
[35:29.200 --> 35:32.200] 对于大家来说都是看起来有点太遥远了
[35:32.200 --> 35:34.200] 而且有点很神秘的感觉
[35:34.200 --> 35:37.200] 这个事情啊
[35:37.200 --> 35:40.200] 其实我们倒有挺多讲的
[35:40.200 --> 35:42.200] 因为我现在也天天在实验室浪嘛
[35:42.200 --> 35:45.200] 这个大概是什么个情况呢
[35:45.200 --> 35:49.200] 因为我大家大概早上八点来
[35:49.200 --> 35:52.200] 下午三四点就走吧
[35:52.200 --> 35:54.200] 首先比较自由
[35:54.200 --> 35:55.200] 然后呢
[35:55.200 --> 35:57.200] 感论文的时候会比较急
[35:57.200 --> 36:00.200] 这个跟大家普通的其他学科也一样
[36:00.200 --> 36:01.200] 然后但是我们每天讨论问题
[36:01.200 --> 36:03.200] 可能会稍微有点差别
[36:03.200 --> 36:06.200] 比方说因为我们其实也是很关注使用的
[36:06.200 --> 36:09.200] 比方说我跟我的学长
[36:09.200 --> 36:11.200] 我们会讨论的问题是什么呢
[36:11.200 --> 36:13.200] 是我们做一个Gal game
[36:13.200 --> 36:15.200] 这个话可能
[36:15.200 --> 36:16.200] 反正就是做一个游戏嘛
[36:16.200 --> 36:19.200] 然后这个游戏它怎么让开发者能够
[36:19.200 --> 36:20.200] 用更少的
[36:20.200 --> 36:24.200] 学习更少的知识去开发一个更完整的游戏
[36:24.200 --> 36:25.200] 就是说它不需要
[36:25.200 --> 36:27.200] 它需要更少的学习
[36:27.200 --> 36:28.200] 但是这个语言本身能够给他
[36:28.200 --> 36:30.200] 就是他在使用的时候能够
[36:30.200 --> 36:32.200] 能够有个类似交互的功能
[36:32.200 --> 36:33.200] 就是说你这样写
[36:33.200 --> 36:34.200] 编译会告诉你
[36:34.200 --> 36:35.200] 这样写不对
[36:35.200 --> 36:36.200] 对
[36:36.200 --> 36:37.200] 就是他会慢慢的提
[36:37.200 --> 36:39.200] 把这些东西通过编译器的hint
[36:39.200 --> 36:40.200] 慢慢的告诉你
[36:40.200 --> 36:42.200] 并且这个语言特性
[36:42.200 --> 36:45.200] 在这个语言里面去encode的
[36:45.200 --> 36:47.200] 这个写游戏它需要的要素
[36:47.200 --> 36:48.200] 比方说我们有一个语句说
[36:48.200 --> 36:50.200] 叫创建角色
[36:50.200 --> 36:53.200] 有个语句叫这个创建场景
[36:53.200 --> 36:55.200] 有个语句叫创建音效
[36:55.200 --> 36:58.200] 他会把这些东西给编码在语言里面
[36:58.200 --> 36:59.200] 然后我跟学长在研究
[36:59.200 --> 37:01.200] 这个东西可以做
[37:01.200 --> 37:02.200] 然后还有就是
[37:02.200 --> 37:03.200] 还有意思
[37:03.200 --> 37:05.200] 比方说我们另一个学长
[37:05.200 --> 37:07.200] 他喜欢听歌
[37:07.200 --> 37:09.200] 然后他们那个音乐圈子里面
[37:09.200 --> 37:12.200] 有人做了一门外语
[37:12.200 --> 37:13.200] 也不说外语吧
[37:13.200 --> 37:15.200] 就是他们喜欢用那个
[37:15.200 --> 37:17.200] 自己造语言去写歌词
[37:17.200 --> 37:18.200] 然后学长说
[37:18.200 --> 37:19.200] 我想把这个做成编成语言
[37:19.200 --> 37:20.200] 然后他说
[37:20.200 --> 37:23.200] 我听你前天写了一个编译到python的IR
[37:23.200 --> 37:24.200] 我能不能上一下
[37:24.200 --> 37:25.200] 就是这种
[37:25.200 --> 37:26.200] 平时是这样
[37:26.200 --> 37:27.200] 对
[37:27.200 --> 37:29.200] 就是造语言就是日常
[37:29.200 --> 37:30.200] 对
[37:30.200 --> 37:31.200] 但当然也不是
[37:31.200 --> 37:32.200] 造的也不那么频繁
[37:32.200 --> 37:34.200] 就是更多是这种方言
[37:34.200 --> 37:35.200] 就是在一个语言里面
[37:35.200 --> 37:37.200] 看起来像另一门语言的一种方言
[37:37.200 --> 37:38.200] 叫DSL
[37:38.200 --> 37:39.200] 就是EDSL
[37:39.200 --> 37:41.200] 就嵌入
[37:41.200 --> 37:42.200] 对
[37:42.200 --> 37:43.200] 你说
[37:43.200 --> 37:45.200] 我说就是关于方言这个
[37:45.200 --> 37:47.200] 我觉得也很有意思
[37:47.200 --> 37:48.200] 就是方言英文是dialect
[37:48.200 --> 37:49.200] 对吧
[37:49.200 --> 37:50.200] 对
[37:50.200 --> 37:52.200] 然后那怎么定义
[37:52.200 --> 37:54.200] 就是说一个东西是另外一个的方言
[37:54.200 --> 37:56.200] 或者说木兰算不算python的方言
[37:56.200 --> 37:58.200] 木兰
[37:58.200 --> 37:59.200] 对
[37:59.200 --> 38:00.200] 这个话题很好
[38:00.200 --> 38:03.200] 首先我觉得木兰应该是算python的方言的
[38:03.200 --> 38:05.200] 因为说
[38:05.200 --> 38:06.200] 怎么个说法
[38:06.200 --> 38:08.200] 因为它的语言特性保持所有python语言特性
[38:08.200 --> 38:10.200] 它的调用的规则
[38:10.200 --> 38:11.200] 就是说一个函数调用
[38:11.200 --> 38:14.200] 它背后工作原理跟python一模一样
[38:14.200 --> 38:16.200] 它的语言的构造
[38:16.200 --> 38:19.200] 它里面的class这些结构都是保持的
[38:19.200 --> 38:20.200] 我们可以认为就是说
[38:20.200 --> 38:23.200] 它们是同一种语言特性
[38:23.200 --> 38:25.200] 就是同一套语言特性
[38:25.200 --> 38:26.200] 几乎完全一致
[38:26.200 --> 38:27.200] 对
[38:27.200 --> 38:29.200] 然后除非发生非常显著的变化
[38:29.200 --> 38:31.200] 比方说你支持了某些
[38:31.200 --> 38:33.200] 像像韦迪龟这样的特性
[38:33.200 --> 38:34.200] 这样的话我们可以说
[38:34.200 --> 38:37.200] 跟python发生了一定的差异
[38:37.200 --> 38:39.200] 这个时候就
[38:39.200 --> 38:41.200] 我觉得可能会叫另一种语言而不叫方言
[38:41.200 --> 38:42.200] 那么
[38:42.200 --> 38:44.200] 即使它有大括号也可以算是python的方言
[38:44.200 --> 38:46.200] 就只要说
[38:46.200 --> 38:49.200] 就是大部分python的特性都有
[38:49.200 --> 38:51.200] 这一点其实
[38:51.200 --> 38:54.200] 这点我觉得可能不确定
[38:54.200 --> 38:55.200] 就是
[38:55.200 --> 38:57.200] 因为只要怎么看
[38:57.200 --> 38:59.200] 就是这个缩近本身
[38:59.200 --> 39:01.200] 它是否是一个非常
[39:01.200 --> 39:04.200] 它确实是一个非常有标志性的东西
[39:04.200 --> 39:05.200] 是吧
[39:05.200 --> 39:06.200] 但是它
[39:06.200 --> 39:10.200] 它是否能够作为这个语言的分类的一个依据
[39:10.200 --> 39:12.200] 其实我们
[39:12.200 --> 39:14.200] 我们需要某种
[39:14.200 --> 39:15.200] 共识
[39:15.200 --> 39:16.200] 而不是说
[39:16.200 --> 39:18.200] 某个研究者他提出这个就行
[39:18.200 --> 39:21.200] 这一点上应该还是需要某种共识
[39:21.200 --> 39:23.200] 因为更多情况下是说
[39:23.200 --> 39:25.200] PL研究者他做了某种
[39:25.200 --> 39:27.200] 他做某种定义
[39:27.200 --> 39:28.200] 但是大家不认可的话
[39:28.200 --> 39:29.200] 其实也不行
[39:29.200 --> 39:30.200] 对OK
[39:30.200 --> 39:33.200] 对
[39:33.200 --> 39:35.200] 其实我觉得
[39:35.200 --> 39:37.200] 其实我突然就是想问一个问题
[39:37.200 --> 39:39.200] 那么红姐你觉得说木兰
[39:39.200 --> 39:42.200] 它有什么正面意义没有
[39:42.200 --> 39:44.200] 它的正面意义
[39:44.200 --> 39:46.200] 这个我觉得有的
[39:46.200 --> 39:49.200] 我觉得引发了大众对于
[39:49.200 --> 39:52.200] 编程语言领域的好奇
[39:52.200 --> 39:56.200] 或者说引发了至少有一些就是
[39:56.200 --> 39:59.200] 就比如说CS的学生会
[39:59.200 --> 40:02.200] 会更多去看一下它这个语言是怎么实现的
[40:02.200 --> 40:04.200] 大概
[40:04.200 --> 40:05.200] 虽然它实现的很简陋
[40:05.200 --> 40:07.200] 但是对这个意思
[40:07.200 --> 40:10.200] 我觉得它的语言到底确很有教学力
[40:10.200 --> 40:13.200] 但如果它不是用POY写的话
[40:13.200 --> 40:14.200] 因为它代码确实挺太长了
[40:14.200 --> 40:17.200] 如果你是相关的专业的研究者的话
[40:17.200 --> 40:19.200] 你可能不能一眼看到它在干嘛
[40:19.200 --> 40:24.200] 因为它东西有点噪音这个事情
[40:24.200 --> 40:25.200] 但是它的代码结构
[40:25.200 --> 40:27.200] 怎么讲
[40:27.200 --> 40:31.200] 噪音这个事情是说
[40:31.200 --> 40:34.200] 这个就是我怎么说呢
[40:34.200 --> 40:36.200] 我觉得这个POY这个框架
[40:36.200 --> 40:39.200] 它稍微有点过时
[40:39.200 --> 40:42.200] 它稍微有点不贴近现代的这种
[40:42.200 --> 40:44.200] 已有的这种生态
[40:44.200 --> 40:47.200] 你要不要先讲一下POY这个框架是在干嘛
[40:47.200 --> 40:48.200] 因为我之前稍微看一下
[40:48.200 --> 40:51.200] 但我觉得可能大部分听众并不了解
[40:51.200 --> 40:55.200] POY这个框架是Python的一个框架
[40:55.200 --> 40:58.200] 它是这种
[40:58.200 --> 41:00.200] 这个没有静态生成
[41:00.200 --> 41:02.200] 它是完全在编译机
[41:02.200 --> 41:04.200] 你写一个Python的class
[41:04.200 --> 41:06.200] 然后在class上面
[41:06.200 --> 41:09.200] 用一些就是class或者它的method上面
[41:09.200 --> 41:13.200] 用一些这个叫一些declarator
[41:13.200 --> 41:16.200] 去给出它的文法定义
[41:16.200 --> 41:19.200] 文法就是文法是用来标记
[41:19.200 --> 41:21.200] 编程语言的语法的一种
[41:21.200 --> 41:25.200] 就是一种规定的形式语言
[41:25.200 --> 41:27.200] 举个例子呢
[41:27.200 --> 41:30.200] 就是巴克斯这个范氏
[41:30.200 --> 41:31.200] 就是说呢
[41:31.200 --> 41:34.200] 对比方说我说A等于BC
[41:34.200 --> 41:37.200] 它其实说的是A这个规则
[41:37.200 --> 41:41.200] 它可以衍生出B和C两种子规则
[41:41.200 --> 41:45.200] 这种子规则可能是中值子规则
[41:45.200 --> 41:47.200] 有可能是非中值的
[41:47.200 --> 41:49.200] 非中值的话就是说它可以继续衍生
[41:49.200 --> 41:52.200] B可以等于DE这种
[41:52.200 --> 41:54.200] 然后中值的话就是说
[41:54.200 --> 41:57.200] 这个DE它必须是某一种token
[41:57.200 --> 41:59.200] token是什么意思呢
[41:59.200 --> 42:01.200] 就是说它是把一个
[42:01.200 --> 42:04.200] 就是字符算在进行pass之前
[42:04.200 --> 42:07.200] 很多时候会被处理成一块一块的
[42:07.200 --> 42:10.200] 然后每一块一小块
[42:10.200 --> 42:12.200] 它都是一个token
[42:12.200 --> 42:14.200] token的话就是我们说的
[42:14.200 --> 42:16.200] 一般来说都会被这个pass的
[42:16.200 --> 42:19.200] 这个中值规则去解析掉
[42:19.200 --> 42:23.200] 这个是不是讲起来有点麻烦
[42:23.200 --> 42:25.200] 对有点抽象
[42:25.200 --> 42:27.200] 我个人觉得
[42:27.200 --> 42:29.200] 如果是我的话我会这样讲
[42:29.200 --> 42:31.200] 我就会说
[42:31.200 --> 42:34.200] 就是比如说用一个例子来讲的话
[42:34.200 --> 42:36.200] 就相当于你的一个文件它是有
[42:36.200 --> 42:39.200] 比如说每个statement
[42:39.200 --> 42:40.200] 它最后要有一个分号
[42:40.200 --> 42:43.200] 那么这个文件其实就是有一堆分号
[42:43.200 --> 42:45.200] 间隔的statement来构成的
[42:45.200 --> 42:46.200] 然后一个statement呢
[42:46.200 --> 42:49.200] 又可以是有多个分号间隔的
[42:49.200 --> 42:51.200] 也是多个分号间隔
[42:51.200 --> 42:53.200] 就是比如说
[42:53.200 --> 42:55.200] 比如说expression
[42:55.200 --> 42:57.200] 用某种某些组合来构成的
[42:57.200 --> 42:59.200] 然后一个expression
[42:59.200 --> 43:01.200] 它又可以包含一些
[43:01.200 --> 43:03.200] 就是什么什么样的元素
[43:03.200 --> 43:04.200] 就是对吧
[43:04.200 --> 43:05.200] 然后其实就是逐渐往下
[43:05.200 --> 43:08.200] 然后来分解到最底层的一个token
[43:08.200 --> 43:09.200] 就比如说一个token就像
[43:09.200 --> 43:12.200] 比如说if或者是else
[43:12.200 --> 43:14.200] 或者是那个等于就这种东西
[43:14.200 --> 43:15.200] 对吧
[43:15.200 --> 43:17.200] 你这个说法其实可能很形象
[43:17.200 --> 43:19.200] 但是我觉得有奇异
[43:19.200 --> 43:21.200] 就是因为大家会认为
[43:21.200 --> 43:23.200] passer是不是就是不停的去split
[43:23.200 --> 43:25.200] 这个其实从上到下
[43:25.200 --> 43:26.200] split这个方法
[43:26.200 --> 43:28.200] 其实是一种passing方法
[43:28.200 --> 43:29.200] 不不不
[43:29.200 --> 43:30.200] 我说的是文法
[43:30.200 --> 43:32.200] 就是你不是在给听众解释
[43:32.200 --> 43:33.200] 什么是文法吗
[43:33.200 --> 43:34.200] 对我就想说文法
[43:34.200 --> 43:37.200] 其实它包含的东西就是说
[43:37.200 --> 43:39.200] 你这个就或者说什么
[43:39.200 --> 43:43.200] 才是被认为是符合你这个语言的
[43:43.200 --> 43:48.200] syntax的这样一个内容
[43:48.200 --> 43:49.200] 这样说吧
[43:49.200 --> 43:51.200] 我觉得有一句话可以这样说
[43:51.200 --> 43:54.200] 就是说把一个字符串变成一个有结构的
[43:54.200 --> 43:58.200] 有特定形状的一个数据结构
[43:58.200 --> 43:59.200] 嗯嗯
[43:59.200 --> 44:01.200] 这个挺精确的
[44:01.200 --> 44:02.200] 我觉得
[44:02.200 --> 44:04.200] 那其实文法就是规定
[44:04.200 --> 44:07.200] 它是是怎样从字符串
[44:07.200 --> 44:10.200] 到这个这个特定的数据结构的
[44:10.200 --> 44:13.200] 它是一个有一个确定的规则
[44:13.200 --> 44:14.200] 这是文法
[44:14.200 --> 44:16.200] 当然就是说解释这个文法的话
[44:16.200 --> 44:19.200] 从这个文法变成真正的passing
[44:19.200 --> 44:23.200] 一般来说是需要相当复杂的过程的
[44:23.200 --> 44:25.200] 那么就有很多的框架
[44:25.200 --> 44:27.200] 那么很早的时候就有什么
[44:27.200 --> 44:30.200] 就是像C语言里面的什么ycc这种
[44:30.200 --> 44:33.200] 然后像后面python里面就是说
[44:33.200 --> 44:34.200] 说python的ycc
[44:34.200 --> 44:36.200] py这些东西
[44:36.200 --> 44:38.200] 其实现在我的话就是说
[44:38.200 --> 44:39.200] 比较流行的框架
[44:39.200 --> 44:40.200] 我就推荐是
[44:40.200 --> 44:42.200] 就是说如果你真的要去写的话
[44:42.200 --> 44:45.200] 我真的不建议说是像py这样的东西
[44:45.200 --> 44:46.200] 为什么呢
[44:46.200 --> 44:48.200] 它就现在我们先不说
[44:48.200 --> 44:49.200] 现在流行什么
[44:49.200 --> 44:50.200] 现在说py这个东西
[44:50.200 --> 44:51.200] 它问题在于就是说
[44:51.200 --> 44:56.200] 它它把这个这个你的文法搞得很松散
[44:56.200 --> 45:00.200] 导致用户他不能一眼去把整个语言有概念
[45:00.200 --> 45:02.200] 因为文法一般来说是很简短的
[45:02.200 --> 45:04.200] 像python的文法的话
[45:04.200 --> 45:09.200] 虽然近一两年突然暴增了很多
[45:09.200 --> 45:11.200] 但是在两年之前
[45:11.200 --> 45:14.200] 也就是我刚开始研究python之前
[45:14.200 --> 45:16.200] 它是只有100多行的文法
[45:16.200 --> 45:18.200] 也就是说你把文件稍微拉小一点
[45:18.200 --> 45:19.200] 一眼过去
[45:19.200 --> 45:23.200] 整个python的文法都可以清晰的送到原点
[45:23.200 --> 45:24.200] 实际上
[45:24.200 --> 45:26.200] 它现在也并不是很多
[45:26.200 --> 45:28.200] 其实在文档里好像就有一页
[45:28.200 --> 45:31.200] 然后就就是文法都在那
[45:31.200 --> 45:33.200] 现在其实不是
[45:33.200 --> 45:35.200] 现在有100多行了
[45:35.200 --> 45:38.200] 之前不是也说是100多行
[45:38.200 --> 45:40.200] 对之前是100几行
[45:40.200 --> 45:41.200] 现在是190多行
[45:41.200 --> 45:43.200] 虽然现在带一点注视
[45:43.200 --> 45:45.200] 现在虽然确实带了一点注视
[45:45.200 --> 45:46.200] 所以190多行就是比较多
[45:46.200 --> 45:48.200] 然后100行就是不多
[45:48.200 --> 45:49.200] 也不算多
[45:49.200 --> 45:50.200] 也不算多
[45:50.200 --> 45:52.200] 因为像思耀家他们都是接近1000行
[45:52.200 --> 45:53.200] 我就开玩笑
[45:53.200 --> 45:54.200] 对
[45:54.200 --> 45:57.200] 就说像木兰的话
[45:57.200 --> 45:59.200] 你不能去一眼知道
[45:59.200 --> 46:02.200] 它的这个语言有多少的文法规则
[46:02.200 --> 46:03.200] 你不知道
[46:03.200 --> 46:04.200] 说py吧
[46:04.200 --> 46:05.200] 对对对
[46:05.200 --> 46:06.200] 木兰这种做法
[46:06.200 --> 46:07.200] 它使用py
[46:07.200 --> 46:08.200] 第一点是这个
[46:08.200 --> 46:11.200] 第二点是py它不是
[46:11.200 --> 46:13.200] 它是运行时生成puzzle的
[46:13.200 --> 46:15.200] 就是说你等于说你每次运行
[46:15.200 --> 46:17.200] 它都会重新去构建一个puzzle
[46:17.200 --> 46:20.200] 这个其实会影响这个puzzle
[46:20.200 --> 46:22.200] 它的优化的这种可能性
[46:22.200 --> 46:24.200] 因为一般来说puzzle优化
[46:24.200 --> 46:26.200] 还是会消耗一定的时间的
[46:26.200 --> 46:29.200] 当你每次开始进程的时候
[46:29.200 --> 46:31.200] 你都要去构造你的puzzle
[46:31.200 --> 46:34.200] 那无法避免的事情就是说
[46:34.200 --> 46:37.200] 你的puzzle不可能优化的很复杂
[46:37.200 --> 46:38.200] 优化的很强
[46:38.200 --> 46:39.200] 对
[46:39.200 --> 46:42.200] 还有就是说它的语言的这种
[46:42.200 --> 46:45.200] 这种表达能力上其实也有欠缺
[46:45.200 --> 46:48.200] 就我们可以看到py上面
[46:48.200 --> 46:51.200] 它还在使用这种通过
[46:51.200 --> 46:52.200] 就是一个文法
[46:52.200 --> 46:56.200] 它其实它的一个规则会有很多个部分
[46:56.200 --> 46:59.200] 就说b等于a等于bcd
[46:59.200 --> 47:00.200] 它其实分成三个部分
[47:00.200 --> 47:02.200] 那么我们取这些部分的时候
[47:02.200 --> 47:04.200] 我们是通过它的这个序号取
[47:04.200 --> 47:06.200] 还是通过某一种名字取
[47:06.200 --> 47:09.200] 其实更好的办法可能是通过某种名字取
[47:09.200 --> 47:11.200] 这样有清晰的语义
[47:11.200 --> 47:14.200] 但是py是完全没有考虑这些事情的
[47:14.200 --> 47:15.200] 对
[47:15.200 --> 47:16.200] 总之各方面的
[47:16.200 --> 47:18.200] 还有性能上面的差异
[47:18.200 --> 47:20.200] 它的parsing速度其实也是相当慢的
[47:20.200 --> 47:21.200] 对
[47:21.200 --> 47:22.200] 反正各种各样的问题
[47:22.200 --> 47:23.200] 导致其实现在
[47:23.200 --> 47:25.200] 因为它是相对来说比较过时的
[47:25.200 --> 47:26.200] 对
[47:26.200 --> 47:27.200] 它没有自己的优势
[47:27.200 --> 47:28.200] 没有自己独特的优势case
[47:28.200 --> 47:31.200] 像pyparsing这种库
[47:31.200 --> 47:32.200] 虽然它的性能很差
[47:32.200 --> 47:34.200] 但是它有自己明确的优势case
[47:34.200 --> 47:36.200] 它的构建很快
[47:36.200 --> 47:37.200] 它运行时构建
[47:37.200 --> 47:38.200] 对
[47:38.200 --> 47:39.200] 所以它有自己明确的优势case
[47:39.200 --> 47:42.200] 然后如果说真的要写个语言的话
[47:42.200 --> 47:44.200] 我们就最后说一下parsing吧
[47:44.200 --> 47:47.200] 就是像parsing有个叫lark的parsing
[47:47.200 --> 47:50.200] l-a-r-k
[47:50.200 --> 47:52.200] 这个parsing其实挺不错的
[47:52.200 --> 47:53.200] 对
[47:53.200 --> 47:55.200] 相当于说真的很前沿
[47:55.200 --> 47:56.200] 对
[47:56.200 --> 48:00.200] 然后大概就是讲parsing相关的东西
[48:01.200 --> 48:05.200] 所以其实就是技术选择也是品位的一部分
[48:05.200 --> 48:08.200] 他选了表完就讲那个了
[48:08.200 --> 48:10.200] 这一点是我猜测可能是他
[48:10.200 --> 48:12.200] 可能和年纪有关
[48:12.200 --> 48:13.200] 我觉得或许是
[48:13.200 --> 48:14.200] 但也不太
[48:14.200 --> 48:16.200] 他毕竟只是硕士
[48:16.200 --> 48:18.200] 这点是我很疑惑的
[48:18.200 --> 48:19.200] 等会
[48:19.200 --> 48:20.200] 那个人不是个副研究员吗
[48:20.200 --> 48:23.200] 还是说实际干活的其实是他学生
[48:23.200 --> 48:24.200] 他是学生
[48:24.200 --> 48:25.200] 他应该是学生
[48:25.200 --> 48:27.200] 应该是或者是博士在读之类的
[48:27.200 --> 48:30.200] 总之他年纪肯定不大
[48:30.200 --> 48:31.200] 肯定不是很大
[48:31.200 --> 48:32.200] 但是他选择
[48:32.200 --> 48:33.200] 因为我们技术很老
[48:33.200 --> 48:35.200] 对确实相对来说
[48:36.200 --> 48:37.200] 确实有一点老
[48:37.200 --> 48:38.200] 也不能说特老吧
[48:38.200 --> 48:40.200] 因为十多年前也还挺流行
[48:41.200 --> 48:42.200] 对
[48:42.200 --> 48:43.200] OK
[48:43.200 --> 48:44.200] 行
[48:44.200 --> 48:45.200] 然后我记得你之前说
[48:45.200 --> 48:47.200] 那个他那个人之前还造过一个语言
[48:47.200 --> 48:48.200] 然后你觉得不错
[48:48.200 --> 48:50.200] 然后来表现这个
[48:50.200 --> 48:51.200] 这个事情呢
[48:51.200 --> 48:53.200] 是我因为我没有看到这个语言
[48:53.200 --> 48:54.200] 但是钟崑月的说法
[48:54.200 --> 48:55.200] 因为我比较相信钟崑月
[48:55.200 --> 48:57.200] 因为我毕竟和那边有合作
[48:57.200 --> 48:58.200] 他们这个
[48:59.200 --> 49:00.200] 他们那边说
[49:00.200 --> 49:02.200] 说有一个东西叫miniDua
[49:02.200 --> 49:05.200] 是自己独立实现的这个虚拟机
[49:05.200 --> 49:07.200] 自己独立实现的指令集
[49:07.200 --> 49:08.200] 我说这个东西还不错
[49:08.200 --> 49:10.200] 它其实挺完整的一个东西
[49:10.200 --> 49:12.200] 对但是我没有看到它
[49:13.200 --> 49:14.200] 包括一个东西
[49:14.200 --> 49:15.200] 它确实它有实现一些互联网
[49:15.200 --> 49:17.200] 那个互联网的一些东西
[49:18.200 --> 49:19.200] 它是
[49:19.200 --> 49:20.200] 钟崑月的说法是这样的
[49:20.200 --> 49:23.200] 在他的批评的这个处理结果公式里面
[49:23.200 --> 49:24.200] 是有说的
[49:24.200 --> 49:26.200] 他这个东西还不能下载吗
[49:26.200 --> 49:27.200] 还是
[49:27.200 --> 49:28.200] 我没有看到
[49:28.200 --> 49:29.200] 没放出来吗
[49:29.200 --> 49:30.200] 就是说
[49:30.200 --> 49:31.200] 还没放出来
[49:31.200 --> 49:32.200] 对
[49:33.200 --> 49:34.200] OK
[49:34.200 --> 49:35.200] 他做一个东西不放出来
[49:35.200 --> 49:36.200] 意义是啥
[49:36.200 --> 49:37.200] 我就不是特别理解
[49:37.200 --> 49:38.200] 对但是
[49:38.200 --> 49:39.200] 但是我觉得那个
[49:39.200 --> 49:41.200] 我对于木兰觉得最屌的
[49:41.200 --> 49:42.200] 就说是这样
[49:42.200 --> 49:44.200] 我觉得最扯的你知道是什么吗
[49:46.200 --> 49:47.200] 就是他说是
[49:47.200 --> 49:49.200] 就是物联网这一块
[49:49.200 --> 49:51.200] 然后我觉得是相当扯
[49:51.200 --> 49:53.200] 因为我之前就是做嵌入式的
[49:53.200 --> 49:55.200] 然后我对我之前是做嵌入式的
[49:55.200 --> 49:58.200] 因为我当时特别特别好奇
[49:58.200 --> 49:59.200] 我就很好奇
[49:59.200 --> 50:01.200] 他怎么样是把一个内python的东西
[50:02.200 --> 50:05.200] 然后这一套语法这么复杂的东西
[50:05.200 --> 50:09.200] 然后而且还是一个解释性的东西给运行在
[50:09.200 --> 50:12.200] 他说是好像说是可以跑在八位处理器上的
[50:12.200 --> 50:13.200] 然后我
[50:13.200 --> 50:14.200] 对
[50:14.200 --> 50:15.200] 对
[50:15.200 --> 50:16.200] 你们可能对于这个不太
[50:16.200 --> 50:17.200] 对
[50:17.200 --> 50:18.200] 对于这个不太熟悉
[50:18.200 --> 50:19.200] 我举个例子
[50:19.200 --> 50:21.200] 之前我们在用那个
[50:21.200 --> 50:23.200] 在用最简单的处理器的
[50:23.200 --> 50:24.200] 就是那个
[50:24.200 --> 50:25.200] 就是80c51
[50:25.200 --> 50:27.200] 因为大家嵌入式的就比较熟悉
[50:27.200 --> 50:28.200] 80c51处理器
[50:28.200 --> 50:30.200] 其实我们有个温度传感器
[50:30.200 --> 50:31.200] 温度传感器
[50:31.200 --> 50:35.200] 他通信协议是用叫做iFONC
[50:35.200 --> 50:36.200] 然后就说是英文
[50:36.200 --> 50:37.200] 就是i2c
[50:37.200 --> 50:38.200] 然后的话
[50:38.200 --> 50:43.200] 他实验一般是要求不超过三微秒时间
[50:43.200 --> 50:47.200] 就是说是他的时间控制是以微秒计算的
[50:47.200 --> 50:49.200] 然后的话
[50:49.200 --> 50:51.200] 这个时候他在对于这些
[50:51.200 --> 50:53.200] 因为嵌入式的他传感器的协议
[50:53.200 --> 50:56.200] 就是他是对于时序要求极其敏感的
[50:56.200 --> 50:59.200] 然后如果说你在跑一个解释器在上面
[50:59.200 --> 51:03.200] 然后我估计直接起步都是一毫秒起
[51:03.200 --> 51:05.200] 这个东西我觉得我就特别好奇
[51:05.200 --> 51:10.200] 他是怎么样的能够吹出在那个物联网领域得到大规模应用的
[51:13.200 --> 51:14.200] 这个那就是
[51:14.200 --> 51:15.200] 是啊
[51:15.200 --> 51:18.200] 这个他已经承认是就纯吹的了
[51:18.200 --> 51:19.200] 所以
[51:21.200 --> 51:24.200] 其实大家都在都往物联网上靠这点也是挺有意思的
[51:24.200 --> 51:25.200] 我觉得
[51:26.200 --> 51:27.200] 是的
[51:27.200 --> 51:29.200] 现在感觉是什么语言都在讨论
[51:29.200 --> 51:31.200] 不是给人工智能准备的
[51:31.200 --> 51:32.200] 就是给沙尔编程准备的
[51:32.200 --> 51:33.200] 然后再不行
[51:33.200 --> 51:35.200] 你还可以说你是给物联网准备的
[51:36.200 --> 51:37.200] 说句老实话
[51:37.200 --> 51:39.200] 其实我不咋知道物联网是啥
[51:39.200 --> 51:41.200] 我感觉我有点有点浪费
[51:41.200 --> 51:42.200] 其实我也
[51:42.200 --> 51:43.200] 我真不知道
[51:43.200 --> 51:44.200] 我真真不清楚
[51:44.200 --> 51:52.200] 我感觉物联网就是除了你的电脑手机之外的能联网的设备
[51:52.200 --> 51:53.200] 对
[51:53.200 --> 51:56.200] 我觉得他其实这个概念是很早以前的了
[51:56.200 --> 51:59.200] 其实他其实就是IOT这套东西的衍生
[51:59.200 --> 52:01.200] 就是说是嵌入式移动设备的衍生
[52:03.200 --> 52:04.200] 对
[52:04.200 --> 52:07.200] 然后的话当然现在可能说有引进出来的很多
[52:07.200 --> 52:10.200] 就是说是新的概念
[52:10.200 --> 52:12.200] 比如说边缘计算或是其他东西
[52:12.200 --> 52:15.200] 当然这个东西和我们今天讨论的也没什么关系
[52:15.200 --> 52:16.200] 就是OT了
[52:16.200 --> 52:17.200] 但是的话
[52:17.200 --> 52:20.200] 反正我就觉得我觉得他让我们现在嘛
[52:20.200 --> 52:22.200] 然后大家要做个新东西出来
[52:22.200 --> 52:27.200] 你要拉前的最好的三个方向就是人工智能
[52:27.200 --> 52:29.200] 第二个大数据已经过时了
[52:29.200 --> 52:30.200] 现在是要叫做人工智能
[52:30.200 --> 52:32.200] 然后第二个沙尔编程
[52:32.200 --> 52:34.200] 第三个是物联网
[52:37.200 --> 52:38.200] 好
[52:38.200 --> 52:45.200] 那其实红姐你对于就是像木兰和就木兰这方面
[52:45.200 --> 52:47.200] 还有没有什么别的想补充的
[52:50.200 --> 52:53.200] 这个话我个人觉得就是
[52:54.200 --> 52:56.200] 虽然我说了也觉得没用吧
[52:56.200 --> 52:58.200] 就是我还是希望大家就是
[52:58.200 --> 52:59.200] 就是
[53:00.200 --> 53:02.200] 之前不是左老师说这个
[53:02.200 --> 53:04.200] 不是Sony问他说
[53:04.200 --> 53:06.200] 这个学编程语言有什么用吗
[53:06.200 --> 53:07.200] 对吧
[53:07.200 --> 53:08.200] 对于已经工作的人来说
[53:08.200 --> 53:10.200] 我觉得其实还是有用
[53:10.200 --> 53:12.200] 就是从这一点上来说
[53:12.200 --> 53:14.200] 就是至少我们应该
[53:14.200 --> 53:19.200] 某种程度上对这个东西是否值得去
[53:19.200 --> 53:20.200] 这个吹
[53:20.200 --> 53:22.200] 是有一个初步的了解
[53:22.200 --> 53:23.200] 对吧
[53:23.200 --> 53:24.200] 就是我们至少
[53:24.200 --> 53:27.200] 就是我们虽然不能知道它大概是处于什么位置
[53:27.200 --> 53:29.200] 他不能知道他精确处于什么位置
[53:29.200 --> 53:31.200] 但是我们要有一个
[53:31.200 --> 53:34.200] 就是能有一个相对来说模糊的判断
[53:34.200 --> 53:35.200] 对
[53:35.200 --> 53:36.200] 我觉得这个是肯定有用的
[53:36.200 --> 53:37.200] 因为
[53:37.200 --> 53:40.200] 我们知道这个网上很多的信息
[53:40.200 --> 53:41.200] 他们有些人说的话对不对
[53:41.200 --> 53:42.200] 其实
[53:42.200 --> 53:45.200] 还是要很多时候依靠我们自己的知识水平去判断的
[53:45.200 --> 53:47.200] 当我们对吧
[53:47.200 --> 53:49.200] 假如说像木兰这样语言出来
[53:49.200 --> 53:52.200] 假如说真的是没有人去指责他
[53:52.200 --> 53:53.200] 大家也不关心
[53:53.200 --> 53:54.200] 对吧
[53:54.200 --> 53:56.200] 然后也没有很多人去搞
[53:56.200 --> 53:57.200] 像比如说搞POL
[53:57.200 --> 53:58.200] 其实我们都没听到
[53:58.200 --> 53:59.200] 都是看别人转的
[53:59.200 --> 54:00.200] 他看到的
[54:00.200 --> 54:01.200] 对
[54:01.200 --> 54:02.200] 就是这种
[54:02.200 --> 54:03.200] 然后大家也都不关心
[54:03.200 --> 54:05.200] 他就就就只听到说
[54:05.200 --> 54:06.200] 国产出语言了
[54:06.200 --> 54:07.200] 那么有些人就会说啊
[54:07.200 --> 54:08.200] 国产出语言了
[54:08.200 --> 54:10.200] 只要听到国产就开始
[54:10.200 --> 54:11.200] 就是这种
[54:11.200 --> 54:13.200] 那那这样对社会影响
[54:13.200 --> 54:14.200] 其实是很不好的
[54:14.200 --> 54:15.200] 对吧
[54:15.200 --> 54:16.200] 对
[54:15.200 --> 54:16.200] 而且对
[54:16.200 --> 54:19.200] 这更多的是对真正在做事的人来说
[54:19.200 --> 54:20.200] 更是一种侮辱
[54:20.200 --> 54:21.200] 对
[54:21.200 --> 54:22.200] 是这样的
[54:22.200 --> 54:23.200] 对
[54:22.200 --> 54:25.200] 所以我觉得其实对大家看一下
[54:25.200 --> 54:26.200] 稍微就是说
[54:26.200 --> 54:27.200] 就我们不需要
[54:27.200 --> 54:28.200] 不需要任何技术细节
[54:28.200 --> 54:29.200] 我们只要知道
[54:29.200 --> 54:32.200] 就是说能够去判断某段程序
[54:32.200 --> 54:34.200] 而不是某一大段程序
[54:34.200 --> 54:35.200] 这样吧
[54:35.200 --> 54:37.200] 就是他可能会是在干什么
[54:37.200 --> 54:38.200] 对
[54:38.200 --> 54:39.200] 好
[54:39.200 --> 54:40.200] 对
[54:40.200 --> 54:43.200] 我觉得这个其实也是一个蛮好的总结吧
[54:43.200 --> 54:44.200] 就是说
[54:44.200 --> 54:45.200] 其实更
[54:45.200 --> 54:49.200] 我们去应该或者说更应该关注一些真正在做
[54:49.200 --> 54:51.200] 有意义工作的人
[54:51.200 --> 54:54.200] 比如说可能洪杰搞的一些python的扩展
[54:54.200 --> 54:55.200] 我还没有
[54:55.200 --> 54:57.200] 我还没有开始搞真正实用的
[54:57.200 --> 54:58.200] 对
[54:58.200 --> 54:59.200] 反正就是
[54:59.200 --> 55:00.200] 对要
[55:00.200 --> 55:01.200] 或者说技术的品位吧
[55:01.200 --> 55:02.200] 就是要
[55:02.200 --> 55:04.200] 还是要建立在
[55:04.200 --> 55:07.200] 就是有一定的了解之上才能
[55:07.200 --> 55:09.200] 有更好的一个判断
[55:09.200 --> 55:10.200] OK
[55:10.200 --> 55:11.200] 然后
[55:11.200 --> 55:14.200] 你知道我们例行有一个推荐环节对吧
[55:14.200 --> 55:17.200] 你还听过我们之前的几期应该会知道
[55:17.200 --> 55:18.200] 对
[55:18.200 --> 55:19.200] 不好意思
[55:19.200 --> 55:21.200] 其实我只听到一点点前面
[55:21.200 --> 55:22.200] 没有听到最后
[55:22.200 --> 55:23.200] But anyway
[55:23.200 --> 55:25.200] 我们有一个
[55:25.200 --> 55:27.200] 就每期都会推荐
[55:27.200 --> 55:28.200] 推荐两个东西
[55:28.200 --> 55:30.200] 一个是推荐一个库
[55:30.200 --> 55:33.200] 然后另外一个是推荐
[55:33.200 --> 55:35.200] 就是不是库之外的任何东西
[55:35.200 --> 55:37.200] 比如说你看过的一个文章
[55:37.200 --> 55:40.200] 一篇一个视频或者一个什么什么
[55:40.200 --> 55:41.200] 对
[55:41.200 --> 55:43.200] 然后你可以稍微想一下
[55:43.200 --> 55:46.200] 有没有什么东西要推荐给听众们
[55:46.200 --> 55:47.200] 我来推荐吗
[55:47.200 --> 55:49.200] 你们没什么说的吗
[55:49.200 --> 55:51.200] 你先推荐吧
[55:51.200 --> 55:54.200] 我其实还没有想好我要说什么
[55:54.200 --> 55:56.200] 我想问一下之前那个BuyCode
[55:56.200 --> 55:58.200] 你推荐过吗
[55:58.200 --> 56:01.200] 应该
[56:01.200 --> 56:02.200] 推荐库吗
[56:02.200 --> 56:03.200] 我我我
[56:03.200 --> 56:06.200] 你没有推荐过我确定
[56:06.200 --> 56:07.200] 对
[56:07.200 --> 56:11.200] 那咱们那我这次就推荐BuyCode的这个库呗
[56:11.200 --> 56:12.200] Vestina写的
[56:12.200 --> 56:14.200] 我觉得非常有意义的一个库
[56:14.200 --> 56:17.200] 真的是Enable了很多东西
[56:17.200 --> 56:20.200] 虽然说被布鲁克兹骂
[56:20.200 --> 56:22.200] 骂说这个东西没用
[56:22.200 --> 56:25.200] 但实际上我觉得他做些事才真没用
[56:25.200 --> 56:27.200] 总之就是这个库的话
[56:27.200 --> 56:32.200] 如果你真的想在Python里面去搞任何的
[56:32.200 --> 56:35.200] 我觉得的话就是说
[56:35.200 --> 56:38.200] 这个能超过Python本身表达力的东西
[56:38.200 --> 56:40.200] 然后又想利用Python的生态
[56:40.200 --> 56:42.200] 又想利用Python的这些
[56:42.200 --> 56:45.200] 就是它的这种运行时爆错的一些优点的话
[56:45.200 --> 56:50.200] 那么你一定会喜欢上BuyCode这个库
[56:50.200 --> 56:51.200] 对
[56:51.200 --> 56:53.200] 它具体是干什么用的吧
[56:53.200 --> 56:54.200] 对我虽然知道
[56:54.200 --> 56:56.200] 它是干什么用的
[56:56.200 --> 56:58.200] 它是这个就是说
[56:58.200 --> 57:00.200] 我们知道Python它的
[57:00.200 --> 57:02.200] NST最后之前不是讲过吗
[57:02.200 --> 57:03.200] 会编译成这个
[57:03.200 --> 57:04.200] 字节码
[57:04.200 --> 57:05.200] Code Object对
[57:05.200 --> 57:07.200] 然后这里面字节码的话
[57:07.200 --> 57:08.200] 它是有指令的
[57:08.200 --> 57:11.200] Python它有个虚拟机会解释这个指令
[57:11.200 --> 57:12.200] 是一个站机
[57:12.200 --> 57:14.200] 就是说Push一个东西进去
[57:14.200 --> 57:15.200] 然后Pub出来
[57:15.200 --> 57:16.200] 像这样操作
[57:16.200 --> 57:18.200] 这个字节码就是说
[57:18.200 --> 57:21.200] 让你在更高层面去操作这个
[57:21.200 --> 57:23.200] 这些指令集
[57:23.200 --> 57:25.200] 有很可以避免很多的问题
[57:25.200 --> 57:26.200] 就是说
[57:26.200 --> 57:28.200] 咱们不讲很细了
[57:28.200 --> 57:29.200] 就是说
[57:29.200 --> 57:31.200] 比方说我们想说
[57:31.200 --> 57:32.200] 我们把一个东西放在站上
[57:32.200 --> 57:34.200] 然后去打印它
[57:34.200 --> 57:35.200] 那么在字节码层面
[57:35.200 --> 57:36.200] 其实就是一个
[57:36.200 --> 57:37.200] Load
[57:37.200 --> 57:38.200] 然后一个名字
[57:38.200 --> 57:39.200] 加上Print
[57:39.200 --> 57:40.200] Expression
[57:40.200 --> 57:41.200] 这也是个
[57:41.200 --> 57:42.200] 这两个指令
[57:42.200 --> 57:44.200] 就是说你可以去通过
[57:44.200 --> 57:47.200] 相当高层面的这种字节码的
[57:47.200 --> 57:49.200] 这种
[57:49.200 --> 57:51.200] 不知道这是怎么说吧
[57:51.200 --> 57:52.200] 就是说
[57:52.200 --> 57:54.200] 不需要你写0101
[57:54.200 --> 57:56.200] 不需要你去用
[57:56.200 --> 57:58.200] 具体要怎么讲好处
[57:58.200 --> 57:59.200] 我觉得其实Bytecode
[57:59.200 --> 58:00.200] 就可以概括成
[58:00.200 --> 58:02.200] Python字节码的一个抽象
[58:02.200 --> 58:04.200] 就是相当于
[58:04.200 --> 58:06.200] 你可以用更
[58:06.200 --> 58:07.200] 用更简单的方式去
[58:07.200 --> 58:09.200] 直接操作Python字节码
[58:09.200 --> 58:10.200] 其实也就这样
[58:10.200 --> 58:11.200] 对
[58:11.200 --> 58:12.200] 是这样说
[58:12.200 --> 58:13.200] 对
[58:13.200 --> 58:14.200] 它是内置的吗
[58:14.200 --> 58:15.200] 还是
[58:15.200 --> 58:17.200] 它不是内置的
[58:17.200 --> 58:18.200] 四字三方库
[58:18.200 --> 58:19.200] 对
[58:19.200 --> 58:20.200] 但它的作者
[58:20.200 --> 58:21.200] 我们有理由相信
[58:21.200 --> 58:22.200] 它接近于内置
[58:22.200 --> 58:23.200] 对
[58:23.200 --> 58:24.200] 就是Vector
[58:24.200 --> 58:25.200] 你应该知道
[58:25.200 --> 58:26.200] 就是翔哥的
[58:26.200 --> 58:27.200] Mentor
[58:27.200 --> 58:28.200] 对
[58:28.200 --> 58:29.200] 我知道
[58:29.200 --> 58:30.200] Stinger
[58:30.200 --> 58:31.200] 对
[58:33.200 --> 58:34.200] OK
[58:34.200 --> 58:35.200] 然后对我要澄清点
[58:35.200 --> 58:36.200] 刚红姐说的这个
[58:36.200 --> 58:37.200] 站其实是指的
[58:37.200 --> 58:39.200] Python虚拟机的站
[58:39.200 --> 58:40.200] 而不是
[58:40.200 --> 58:41.200] 就是我们
[58:41.200 --> 58:42.200] 对
[58:42.200 --> 58:43.200] 这个
[58:43.200 --> 58:45.200] 这个确实要声明一下
[58:45.200 --> 58:46.200] 这个
[58:46.200 --> 58:47.200] 对
[58:47.200 --> 58:48.200] 它听了会误解
[58:48.200 --> 58:49.200] 对
[58:50.200 --> 58:51.200] 好
[58:51.200 --> 58:53.200] 然后除了酷之外的呢
[58:53.200 --> 58:54.200] 嗯
[58:54.200 --> 58:56.200] 除了酷之外的
[58:56.200 --> 58:57.200] 对
[58:57.200 --> 58:58.200] 什么都可以
[58:58.200 --> 58:59.200] 这个就很随便
[58:59.200 --> 59:00.200] 这个就真的什么都可以
[59:00.200 --> 59:01.200] 你
[59:01.200 --> 59:02.200] 你推
[59:02.200 --> 59:04.200] 你推荐一部新番也是可以的
[59:04.200 --> 59:05.200] 或是推荐
[59:05.200 --> 59:06.200] 对对真可以真可以
[59:06.200 --> 59:07.200] 真的
[59:07.200 --> 59:08.200] 推荐某一个新番
[59:08.200 --> 59:10.200] 或是某一个黄油游戏都可以的
[59:10.200 --> 59:12.200] 我们这可以推荐黄油游戏吗
[59:12.200 --> 59:13.200] 可以
[59:13.200 --> 59:16.200] 我是觉得没问题了
[59:16.200 --> 59:18.200] 那我还觉得还是推荐番吧
[59:18.200 --> 59:19.200] 我觉得
[59:19.200 --> 59:21.200] 因为毕竟我现在没有玩黄油
[59:21.200 --> 59:23.200] 我打算是写完
[59:23.200 --> 59:25.200] 用我的新语言写完
[59:25.200 --> 59:27.200] 走到这个再去写我的黄油
[59:27.200 --> 59:28.200] 哈哈哈
[59:28.200 --> 59:30.200] 其实就是挑剔研究者
[59:30.200 --> 59:31.200] 说实话
[59:31.200 --> 59:33.200] 一定要用自己的语言写出黄油才能玩
[59:33.200 --> 59:35.200] 对我们是在给
[59:35.200 --> 59:38.200] 我在我和学长在合照上申请这个立项你知道吗
[59:38.200 --> 59:41.200] 我们想把这个做成像真正的科研项目
[59:41.200 --> 59:44.200] 就是写黄油的语言
[59:45.200 --> 59:46.200] 这是实话
[59:46.200 --> 59:47.200] 对
[59:47.200 --> 59:48.200] 可以可以期待一下
[59:48.200 --> 59:49.200] 期待
[59:49.200 --> 59:50.200] 哈哈哈
[59:50.200 --> 59:51.200] 嗯
[59:52.200 --> 59:54.200] 那我来看一下我的这份列表
[59:54.200 --> 59:56.200] 因为确实毕竟我昨晚也熬夜对吧
[59:56.200 --> 59:59.200] 我现在可能记性也特别好啊
[59:59.200 --> 01:00:03.200] 我是你们PLT的那个太硬核了吧
[01:00:03.200 --> 01:00:05.200] 自己写黄油
[01:00:05.200 --> 01:00:06.200] 哈哈
[01:00:06.200 --> 01:00:07.200] 不不不
[01:00:07.200 --> 01:00:08.200] 不是那个
[01:00:08.200 --> 01:00:09.200] 不是不不
[01:00:09.200 --> 01:00:10.200] 不是那个
[01:00:10.200 --> 01:00:11.200] 不是那个
[01:00:11.200 --> 01:00:12.200] 不是那个
[01:00:12.200 --> 01:00:13.200] 不是那个
[01:00:13.200 --> 01:00:14.200] 不是那个
[01:00:14.200 --> 01:00:15.200] 不是那个
[01:00:15.200 --> 01:00:16.200] 不是那个
[01:00:16.200 --> 01:00:17.200] 不是那个
[01:00:17.200 --> 01:00:19.200] 我其实本身是可能利用已有的东西
[01:00:19.200 --> 01:00:24.200] 但是就是怎么去造出一个让大家可以更容易写的东西
[01:00:24.200 --> 01:00:27.200] 其实我并不会去考虑说怎么去演这个事情
[01:00:28.200 --> 01:00:30.200] 说到写黄油
[01:00:30.200 --> 01:00:35.200] 我我我不是他们他们不是一直用那个RPG Maker来做东西吗
[01:00:35.200 --> 01:00:37.200] 那像比如说你用一个语言可能
[01:00:38.200 --> 01:00:41.200] 就说能达到图形界面
[01:00:41.200 --> 01:00:43.200] 是不是确定真的有图形界面方便吗
[01:00:43.200 --> 01:00:44.200] 这个是我的一个问题
[01:00:44.200 --> 01:00:47.200] 就或者说只是因为你们想造一个语言
[01:00:47.200 --> 01:00:48.200] 所以才选择造一个语言
[01:00:48.200 --> 01:00:52.200] 不是PLT没有说一定是不一定是文本形式的
[01:00:52.200 --> 01:00:53.200] 就是我虽然有文本形式的
[01:00:53.200 --> 01:00:55.200] 但是我也我也有JY形式的
[01:00:55.200 --> 01:00:57.200] 这都是可以的
[01:00:57.200 --> 01:00:58.200] 有对对
[01:00:58.200 --> 01:00:59.200] 也可以这样做
[01:00:59.200 --> 01:01:00.200] 对
[01:01:00.200 --> 01:01:02.200] 其实那样那个也是个方向
[01:01:02.200 --> 01:01:03.200] 对
[01:01:03.200 --> 01:01:05.200] 但是我但是我但是我好奇
[01:01:05.200 --> 01:01:06.200] 比如说你黄油的话
[01:01:06.200 --> 01:01:09.200] 你不可能说我做成终端式的黄油对吧
[01:01:09.200 --> 01:01:11.200] 那么你肯定涉及到各种图形的渲染
[01:01:11.200 --> 01:01:12.200] 或者是其他东西
[01:01:12.200 --> 01:01:14.200] 对这一块的话你们会怎么样去处理
[01:01:16.200 --> 01:01:18.200] 这个其实我刚刚说的是
[01:01:18.200 --> 01:01:19.200] 我们不考虑这点
[01:01:19.200 --> 01:01:22.200] 其实这点不一定就是像我的学长
[01:01:22.200 --> 01:01:23.200] 他写C++2他就喜欢
[01:01:23.200 --> 01:01:24.200] 我说我用Python写
[01:01:24.200 --> 01:01:26.200] 他说我不会用Python
[01:01:26.200 --> 01:01:29.200] 他说他上不了上不到别的什么架构什么的
[01:01:29.200 --> 01:01:30.200] 我根本不想理他
[01:01:31.200 --> 01:01:33.200] 大家的观点是有差异的
[01:01:33.200 --> 01:01:34.200] 他会觉得自己想写个渲染器
[01:01:34.200 --> 01:01:35.200] 他确实也写过渲染器
[01:01:35.200 --> 01:01:37.200] 而且在之前签约员上面
[01:01:37.200 --> 01:01:39.200] 他去他去展示了他的渲染器
[01:01:39.200 --> 01:01:40.200] 然后我
[01:01:40.200 --> 01:01:42.200] 对但是我的话我不会觉得
[01:01:42.200 --> 01:01:44.200] 我觉得我就要快点把这个东西做出来
[01:01:44.200 --> 01:01:45.200] 然后我觉得这个东西
[01:01:45.200 --> 01:01:47.200] 我搞黄油我为什么要考虑性能
[01:01:47.200 --> 01:01:48.200] 我是不是吃多了
[01:01:48.200 --> 01:01:49.200] 对吧这点上
[01:01:49.200 --> 01:01:52.200] 然后我和他达成达不成一致
[01:01:52.200 --> 01:01:53.200] 像我的话我就会说
[01:01:53.200 --> 01:01:55.200] 看什么东西已经渲染好了
[01:01:55.200 --> 01:01:56.200] 对吧我经常听说
[01:01:56.200 --> 01:01:57.200] 之前不是个什么
[01:01:57.200 --> 01:01:59.200] 什么什么浪来着
[01:01:59.200 --> 01:02:01.200] 写冰雪奇缘什么的
[01:02:01.200 --> 01:02:02.200] 我听大家在吹那个
[01:02:02.200 --> 01:02:04.200] 对吧我能不能用一下这个东西
[01:02:04.200 --> 01:02:05.200] 对吧我能够编译过去
[01:02:05.200 --> 01:02:07.200] 我能不能用使用这些已有的东西
[01:02:07.200 --> 01:02:09.200] 对这个是挺好思路
[01:02:09.200 --> 01:02:10.200] 对对
[01:02:10.200 --> 01:02:11.200] 对啊
[01:02:11.200 --> 01:02:12.200] 对我就是说
[01:02:12.200 --> 01:02:14.200] 我的话就是组合已有的东西
[01:02:14.200 --> 01:02:15.200] 让大家觉得
[01:02:15.200 --> 01:02:16.200] 这个东西更好用
[01:02:16.200 --> 01:02:17.200] 这样就行了
[01:02:17.200 --> 01:02:19.200] 对我来说这样就够了
[01:02:19.200 --> 01:02:20.200] OK明白了
[01:02:20.200 --> 01:02:21.200] OK
[01:02:21.200 --> 01:02:23.200] 你想好了推荐的了吗
[01:02:23.200 --> 01:02:24.200] 对想好了
[01:02:24.200 --> 01:02:26.200] 那个挺好看的
[01:02:26.200 --> 01:02:27.200] 李克森
[01:02:27.200 --> 01:02:29.200] 李克森最后行往
[01:02:29.200 --> 01:02:31.200] 我知道那个很好看
[01:02:31.200 --> 01:02:33.200] 我听别人评价
[01:02:33.200 --> 01:02:34.200] 有点傻乎乎的感觉
[01:02:34.200 --> 01:02:35.200] 对是挺傻乎乎
[01:02:35.200 --> 01:02:38.200] 但是但是很好看
[01:02:38.200 --> 01:02:39.200] 很好看
[01:02:39.200 --> 01:02:41.200] 他的对他是真的是硬核
[01:02:41.200 --> 01:02:43.200] 而且他的考究是很严谨的
[01:02:43.200 --> 01:02:44.200] 对考究很严谨
[01:02:44.200 --> 01:02:45.200] 这点是真的
[01:02:45.200 --> 01:02:49.200] 对对就包括他的那个OP里面
[01:02:49.200 --> 01:02:51.200] OP里面一闪而过的
[01:02:51.200 --> 01:02:52.200] 就是说是
[01:02:52.200 --> 01:02:54.200] 还有就是他有一些画面里面
[01:02:54.200 --> 01:02:56.200] 用那个Linux去写那个写论文
[01:02:56.200 --> 01:02:59.200] 然后那个是真正的可以执行的代码
[01:02:59.200 --> 01:03:01.200] 不是就是说是像某些国产剧里面
[01:03:01.200 --> 01:03:02.200] 直接用个Hello world
[01:03:02.200 --> 01:03:04.200] 当做在黑入系统一样
[01:03:04.200 --> 01:03:06.200] 是的
[01:03:06.200 --> 01:03:08.200] 说起来那个很多新番里面
[01:03:08.200 --> 01:03:10.200] 他们都会有些代码嘛
[01:03:10.200 --> 01:03:13.200] 然后以前我还就是看过一些别人总结
[01:03:13.200 --> 01:03:15.200] 这个话题其实也蛮有意思
[01:03:15.200 --> 01:03:17.200] 我们以后也可以来聊
[01:03:17.200 --> 01:03:21.200] 好那好大家也可以去看一下
[01:03:21.200 --> 01:03:23.200] 虽然我没有看过
[01:03:23.200 --> 01:03:24.200] 但是真的好看
[01:03:24.200 --> 01:03:26.200] 我强烈推荐我和女朋友都追
[01:03:26.200 --> 01:03:28.200] 没想到你也追番
[01:03:28.200 --> 01:03:30.200] 我以为你不追番
[01:03:30.200 --> 01:03:33.200] 我看着不像追番的样子了吗
[01:03:33.200 --> 01:03:34.200] 不像啊
[01:03:34.200 --> 01:03:36.200] 不像不像
[01:03:36.200 --> 01:03:38.200] 不像我觉得这个东西
[01:03:38.200 --> 01:03:40.200] 现在也没有说谁追
[01:03:40.200 --> 01:03:42.200] 一定要追什么番
[01:03:42.200 --> 01:03:43.200] 然后像什么样子吧
[01:03:43.200 --> 01:03:44.200] 我觉得对吧
[01:03:44.200 --> 01:03:48.200] 现在感觉也不是什么老二次元之类的
[01:03:48.200 --> 01:03:51.200] 我最近在追的就是那个
[01:03:51.200 --> 01:03:54.200] 一个是三个新炮姐
[01:03:54.200 --> 01:03:56.200] 然后是还有那个李克生
[01:03:56.200 --> 01:03:58.200] 还有一个是那个强者
[01:03:58.200 --> 01:04:00.200] 过分强缺也过分谨慎
[01:04:00.200 --> 01:04:02.200] 我靠你追的我都没看
[01:04:02.200 --> 01:04:03.200] 我都不追
[01:04:03.200 --> 01:04:05.200] 都是我拒不感兴趣的
[01:04:05.200 --> 01:04:07.200] 哦哦
[01:04:07.200 --> 01:04:09.200] 那个都挺好看的
[01:04:09.200 --> 01:04:12.200] 我觉得炮姐反而倒没那么好看
[01:04:12.200 --> 01:04:14.200] 对炮姐新番其实一般
[01:04:14.200 --> 01:04:15.200] 炮姐新番真的一般
[01:04:15.200 --> 01:04:17.200] 说真的我也很推荐
[01:04:17.200 --> 01:04:18.200] 对我也很推荐
[01:04:18.200 --> 01:04:20.200] 那个我看完了小说
[01:04:20.200 --> 01:04:21.200] 对对对
[01:04:21.200 --> 01:04:23.200] 这个真的是一个很反套路的
[01:04:23.200 --> 01:04:25.200] 反正但是非常好看
[01:04:25.200 --> 01:04:27.200] 你们品位差别好大好吧
[01:04:27.200 --> 01:04:28.200] 咱们先不聊这个话题
[01:04:28.200 --> 01:04:29.200] 有点跑题
[01:04:29.200 --> 01:04:31.200] 那那主要你有没有什么要推荐
[01:04:31.200 --> 01:04:33.200] 我推荐的话
[01:04:33.200 --> 01:04:34.200] 我推荐一个酷的话
[01:04:34.200 --> 01:04:35.200] 是fast API
[01:04:35.200 --> 01:04:36.200] 对fast API
[01:04:36.200 --> 01:04:38.200] 它是最近我觉得是非常棒的
[01:04:38.200 --> 01:04:41.200] 一个web framework
[01:04:41.200 --> 01:04:43.200] 然后它的棒的第一个地方
[01:04:43.200 --> 01:04:45.200] 它是百分之百的一个
[01:04:45.200 --> 01:04:46.200] 就是说测试覆盖率
[01:04:46.200 --> 01:04:49.200] 就是说在至少在那个可靠性这一上
[01:04:49.200 --> 01:04:51.200] 是能得到一定的保证
[01:04:51.200 --> 01:04:52.200] 这个我要argue一下
[01:04:52.200 --> 01:04:55.200] 我不觉得百分之百测试覆盖率
[01:04:55.200 --> 01:04:56.200] 就等于可靠性
[01:04:56.200 --> 01:04:57.200] but anyway 你可以继续
[01:04:57.200 --> 01:04:58.200] 对对
[01:04:58.200 --> 01:05:00.200] 但是第二第二一点的话
[01:05:00.200 --> 01:05:02.200] 它是我非常喜欢的一点
[01:05:02.200 --> 01:05:03.200] 然后就是说是
[01:05:03.200 --> 01:05:06.200] 它是那个百分之百的
[01:05:06.200 --> 01:05:08.200] 那个type hint的覆盖
[01:05:08.200 --> 01:05:09.200] 这个我喜欢
[01:05:09.200 --> 01:05:10.200] 这个好这个好
[01:05:10.200 --> 01:05:11.200] 这个真的好
[01:05:11.200 --> 01:05:13.200] 这个写代码是真的舒服
[01:05:13.200 --> 01:05:15.200] 对它是百分之百
[01:05:15.200 --> 01:05:17.200] 第三个它的它的API设计
[01:05:17.200 --> 01:05:18.200] 是非常友好的
[01:05:18.200 --> 01:05:21.200] 而且它是它就说是
[01:05:21.200 --> 01:05:24.200] 它在就说是序列化与反序列化方面
[01:05:24.200 --> 01:05:26.200] 它是提供了很多
[01:05:26.200 --> 01:05:28.200] 包括工具和其他支持
[01:05:28.200 --> 01:05:29.200] 我举个例子
[01:05:29.200 --> 01:05:32.200] 就比如说我传递一个Jason进来的时候
[01:05:32.200 --> 01:05:34.200] 很多时候大家可能说是我为了把它
[01:05:34.200 --> 01:05:37.200] 序列化成一个就具体的一个python object
[01:05:37.200 --> 01:05:41.200] 然后来就是说是以便我自己在IDE里面去编辑
[01:05:41.200 --> 01:05:43.200] 以及说是可读性上的获得的优势
[01:05:43.200 --> 01:05:46.200] 那么我需要去引入很多第三方的东西
[01:05:46.200 --> 01:05:48.200] 而在fastAPI这一块的话
[01:05:48.200 --> 01:05:50.200] 它是直接内置的
[01:05:50.200 --> 01:05:52.200] 然后第四个的话是
[01:05:52.200 --> 01:05:54.200] 它提供了周边很好用的工具
[01:05:54.200 --> 01:05:56.200] 就比如说它内置的一个
[01:05:56.200 --> 01:05:57.200] 就是时代web界面
[01:05:57.200 --> 01:05:59.200] 就类似于Sugar这种
[01:05:59.200 --> 01:06:01.200] 就说是一个
[01:06:01.200 --> 01:06:06.200] 就是它支持一个完整的OpenAPI2.0的这样一个接口说明
[01:06:06.200 --> 01:06:07.200] 就说你写完接口
[01:06:07.200 --> 01:06:10.200] 它就是一个文档了
[01:06:10.200 --> 01:06:12.200] 然后包括它还支持
[01:06:12.200 --> 01:06:14.200] 就比如说像可能说在其他语言里面
[01:06:14.200 --> 01:06:17.200] 常见的一些dependency ejection这样的一个东西
[01:06:17.200 --> 01:06:20.200] 就是依赖注入这样的一些东西
[01:06:20.200 --> 01:06:22.200] 我觉得它是一个非常现代化的
[01:06:22.200 --> 01:06:23.200] 然后也是非常好用
[01:06:23.200 --> 01:06:24.200] 它工具很齐备
[01:06:24.200 --> 01:06:29.200] 然后API设计非常友好的一个webframework
[01:06:29.200 --> 01:06:31.200] 它是Python的吗
[01:06:31.200 --> 01:06:32.200] Python
[01:06:32.200 --> 01:06:33.200] PythonOK
[01:06:33.200 --> 01:06:34.200] 对100%
[01:06:34.200 --> 01:06:38.200] 我最觉得最刺激我的就是100%的Type hint覆盖
[01:06:38.200 --> 01:06:40.200] 而且它是支持WSGI的
[01:06:40.200 --> 01:06:43.200] 那个传统的webWSGI模式
[01:06:43.200 --> 01:06:45.200] 也支持新的就是那个
[01:06:45.200 --> 01:06:48.200] Jungle提出的那个ASGI的模式
[01:06:48.200 --> 01:06:49.200] ASGI
[01:06:49.200 --> 01:06:51.200] 对它是双两种模式都支持的
[01:06:51.200 --> 01:06:53.200] 反正我觉得是非常棒
[01:06:53.200 --> 01:06:54.200] 我有个问题
[01:06:54.200 --> 01:06:58.200] 它怎么定义100%的Type hint覆盖
[01:06:58.200 --> 01:07:00.200] 这一点我只是
[01:07:00.200 --> 01:07:02.200] 这点可以做到
[01:07:02.200 --> 01:07:03.200] 我就是怎么去验证它
[01:07:03.200 --> 01:07:04.200] 我觉得我有想法
[01:07:04.200 --> 01:07:06.200] 张力要说吗
[01:07:06.200 --> 01:07:07.200] 红姐你先来
[01:07:07.200 --> 01:07:09.200] OK
[01:07:09.200 --> 01:07:12.200] 就是说你任何在
[01:07:12.200 --> 01:07:14.200] 就是说你使用它这个代码的时候
[01:07:14.200 --> 01:07:20.200] 你任何在你自己在进行必要Type hint的情况下
[01:07:20.200 --> 01:07:22.200] 它一定能够推出正确类型
[01:07:22.200 --> 01:07:23.200] 我同意
[01:07:23.200 --> 01:07:25.200] 然后我自己
[01:07:25.200 --> 01:07:26.200] 什么意思
[01:07:26.200 --> 01:07:27.200] 没懂
[01:07:27.200 --> 01:07:29.200] 就是说当你自己比方说
[01:07:29.200 --> 01:07:30.200] 我在写这个python代码
[01:07:30.200 --> 01:07:31.200] 我在使用它的时候
[01:07:31.200 --> 01:07:35.200] 当我自己的代码是正确的被那个hints过的
[01:07:35.200 --> 01:07:37.200] 然后我的这个代码的表达力
[01:07:37.200 --> 01:07:39.200] 是不超过它这个类型系统的时候
[01:07:39.200 --> 01:07:40.200] 它所有的代码
[01:07:40.200 --> 01:07:43.200] 然后你在你的所有的表达式
[01:07:43.200 --> 01:07:45.200] 都应该能够正确的推出类型
[01:07:45.200 --> 01:07:46.200] 我理解你的意思
[01:07:46.200 --> 01:07:47.200] 对
[01:07:47.200 --> 01:07:49.200] 然后我的那个定义其实是
[01:07:49.200 --> 01:07:51.200] 跟红姐是可能相比
[01:07:51.200 --> 01:07:52.200] 可能稍微肤浅一点
[01:07:52.200 --> 01:07:53.200] 我其实定义很简单
[01:07:53.200 --> 01:07:55.200] 就是说两个层面
[01:07:55.200 --> 01:07:58.200] 第一个就是说是你所有的内置类型都是
[01:07:58.200 --> 01:07:59.200] 就是内置类型
[01:07:59.200 --> 01:08:02.200] 你自己内部的数据结构里面的Field
[01:08:02.200 --> 01:08:03.200] 所有东西
[01:08:03.200 --> 01:08:05.200] 我在不去看你具体的逻辑之前
[01:08:05.200 --> 01:08:07.200] 我能够一眼得出你这个
[01:08:07.200 --> 01:08:09.200] 整体的结构以及类型
[01:08:09.200 --> 01:08:11.200] 第二个是你所有的方法
[01:08:11.200 --> 01:08:13.200] 不管是方法还是函数
[01:08:13.200 --> 01:08:15.200] 然后我在不去看你具体的body之前
[01:08:15.200 --> 01:08:16.200] 我能够得到
[01:08:16.200 --> 01:08:18.200] 就是说是传入输出信息
[01:08:18.200 --> 01:08:19.200] 我觉得这个东西
[01:08:19.200 --> 01:08:23.200] 他就是如果说我里面我说看过
[01:08:23.200 --> 01:08:25.200] 他里面所有代码能达到这样的目的
[01:08:25.200 --> 01:08:27.200] 那么我觉得他是百分之百覆盖的
[01:08:27.200 --> 01:08:29.200] 对那你这个是在看
[01:08:29.200 --> 01:08:32.200] 我内心及文档这个确实很好
[01:08:32.200 --> 01:08:33.200] 但我还关注是另一点
[01:08:33.200 --> 01:08:35.200] 想问你可能你是否还使用过这个库
[01:08:35.200 --> 01:08:37.200] 我觉得他使用上应该有更舒服的一点
[01:08:37.200 --> 01:08:40.200] 就是说你任何东西点一下都会有
[01:08:40.200 --> 01:08:41.200] 都会有补充
[01:08:41.200 --> 01:08:42.200] 是的
[01:08:42.200 --> 01:08:43.200] 我就是很喜欢
[01:08:43.200 --> 01:08:46.200] 因为他对他自己一个引以为傲的点
[01:08:46.200 --> 01:08:49.200] 就是那个IDE friendly
[01:08:49.200 --> 01:08:51.200] 就是那个IDE友好
[01:08:51.200 --> 01:08:53.200] 就是说因为大家都知道Python
[01:08:53.200 --> 01:08:54.200] 其实之前是动态类型
[01:08:54.200 --> 01:08:56.200] 你可以中途hook
[01:08:56.200 --> 01:08:58.200] 就是说是很多类型是在
[01:08:58.200 --> 01:09:00.200] 就是对于编辑器很不友好
[01:09:00.200 --> 01:09:02.200] 然后而是而他的话
[01:09:02.200 --> 01:09:03.200] 就是说是你编辑器
[01:09:03.200 --> 01:09:05.200] 就是说只要是他内部的东西
[01:09:05.200 --> 01:09:07.200] 你一定够了编辑器
[01:09:07.200 --> 01:09:09.200] 一定能够得出具体的信息
[01:09:09.200 --> 01:09:11.200] 非常舒服
[01:09:11.200 --> 01:09:13.200] 这个其实就是有type hint保证的是吧
[01:09:13.200 --> 01:09:14.200] 是的
[01:09:14.200 --> 01:09:17.200] 对但这点其实现在很难做快的
[01:09:17.200 --> 01:09:19.200] 因为像PyCharm的话
[01:09:19.200 --> 01:09:21.200] 他支持的这个类型并不是很高级
[01:09:21.200 --> 01:09:23.200] 就现在已经被mypy反超了
[01:09:23.200 --> 01:09:25.200] 所以他能做这点
[01:09:25.200 --> 01:09:30.200] 其实应该是挺挺挺挺花很大精力的
[01:09:30.200 --> 01:09:31.200] 应该是
[01:09:31.200 --> 01:09:34.200] 不是你但是这个IDE friendly
[01:09:34.200 --> 01:09:36.200] 难道不就是你把type hint
[01:09:36.200 --> 01:09:38.200] 比如说我就能写type hint的地方
[01:09:38.200 --> 01:09:40.200] 我全写上了不就能保证了吗
[01:09:40.200 --> 01:09:41.200] 难道不是这样吗
[01:09:41.200 --> 01:09:42.200] 并不一定
[01:09:42.200 --> 01:09:44.200] 因为有些时候就是我举例子
[01:09:44.200 --> 01:09:46.200] 比方说我们现在有个函数
[01:09:46.200 --> 01:09:48.200] 就是IO的open函数
[01:09:48.200 --> 01:09:49.200] 他有些参数
[01:09:49.200 --> 01:09:51.200] 他是根据他的返回值
[01:09:51.200 --> 01:09:53.200] 是根据他的值的类型去判断的
[01:09:53.200 --> 01:09:56.200] 依赖类型就是我对我判断
[01:09:56.200 --> 01:09:57.200] 是我open的时候
[01:09:57.200 --> 01:09:58.200] 对吧我的值
[01:09:58.200 --> 01:10:00.200] 我传入的是这个
[01:10:00.200 --> 01:10:02.200] 写是写是w
[01:10:02.200 --> 01:10:05.200] 那么他返回的类型可能就不一样
[01:10:05.200 --> 01:10:06.200] 返回的是wb
[01:10:06.200 --> 01:10:07.200] 他返回类型不一样
[01:10:07.200 --> 01:10:10.200] 对r和rb也是不一样的
[01:10:10.200 --> 01:10:12.200] 对
[01:10:12.200 --> 01:10:13.200] 会有这样的问题
[01:10:13.200 --> 01:10:15.200] 不是我的意思就是说
[01:10:15.200 --> 01:10:17.200] 他的API friendly
[01:10:17.200 --> 01:10:18.200] 他达到这点
[01:10:18.200 --> 01:10:20.200] 然后在他这个fast API
[01:10:20.200 --> 01:10:23.200] 库本身上他做了的东西是什么
[01:10:23.200 --> 01:10:24.200] 就是说
[01:10:24.200 --> 01:10:25.200] 他可能不能用
[01:10:25.200 --> 01:10:26.200] 就是说
[01:10:26.200 --> 01:10:27.200] 比方说你在
[01:10:27.200 --> 01:10:29.200] 本身mypy提供了非常高级的东西
[01:10:29.200 --> 01:10:31.200] 能够去让你写的很舒服
[01:10:31.200 --> 01:10:33.200] 但是你为了兼容所有的ID
[01:10:33.200 --> 01:10:34.200] 你可能并不能那样做
[01:10:34.200 --> 01:10:36.200] 就好像我们在写python的时候
[01:10:36.200 --> 01:10:37.200] 对吧你为了兼容性
[01:10:37.200 --> 01:10:39.200] 你不能去用3.7的特性
[01:10:39.200 --> 01:10:41.200] 你必须用3.5的3.4的
[01:10:41.200 --> 01:10:43.200] 都有人用了东西
[01:10:43.200 --> 01:10:45.200] 你说的mypy提供了的
[01:10:45.200 --> 01:10:48.200] 然后其他东西没提供的是有什么
[01:10:48.200 --> 01:10:52.200] 我还真不是很清楚
[01:10:52.200 --> 01:10:54.200] 这个东西就是我刚刚
[01:10:54.200 --> 01:10:55.200] 我刚刚举的例子就是那个
[01:10:55.200 --> 01:10:56.200] 就是literal type
[01:10:56.200 --> 01:10:57.200] 就是字面量类型
[01:10:57.200 --> 01:10:59.200] 但字面量类型在
[01:10:59.200 --> 01:11:01.200] 就是说你只要想用的话
[01:11:01.200 --> 01:11:02.200] 现在已经可以用了
[01:11:02.200 --> 01:11:03.200] 3.8类是有的
[01:11:03.200 --> 01:11:04.200] 在pycharm里面的话
[01:11:04.200 --> 01:11:08.200] 是他可能还不太不是特别好的支持
[01:11:08.200 --> 01:11:10.200] 对pycharm现在支持
[01:11:10.200 --> 01:11:12.200] 对支持支持不太好
[01:11:12.200 --> 01:11:13.200] 还有就是比方说
[01:11:13.200 --> 01:11:15.200] 我们的我举例子
[01:11:15.200 --> 01:11:17.200] 比方说这个colabotype
[01:11:17.200 --> 01:11:20.200] 这种东西你在pycharm里面做
[01:11:20.200 --> 01:11:22.200] 做anias你做typeanias
[01:11:22.200 --> 01:11:24.200] 在mypy里面是完全work的
[01:11:24.200 --> 01:11:25.200] 但在pycharm里面
[01:11:25.200 --> 01:11:26.200] 它是不行的
[01:11:26.200 --> 01:11:27.200] pycharm其实很多都是
[01:11:27.200 --> 01:11:29.200] 它的都很不稳定
[01:11:29.200 --> 01:11:30.200] 就是它的这种用法
[01:11:30.200 --> 01:11:32.200] 就是你稍微改一下写法
[01:11:32.200 --> 01:11:34.200] 它可能就不能用了
[01:11:34.200 --> 01:11:37.200] 对所以你要去让它全部work通
[01:11:37.200 --> 01:11:39.200] 这些事情其实并不是那么好
[01:11:39.200 --> 01:11:41.200] 但是这个都就说
[01:11:41.200 --> 01:11:43.200] 我还是没有理解fast ABI
[01:11:43.200 --> 01:11:44.200] 它本身要做什么
[01:11:44.200 --> 01:11:46.200] 因为你说这些都是typechecker
[01:11:46.200 --> 01:11:47.200] 做的事情对吧
[01:11:47.200 --> 01:11:50.200] 对他他就是要支持所有typechecker
[01:11:50.200 --> 01:11:52.200] 那他支持他除了就是说写
[01:11:52.200 --> 01:11:54.200] 他写typehint
[01:11:54.200 --> 01:11:56.200] 他还要做什么
[01:11:56.200 --> 01:11:57.200] typehint写的时候
[01:11:57.200 --> 01:11:58.200] 有简单有复杂写法
[01:11:58.200 --> 01:11:59.200] 对吧对吧
[01:11:59.200 --> 01:12:01.200] 比方说我写我标那件事
[01:12:01.200 --> 01:12:03.200] 我写我写一个词
[01:12:03.200 --> 01:12:05.200] 比如我写我每次都要去构造
[01:12:05.200 --> 01:12:06.200] 一个很长的colabotype
[01:12:06.200 --> 01:12:08.200] 那其实这个时候很痛苦的
[01:12:08.200 --> 01:12:10.200] 哦我理解你的意思
[01:12:10.200 --> 01:12:12.200] 就是OK我理解你意思
[01:12:12.200 --> 01:12:14.200] 就是说像一套它有
[01:12:14.200 --> 01:12:17.200] 它的typehint的写法
[01:12:17.200 --> 01:12:19.200] 是能够让所有IDE都理解的
[01:12:19.200 --> 01:12:21.200] 就这点是比较难
[01:12:21.200 --> 01:12:22.200] OKOK
[01:12:22.200 --> 01:12:23.200] 对比如说我举个
[01:12:23.200 --> 01:12:26.200] 我不知道我是这个举个例子对不对
[01:12:26.200 --> 01:12:27.200] 就比如说
[01:12:27.200 --> 01:12:28.200] 但就是那个我就
[01:12:28.200 --> 01:12:30.200] 然后就比如说我
[01:12:30.200 --> 01:12:32.200] 我返回一个值的时候
[01:12:32.200 --> 01:12:33.200] 它既然可能是空
[01:12:33.200 --> 01:12:34.200] 可能是其他
[01:12:34.200 --> 01:12:35.200] 那么我直接返回空
[01:12:35.200 --> 01:12:38.200] 其实在某些检查器里面
[01:12:38.200 --> 01:12:39.200] 它是可以的
[01:12:39.200 --> 01:12:41.200] 就是说是你直接返回空值
[01:12:41.200 --> 01:12:42.200] 也是允许的
[01:12:42.200 --> 01:12:43.200] 然后但是在那个
[01:12:43.200 --> 01:12:44.200] 另外一些IDE里面
[01:12:44.200 --> 01:12:45.200] 你就必须要显示了
[01:12:45.200 --> 01:12:47.200] 去有optional的指定
[01:12:47.200 --> 01:12:49.200] 然后你的返回空才是合法的
[01:12:49.200 --> 01:12:50.200] 所以说是这个地方
[01:12:50.200 --> 01:12:51.200] 可能就是这样一个
[01:12:51.200 --> 01:12:52.200] 就是说是你需要
[01:12:52.200 --> 01:12:53.200] 最不同的检查机制
[01:12:53.200 --> 01:12:56.200] 做一个一个就是说是兼容
[01:12:56.200 --> 01:12:57.200] 那我怎么兼容呢
[01:12:57.200 --> 01:12:58.200] 就是写optional呗
[01:12:58.200 --> 01:13:00.200] 你本来可以不用写optional
[01:13:00.200 --> 01:13:02.200] 但是你为了兼容一些
[01:13:02.200 --> 01:13:04.200] 对对对
[01:13:04.200 --> 01:13:06.200] OK理解了
[01:13:07.200 --> 01:13:08.200] 对行
[01:13:09.200 --> 01:13:10.200] 哦
[01:13:10.200 --> 01:13:11.200] 我们聊了好多
[01:13:11.200 --> 01:13:12.200] 就是跟fastAPI
[01:13:12.200 --> 01:13:14.200] 好像不是直接有关
[01:13:14.200 --> 01:13:15.200] but anyway
[01:13:15.200 --> 01:13:16.200] 就是其实我觉得
[01:13:16.200 --> 01:13:17.200] 这些讨论都很有意思
[01:13:17.200 --> 01:13:18.200] 好然后我这边
[01:13:18.200 --> 01:13:19.200] 其实一下也想不到
[01:13:19.200 --> 01:13:21.200] 有什么要推荐的
[01:13:21.200 --> 01:13:23.200] 但是
[01:13:23.200 --> 01:13:25.200] 对那我就不推荐了
[01:13:25.200 --> 01:13:28.200] 然后我们也差不多录了这么多
[01:13:28.200 --> 01:13:31.200] 那最后还是请红姐
[01:13:31.200 --> 01:13:32.200] 来
[01:13:32.200 --> 01:13:34.200] 看看有没有什么话
[01:13:34.200 --> 01:13:36.200] 对于一些就是其他程序员
[01:13:36.200 --> 01:13:39.200] 尤其是编程的初学者的建议
[01:13:39.200 --> 01:13:40.200] 或者说这样
[01:13:40.200 --> 01:13:43.200] 就我们也会问嘉宾一些这种问题
[01:13:43.200 --> 01:13:45.200] 怎么说我感觉
[01:13:45.200 --> 01:13:47.200] 我感觉你每次都问我这个问题
[01:13:47.200 --> 01:13:48.200] 对对对
[01:13:48.200 --> 01:13:49.200] 因为我们在博客
[01:13:49.200 --> 01:13:51.200] 可能上次在Packhung问过你
[01:13:51.200 --> 01:13:53.200] 但是这个博客里也会问的
[01:13:53.200 --> 01:13:54.200] 对
[01:13:54.200 --> 01:13:56.200] 好吧
[01:13:56.200 --> 01:13:58.200] 就是我还是那句话
[01:13:58.200 --> 01:14:00.200] 就是第一个还是
[01:14:00.200 --> 01:14:02.200] 这个Coding Style之类的问题
[01:14:02.200 --> 01:14:04.200] 要重视
[01:14:04.200 --> 01:14:06.200] 然后就是
[01:14:06.200 --> 01:14:09.200] 敲码画还是要有兴趣吧
[01:14:09.200 --> 01:14:11.200] 就是要找到自己特别喜欢的东西
[01:14:11.200 --> 01:14:12.200] 一定要去
[01:14:12.200 --> 01:14:16.200] 要强力让自己去找到这种
[01:14:16.200 --> 01:14:19.200] 让自己有强烈的现身感的东西
[01:14:19.200 --> 01:14:20.200] 是不是你的意思就是
[01:14:20.200 --> 01:14:21.200] 如果你对代码不感兴趣
[01:14:21.200 --> 01:14:23.200] 那就不要敲了
[01:14:23.200 --> 01:14:24.200] 也不能这样说吧
[01:14:24.200 --> 01:14:26.200] 因为毕竟
[01:14:26.200 --> 01:14:27.200] 对吧
[01:14:27.200 --> 01:14:29.200] 作为现在比较少的一种
[01:14:29.200 --> 01:14:31.200] 就是真的能靠实力吃饭的
[01:14:31.200 --> 01:14:32.200] 一个
[01:14:32.200 --> 01:14:34.200] 一种职业吧
[01:14:34.200 --> 01:14:36.200] 我觉得
[01:14:36.200 --> 01:14:38.200] 尽量能去找到这样的东西
[01:14:38.200 --> 01:14:39.200] 我是这样推荐就是
[01:14:39.200 --> 01:14:41.200] 因为这其实并不难
[01:14:41.200 --> 01:14:43.200] 我觉得因为人人都有自己喜欢的东西
[01:14:43.200 --> 01:14:44.200] 对吧
[01:14:44.200 --> 01:14:45.200] 现在编程的技术
[01:14:45.200 --> 01:14:47.200] 真的是和很多东西的交
[01:14:47.200 --> 01:14:48.200] 的沟通是很深的
[01:14:48.200 --> 01:14:50.200] 就是如果你有自己想要做的东西
[01:14:50.200 --> 01:14:53.200] 你可以尝试去用编程去解决它
[01:14:53.200 --> 01:14:54.200] 对吧
[01:14:54.200 --> 01:14:56.200] 这种一定会产生某种
[01:14:56.200 --> 01:14:57.200] 就是兴趣上的
[01:14:57.200 --> 01:14:59.200] 这种迸发
[01:14:59.200 --> 01:15:00.200] 对吧
[01:15:00.200 --> 01:15:01.200] 你想我开始
[01:15:01.200 --> 01:15:03.200] 我开始也想做人工智能
[01:15:03.200 --> 01:15:04.200] 虽然说我的梦想
[01:15:04.200 --> 01:15:06.200] 最后现在是
[01:15:06.200 --> 01:15:07.200] 就是
[01:15:07.200 --> 01:15:09.200] 没有最后延续下去
[01:15:09.200 --> 01:15:10.200] 这种
[01:15:10.200 --> 01:15:11.200] 就没有成为我的主业
[01:15:11.200 --> 01:15:13.200] 但实际上它确实推动了我
[01:15:13.200 --> 01:15:14.200] 就是达到
[01:15:14.200 --> 01:15:15.200] 先达到某种水平
[01:15:15.200 --> 01:15:16.200] 对
[01:15:16.200 --> 01:15:17.200] 对
[01:15:17.200 --> 01:15:18.200] 所以也不要
[01:15:18.200 --> 01:15:19.200] 不要有什么心理负担
[01:15:19.200 --> 01:15:21.200] 就是说我一定要去实现它
[01:15:21.200 --> 01:15:22.200] 对吧
[01:15:22.200 --> 01:15:23.200] 先去做就不要去考虑那么多了
[01:15:23.200 --> 01:15:26.200] 就是先感受这种奋斗的过程
[01:15:26.200 --> 01:15:27.200] 是很舒服的
[01:15:27.200 --> 01:15:27.200] 对
[01:15:27.200 --> 01:15:28.200] 我觉得那段时间
[01:15:28.200 --> 01:15:29.200] 我学习最快的那段时间
[01:15:29.200 --> 01:15:30.200] 其实真的很快了
[01:15:30.200 --> 01:15:31.200] 对
[01:15:31.200 --> 01:15:33.200] 到现在就是每天看论文
[01:15:33.200 --> 01:15:34.200] 痛的痛苦的不行
[01:15:34.200 --> 01:15:35.200] 真的很痛苦
[01:15:35.200 --> 01:15:36.200] 就是
[01:15:36.200 --> 01:15:37.200] 就
[01:15:37.200 --> 01:15:38.200] 就我
[01:15:38.200 --> 01:15:39.200] 我还从来
[01:15:39.200 --> 01:15:40.200] 我上个月
[01:15:40.200 --> 01:15:40.200] 对
[01:15:40.200 --> 01:15:41.200] 我就是一月
[01:15:41.200 --> 01:15:42.200] 一月初真的是第一次感受到
[01:15:42.200 --> 01:15:44.200] 我自己看不懂的论文
[01:15:44.200 --> 01:15:46.200] 就是这种因为以前都很自大
[01:15:46.200 --> 01:15:47.200] 后面真的发现看不懂的论文的时候
[01:15:47.200 --> 01:15:48.200] 就会觉得
[01:15:48.200 --> 01:15:50.200] 还是以前刚开始学的时候
[01:15:50.200 --> 01:15:52.200] 这段时间真的是上升很快
[01:15:52.200 --> 01:15:53.200] 对
[01:15:53.200 --> 01:15:54.200] 对
[01:15:54.200 --> 01:15:56.200] 这段时间在学习上对自己价值更大
[01:15:56.200 --> 01:15:57.200] 其实因为我看不懂这篇论文
[01:15:57.200 --> 01:15:58.200] 我可以跳
[01:15:58.200 --> 01:15:59.200] 我真的没那么必要
[01:15:59.200 --> 01:16:01.200] 但是在你真正上升期的时候
[01:16:01.200 --> 01:16:03.200] 你在学很多基础东西的时候
[01:16:03.200 --> 01:16:04.200] 那些东西对你来说
[01:16:04.200 --> 01:16:05.200] 其实是更essential的
[01:16:05.200 --> 01:16:06.200] 就是更
[01:16:06.200 --> 01:16:07.200] 真的是更
[01:16:07.200 --> 01:16:08.200] 更影响你未来
[01:16:08.200 --> 01:16:10.200] 更多的东西
[01:16:10.200 --> 01:16:11.200] 不像说我现在
[01:16:11.200 --> 01:16:12.200] 我真的看不懂了
[01:16:12.200 --> 01:16:13.200] 我可以放掉它
[01:16:13.200 --> 01:16:14.200] 好
[01:16:14.200 --> 01:16:15.200] 那好
[01:16:15.200 --> 01:16:17.200] 那我们就录到这样吧
[01:16:17.200 --> 01:16:20.200] 然后也是谢谢洪姐来参与我们的节目
[01:16:20.200 --> 01:16:21.200] 然后也谢谢主要
[01:16:21.200 --> 01:16:22.200] 对
[01:16:22.200 --> 01:16:23.200] 洪姐辛苦
[01:16:23.200 --> 01:16:24.200] 今天去休息
[01:16:24.200 --> 01:16:25.200] 别猝死了
[01:16:25.200 --> 01:16:25.200] 好
[01:16:25.200 --> 01:16:26.200] 各位听众
[01:16:26.200 --> 01:16:27.200] 我们下期再见
[01:16:27.200 --> 01:16:29.200] 拜拜
[01:16:30.200 --> 01:16:31.200] 好
[01:16:31.200 --> 01:16:31.200] 本期捕蛇
[01:16:31.200 --> 01:16:32.200] 惹獸的
[01:16:32.200 --> 01:16:33.200] 播客
[01:16:33.200 --> 01:16:34.200] 就到这里
[01:16:34.200 --> 01:16:35.200] 感谢您的收听
[01:16:35.200 --> 01:16:36.200] 本期内容中提到的资料链接
[01:16:36.200 --> 01:16:37.200] 都会放到我们的网站上
[01:16:37.200 --> 01:16:38.200] 我们的
[01:16:38.200 --> 01:16:40.200] 网址是pythonhunter.org
[01:16:40.200 --> 01:16:43.200] 由于我们主播的直库账号被禁
[01:16:43.200 --> 01:16:45.200] 所以以后的更新都不会再
[01:16:45.200 --> 01:16:46.200] 发布到直库上
[01:16:46.200 --> 01:16:47.200] 请您留意
[01:16:47.200 --> 01:16:48.200] 推荐您使用
[01:16:48.200 --> 01:16:49.200] 万用型客户端
[01:16:49.200 --> 01:16:51.200] 订阅我们的播客
[01:16:51.200 --> 01:16:52.200] 也欢迎您关注
[01:16:52.200 --> 01:16:55.400] 加入我们的Telegram群组和其他听众一起聊天
[01:16:55.400 --> 01:16:58.900] 我们的推特是PythonHunter加一个下滑线
[01:16:58.900 --> 01:17:02.300] Telegram群组的链接可以在我们的网站上找到
[01:17:02.300 --> 01:17:22.300] 我们下期再见
