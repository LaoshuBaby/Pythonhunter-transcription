[00:00.000 --> 00:20.000] 本节目由红十字会主持人提供的字幕
[00:20.000 --> 00:22.000] 各位听众,大家好。
[00:22.000 --> 00:25.000] 欢迎来到最新一期的《捕蛇者说》。
[00:25.000 --> 00:28.000] 我们今天的嘉宾是明西。
[00:28.000 --> 00:33.000] 明西也是之前上过我们第15期节目的嘉宾。
[00:33.000 --> 00:36.000] 然后我们另一位主播是赖清涛。
[00:36.000 --> 00:38.000] 先给大家打个招呼。
[00:38.000 --> 00:42.000] 大家好,我是清涛。好久不见。
[00:42.000 --> 00:46.000] 然后今天我们请明西来,
[00:46.000 --> 00:49.000] 自然还是要聊一下包管理相关的话题。
[00:49.000 --> 00:52.000] 不过我们今天会把重点放在他
[00:52.000 --> 00:56.000] 这两三年来一直在开发的一个包管理工具,
[00:56.000 --> 00:58.000] 也就是PDM上。
[00:58.000 --> 01:02.000] 我们先请明西来做一下自我介绍吧。
[01:02.000 --> 01:05.000] 大家好,我是明西。
[01:05.000 --> 01:08.000] 我也是在两年前吧,
[01:08.000 --> 01:11.000] 也是参加过我们《捕蛇者说》的录制。
[01:11.000 --> 01:16.000] 当时的话,对,我是一个Python开发,
[01:16.000 --> 01:22.000] 然后是PYPA,Python打包委员会的一个成员吧。
[01:22.000 --> 01:26.000] 我平常的话就是致力于改善
[01:26.000 --> 01:28.000] 这个Python打包的一个生态。
[01:28.000 --> 01:31.000] 当时上一次来参加的时候,
[01:31.000 --> 01:35.000] 当时PDM可能才诞生几个月左右。
[01:35.000 --> 01:40.000] 所以这次的话可能会更有机会来详细的说一下
[01:40.000 --> 01:45.000] 这个比当时来说更加成熟的一个项目。
[01:45.000 --> 01:47.000] 好的,欢迎明西。
[01:47.000 --> 01:51.000] 然后明西也是我们为数不多来参加过多期节目。
[01:51.000 --> 01:54.000] 感觉时光飞逝,两年一下子就过去了。
[01:54.000 --> 01:56.000] 对,我刚刚也听到两年,
[01:56.000 --> 01:58.000] 觉得哇,过这么久了吗?
[01:58.000 --> 02:00.000] 我觉得只有一年。
[02:00.000 --> 02:04.000] 好,那我们就直接进入正题讲一下PDM。
[02:04.000 --> 02:08.000] 首先就是如果你不写Python,
[02:08.000 --> 02:13.000] 或者说没有很关注Python这边新的工具的话,
[02:13.000 --> 02:15.000] 可能对PDM不是非常熟悉。
[02:15.000 --> 02:19.000] 那么PDM的全称是Python Development Master。
[02:19.000 --> 02:24.000] 它是一个可以和比如说Portrait
[02:24.000 --> 02:27.000] 或者PPMV对标的一个包管理工具。
[02:27.000 --> 02:31.000] 那么我们还是想先请明西从他的角度来
[02:31.000 --> 02:34.000] 简单对PDM做一个介绍。
[02:34.000 --> 02:36.000] 先交给你。
[02:36.000 --> 02:40.000] 好的,在开始做PDM的时候,
[02:40.000 --> 02:45.000] 我只是想去试验一下就是Python里面
[02:45.000 --> 02:48.000] 关于包管理的最新几个标准。
[02:48.000 --> 02:51.000] 因为Python包管理这一块呢,
[02:51.000 --> 02:56.000] 其实从18年以后已经有很大的变化,
[02:56.000 --> 02:59.000] 也是和之前的方式完全不一样。
[02:59.000 --> 03:03.000] 所以其实如果要我来定位PDM的话,
[03:03.000 --> 03:08.000] 它其实是一个聚焦于最新打包规范的
[03:08.000 --> 03:11.000] 这么一个新式的包管理器吧。
[03:12.000 --> 03:14.000] 那既然你到新式的话,
[03:14.000 --> 03:17.000] 就是我们自然问题就是旧式代表。
[03:17.000 --> 03:23.000] 旧式的话,如果大家从2.7时代过来,
[03:23.000 --> 03:26.000] 或者是从几年前就开始用Python的话,
[03:26.000 --> 03:30.000] 我们如果去看很多开源项目的话,
[03:30.000 --> 03:33.000] 我们可能习惯于说把它clone下来,
[03:33.000 --> 03:36.000] 然后run一个Python,
[03:36.000 --> 03:39.000] setup.py.install,
[03:39.000 --> 03:43.000] 或者setup.py.develop,
[03:43.000 --> 03:45.000] 这种方式去安装。
[03:45.000 --> 03:47.000] 那其实这种方式呢,
[03:47.000 --> 03:51.000] 我们在最新的规范里已经是不被推荐了。
[03:51.000 --> 03:52.000] 也就是说,
[03:52.000 --> 03:54.000] setup.py这个脚本文件呢,
[03:54.000 --> 03:56.000] 它其实是tool specific,
[03:56.000 --> 04:02.000] 它是setup.tools这个工具专用的一个
[04:02.000 --> 04:05.000] 原数据的描述文件。
[04:05.000 --> 04:09.000] 那其实最新的打包规范来说,
[04:09.000 --> 04:13.000] 是我们不用去关注你使用的打包工具是
[04:13.000 --> 04:14.000] setup.tools,
[04:14.000 --> 04:16.000] 或者是其他的什么东西。
[04:16.000 --> 04:18.000] 我们不需要去关心这个,
[04:18.000 --> 04:22.000] 因为我们已经有实现一个标准化的协议,
[04:22.000 --> 04:26.000] 去把这种工具化的差异给抹除掉,
[04:26.000 --> 04:27.000] 使得我们前端,
[04:27.000 --> 04:29.000] 就不需要关注这些,
[04:29.000 --> 04:31.000] 你使用什么工具。
[04:31.000 --> 04:33.000] 那是不是可以,
[04:33.000 --> 04:35.000] 就是从我的角度看,
[04:35.000 --> 04:39.000] 我觉得可能新式的python包管理工具,
[04:39.000 --> 04:43.000] 或者新式的python包管理的流程都有几个特征吧,
[04:43.000 --> 04:46.000] 就是首先我们肯定是用一个toml文件,
[04:46.000 --> 04:49.000] pyproject.toml来定义一些原数据,
[04:49.000 --> 04:50.000] 然后呢,
[04:50.000 --> 04:51.000] 然后呢,
[04:51.000 --> 04:52.000] 然后呢,
[04:52.000 --> 04:53.000] 然后呢,
[04:53.000 --> 04:54.000] 然后呢,
[04:54.000 --> 04:55.000] 然后呢,
[04:55.000 --> 04:56.000] 然后呢,
[04:56.000 --> 04:57.000] 然后呢,
[04:57.000 --> 04:58.000] 然后呢,
[04:58.000 --> 04:59.000] 然后呢,
[04:59.000 --> 05:01.000] 然后 steals.pyprojectctoml,
[05:01.000 --> 05:02.000] 来定义一些原数据,
[05:02.000 --> 05:03.000] 包括各种的一赖。
[05:03.000 --> 05:07.000] 然后另外一个特征可能是有一个Log file,
[05:07.000 --> 05:09.000] 就是很相应于每个库,
[05:09.000 --> 05:12.000] 然后每个一赖它是什么版本,
[05:12.000 --> 05:14.000] 然后都写在Log file里,
[05:14.000 --> 05:16.000] 然后不知道有没有,
[05:16.000 --> 05:17.000] 有没有什么别的,
[05:17.000 --> 05:19.000] 我们有没有什么别的,
[05:19.000 --> 05:20.000] 也就是说,
[05:20.000 --> 05:22.000] 比较重要的现代python包管ploy 你特征吗?
[05:22.000 --> 05:23.000] 是pyprojectctoml,
[05:23.000 --> 05:24.000] 一个是Log file,
[05:24.000 --> 05:29.000] 其实这两个也是属于解决两个不同的问题,
[05:29.000 --> 05:31.000] 我们首先说打包,
[05:31.000 --> 05:33.000] 打包标准化这一方面呢,
[05:33.000 --> 05:36.000] 是pyprojectctoml,
[05:36.000 --> 05:40.000] 这个文件逐渐的成为标准的原数据描述文件,
[05:40.000 --> 05:44.000] 也就是PP518里面所规定的内容,
[05:44.000 --> 05:49.000] 这里面现在支持这个文件格式的,
[05:49.000 --> 05:54.000] 大概有flit poetry和hash,
[05:54.000 --> 05:57.000] 以及PDM这几个,
[05:57.000 --> 05:59.000] 那Log file,
[05:59.000 --> 06:03.000] Log file其实是一个依赖管理的一个文件,
[06:03.000 --> 06:08.000] 它是针对于那些具有依赖管理功能的包材特有的一个文件,
[06:08.000 --> 06:09.000] 所以说,
[06:09.000 --> 06:12.000] 如果是你这个工具只用打包的话,
[06:12.000 --> 06:14.000] 它其实是不需要这个Log file,
[06:14.000 --> 06:17.000] 比如说flit就没有这个Log file,
[06:17.000 --> 06:24.000] Log file其实是说你把你的包里面的一些依赖,
[06:24.000 --> 06:28.000] 把它给锁定在固定的一些版本,
[06:28.000 --> 06:33.000] 你达到我们可以复制它的安装过程,
[06:33.000 --> 06:36.000] 就是说可复现的安装过程,
[06:36.000 --> 06:39.000] 甚至说可复现的build过程。
[06:39.000 --> 06:49.000] 那是不是说像一些打包的library之类的东西,
[06:49.000 --> 06:50.000] 你把它打包完了,
[06:50.000 --> 06:52.000] 上传到pipe之后,
[06:52.000 --> 06:53.000] 其实是没有Log文件的,
[06:53.000 --> 06:59.000] 然后你每次下载的时候相当于每一个就是你可能是用poetry,
[06:59.000 --> 07:01.000] PDM或者是配合安装的,
[07:01.000 --> 07:05.000] 它要去现场来解析这个依赖。
[07:05.000 --> 07:06.000] 对,
[07:07.000 --> 07:09.000] 如果有Log file的话,
[07:09.000 --> 07:11.000] 你就可以不用去解析,
[07:11.000 --> 07:14.000] 你只用从Log file里面读你要安装哪些包,
[07:14.000 --> 07:16.000] 哪些版本就可以。
[07:16.000 --> 07:23.000] 那我是不是可以理解成像library库跟那些命令行工具,
[07:23.000 --> 07:25.000] 是不用Log file的,
[07:25.000 --> 07:27.000] 因为他们每次安装的时候都要解析依赖,
[07:27.000 --> 07:30.000] 但是像你部署的web应用程序,
[07:30.000 --> 07:33.000] 你写的程序你想锁定所有的依赖的话,
[07:33.000 --> 07:35.000] 这个场景是用Log file的。
[07:35.000 --> 07:36.000] 对,
[07:36.000 --> 07:37.000] 没错,
[07:37.000 --> 07:41.000] 这两种类型的包分别一个叫library,
[07:41.000 --> 07:43.000] 一个叫application应用,
[07:43.000 --> 07:45.000] 那针对应用来说,
[07:45.000 --> 07:48.000] 我们比较关注于说它的安装是可复现的,
[07:48.000 --> 07:52.000] 就是说你在本地安装的包跟你在服务器上安装的包,
[07:52.000 --> 07:53.000] 它版本是一样的,
[07:53.000 --> 07:55.000] 甚至它的文件是一样的,
[07:55.000 --> 07:57.000] 如果最严格的意义上来说。
[07:58.000 --> 08:02.000] 所以对于一个library来说,
[08:02.000 --> 08:06.000] 其实你可以不用上传Log file,
[08:06.000 --> 08:11.000] 因为Log file里面的东西也不会打包到你的包的原数据里面去,
[08:11.000 --> 08:19.000] 但是Log file其实只对于开发流程是有用的,
[08:19.000 --> 08:23.000] 就是说用贡献者来做开发的话,
[08:23.000 --> 08:27.000] 它可以从Log file去安装到你所需要的所有工具的版本。
[08:27.000 --> 08:31.000] 所以现在其实是library,
[08:31.000 --> 08:35.000] 你在它的Git的这样的仓库里面也基本上都会发现一个Log file。
[08:35.000 --> 08:36.000] 对,
[08:36.000 --> 08:40.000] 也有的实践是。
[08:40.000 --> 08:43.000] 对,
[08:43.000 --> 08:45.000] 我还有一点疑问,
[08:45.000 --> 08:51.000] 就是你们刚刚提到的新式的那种是用Pipeline Jack来维护打包的原数据,
[08:51.000 --> 08:55.000] 比如说这个叫什么名字,
[08:55.000 --> 09:00.000] 但是就是明星方也提到,
[09:00.000 --> 09:05.000] 它是想要跟特殊的工具结合的,
[09:05.000 --> 09:07.000] 但是现在打包出来,
[09:07.000 --> 09:11.000] 是不是还是里面会有一个setup.py,
[09:11.000 --> 09:13.000] 就是你原版没有,
[09:13.000 --> 09:17.000] 你build出来上传之后是没有的。
[09:17.000 --> 09:18.000] 没有的,
[09:18.000 --> 09:22.000] Pipeline Jack的原数据的话,
[09:22.000 --> 09:26.000] 其实只在原代码打包里面有,
[09:26.000 --> 09:28.000] 也就是source distribution,
[09:28.000 --> 09:31.000] 如果打包成wheel的话,
[09:31.000 --> 09:34.000] 它里面只包含着代码,
[09:34.000 --> 09:39.000] 它的原数据其实是会被转换成另一个标准的格式,
[09:39.000 --> 09:42.000] 放在wheel的原数据里面。
[09:43.000 --> 09:45.000] 那之前的这个,
[09:45.000 --> 09:50.000] 这种方式是不是不兼容之前老版本的那些配合,
[09:50.000 --> 09:54.000] 因为之前老版本的配合都需要这个setup.py的吗?
[09:55.000 --> 09:56.000] 对,
[09:56.000 --> 10:04.000] 那其实从Pip记得应该是从18以后开始支持这个pyproject.toml,
[10:04.000 --> 10:08.000] 所以现在的话应该很少有18以前的版本,
[10:08.000 --> 10:12.000] 因为现在最新版本已经是2.2了。
[10:14.000 --> 10:18.000] 那个pyproject其实也不在这个打包的里面,
[10:18.000 --> 10:24.000] 它是会生成一种其他的格式的文件来描述原数据。
[10:24.000 --> 10:25.000] 对,
[10:25.000 --> 10:27.000] 只是对于wheel包来说,
[10:27.000 --> 10:28.000] 如果是原代码包的话,
[10:28.000 --> 10:32.000] 原代码包的意思就是说你的原代码是什么样子的,
[10:32.000 --> 10:35.000] 打包上去也是什么样子的,
[10:35.000 --> 10:39.000] 它会通过你这个原代码再复现出那个wheel。
[10:42.000 --> 10:46.000] 所以这样就做到它跟那个特殊的工具来结合,
[10:46.000 --> 10:48.000] 就是说无论你用PDM,
[10:48.000 --> 10:51.000] Pip还是包区来打包,
[10:51.000 --> 10:55.000] 你必须用上传的文件里面的格式都是去生成的另一种。
[10:55.000 --> 10:56.000] 对,
[10:56.000 --> 10:57.000] 安装的时候,
[10:57.000 --> 10:59.000] 它不会再去读setup.py,
[10:59.000 --> 11:01.000] 是会去通过这个文件来读到原数据,
[11:01.000 --> 11:02.000] 然后帮你安装这个包。
[11:02.000 --> 11:03.000] 对,
[11:05.000 --> 11:09.000] 这个其实就涉及到PP517的内容了,
[11:09.000 --> 11:14.000] 它是把这个build工具给结合,
[11:14.000 --> 11:19.000] 也就是说你只用上传一个pyproject的toml在你的原代码里面,
[11:19.000 --> 11:26.000] 然后你可以在那个toml文件里面去指定我要用什么工具来构建我的wheel。
[11:27.000 --> 11:31.000] 那么在最新的新版本的peep里面,
[11:31.000 --> 11:32.000] 它就可以读取到这个,
[11:32.000 --> 11:37.000] 然后它可以去帮你下载指定的工具,
[11:37.000 --> 11:41.000] 然后去构建出一个可用的wheel。
[11:43.000 --> 11:46.000] 为什么是用peep来构建wheel?
[11:50.000 --> 11:52.000] 我们需要解释一下wheel吗?
[11:52.000 --> 11:55.000] 可能如果听众不清楚。
[11:57.000 --> 11:58.000] 对,
[11:58.000 --> 12:01.000] 我觉得你可以把python打包安装的过程,
[12:01.000 --> 12:06.000] 然后假设听众刚刚写python,
[12:06.000 --> 12:07.000] 对于这些不太了解,
[12:07.000 --> 12:09.000] 然后可以从头解释。
[12:09.000 --> 12:10.000] 对,
[12:10.000 --> 12:11.000] 其实我也不太了解,
[12:11.000 --> 12:13.000] 我一直有一个疑问,
[12:13.000 --> 12:16.000] 就是peep有的时候安装完了之后,
[12:16.000 --> 12:19.000] 它会打出来银行build PEP,
[12:19.000 --> 12:22.000] 集几个什么东西,
[12:22.000 --> 12:23.000] 然后要build一个新的,
[12:23.000 --> 12:24.000] 记不太清了,
[12:24.000 --> 12:27.000] 我其实不太清楚这个过程在做什么。
[12:27.000 --> 12:28.000] 对,
[12:28.000 --> 12:29.000] 我们从头来介绍一下,
[12:29.000 --> 12:31.000] 就是我们怎么从源代码,
[12:31.000 --> 12:34.000] 构建出可以安装的包。
[12:37.000 --> 12:41.000] 就是说大家可能做python的library,
[12:41.000 --> 12:43.000] 或者是application也好,
[12:43.000 --> 12:46.000] 我们肯定是首先是有一个源代码的仓库里面,
[12:46.000 --> 12:49.000] 是有我们所有的python文件在里面。
[12:51.000 --> 12:52.000] 打包的话,
[12:52.000 --> 12:55.000] 我们就需要放置一个pyproject跟common文件,
[12:55.000 --> 12:56.000] 或者是ending,
[12:56.000 --> 12:59.000] 如果是setup.tools的话,
[12:59.000 --> 13:01.000] 你可能要放一个setup.py文件在里面,
[13:01.000 --> 13:04.000] 然后在里面去指定,
[13:06.000 --> 13:10.000] 以工具指定的方式去指定的原数据,
[13:10.000 --> 13:12.000] 那python打包的话,
[13:12.000 --> 13:17.000] 它就去读取你的原数据里面的配置,
[13:18.000 --> 13:24.000] 然后去生成一个wheel,
[13:24.000 --> 13:26.000] 这个wheel和你的源代码包,
[13:26.000 --> 13:27.000] 它有什么区别呢?
[13:27.000 --> 13:29.000] 就是说这个wheel,
[13:29.000 --> 13:32.000] 他们的文件是已经完全准备好的,
[13:32.000 --> 13:35.000] 包括如果是有c的代码,
[13:35.000 --> 13:37.000] 它是已经被打包成,
[13:37.000 --> 13:39.000] 已经构建好成so,
[13:39.000 --> 13:42.000] 或者是什么shared library这种东西。
[13:42.000 --> 13:45.000] 那如果是对于一个wheel的安装,
[13:45.000 --> 13:48.000] 你只需要做的事情就是把它解压,
[13:48.000 --> 13:52.000] 然后把文件挪到你的library path下面,
[13:52.000 --> 13:54.000] 这个事情就已经完成了。
[13:57.000 --> 13:58.000] 对,就是说wheel,
[13:58.000 --> 14:01.000] 它其实是一个构建好,
[14:01.000 --> 14:03.000] 或者叫prebuilt,
[14:03.000 --> 14:04.000] 已经构建好了,
[14:04.000 --> 14:06.000] 已经下载起来安装,
[14:06.000 --> 14:08.000] 但是呢,
[14:08.000 --> 14:10.000] 对于很多Linux发行板,
[14:10.000 --> 14:13.000] 他们有他们自己的打包团队,
[14:13.000 --> 14:17.000] 他们会比较倾向于自己来控制这个打包过程,
[14:17.000 --> 14:19.000] 因为他们会有一些工具链在这里,
[14:19.000 --> 14:22.000] 所以他们可能不太关注你的wheel,
[14:22.000 --> 14:24.000] 他们关注你的,
[14:24.000 --> 14:26.000] 你的这个源代码格式,
[14:26.000 --> 14:27.000] source distribution,
[14:27.000 --> 14:31.000] 他们会倾向于把这个源代码格式的东西,
[14:31.000 --> 14:33.000] 自己拿下来,
[14:33.000 --> 14:34.000] 自己去打包,
[14:34.000 --> 14:37.000] 那这时候他们也需要去支持,
[14:37.000 --> 14:40.000] 读取这个pyproject的toml的内容。
[14:42.000 --> 14:45.000] wheel就是一个比较傻瓜,
[14:45.000 --> 14:48.000] 然后就是比较简单的安装方式,
[14:48.000 --> 14:50.000] 但是你如果从源代码安装的话,
[14:50.000 --> 14:53.000] 各个操作系统就可能有不同的方式,
[14:53.000 --> 14:54.000] 是,
[14:54.000 --> 14:55.000] wheel就比较像,
[14:55.000 --> 14:56.000] 比如说一个,
[14:56.000 --> 14:57.000] 你在windows家,
[14:57.000 --> 15:00.000] 然后就有一个那种UI的安装界面,
[15:00.000 --> 15:03.000] 它基本上就是把一些文件从一个地方挪到另外一个地方,
[15:03.000 --> 15:04.000] 对,
[15:04.000 --> 15:06.000] 所以其实就是,
[15:06.000 --> 15:07.000] 如果你在一个,
[15:07.000 --> 15:09.000] 比如说ubuntu上面,
[15:09.000 --> 15:11.000] 你用pip install,
[15:11.000 --> 15:12.000] 你用的其实是,
[15:12.000 --> 15:13.000] 如果有wheel的话,
[15:13.000 --> 15:14.000] 其实用的是wheel,
[15:14.000 --> 15:16.000] 但是你用apt install的话,
[15:16.000 --> 15:19.000] 它就会用ubuntu团队打包的那些东西,
[15:19.000 --> 15:20.000] 对,
[15:20.000 --> 15:22.000] apt install的东西,
[15:22.000 --> 15:25.000] 其实是ubuntu自己从源代码打包出来的,
[15:25.000 --> 15:27.000] 它自己的wheel。
[15:28.000 --> 15:29.000] 明白了,
[15:29.000 --> 15:30.000] 你刚刚说就是,
[15:30.000 --> 15:33.000] 它直接下载那个wheel来copy,
[15:33.000 --> 15:36.000] 但是linux它有不同的那个架构,
[15:36.000 --> 15:37.000] 然后有不同的,
[15:37.000 --> 15:39.000] 就比如说python2,
[15:39.000 --> 15:40.000] python3,
[15:40.000 --> 15:41.000] 还有一些东西,
[15:41.000 --> 15:44.000] 那它是怎么找到对应的这个wheel?
[15:44.000 --> 15:46.000] 这个问题提的很好,
[15:46.000 --> 15:51.000] 因为如果你去看pypi上传的那些文件,
[15:51.000 --> 15:55.000] 你可以发现对于那种非纯python的,
[15:55.000 --> 15:57.000] 就可能有c扩展的那些包,
[15:57.000 --> 16:06.000] 它的wheel的文件名里面是会有代用的API信息或者python版本信息,
[16:06.000 --> 16:08.000] 比如说numpy,
[16:08.000 --> 16:11.000] 它可能会有很多wheel,
[16:11.000 --> 16:12.000] 各种版本,
[16:12.000 --> 16:15.000] 从它支持的3.7到3.10,
[16:15.000 --> 16:16.000] 每一个版本,
[16:16.000 --> 16:19.000] 每一个系统都有一个wheel,
[16:19.000 --> 16:21.000] 那么pep,
[16:21.000 --> 16:24.000] 比如说pip去安装的时候,
[16:24.000 --> 16:27.000] 它会去从这个列表里面去找这些wheel,
[16:27.000 --> 16:32.000] 然后挨个便利看一下它是不是符合当前系统的一个限制。
[16:35.000 --> 16:37.000] 所以这个wheel,
[16:37.000 --> 16:39.000] 如果这个包支持wheel的话,
[16:40.000 --> 16:44.000] 那个列表就跟我们经常在pollout的项目里面,
[16:44.000 --> 16:46.000] 在release里面看到的那个列表一样,
[16:46.000 --> 16:47.000] 就会有一大串,
[16:47.000 --> 16:49.000] architecture什么的,
[16:49.000 --> 16:50.000] pip,
[16:50.000 --> 16:52.000] x8664或者arm64,
[16:52.000 --> 16:54.000] 各种不同的架构。
[16:58.000 --> 17:00.000] 那它如果是找不到呢?
[17:01.000 --> 17:03.000] 就是它找不到那个,
[17:03.000 --> 17:07.000] 比如说我这个系统对应的那个wheel包。
[17:07.000 --> 17:08.000] 对,
[17:08.000 --> 17:10.000] 它如果找不到wheel的包,
[17:10.000 --> 17:13.000] 可能很多打包作者他不会去上传,
[17:13.000 --> 17:19.000] 因为这个pypi上的内容全部是要依赖你的作者去上传的。
[17:19.000 --> 17:21.000] 它如果找不到的话,
[17:21.000 --> 17:23.000] 如果你的作者上传了原代码的包,
[17:23.000 --> 17:25.000] 那么pip就会下载原代码,
[17:25.000 --> 17:28.000] 然后自己在本地去构建一个wheel,
[17:28.000 --> 17:29.000] 然后安装。
[17:29.000 --> 17:31.000] 如果没有找到的话,
[17:31.000 --> 17:32.000] 就是都没有找的话,
[17:32.000 --> 17:33.000] 那就是fail了。
[17:34.000 --> 17:36.000] 我想举一个反例,
[17:36.000 --> 17:41.000] 假如说一个wheel的包是作者上传的,
[17:41.000 --> 17:43.000] 假如说作者上传错了,
[17:43.000 --> 17:48.000] 它本来是一个比如说arm架构的编译的结果,
[17:48.000 --> 17:50.000] 结果它改成差不多又上传了,
[17:50.000 --> 17:52.000] 那其实wheel安装的时候,
[17:52.000 --> 17:53.000] 它应该不会发现,
[17:53.000 --> 17:54.000] 对吧?
[17:54.000 --> 17:55.000] 它只会上传文件,
[17:55.000 --> 17:56.000] 靠过去。
[17:56.000 --> 17:57.000] 对,
[17:57.000 --> 17:58.000] 靠过去,
[17:58.000 --> 17:59.000] 然后用不了。
[17:59.000 --> 18:05.000] 那其实可以理解成这个wheel其实是作者把给用户编译的这个麻烦留给了自己,
[18:05.000 --> 18:07.000] 它把所有东西都编译好了,
[18:07.000 --> 18:09.000] 用的时候只要下载就好了。
[18:10.000 --> 18:11.000] 对,
[18:11.000 --> 18:15.000] 我也看到很多常见的安装错误,
[18:15.000 --> 18:18.000] 比如说你安装一个MySQL client,
[18:18.000 --> 18:21.000] 然后会报一些编译错误,
[18:21.000 --> 18:23.000] 那可能是没有对应的编译文件,
[18:23.000 --> 18:27.000] 所以如果是没有找到对应的wheel,
[18:27.000 --> 18:28.000] 需要从原代码编译的话,
[18:28.000 --> 18:32.000] 你就需要你的系统上有安装编译的工具链。
[18:33.000 --> 18:38.000] 就是能不能详细讲一下就是从原代码然后变成wheel的这个过程,
[18:38.000 --> 18:41.000] 因为感觉比如说我们想编译出不同架构,
[18:41.000 --> 18:42.000] 支持不同架构的wheel的话,
[18:42.000 --> 18:44.000] 那还是涉及交叉编译吗?
[18:44.000 --> 18:46.000] 我觉得难道说这个是PIP支持的,
[18:46.000 --> 18:50.000] 还是说我们就得在对应的那个操作系统上去大爆出一个wheel?
[18:52.000 --> 18:55.000] 在单纯用PIP来说,
[18:55.000 --> 18:57.000] 我们是不支持交叉编译的,
[18:57.000 --> 18:59.000] 我们因为PIP只是在本地编译,
[19:00.000 --> 19:01.000] 对,
[19:01.000 --> 19:04.000] 它会如果是默认的C扩展的话,
[19:04.000 --> 19:09.000] 它会调用默认的系统上的那个C的编译的工具链,
[19:09.000 --> 19:11.000] 比如说Linux上是GCC,
[19:11.000 --> 19:16.000] 然后Windows上是MSVC这种这些东西,
[19:16.000 --> 19:20.000] 如果要坚持支持交叉编译的话,
[19:20.000 --> 19:26.000] 其实是有提供那个社区也有提供工具,
[19:26.000 --> 19:29.000] 它是基于容器化的一个构建,
[19:29.000 --> 19:33.000] 所以本质上其实你还是要在对应的系统架构里面去做编译。
[19:34.000 --> 19:37.000] 是那个Managed Linux吗?
[19:38.000 --> 19:40.000] 叫做CI Build Wheel,
[19:41.000 --> 19:43.000] 它是一个GitHub Action。
[19:43.000 --> 19:47.000] 哦,GitHub Action太强大了。
[19:48.000 --> 19:51.000] 那这个其实就是基于Action的工作,
[19:51.000 --> 19:58.000] 会启动不同架构的容器或者虚拟机来在里面编译好了吗?
[19:59.000 --> 20:00.000] OK。
[20:02.000 --> 20:04.000] 那我们就是把话题拉回来一点,
[20:04.000 --> 20:09.000] 刚才就是明细介绍了一个就是现代Python打包的过程,
[20:09.000 --> 20:11.000] 有两种,一个是源代码,一个是wheel,
[20:11.000 --> 20:14.000] 然后wheel的话肯定是更为普遍一点的,
[20:14.000 --> 20:18.000] 然后那我们接下来的问题就是说,
[20:18.000 --> 20:20.000] 既然Python已经有了这些基础架构,
[20:20.000 --> 20:22.000] 包括Pyproject.tomo,
[20:22.000 --> 20:25.000] 然后Lockerfile,
[20:25.000 --> 20:27.000] 然后wheel的格式,
[20:27.000 --> 20:29.000] 包括Type有很多改进,
[20:29.000 --> 20:33.000] 那为什么用户应该选择PDM这个工具呢?
[20:33.000 --> 20:37.000] 就是说如果所有的这些都是一个标准化的,
[20:37.000 --> 20:40.000] 有标准化的打包工具,
[20:40.000 --> 20:42.000] 是不是都基本上一样呢?
[20:47.000 --> 20:51.000] 这里就可能要自吹自擂一下了,
[20:51.000 --> 20:56.000] 可能要涉及到比较一些其他的竞品,
[20:56.000 --> 20:58.000] 比如说PDM的话,
[20:58.000 --> 21:03.000] 它其实是一个用户界面,
[21:05.000 --> 21:10.000] 可能会比较类似于Pip的一个功能和作用,
[21:11.000 --> 21:15.000] 那如果大家对Poetry比较熟悉的话,
[21:15.000 --> 21:19.000] Poetry也是一个比较有名的包管理器,
[21:19.000 --> 21:21.000] 但是Poetry的问题呢,
[21:21.000 --> 21:25.000] 是它的Pyprojecttomo不是标准化的,
[21:25.000 --> 21:27.000] 它是一个自己发明的一个格式。
[21:29.000 --> 21:31.000] 对,这可能因为它做的比较早,
[21:31.000 --> 21:36.000] 当时那个标准化的格式PPRE还没出来,对吧?
[21:36.000 --> 21:38.000] 这个我倒不知道,
[21:38.000 --> 21:39.000] 我一直在用Poetry,
[21:39.000 --> 21:42.000] 所以它也叫Pyprojecttomo,
[21:42.000 --> 21:45.000] 但其实它跟其他的产品是不兼容的,对吗?
[21:46.000 --> 21:48.000] 对于构建工具来说,
[21:48.000 --> 21:52.000] 其实构建工具你只用在里面指定的,
[21:52.000 --> 21:54.000] 你要使用什么构建方法,
[21:54.000 --> 22:00.000] 那这个是先期标准化的一个东西,
[22:00.000 --> 22:03.000] 然后后面才标准化你的原数据是怎么写的,
[22:03.000 --> 22:07.000] 所以我指的是这个Poetry没有跟上这个标准,
[22:08.000 --> 22:11.000] 后面的原数据的一个标准格式
[22:11.000 --> 22:16.000] 是在PEP621里面去决定的。
[22:18.000 --> 22:21.000] 所以PEM的一个优势就是永远紧张标准。
[22:24.000 --> 22:27.000] 对,那PEP621的话,
[22:27.000 --> 22:33.000] 它是一个指导你怎么去在Pyprojecttomo里面
[22:33.000 --> 22:35.000] 去写原数据的一个PEP,
[22:35.000 --> 22:39.000] 那比如说你的依赖要怎么写,
[22:39.000 --> 22:42.000] 你的name version要怎么写,
[22:42.000 --> 22:47.000] 而且在这个基础上支持一定的动态的能力,
[22:48.000 --> 22:51.000] 那我们知道这个动态怎么理解?
[22:53.000 --> 22:58.000] 动态能力就是它不是直接写在里面,
[22:58.000 --> 23:01.000] 然后从静态分析一下就出来,
[23:01.000 --> 23:04.000] 动态是你在build time,
[23:04.000 --> 23:06.000] 它才会去把这个值固定下来,
[23:06.000 --> 23:09.000] 你把它build成wheel的这个过程,
[23:09.000 --> 23:11.000] 就是在这个过程里面,
[23:11.000 --> 23:14.000] 它才会把这个值给固定下来,
[23:14.000 --> 23:16.000] 写到wheel的原数据里面,
[23:16.000 --> 23:18.000] 因为我们知道wheel里面是全静态的,
[23:18.000 --> 23:21.000] 就是你在里面不能执行任何代码,
[23:21.000 --> 23:22.000] 你就只是copy而已。
[23:23.000 --> 23:25.000] OK,谢谢。
[23:26.000 --> 23:29.000] 那我们说到这个呢,
[23:29.000 --> 23:31.000] 就要说起旧式的打包,
[23:31.000 --> 23:35.000] 就是setup.py这种方式的最大问题,
[23:35.000 --> 23:40.000] 就是它的原数据是在python脚本里面去指定的,
[23:40.000 --> 23:45.000] 那python脚本里面你可以写任意动态的东西,
[23:45.000 --> 23:47.000] 我们就举一个极端例子,
[23:47.000 --> 23:49.000] 就是说你可以在里面写一个random,
[23:49.000 --> 23:52.000] 就是说如果random大于0.5的话,
[23:52.000 --> 23:54.000] 那我就加这个依赖,
[23:54.000 --> 23:58.000] 不够0.5的话我就不加这个依赖,
[23:58.000 --> 24:01.000] 那它的依赖到底是什么呢?
[24:01.000 --> 24:03.000] 它只有在build time的时候才能确定。
[24:06.000 --> 24:08.000] 对,说到这个,
[24:08.000 --> 24:12.000] 我想提一个我们做应用的时候会用的技巧,
[24:12.000 --> 24:14.000] 就是其实我们会写一个,
[24:14.000 --> 24:17.000] 比如说Installer去安装一个软件,
[24:17.000 --> 24:19.000] 但是这个Installer我们可能没有地方放,
[24:19.000 --> 24:22.000] 就是你不知道它应该放在哪儿,
[24:22.000 --> 24:24.000] 就是你需要确定,
[24:24.000 --> 24:26.000] 因为每一款软件它有版本嘛,
[24:26.000 --> 24:28.000] Installer可能要控制版本,
[24:28.000 --> 24:33.000] 可能需要一个比较复杂的存放Installer,
[24:33.000 --> 24:35.000] 然后指定版本下载的这么一个东西,
[24:35.000 --> 24:37.000] 所以我们经常会创建一个pip包,
[24:37.000 --> 24:39.000] 然后里面什么东西都没有,
[24:39.000 --> 24:41.000] 就一个setup.py,
[24:41.000 --> 24:43.000] 那个setup.py其实就是一个Installer,
[24:43.000 --> 24:47.000] 就是说你在pipInstaller这个东西的时候,
[24:47.000 --> 24:50.000] 比如说你安装了一个包叫abc,
[24:50.000 --> 24:53.000] 安装这个abc任何用没有,
[24:53.000 --> 24:54.000] 只是安装abc的时候,
[24:54.000 --> 24:56.000] 使用这个setup.py,
[24:56.000 --> 24:59.000] 帮你在这个系统上装了一个软件,
[25:00.000 --> 25:01.000] 明白,
[25:01.000 --> 25:05.000] 就是你在setup.py里面去download别的东西,
[25:06.000 --> 25:07.000] 对,
[25:07.000 --> 25:09.000] 所以我们就把这个公司的Pip,
[25:09.000 --> 25:13.000] 当成一个存放安装脚本的这么一个东西,
[25:13.000 --> 25:15.000] 我觉得也挺好,
[25:16.000 --> 25:19.000] 那这样就要求你们只能上传原代码的格式,
[25:19.000 --> 25:21.000] 如果是Vue的话是做不到的,
[25:23.000 --> 25:24.000] 对,
[25:24.000 --> 25:27.000] 因为我们那个pip包其实里面啥都没有嘛,
[25:27.000 --> 25:30.000] 所以我们就是基本上只用那个setup.py,
[25:30.000 --> 25:32.000] 所以只上传原代码的格式,
[25:34.000 --> 25:35.000] 对,
[25:35.000 --> 25:42.000] 那就衍生到另外一个问题,
[25:42.000 --> 25:45.000] 就是说为什么Python的包管理,
[25:45.000 --> 25:48.000] Python的依赖解析这么的烂,
[25:48.000 --> 25:51.000] 就是因为有很多历史遗留问题,
[25:51.000 --> 25:53.000] 导致这些依赖本身都已经不是,
[25:53.000 --> 25:54.000] 都不是固定的,
[25:54.000 --> 25:56.000] 它有可能是动态的,
[25:56.000 --> 26:02.000] 那你如何要求一个pypi去把你的依赖缓存下来呢?
[26:02.000 --> 26:04.000] 它缓存不了,
[26:04.000 --> 26:10.000] 它就只能把这些工作全部给推到你的包管理器子里面,
[26:11.000 --> 26:12.000] 对,
[26:12.000 --> 26:16.000] 那我们还觉得就是那个结合PDM的优势,
[26:16.000 --> 26:18.000] 为什么要用PDM这点来讲,
[26:18.000 --> 26:21.000] 就是说PDM在处理Python的依赖,
[26:21.000 --> 26:23.000] 就是对很多历史遗留问题上,
[26:23.000 --> 26:25.000] 是不是比其他包管理工具要做得更好?
[26:26.000 --> 26:28.000] 我觉得你的答案应该是是的,
[26:32.000 --> 26:38.000] 这也是由于Python包管理的本身的缺陷,
[26:38.000 --> 26:41.000] 导致刚才说的我们的依赖固定不了,
[26:41.000 --> 26:48.000] 所以PDM本身也是要在客户端这一侧去解决依赖,
[26:49.000 --> 26:53.000] 那么它好的地方是它的缓存还是比较多的,
[26:53.000 --> 26:56.000] 各种的级别的缓存,
[26:56.000 --> 27:00.000] 它首先是HTTP下载的一个缓存,
[27:00.000 --> 27:04.000] 然后是依赖解析出来的,
[27:04.000 --> 27:06.000] 比如说你的包有什么依赖,
[27:06.000 --> 27:08.000] 这个也是会缓存到本地的,
[27:11.000 --> 27:13.000] 然后你解析完了依赖,
[27:13.000 --> 27:14.000] 你可能要下载这些包,
[27:14.000 --> 27:16.000] 然后下载的包也是有缓存的,
[27:18.000 --> 27:21.000] 所以缓存影响的是一个下载包的时候,
[27:21.000 --> 27:23.000] 下载安装的速度是吧?
[27:23.000 --> 27:33.000] 对,而且PDM用的依赖解析器和新版的PIP用的其实是一样的,
[27:35.000 --> 27:44.000] 它可以去自动的去回溯旧的版本去一直找到匹配的依赖。
[27:44.000 --> 27:50.000] 我记得跟新唐刚才说的那个问题有关,
[27:50.000 --> 27:54.000] 好像一开始Portrait介绍它的一个优势的时候,
[27:54.000 --> 28:00.000] 就是说它的依赖解析比PPMV要正确一些,
[28:00.000 --> 28:02.000] 就有些PPMV解析不出来的,
[28:02.000 --> 28:03.000] 它能解析出来,
[28:03.000 --> 28:10.000] 所以意思是它们两个其实都是用的一个自造的依赖解析,
[28:10.000 --> 28:11.000] 可以这样理解吗?
[28:11.000 --> 28:16.000] 对,PPMV我有信以前也维护过,
[28:16.000 --> 28:20.000] 它之前用的依赖解析其实是PIPtools,
[28:20.000 --> 28:26.000] 后来的话也是转到了PIP用的resolve-lib上面,
[28:26.000 --> 28:31.000] 那Portrait自始至终都是用了一个自造的依赖解析,
[28:31.000 --> 28:42.000] 它的优势是可能它忽略了一些corner case来达到比较更快的一个依赖解析,
[28:42.000 --> 28:49.000] 而且它支持一个多条件的一个依赖指令,
[28:49.000 --> 28:52.000] 比如说你的某个包,
[28:52.000 --> 28:54.000] 比如说request吧,
[28:55.000 --> 29:02.000] 我在Python大于3.8的版本上我要安装2.25,
[29:02.000 --> 29:07.000] 否则的话我就安装2.23,
[29:07.000 --> 29:10.000] Portrait是可以支持这种方式的,
[29:10.000 --> 29:17.000] 那PDM和PIP它都是不支持这种方式,
[29:17.000 --> 29:20.000] 但是PIP它不用关心这个问题,
[29:20.000 --> 29:22.000] 因为它不用,
[29:22.000 --> 29:28.000] 它只用去管你当前这个环境下需要安装什么包,
[29:28.000 --> 29:32.000] 而不用去做这个cross platform,
[29:32.000 --> 29:34.000] 就是跨平台的一个依赖解析,
[29:34.000 --> 29:38.000] 那PDM跟Portrait它其实都是,
[29:38.000 --> 29:41.000] 它产生的这个log file都是跨平台的,
[29:41.000 --> 29:45.000] 也就是说你在Windows上生成的这个log file,
[29:45.000 --> 29:48.000] 它其实是可以在Linux上去使用的,
[29:49.000 --> 29:51.000] 这样明白,
[29:51.000 --> 29:53.000] 因为本质上PIP是没有log file的,
[29:53.000 --> 29:54.000] 对,
[29:54.000 --> 29:55.000] 只有一个,
[29:55.000 --> 30:00.000] 你刚刚说PDM是用ATTP来解决,
[30:00.000 --> 30:01.000] 这句话是什么意思,
[30:01.000 --> 30:05.000] 就是说它解析的依赖的需要的数据,
[30:05.000 --> 30:08.000] 是通过Pip.org的API拿到的吗?
[30:09.000 --> 30:18.000] 现在PDM其实支持多种拿这个依赖数据的方式,
[30:18.000 --> 30:23.000] 一个是通过Pip Jason API,
[30:23.000 --> 30:26.000] 另外一个就是最朴素的,
[30:26.000 --> 30:28.000] 就是把这个包download下来,
[30:28.000 --> 30:29.000] 如果是无有的话,
[30:29.000 --> 30:31.000] 直接去里面去看它的原数据就行。
[30:31.000 --> 30:37.000] 所以我在用Portrait的时候,
[30:37.000 --> 30:38.000] 因为有的时候比较慢,
[30:38.000 --> 30:41.000] 可能我们自己的Pip不支持API,
[30:41.000 --> 30:43.000] 所以它要下来很多包对吧,
[30:43.000 --> 30:46.000] 它要把不同的版本下来下来,
[30:46.000 --> 30:47.000] 看最后用哪一个比较好。
[30:47.000 --> 30:48.000] 对,
[30:48.000 --> 30:50.000] 这时候如果你的包是那种巨型的,
[30:50.000 --> 30:51.000] 比如说TensorFlow的话,
[30:51.000 --> 30:54.000] 可能会代价比较大。
[30:54.000 --> 30:57.000] 我觉得这个是个经典问题。
[30:57.000 --> 31:03.000] 这个解析速度要下载的东西太多了,
[31:03.000 --> 31:04.000] 不同的包,
[31:04.000 --> 31:05.000] 不同的版本。
[31:05.000 --> 31:08.000] 对,
[31:08.000 --> 31:12.000] 其实这个社区也有注意到这个问题,
[31:12.000 --> 31:15.000] 所以也制定了一些新的标准,
[31:15.000 --> 31:17.000] 当然这些标准还在这个草案过程中,
[31:17.000 --> 31:20.000] 比如说我们直接把这个包的原数据
[31:20.000 --> 31:23.000] 直接传到这个Pip上,
[31:23.000 --> 31:26.000] 你不用去把那个wheel下来下来,
[31:26.000 --> 31:28.000] 你只用把它的原数据下来下来就行。
[31:28.000 --> 31:31.000] 对,
[31:32.000 --> 31:35.000] 我觉得Pipeline现在这么搞,
[31:35.000 --> 31:40.000] 这个Pipeline.org承受的流量很了不起啊,
[31:40.000 --> 31:41.000] 就像每次CDI,
[31:41.000 --> 31:42.000] 我们PDM,
[31:42.000 --> 31:45.000] ESOL这次都要去杀一件东西,
[31:45.000 --> 31:46.000] Portrait,
[31:46.000 --> 31:47.000] ESOL。
[31:47.000 --> 31:50.000] 是的,
[31:50.000 --> 31:51.000] OK,
[31:51.000 --> 31:54.000] 那那个回到PDM的优势上,
[31:54.000 --> 31:56.000] 刚才讲了两个问题,
[31:56.000 --> 31:59.000] 一个是就是说它的速度,
[31:59.000 --> 32:00.000] 有各种反算,
[32:00.000 --> 32:05.000] 然后一个是它的依赖解析是和Pip一样的,
[32:05.000 --> 32:06.000] 就是说在正确性方面,
[32:06.000 --> 32:08.000] 正确的情况下没有保证,
[32:08.000 --> 32:10.000] 那还有什么优势?
[32:10.000 --> 32:15.000] 另外一个比较大的方面就是一个用户层面的吧,
[32:15.000 --> 32:17.000] 就是使用层面的话,
[32:17.000 --> 32:19.000] 它是更自由的,
[32:19.000 --> 32:23.000] 因为它的选项和配置项都很多,
[32:23.000 --> 32:27.000] 比如说刚才我们说到依赖这个原数据的一个获取信息,
[32:27.000 --> 32:30.000] 这个多种方式我们这是可以配置的,
[32:30.000 --> 32:34.000] 第二个是我们这个依赖升级的一个策略,
[32:34.000 --> 32:39.000] 是不管旧版本直接把它直接升级到新版本,
[32:39.000 --> 32:40.000] 这是一个策略,
[32:40.000 --> 32:43.000] 第二个是我们尽可能用已经lock好的版本,
[32:43.000 --> 32:49.000] 而只去动我们需要希望它动了升级的那个些版本,
[32:49.000 --> 32:51.000] 这是另外一种策略,
[32:51.000 --> 32:54.000] 对这个策略也是可以切换的,
[32:54.000 --> 32:56.000] 那在其他的包管理工具中,
[32:56.000 --> 32:58.000] 其实可能没有这些个选项,
[32:58.000 --> 33:03.000] 第三个就是它的插件化,
[33:03.000 --> 33:10.000] 我们在这个PDM很早的时候就已经支持这个插件了,
[33:10.000 --> 33:17.000] 也就是说社区可以去通过去做自己的插件,
[33:17.000 --> 33:18.000] 完成他们自己想要的功能,
[33:18.000 --> 33:20.000] 那poetry的话,
[33:20.000 --> 33:28.000] 它直到最近也是在1.20beta上面去实现的这些插件功能,
[33:28.000 --> 33:34.000] 你能举一个比如说大家用比较多的PDM插件的例子吗?
[33:34.000 --> 33:39.000] 比如说比较早的做了一个PDM插件,
[33:39.000 --> 33:45.000] 就是可以把你的安装的这些包打包成一个zipapp,
[33:46.000 --> 33:49.000] zipapp就是一个zip文件,
[33:49.000 --> 33:52.000] 然后里面包含你所有需要的Python包,
[33:52.000 --> 33:56.000] 然后你可以把这个zipapp直接拷给你的同事,
[33:56.000 --> 33:59.000] 然后他可以直接用Python去运行,
[33:59.000 --> 34:00.000] 不用安装任何依赖。
[34:03.000 --> 34:05.000] Python可以import zip这个?
[34:05.000 --> 34:06.000] 对。
[34:09.000 --> 34:12.000] 所以usability上,
[34:13.000 --> 34:15.000] 其实关于那个插件我还挺好奇的,
[34:15.000 --> 34:17.000] 因为我没有详细研究过PDM插件,
[34:17.000 --> 34:22.000] 它只是能定制你的打包过程吗?
[34:22.000 --> 34:26.000] 还是说它能控制哪些东西?
[34:27.000 --> 34:29.000] 插件支持的话,
[34:31.000 --> 34:33.000] 第一个是你可以增加配置,
[34:34.000 --> 34:35.000] 配置项。
[34:35.000 --> 34:36.000] 配置是什么意思?
[34:36.000 --> 34:39.000] 就是PDMconfig的那些内容,
[34:39.000 --> 34:42.000] 就是说你可以为你的工具加配置,
[34:42.000 --> 34:44.000] 第二个是可以加命令,
[34:44.000 --> 34:45.000] 加新的命令,
[34:45.000 --> 34:48.000] 或者去覆盖已有的命令,
[34:48.000 --> 34:55.000] 第三个也可以做到去控制依赖解析过程,
[34:55.000 --> 34:57.000] 安装过程,
[34:57.000 --> 35:04.000] 或者你的项目所支持的一些配置,
[35:04.000 --> 35:06.000] 这些都是可以自定义的。
[35:07.000 --> 35:11.000] 所以感觉这些是不是对一些大公司会更有用一些,
[35:11.000 --> 35:14.000] 他们可能比如说内部肯定不是用Pipeline,
[35:14.000 --> 35:18.000] 他们需要做一些这种customization的东西,
[35:20.000 --> 35:22.000] 比如说像新涛他们可能就很喜欢。
[35:22.000 --> 35:23.000] 对。
[35:27.000 --> 35:29.000] 所以你还没有提到user script,
[35:29.000 --> 35:33.000] 我觉得这个也是PDM一个挺方便的地方。
[35:33.000 --> 35:39.000] 对,你的PDM user script其实主要是借鉴NPM的那些,
[35:39.000 --> 35:41.000] 那一套逻辑。
[35:41.000 --> 35:46.000] 我们可以除了去自定义自己的快捷方式,
[35:46.000 --> 35:48.000] 比如说我一条很长的命令,
[35:48.000 --> 35:51.000] 就像每次PDM run的时候去打那么很长的命令,
[35:51.000 --> 35:53.000] 可以把它指定一个名字,
[35:53.000 --> 35:57.000] 我们可以用这个短名去执行这一条命令,
[35:57.000 --> 36:04.000] 另外一个就是它可以去支持一些pre script和post script,
[36:04.000 --> 36:09.000] 也就是说你这个脚本执行之前或执行之后要做什么事情,
[36:09.000 --> 36:15.000] 就是可以在一定程度上去做到那个script的编排吧。
[36:16.000 --> 36:20.000] 我们要不直接就进入这个PDM2.0的环节吧,
[36:20.000 --> 36:24.000] 然后我们这次想录音也是因为PDM发了一个大版本,
[36:24.000 --> 36:29.000] 是2.0版本,那2.0版本有很多很重大的改进,
[36:29.000 --> 36:35.000] 那其中最重大的改进可能就是说不再默认使用pip2,
[36:35.000 --> 36:45.000] 也就是说你不会再默认把一些python的包存在本地的package这个文件夹里,
[36:45.000 --> 36:49.000] 那就是说这个其实也是一个非常大的改变,
[36:49.000 --> 36:54.000] 因为PDM一开始一直是作为一个像pip582实现,
[36:54.000 --> 36:57.000] 来进入这样一个python包装的一个市场,
[36:57.000 --> 37:01.000] 那还是请明锡来聊一下就是这个背后的考虑,
[37:01.000 --> 37:05.000] 和就是比如说一些用户的反馈是怎么样的,
[37:05.000 --> 37:07.000] 给大家介绍一下。
[37:08.000 --> 37:11.000] 先说一下pip582吧,
[37:11.000 --> 37:17.000] 就是说传统上我们这个如果要做项目的依赖隔离的话,
[37:17.000 --> 37:19.000] 我们会要建一个虚拟环境,
[37:19.000 --> 37:23.000] 我们把包装在那个虚拟环境里面,
[37:23.000 --> 37:27.000] 那pip582就是提供了另外一个可能的选择,
[37:27.000 --> 37:32.000] 就是说我们在这个项目下面建一个专门存放包的一个目的,
[37:32.000 --> 37:35.000] 有点像APM的那个node modules,
[37:35.000 --> 37:40.000] 只是它的名字叫双下滑线pypackages,
[37:40.000 --> 37:47.000] 那我们通过一些对于这个python解释器的改造,
[37:47.000 --> 37:53.000] 我们可以让它去直接读取这个目录下面的包,
[37:53.000 --> 37:55.000] 而不用去activate一个虚拟环境,
[37:55.000 --> 37:58.000] 这个是pip582的内容,
[37:58.000 --> 38:06.000] 那为什么我们要在PDM2.0里面去把这个东西降到第二优先级,
[38:06.000 --> 38:08.000] 我们并不是说不支持它,
[38:08.000 --> 38:10.000] 我们只是把它变成不是默认了,
[38:10.000 --> 38:19.000] 主要是因为虚拟环境这种方式毕竟已经存在很久了,
[38:19.000 --> 38:23.000] 所以所有的工具链包括IDE,
[38:23.000 --> 38:27.000] 包括一些type check和link的工具,
[38:27.000 --> 38:31.000] 其实对于这种虚拟环境的支持无疑是更好的,
[38:32.000 --> 38:38.000] 而且另外一个最大的问题就是pip582这个提案,
[38:38.000 --> 38:41.000] 它其实还在这个草案过程中,
[38:41.000 --> 38:49.000] 也就是说它其实还有一些没有解决的问题存在,
[38:49.000 --> 38:55.000] 所以导致它这个进度停滞不前,
[38:55.000 --> 39:05.000] 比如说它甚至没有去规定你的可执行文件executable应该放在哪个地方,
[39:05.000 --> 39:08.000] 它只是规定你的library放在哪个地方。
[39:08.000 --> 39:16.000] 对,我很好奇你有没有和pip582的作者有过交流,
[39:16.000 --> 39:19.000] 你是唯一一个实现的。
[39:19.000 --> 39:24.000] 其实PDM之前有另外一个raster的实现,
[39:24.000 --> 39:28.000] rewriting raster,叫做pipeflow,
[39:28.000 --> 39:36.000] 那个PDM也是直接从那上面站在巨人的肩膀上办成的,
[39:36.000 --> 39:38.000] 它是一个python的实现。
[39:38.000 --> 39:46.000] 我也有跟进社区关于pip582的一些讨论,
[39:47.000 --> 39:51.000] 因为原作者的话,
[39:51.000 --> 39:56.000] 他可能是经历从这里转移了,
[39:56.000 --> 39:58.000] 所以就没有继续再放在上面。
[40:00.000 --> 40:03.000] 对,我感觉两年了,
[40:03.000 --> 40:04.000] 这个还是draft,
[40:04.000 --> 40:09.000] 感觉确实看不到什么希望了两年。
[40:10.000 --> 40:15.000] 是,这个也是我当时看到PM2.0发布,
[40:15.000 --> 40:20.000] 为什么把pip582放到一个非默认的选项里面,
[40:20.000 --> 40:26.000] 就是说感觉这个提案没有办法在短期内被接受,
[40:26.000 --> 40:27.000] 变成一个标准,
[40:27.000 --> 40:31.000] 所以用户接受起来可能会很难,
[40:31.000 --> 40:37.000] 因为大家可能就不想用一个非标准的东西,
[40:37.000 --> 40:38.000] 大家想用标准的东西,
[40:38.000 --> 40:41.000] 大家想用虚拟环境,
[40:41.000 --> 40:46.000] 所以就这个造成了PDM的推广上会有些困难,
[40:46.000 --> 40:50.000] 所以是不是可以理解为这个很大程度上
[40:50.000 --> 40:55.000] 是为了让PDM变得更流行的一个策略?
[40:55.000 --> 40:59.000] 对,因为一开始做PDM的时候,
[40:59.000 --> 41:02.000] 我也没想到它会多流行,
[41:02.000 --> 41:05.000] 因为只是一个个人兴趣爱好。
[41:06.000 --> 41:08.000] 那到2.0的话,
[41:08.000 --> 41:11.000] 我觉得它可能比较成熟了,
[41:11.000 --> 41:14.000] 所以我的野心也是相应的变大了,
[41:14.000 --> 41:17.000] 所以我希望它会为更多人所使用吧。
[41:19.000 --> 41:21.000] 但是我觉得这个拍package
[41:21.000 --> 41:23.000] 其实是一个很好的想法,
[41:23.000 --> 41:28.000] 因为我们现在都用拍emv,
[41:29.000 --> 41:34.000] 我出emv,wrapper,拍emv,我出emv,
[41:34.000 --> 41:37.000] 就是用各种东西来管理这个我出emv,
[41:37.000 --> 41:40.000] 就是有的时候你不想嵌套我出emv,
[41:40.000 --> 41:42.000] 它其实已经,
[41:42.000 --> 41:45.000] 就是你现在在一个我出emv里面,
[41:45.000 --> 41:52.000] 这个我出emv其实是连接到拍emv的SHIMS,
[41:52.000 --> 41:54.000] 所以这个环境就比较复杂,
[41:54.000 --> 41:57.000] 但是如果我们用拍package的话,
[41:57.000 --> 42:02.000] 它不管你的python到底连接到哪里,
[42:02.000 --> 42:04.000] 你只要是一个python battery,
[42:04.000 --> 42:07.000] 然后有这个拍package directory,
[42:07.000 --> 42:08.000] 就跟mode一样,
[42:08.000 --> 42:11.000] 它就是依赖就非常清晰,
[42:11.000 --> 42:12.000] 它就在那里,
[42:12.000 --> 42:14.000] 很少有犯错的机会。
[42:14.000 --> 42:15.000] 对对对,
[42:15.000 --> 42:17.000] 信涛也讲到一个比较重要的方面,
[42:17.000 --> 42:18.000] 就是我出emv有一个问题,
[42:18.000 --> 42:20.000] 就是它里面的python解析器
[42:20.000 --> 42:22.000] 都是实际连接到一个
[42:22.000 --> 42:25.000] 真正你的python的安装路径,
[42:25.000 --> 42:27.000] 那就导致你安装的这个python版本,
[42:27.000 --> 42:29.000] 你不能去删除它。
[42:29.000 --> 42:30.000] 对,
[42:30.000 --> 42:31.000] 是的,
[42:31.000 --> 42:33.000] 就是你如果不小心删除,
[42:33.000 --> 42:35.000] 因为你也不知道这个python解析器
[42:35.000 --> 42:37.000] 其实被虚拟环境所使用,
[42:37.000 --> 42:38.000] 你不知道,
[42:38.000 --> 42:40.000] 所以你觉得我可能要升级这个python版本,
[42:40.000 --> 42:41.000] 我把这个删了,
[42:41.000 --> 42:43.000] 就发现有很多虚拟环境不能用了。
[42:43.000 --> 42:45.000] 对对对,
[42:45.000 --> 42:47.000] 我觉得这个最本质的问题,
[42:47.000 --> 42:49.000] 就是python从诞生到今天,
[42:49.000 --> 42:51.000] 就是它的包管理,
[42:51.000 --> 42:53.000] 其实就没有好好的设计过,
[42:53.000 --> 42:56.000] 因为那个虚拟环境,
[42:56.000 --> 42:58.000] 它本质就是python解析器启动的时候,
[42:58.000 --> 43:00.000] 它就找那个os.py,
[43:00.000 --> 43:01.000] 这个module就必须存在了,
[43:01.000 --> 43:04.000] 它就找这个解析器所在的路径,
[43:04.000 --> 43:06.000] 从这个地方开始找,
[43:06.000 --> 43:07.000] 然后找到了这个,
[43:07.000 --> 43:11.000] 它就认为当前的side package应该是在这里,
[43:11.000 --> 43:12.000] 所以说大家,
[43:12.000 --> 43:14.000] 这个我出emv到现在都是一些hack,
[43:14.000 --> 43:19.000] 就是说我们用软链接去修改python的位置,
[43:19.000 --> 43:22.000] 然后让它开始search的开始路径,
[43:22.000 --> 43:23.000] 把它改变,
[43:23.000 --> 43:25.000] 让它从这里开始search,
[43:25.000 --> 43:26.000] 这样的话我们就有一个
[43:26.000 --> 43:29.000] we're true的side packages,
[43:29.000 --> 43:32.000] 到现在大家用的全都是这种话,
[43:32.000 --> 43:34.000] 我觉得非常神奇。
[43:34.000 --> 43:36.000] 是的,
[43:36.000 --> 43:39.000] 所以所谓用到python的地方,
[43:39.000 --> 43:42.000] 就比如说我们公司或者是在社区里,
[43:42.000 --> 43:43.000] 你会看到各种各样的问题,
[43:43.000 --> 43:45.000] 就是非常非常多,
[43:45.000 --> 43:47.000] 被问了上百万遍,
[43:47.000 --> 43:48.000] 就是我安装了,
[43:48.000 --> 43:50.000] 我pb install了一个东西,
[43:50.000 --> 43:51.000] 但是我pythoninput的时候,
[43:51.000 --> 43:53.000] 为什么它不是找不到,
[43:53.000 --> 43:54.000] 对吧,
[43:54.000 --> 43:58.000] 就是因为你的python甚至可能跟你python的解释器
[43:58.000 --> 43:59.000] 都不是同一个,
[43:59.000 --> 44:01.000] 就是你的python可能用在系统上了,
[44:01.000 --> 44:05.000] 但是你的python启动的时候是用了一个软链接到了,
[44:05.000 --> 44:07.000] 就是可能还是系统上的,
[44:07.000 --> 44:09.000] 但是你跑的是一个软链接,
[44:09.000 --> 44:12.000] 所以它搜索路径不会去找到系统上
[44:12.000 --> 44:14.000] 那个python安装的那个地方,
[44:14.000 --> 44:16.000] 这是一个非常非常经典的问题。
[44:17.000 --> 44:20.000] 这个理解跟我是一致的,
[44:20.000 --> 44:22.000] virtualenv就是一个hack,
[44:22.000 --> 44:24.000] 只是这个hack存在的时间太长了,
[44:24.000 --> 44:25.000] 大家都觉得,
[44:25.000 --> 44:28.000] 以为它是一个正常的事情。
[44:29.000 --> 44:30.000] 对,
[44:30.000 --> 44:35.000] 所以这个其实你如果写两年三年python这个问题,
[44:35.000 --> 44:37.000] 你肯定就了解了,
[44:37.000 --> 44:38.000] 因为你遇到无数遍了,
[44:38.000 --> 44:40.000] 但是对于一个刚开始学python的人,
[44:40.000 --> 44:44.000] 他说我要先学这个binary在哪里,
[44:44.000 --> 44:45.000] 这个软链接,
[44:45.000 --> 44:46.000] 然后os.py,
[44:46.000 --> 44:48.000] 它是怎么找的。
[44:48.000 --> 44:51.000] 我觉得你如果让一个新手学这些很不合理,
[44:51.000 --> 44:53.000] 但是你让一个新手不学这些,
[44:53.000 --> 44:55.000] 去绕过这些东西,
[44:55.000 --> 44:56.000] 用virtualenv,
[44:56.000 --> 45:03.000] 它是基本上没有什么办法去根本上理解这些错误的。
[45:03.000 --> 45:05.000] 我觉得新手就会直接ppinstall,
[45:05.000 --> 45:07.000] 然后所有东西都装到系统python里,
[45:07.000 --> 45:09.000] 然后就一场乱乱的。
[45:09.000 --> 45:10.000] 对这种事,
[45:10.000 --> 45:12.000] 但是ppinstall有一个,
[45:12.000 --> 45:14.000] 我觉得到现在可能没法解决的问题,
[45:14.000 --> 45:16.000] 就是你一旦install了,
[45:16.000 --> 45:17.000] 什么东西到系统上了,
[45:17.000 --> 45:19.000] 你是没办法把它卸载干净的。
[45:19.000 --> 45:21.000] 比如说你ppinstall了一个PDM,
[45:21.000 --> 45:22.000] 然后你pythoninstall,
[45:22.000 --> 45:24.000] 它只会把PDM删掉,
[45:24.000 --> 45:26.000] 它不会把PDM的依赖删掉。
[45:26.000 --> 45:27.000] 对,
[45:27.000 --> 45:29.000] 这也是因为python没有依赖解析,
[45:29.000 --> 45:32.000] 因为它不知道你曾经安装了什么依赖,
[45:32.000 --> 45:33.000] 这是一个这种概念。
[45:33.000 --> 45:34.000] 对,
[45:34.000 --> 45:38.000] 其实python这块就是历史遗留问题太多了,
[45:38.000 --> 45:41.000] 然后你像1989年python大成功之后,
[45:41.000 --> 45:43.000] 那这些best practice什么都没有,
[45:43.000 --> 45:47.000] 然后并且python一开始定位也是一个脚本语言,
[45:47.000 --> 45:49.000] 这些就是工程化的东西,
[45:49.000 --> 45:51.000] 它可能没有考虑太多。
[45:51.000 --> 45:55.000] 所以我觉得其实type582算是在这些混乱上
[45:55.000 --> 45:57.000] 一个非常好的抽象,
[45:57.000 --> 45:59.000] 就我们有一些新的best practice,
[45:59.000 --> 46:01.000] 然后叫npm,
[46:01.000 --> 46:03.000] 虽然这个npm有别的问题,
[46:03.000 --> 46:06.000] 但是大家觉得它的形式还是ok的,
[46:06.000 --> 46:08.000] 然后就是采用这样一种抽象,
[46:08.000 --> 46:11.000] 把原来这些很多像软链接,
[46:11.000 --> 46:14.000] virtualenv这种很奇怪的东西都屏蔽掉,
[46:14.000 --> 46:16.000] 其实我觉得这是一个挺好的方向,
[46:16.000 --> 46:18.000] 但是就是比较可惜,
[46:18.000 --> 46:23.000] 也是各种原因就没有能够成为标准,
[46:23.000 --> 46:29.000] 所以能有ppm这样一个很好的type582实现,
[46:29.000 --> 46:31.000] 我觉得还是社区的一个幸事。
[46:31.000 --> 46:32.000] 对,
[46:32.000 --> 46:36.000] 我觉得ppm用582的这种管理方式
[46:36.000 --> 46:39.000] 能解决我们刚刚说的所有的问题,
[46:39.000 --> 46:42.000] 但是可能有一些新的问题,
[46:42.000 --> 46:48.000] 比如说先安装的命令放在哪里的问题。
[46:48.000 --> 46:54.000] 我其实可以分享一下我当时切换到ppm的一些体验,
[46:54.000 --> 46:56.000] 就是我当时为什么切换到ppm,
[46:56.000 --> 46:57.000] 主要是有两个原因,
[46:57.000 --> 47:02.000] 第一个原因是我系统里需要安装的虚拟环境太多了,
[47:02.000 --> 47:05.000] 因为我之前开发cyberbrain,
[47:05.000 --> 47:09.000] 我需要测试一些小版本,
[47:09.000 --> 47:11.000] 比如说3.6.6,
[47:11.000 --> 47:13.000] 3.6.7的行为可能不一样,
[47:13.000 --> 47:19.000] 然后相当于我就得安装很多很多的python版本,
[47:19.000 --> 47:23.000] 那你可以想象每一个python版本我都得有一个virtualenv,
[47:23.000 --> 47:26.000] 并且我系统里还有其他在维护的项目,
[47:26.000 --> 47:28.000] 那么它又有很多别的virtualenv,
[47:28.000 --> 47:32.000] 所以最后我记得我应该是有十几个virtualenv,
[47:32.000 --> 47:36.000] 就是你每次弄一个列表下来就好长,
[47:36.000 --> 47:37.000] 这样转一转个屏幕,
[47:37.000 --> 47:39.000] 然后我就实在受不了了,
[47:39.000 --> 47:42.000] 我就是很想把这些东西都干掉,
[47:42.000 --> 47:44.000] 并且刚才也提到一个问题,
[47:44.000 --> 47:46.000] 就是你如果用virtualenv的话,
[47:46.000 --> 47:48.000] 你没有办法把原来那个env删掉,
[47:48.000 --> 47:52.000] 就是你比如说我想可能3.5被deprecated,
[47:52.000 --> 47:55.000] 然后想把所有3.5的env都换成3.6,
[47:55.000 --> 47:56.000] 做不到一个事情,
[47:56.000 --> 47:59.000] 除非你把所有的原来的env都删掉,
[47:59.000 --> 48:00.000] 然后重新创建一遍,
[48:00.000 --> 48:01.000] 这个非常非常麻烦。
[48:01.000 --> 48:05.000] 对,其实我也是,
[48:05.000 --> 48:08.000] 这是一个问题,
[48:08.000 --> 48:11.000] 然后另外一个问题是我之前用portrait嘛,
[48:11.000 --> 48:13.000] 然后也用了很长时间,
[48:13.000 --> 48:17.000] 然后就是因为portrait毕竟还是一个
[48:17.000 --> 48:20.000] 当时看来最现代的包装工具,
[48:20.000 --> 48:22.000] 但是就有很多很多bug,
[48:22.000 --> 48:24.000] 具体的哪些bug,
[48:24.000 --> 48:29.000] 反正也现在可能我觉得他们在github上
[48:29.000 --> 48:30.000] 还是open的状态,
[48:30.000 --> 48:36.000] 并且就是说portrait没有很好的去维护,
[48:36.000 --> 48:39.000] 就你感觉有一个bug可能放了两年三年,
[48:39.000 --> 48:41.000] 然后维护者他也没有去管,
[48:41.000 --> 48:44.000] 就有一种就是,
[48:44.000 --> 48:46.000] 也不能说unmaintained吧,
[48:46.000 --> 48:50.000] 反正就是感觉在utility上有点问题,
[48:50.000 --> 48:52.000] 反正我基本每次用portrait都会遇到问题,
[48:52.000 --> 48:56.000] 然后也是这两个问题综合起来之后受不了,
[48:56.000 --> 48:57.000] 就切换到PDM,
[48:57.000 --> 49:00.000] 然后就把所有的virtualenv都干掉了,
[49:00.000 --> 49:05.000] 然后就是相当于只有拍env安装那些python版本,
[49:05.000 --> 49:06.000] 我只需要一个,
[49:06.000 --> 49:09.000] 并且就是因为明显修bug也非常快,
[49:09.000 --> 49:11.000] 但这个我可以之后再聊,
[49:11.000 --> 49:14.000] 所以就是在稳定性方面有很大的提升,
[49:14.000 --> 49:15.000] 对,
[49:15.000 --> 49:17.000] 这是我当时切换的一个体验。
[49:18.000 --> 49:19.000] 嗯,
[49:19.000 --> 49:20.000] 我刚刚看了一下,
[49:20.000 --> 49:23.000] 武器盒里有122个virtualenv,
[49:23.000 --> 49:26.000] 我之前尝试过干过一样的事情,
[49:26.000 --> 49:30.000] 就是我希望把这些virtualenv从一个版本下到另一个版本,
[49:30.000 --> 49:31.000] 我一开始想的是,
[49:31.000 --> 49:36.000] 你只要去修改一下那个symbolic link,
[49:36.000 --> 49:37.000] 然后我,
[49:37.000 --> 49:38.000] 对,
[49:38.000 --> 49:40.000] 但其实会有很多其他的问题,
[49:40.000 --> 49:41.000] 也没成功,
[49:41.000 --> 49:43.000] 最后就把他们全删了。
[49:43.000 --> 49:45.000] 非常麻烦,
[49:45.000 --> 49:46.000] 非常麻烦,
[49:46.000 --> 49:47.000] 所以,
[49:47.000 --> 49:48.000] 嗯,
[49:48.000 --> 49:50.000] 就是说虽然pdm2.0,
[49:50.000 --> 49:51.000] 嗯,
[49:51.000 --> 49:53.000] 把pip2作为非默认选项,
[49:53.000 --> 49:55.000] 但它还是支持的,
[49:55.000 --> 49:57.000] 我觉得我还是会继续使用,
[49:57.000 --> 49:58.000] 可能很多人也会。
[50:00.000 --> 50:01.000] 对,
[50:03.000 --> 50:04.000] 嗯,
[50:04.000 --> 50:07.000] 那就是我们差不多聊一下pip2的,
[50:07.000 --> 50:08.000] 然后,
[50:08.000 --> 50:09.000] 呃,
[50:09.000 --> 50:12.000] 其实pdm2.0还有很多其他的一些很有用的改进,
[50:12.000 --> 50:13.000] 好明星,
[50:13.000 --> 50:14.000] 你要不要来介绍一下?
[50:14.000 --> 50:15.000] 嗯,
[50:16.000 --> 50:17.000] 呃,
[50:17.000 --> 50:19.000] 首先一个是这个,
[50:20.000 --> 50:24.000] 如果相比于其他的一些包管理工具来说,
[50:24.000 --> 50:29.000] 那pdm是对于这个后端是比较自由的,
[50:29.000 --> 50:34.000] 也就是说pdm其实不一定要求你要用pdm的后端,
[50:34.000 --> 50:35.000] 你可以用,
[50:35.000 --> 50:37.000] 你可以用flit的后端,
[50:37.000 --> 50:38.000] 你可以用hatch的后端,
[50:38.000 --> 50:40.000] 或者你可以用setup tools的后端,
[50:40.000 --> 50:42.000] 这个pdm都是完全没有问题,
[50:43.000 --> 50:44.000] 呃,
[50:44.000 --> 50:48.000] 第二个就是pdm支持了publish功能,
[50:48.000 --> 50:49.000] 呵呵呵,
[50:51.000 --> 50:52.000] 呃,
[50:52.000 --> 50:55.000] 之前我一直没有去加上这个publish命令,
[50:56.000 --> 50:57.000] 呃,
[50:57.000 --> 51:01.000] 是因为我觉得publish这个命令非常的,
[51:01.000 --> 51:02.000] 就是这个命令啊,
[51:02.000 --> 51:06.000] 就是有我们已经有现有的工具可以去做的,
[51:06.000 --> 51:08.000] 而且我个人使用来说,
[51:08.000 --> 51:09.000] 我从来不用,
[51:09.000 --> 51:11.000] 我从来不在本地publish,
[51:11.000 --> 51:12.000] 因为我觉得不保险,
[51:13.000 --> 51:16.000] 所以我一直都是在ci里面去publish的,
[51:16.000 --> 51:20.000] 所以可能我对于本人的一个使用习惯,
[51:20.000 --> 51:24.000] 可能没有顾及到大家的一些其他的使用习惯,
[51:24.000 --> 51:26.000] 所以感觉这个呼声还是很高的,
[51:26.000 --> 51:28.000] 所以我还是把这个publish命令给加上,
[51:30.000 --> 51:32.000] 你可不可以介绍一下publish是干什么的?
[51:32.000 --> 51:34.000] 其实我也是很期待这个功能,
[51:35.000 --> 51:37.000] publish就是在你在本地执行一条命令,
[51:37.000 --> 51:39.000] 直接把你的包给上传到PID,
[51:39.000 --> 51:40.000] 一键上传,
[51:41.000 --> 51:42.000] 我想问一下,
[51:42.000 --> 51:44.000] 这个是要从头实现的,
[51:44.000 --> 51:46.000] 因为有一个专门的包叫对,
[51:46.000 --> 51:47.000] 对吧?
[51:47.000 --> 51:48.000] 对对对,
[51:50.000 --> 51:53.000] 因为他要去帮你上传的时候,
[51:53.000 --> 51:54.000] 去解析一些meta信息,
[51:54.000 --> 51:55.000] 然后用API,
[51:56.000 --> 51:57.000] 对,
[51:59.000 --> 52:00.000] 所以,
[52:00.000 --> 52:02.000] 所以这些都是要你来实现的,
[52:02.000 --> 52:04.000] 还是说有一些酷批做的?
[52:05.000 --> 52:06.000] 嗯,
[52:06.000 --> 52:10.000] 我用的方法是基本基本搬运twin的实现吧,
[52:11.000 --> 52:14.000] 因为这个确实他那边去实现的是最好,
[52:14.000 --> 52:18.000] 但是我也不想去引入一个twin的依赖,
[52:18.000 --> 52:20.000] 因为他twin其实还包括很多其他东西,
[52:22.000 --> 52:23.000] 嗯,
[52:23.000 --> 52:24.000] 那是怎么做到的?
[52:24.000 --> 52:26.000] 是直接用了一些代码?
[52:27.000 --> 52:28.000] 对,
[52:28.000 --> 52:31.000] 其实最主要的就是那个原数据的解析上传,
[52:32.000 --> 52:35.000] 我们只能把这个给实现一下就可以了,
[52:37.000 --> 52:38.000] 哦,
[52:39.000 --> 52:40.000] 哦,
[52:40.000 --> 52:44.000] 那他就是你如果用这些代码的话,
[52:44.000 --> 52:48.000] 他一些测试也是要拿到你这边来操,
[52:49.000 --> 52:50.000] 对,
[52:50.000 --> 52:52.000] 测试基本上是自己重新写的,
[52:53.000 --> 52:58.000] 因为我们的测试覆盖也不要求有他们那么高吧,
[52:59.000 --> 53:00.000] 嗯,
[53:00.000 --> 53:02.000] 就我有时候也会这样,
[53:02.000 --> 53:05.000] 就是我看到一个还是或者是node的包,
[53:05.000 --> 53:07.000] 他里面就一个函数,
[53:07.000 --> 53:09.000] 然后他既然做了一个pool,
[53:09.000 --> 53:11.000] 我就直接把那个函数抄过来用,
[53:11.000 --> 53:12.000] 我是去安装那个依赖,
[53:13.000 --> 53:14.000] 对,
[53:14.000 --> 53:16.000] 特别是我只需要他核心的那一块功能,
[53:17.000 --> 53:18.000] 对,
[53:19.000 --> 53:21.000] 我记得我当时切换到PDM,
[53:21.000 --> 53:25.000] 好像问明星的一个问题就是说这个要怎么发布,
[53:25.000 --> 53:27.000] 因为以前我用portrait,
[53:27.000 --> 53:30.000] portrait手他有一个自带的发布功能,
[53:30.000 --> 53:32.000] 明星就说你要用tween,
[53:32.000 --> 53:33.000] 他只能用tween,
[53:34.000 --> 53:35.000] 嗯,
[53:35.000 --> 53:36.000] 对,
[53:36.000 --> 53:40.000] 我的习惯也都是build跟那个上传是两步,
[53:40.000 --> 53:42.000] 我之前用poetry也是poetrybuild,
[53:42.000 --> 53:44.000] 然后poetryupload,
[53:44.000 --> 53:45.000] 他是两步,
[53:45.000 --> 53:46.000] 是两步,
[53:46.000 --> 53:48.000] 但是你是一个工具还是两个工具,
[53:48.000 --> 53:50.000] 我觉得在用户体验上还是差别挺大的,
[53:50.000 --> 53:51.000] 嗯,
[53:51.000 --> 53:53.000] 我之前是因为比较信赖,
[53:53.000 --> 53:56.000] 所以我没有用poetrypublish,
[53:56.000 --> 53:57.000] OK,
[53:59.000 --> 54:00.000] 嗯,
[54:00.000 --> 54:07.000] 那然后我看还有就是你把这个命令行的UI换成了rich,
[54:08.000 --> 54:09.000] 对,
[54:09.000 --> 54:12.000] 因为rich是最近才出现的,
[54:12.000 --> 54:13.000] 嗯,
[54:13.000 --> 54:15.000] 也是一个很强大的UI吧,
[54:16.000 --> 54:19.000] 等于我把这个rich替换了原来很多,
[54:19.000 --> 54:22.000] 很多一些散的完成的功能,
[54:22.000 --> 54:24.000] 只用一个rich就可以做到了,
[54:26.000 --> 54:27.000] 嗯,
[54:27.000 --> 54:29.000] 很火的一个这种酷,
[54:29.000 --> 54:33.000] rich可以说是你如果要构建一个python的命令行工具,
[54:33.000 --> 54:34.000] 必用的酷了,
[54:34.000 --> 54:35.000] 现今来看,
[54:35.000 --> 54:40.000] 是能做出很炫酷的一些命令行效果,
[54:40.000 --> 54:41.000] 对,
[54:41.000 --> 54:42.000] 信超你可能比较了解吧,
[54:42.000 --> 54:43.000] 对,
[54:43.000 --> 54:45.000] 就是他能做出最炫酷的是啥,
[54:47.000 --> 54:48.000] 嗯,
[54:49.000 --> 54:50.000] 最炫酷的,
[54:50.000 --> 54:52.000] 最炫酷的可能是一些建筑条,
[54:52.000 --> 54:54.000] 那些洞的东西,
[54:54.000 --> 54:58.000] 就可以把一些东西能做出来动画的效果,
[54:58.000 --> 54:59.000] 就是他打出来,
[54:59.000 --> 55:00.000] 然后flash掉,
[55:00.000 --> 55:03.000] 就你看着就就就跟动画一样,
[55:03.000 --> 55:04.000] 很酷,
[55:04.000 --> 55:05.000] 像HTOP一样,
[55:06.000 --> 55:07.000] 是的是的,
[55:07.000 --> 55:08.000] 对,
[55:08.000 --> 55:11.000] 我觉得rich最最强大的就是这个live,
[55:11.000 --> 55:12.000] live这个,
[55:12.000 --> 55:14.000] 就是实时展示,
[55:15.000 --> 55:17.000] 就是你可以动态更新,
[55:18.000 --> 55:19.000] 嗯,
[55:20.000 --> 55:21.000] 嗯,
[55:21.000 --> 55:25.000] 那我们看还有就是那个,
[55:26.000 --> 55:28.000] 你把安装,
[55:28.000 --> 55:31.000] 就是你把包安装过程用,
[55:31.000 --> 55:33.000] 从原来用peak,
[55:33.000 --> 55:35.000] 然后切换到了一个自己实现的,
[55:36.000 --> 55:37.000] 对,
[55:37.000 --> 55:39.000] 这也是基于很多的考虑吧,
[55:40.000 --> 55:43.000] 因为之前用peak去做安装的话,
[55:44.000 --> 55:45.000] 嗯,
[55:45.000 --> 55:47.000] 遇到很多问题,
[55:47.000 --> 55:49.000] 最大的问题就是,
[55:49.000 --> 55:50.000] 嗯,
[55:50.000 --> 55:52.000] 一个peak的版本升级,
[55:52.000 --> 55:54.000] 可能就轻易的就把你这个,
[55:54.000 --> 55:55.000] API给break掉,
[55:55.000 --> 55:57.000] 因为他们完全没有承诺,
[55:57.000 --> 55:58.000] 那API的兼容性,
[55:58.000 --> 56:02.000] peak用的是一个基于时间的版本管理,
[56:03.000 --> 56:04.000] 第二个是,
[56:04.000 --> 56:05.000] 这个,
[56:05.000 --> 56:06.000] 不好意思,
[56:06.000 --> 56:07.000] 能不能先说一下,
[56:07.000 --> 56:08.000] 这个peak internal,
[56:08.000 --> 56:09.000] 跟,
[56:09.000 --> 56:10.000] 嗯,
[56:10.000 --> 56:11.000] 哎,
[56:11.000 --> 56:12.000] 这个怎么读啊,
[56:12.000 --> 56:13.000] on earth,
[56:13.000 --> 56:14.000] on earth,
[56:14.000 --> 56:15.000] 嗯,
[56:15.000 --> 56:16.000] 这个是干什么的,
[56:16.000 --> 56:17.000] 嗯,
[56:18.000 --> 56:19.000] on earth,
[56:19.000 --> 56:20.000] 跟peak internal,
[56:20.000 --> 56:22.000] 主要是用来去,
[56:22.000 --> 56:24.000] find的一个package,
[56:24.000 --> 56:26.000] 就是从peak API上找到,
[56:26.000 --> 56:28.000] 一个想要安装的package,
[56:28.000 --> 56:29.000] 哦,
[56:30.000 --> 56:31.000] 也就是,
[56:31.000 --> 56:32.000] 刚才前面也提到,
[56:32.000 --> 56:34.000] 就是从一堆wheel里面,
[56:34.000 --> 56:36.000] 找到我匹配的那个wheel,
[56:36.000 --> 56:37.000] 就是这个功能,
[56:37.000 --> 56:38.000] 嗯,
[56:38.000 --> 56:39.000] 哦,
[56:40.000 --> 56:42.000] 之前我们是直接用的,
[56:42.000 --> 56:43.000] peak内部的API,
[56:43.000 --> 56:45.000] 然后这个API,
[56:46.000 --> 56:47.000] 经常会,
[56:47.000 --> 56:49.000] 因为版本升级而break掉,
[56:49.000 --> 56:50.000] 所以,
[56:51.000 --> 56:52.000] 所以就,
[56:52.000 --> 56:54.000] 就自己实现了一个轮子,
[56:55.000 --> 56:56.000] 第二个问题是,
[56:56.000 --> 56:57.000] 呃,
[56:57.000 --> 56:58.000] 如果,
[56:58.000 --> 57:00.000] 我们要在这个PDM区,
[57:00.000 --> 57:01.000] 依赖peak的话,
[57:01.000 --> 57:04.000] 因为peak实在是一个太基础,
[57:04.000 --> 57:05.000] 太基础的,
[57:05.000 --> 57:06.000] 一个开心的依赖了,
[57:07.000 --> 57:10.000] 那在很多linux发行板上,
[57:10.000 --> 57:11.000] 他们安装工具,
[57:11.000 --> 57:13.000] 他们都不会去隔离安装的,
[57:13.000 --> 57:14.000] 就是说,
[57:14.000 --> 57:16.000] 他们都会把一些包,
[57:16.000 --> 57:18.000] 直接安装在他们的系统中央,
[57:18.000 --> 57:21.000] 那如果你去依赖一个peak的指定版本的话,
[57:22.000 --> 57:24.000] 会造成很多有可能的冲突问题,
[57:25.000 --> 57:26.000] 对,
[57:26.000 --> 57:27.000] 你不能锁定这个版本,
[57:27.000 --> 57:28.000] 对,
[57:30.000 --> 57:31.000] 并且就是应该你只,
[57:31.000 --> 57:32.000] 呃,
[57:32.000 --> 57:33.000] 只需要peak的那个,
[57:33.000 --> 57:35.000] 从pypi找包,
[57:35.000 --> 57:36.000] 然后下载,
[57:36.000 --> 57:38.000] 然后你也不需要其他的,
[57:38.000 --> 57:39.000] 对,
[57:39.000 --> 57:39.000] 对,
[57:39.000 --> 57:40.000] 这也是刚才的问题,
[57:40.000 --> 57:41.000] 我们只需要他其中一块的话,
[57:41.000 --> 57:44.000] 我真的完全不需要去依赖他,
[57:45.000 --> 57:46.000] 嗯,
[57:46.000 --> 57:47.000] 靠过来,
[57:50.000 --> 57:51.000] 嗯,
[57:51.000 --> 57:54.000] 然后那个2.0里还有一个很重要的改进,
[57:54.000 --> 57:55.000] 就是呃,
[57:55.000 --> 57:58.000] 相与user script变得更强大了,
[57:58.000 --> 57:59.000] 所以我觉得呃,
[57:59.000 --> 58:01.000] 对用户来讲还是一个挺重要的改进,
[58:03.000 --> 58:04.000] 对,
[58:04.000 --> 58:05.000] 呃,
[58:05.000 --> 58:07.000] user script就是刚才提到的,
[58:07.000 --> 58:08.000] 呃,
[58:09.000 --> 58:11.000] 跑之前要运行的动作,
[58:11.000 --> 58:13.000] 跑之后要运动的动作,
[58:13.000 --> 58:17.000] 而且还包括很多pdm本身的一些生命周期,
[58:17.000 --> 58:18.000] 比如说你,
[58:18.000 --> 58:19.000] 呃,
[58:19.000 --> 58:22.000] 生成log文件会执行一个脚本,
[58:22.000 --> 58:24.000] 或者说你init完,
[58:24.000 --> 58:26.000] init完会生成执行一个脚本,
[58:26.000 --> 58:29.000] 或者是你install完自动执行一个脚本,
[58:29.000 --> 58:33.000] 这些在我们的脚本系统里面都是可以去实现的,
[58:35.000 --> 58:36.000] 嗯,
[58:37.000 --> 58:38.000] 嗯,
[58:38.000 --> 58:39.000] 对,
[58:41.000 --> 58:42.000] 我记得那个呃,
[58:42.000 --> 58:45.000] 就user script还有一个2.0的改进,
[58:45.000 --> 58:46.000] 就是那个呃,
[58:46.000 --> 58:49.000] 相当于你可以先执行一个script,
[58:49.000 --> 58:50.000] 再执行另外一个,
[58:50.000 --> 58:52.000] 就是把它那个串起来,
[58:52.000 --> 58:53.000] 对对对,
[58:53.000 --> 58:53.000] 呃,
[58:53.000 --> 58:55.000] 这个就是组合脚本,
[58:55.000 --> 58:58.000] 就是说一个脚本里面去执行多个其他脚本,
[58:58.000 --> 59:03.000] 然后这些组合脚本之间也有一些pre script,
[59:03.000 --> 59:06.000] post script的这些东西,
[59:06.000 --> 59:09.000] 所以你可以去把这些功能组合起来,
[59:09.000 --> 59:13.000] 去完成你任意想要的任务编排的一个效果,
[59:14.000 --> 59:15.000] 嗯,
[59:15.000 --> 59:15.000] 哎,
[59:15.000 --> 59:18.000] 我想问一下这个脚本是怎么实现的,
[59:18.000 --> 59:19.000] 就是呃,
[59:19.000 --> 59:22.000] 它是开了subprocess,
[59:22.000 --> 59:23.000] 用python解释,
[59:23.000 --> 59:24.000] 直接python去跑,
[59:24.000 --> 59:28.000] 还是你动态的一port用过你这个脚本,
[59:28.000 --> 59:30.000] 然后在执行里面的排数,
[59:30.000 --> 59:31.000] 嗯,
[59:32.000 --> 59:36.000] 我们的user script支持很多种不同的类型,
[59:36.000 --> 59:38.000] 一个是最普通的,
[59:38.000 --> 59:39.000] 就是cmd,
[59:39.000 --> 59:45.000] 也就是说这种方式是用subprocess去执行的,
[59:45.000 --> 59:46.000] 第二种就是shell,
[59:46.000 --> 59:48.000] 相当于是那个shell等于shell,
[59:48.000 --> 59:51.000] 你可以去做一些shell专用的一些功能,
[59:51.000 --> 59:53.000] 第三个呢,
[59:53.000 --> 59:57.000] 就是你可以执行一个你指定的python函数,
[59:58.000 --> 59:59.000] 嗯,
[59:59.000 --> 01:00:00.000] 呃,
[01:00:00.000 --> 01:00:01.000] python函数呢,
[01:00:01.000 --> 01:00:03.000] 就是这个脚本要是,
[01:00:03.000 --> 01:00:05.000] 就是你怎么引号的,
[01:00:05.000 --> 01:00:06.000] 你怎么找到这个函数,
[01:00:07.000 --> 01:00:08.000] 呃,
[01:00:08.000 --> 01:00:12.000] 这种python函数我们实现方法也是比较tricky,
[01:00:12.000 --> 01:00:18.000] 就是把它从这个他指定的这些函数生成一个我们伪造的一个脚本,
[01:00:18.000 --> 01:00:19.000] 然后执行这个脚本,
[01:00:20.000 --> 01:00:21.000] 嗯,
[01:00:21.000 --> 01:00:22.000] 嗯,
[01:00:22.000 --> 01:00:25.000] 也就是说你去读他的脚本这个文件内容,
[01:00:25.000 --> 01:00:26.000] 然后你把这个,
[01:00:27.000 --> 01:00:28.000] 呃,
[01:00:28.000 --> 01:00:30.000] 要要通过python的语法分析,
[01:00:30.000 --> 01:00:31.000] 然后去算,
[01:00:31.000 --> 01:00:32.000] 嗯,
[01:00:32.000 --> 01:00:37.000] 比如说他要比如说他要执行module a里面的,
[01:00:37.000 --> 01:00:38.000] 呃,
[01:00:38.000 --> 01:00:39.000] b函数,
[01:00:39.000 --> 01:00:41.000] 那我们就生成一个脚本,
[01:00:41.000 --> 01:00:43.000] 脚本里面只有一行from module a,
[01:00:43.000 --> 01:00:44.000] input b,
[01:00:44.000 --> 01:00:45.000] 然后b执行,
[01:00:46.000 --> 01:00:47.000] 嗯,
[01:00:48.000 --> 01:00:49.000] ok,
[01:00:49.000 --> 01:00:52.000] 但是他把他需要把这个脚本放在特定的地方吗?
[01:00:52.000 --> 01:00:55.000] 不然的话你怎么从module a来input?
[01:00:56.000 --> 01:01:03.000] 那我们就就假定用户已经把这些他需要的module已经安装好,
[01:01:03.000 --> 01:01:06.000] 通过PDM install的方式,
[01:01:06.000 --> 01:01:07.000] 哦,
[01:01:07.000 --> 01:01:08.000] ok,
[01:01:08.000 --> 01:01:09.000] 明白了,
[01:01:09.000 --> 01:01:10.000] 嗯,
[01:01:10.000 --> 01:01:11.000] 是,
[01:01:13.000 --> 01:01:14.000] 对,
[01:01:14.000 --> 01:01:15.000] 就是,
[01:01:15.000 --> 01:01:16.000] 呃,
[01:01:16.000 --> 01:01:19.000] 那个关于那个PDM2.0里的一些新功能,
[01:01:19.000 --> 01:01:21.000] 然后就是明显写了一篇文章,
[01:01:21.000 --> 01:01:22.000] 有中英文两个版本,
[01:01:22.000 --> 01:01:23.000] 对,
[01:01:23.000 --> 01:01:24.000] 我们会放在show notes,
[01:01:24.000 --> 01:01:25.000] 大家可以看一下,
[01:01:25.000 --> 01:01:27.000] 就是写的还是非常好的,
[01:01:27.000 --> 01:01:28.000] 然后,
[01:01:28.000 --> 01:01:30.000] 并且其中有一套很喜欢,
[01:01:30.000 --> 01:01:32.000] 就是一个那个用户反馈,
[01:01:33.000 --> 01:01:34.000] 是,
[01:01:34.000 --> 01:01:35.000] 呃,
[01:01:35.000 --> 01:01:36.000] 你要自己说一下吗?
[01:01:36.000 --> 01:01:37.000] 还是,
[01:01:37.000 --> 01:01:38.000] 呃,
[01:01:38.000 --> 01:01:41.000] 所以设计我们之前做那个为什么用PDM的问题,
[01:01:43.000 --> 01:01:48.000] 这个用户反馈也是给我个人比较大的鼓舞吧,
[01:01:48.000 --> 01:01:51.000] 具体的话我们也会贴在你的show notes里面,
[01:01:53.000 --> 01:01:54.000] 嗯,
[01:01:54.000 --> 01:01:56.000] 就就不逐条说了,
[01:01:56.000 --> 01:01:59.000] 但其实他就是一个,
[01:01:59.000 --> 01:02:01.000] 每次有新的用户过来呢,
[01:02:01.000 --> 01:02:04.000] 都是喜忧参半,
[01:02:04.000 --> 01:02:06.000] 喜的是他可能会有一些正面的反馈,
[01:02:06.000 --> 01:02:08.000] 忧的是他可能会爆很多bug,
[01:02:12.000 --> 01:02:15.000] 曾经就是一个爆了很多bug的用户,
[01:02:16.000 --> 01:02:19.000] 我们那个,
[01:02:19.000 --> 01:02:23.000] dbcli在slack有一个channel叫,
[01:02:24.000 --> 01:02:26.000] 叫什么英文忘了,
[01:02:26.000 --> 01:02:27.000] 就是叫夸奖,
[01:02:27.000 --> 01:02:29.000] 然后大家在推特啊,
[01:02:29.000 --> 01:02:30.000] 什么社区啊,
[01:02:30.000 --> 01:02:31.000] 看到一些,
[01:02:31.000 --> 01:02:32.000] mysqli,
[01:02:32.000 --> 01:02:33.000] cli,
[01:02:33.000 --> 01:02:34.000] cli,
[01:02:34.000 --> 01:02:35.000] 有人发推啊,
[01:02:35.000 --> 01:02:36.000] 或者什么,
[01:02:36.000 --> 01:02:37.000] 大家都会贴那些,
[01:02:37.000 --> 01:02:38.000] 所以你打开那个channel,
[01:02:38.000 --> 01:02:39.000] 全都是一些,
[01:02:39.000 --> 01:02:41.000] 非常好的东西,
[01:02:42.000 --> 01:02:44.000] 觉得是很好的,
[01:02:44.000 --> 01:02:48.000] 然后关于这个用户反馈的一些pdm的好处,
[01:02:48.000 --> 01:02:50.000] 其实我们之前也基本聊到了,
[01:02:50.000 --> 01:02:51.000] 那边还有一个,
[01:02:51.000 --> 01:02:53.000] 我们没有聊到的是这个,
[01:02:53.000 --> 01:02:55.000] 那个install catch,
[01:02:55.000 --> 01:02:57.000] 这个我们可以详细说一下,
[01:02:57.000 --> 01:02:58.000] 就是pdm是,
[01:02:59.000 --> 01:03:02.000] 可以支持把你install过的包,
[01:03:02.000 --> 01:03:05.000] 来catch到一个中心化的一个地方,
[01:03:05.000 --> 01:03:07.000] 不用你每次,
[01:03:07.000 --> 01:03:10.000] 每次安装同样的包都要去下载一遍,
[01:03:10.000 --> 01:03:11.000] 具体来说,
[01:03:11.000 --> 01:03:12.000] 就是说,
[01:03:12.000 --> 01:03:15.000] 比如说你有两个project都依赖了,
[01:03:15.000 --> 01:03:16.000] click,
[01:03:16.000 --> 01:03:19.000] 那我们这个click在你的电脑上只会存在遗憾,
[01:03:22.000 --> 01:03:24.000] 这个是用软链接实现的吗,
[01:03:24.000 --> 01:03:26.000] 还是说就是下载那个地方,
[01:03:26.000 --> 01:03:29.000] 如果是支持软链接的系统,
[01:03:29.000 --> 01:03:31.000] 就是用软链接实现的,
[01:03:31.000 --> 01:03:34.000] 否则是用那个pass,
[01:03:34.000 --> 01:03:36.000] pass的hack去实现的,
[01:03:36.000 --> 01:03:39.000] 就是说把把那个中心化,
[01:03:39.000 --> 01:03:41.000] 缓存的那个包的路径,
[01:03:41.000 --> 01:03:43.000] 加到你的syspass里面,
[01:03:43.000 --> 01:03:44.000] 哦,
[01:03:44.000 --> 01:03:46.000] 你这个缓存不光是下载缓存,
[01:03:46.000 --> 01:03:48.000] 就是它实际都没有copy,
[01:03:48.000 --> 01:03:49.000] 对,
[01:03:49.000 --> 01:03:50.000] 对,
[01:03:50.000 --> 01:03:52.000] 它没有没有copy,
[01:03:52.000 --> 01:03:53.000] 就是说,
[01:03:53.000 --> 01:03:54.000] 这个很神奇,
[01:03:54.000 --> 01:03:55.000] 这个,
[01:03:55.000 --> 01:03:56.000] 这个比node强多了,
[01:03:56.000 --> 01:03:57.000] node,
[01:03:59.000 --> 01:04:00.000] 如果,
[01:04:00.000 --> 01:04:02.000] 如果大家用node的话,
[01:04:02.000 --> 01:04:05.000] 你会听说过一个包管理器叫pnpm,
[01:04:05.000 --> 01:04:07.000] 它的主要卖点就是这个,
[01:04:08.000 --> 01:04:09.000] 哦,
[01:04:09.000 --> 01:04:10.000] 这个,
[01:04:10.000 --> 01:04:11.000] 这个很强,
[01:04:11.000 --> 01:04:13.000] 可以省很多磁盘空间吧,
[01:04:13.000 --> 01:04:17.000] 如果大家对磁盘空间可能不那么在意的话,
[01:04:17.000 --> 01:04:18.000] 对,
[01:04:18.000 --> 01:04:19.000] 哎,
[01:04:19.000 --> 01:04:20.000] 他看那个,
[01:04:20.000 --> 01:04:21.000] 呃,
[01:04:21.000 --> 01:04:23.000] pip是不是用的同一个路径,
[01:04:23.000 --> 01:04:24.000] 就比如说,
[01:04:24.000 --> 01:04:25.000] 你pnpm扫了一个东西,
[01:04:25.000 --> 01:04:26.000] 这也有,
[01:04:26.000 --> 01:04:27.000] 这也会有缓存对吧,
[01:04:27.000 --> 01:04:28.000] 呃,
[01:04:28.000 --> 01:04:30.000] 跟pip的缓存的路径是不一样的,
[01:04:32.000 --> 01:04:35.000] 确实可能比较比较难以兼容,
[01:04:35.000 --> 01:04:36.000] 嗯,
[01:04:38.000 --> 01:04:39.000] 是好的,
[01:04:39.000 --> 01:04:40.000] 那,
[01:04:40.000 --> 01:04:41.000] 呃,
[01:04:41.000 --> 01:04:43.000] 其实我们刚才也差不多要聊到这个环节,
[01:04:43.000 --> 01:04:46.000] 就是我们想请明星聊一下,
[01:04:46.000 --> 01:04:50.000] 就开发ppm过程中的一些值得一说的事情,
[01:04:50.000 --> 01:04:53.000] 就是像比如说用户反馈啊,
[01:04:53.000 --> 01:04:54.000] 然后一些,
[01:04:54.000 --> 01:04:55.000] 呃,
[01:04:55.000 --> 01:04:57.000] 像之前提到的用ppm来做速读,
[01:04:57.000 --> 01:04:58.000] 这个都是,
[01:04:58.000 --> 01:04:59.000] 呃,
[01:04:59.000 --> 01:05:00.000] 很有意思的一些一些事情,
[01:05:00.000 --> 01:05:01.000] 对,
[01:05:01.000 --> 01:05:02.000] 那,
[01:05:02.000 --> 01:05:03.000] 呃,
[01:05:03.000 --> 01:05:04.000] 看你想先聊哪一个吧,
[01:05:04.000 --> 01:05:06.000] 那你既然说了速读,
[01:05:06.000 --> 01:05:07.000] 我们就先说一下速读,
[01:05:07.000 --> 01:05:11.000] 那其实这个也是一个比较有趣的事情吧,
[01:05:11.000 --> 01:05:12.000] 就是,
[01:05:12.000 --> 01:05:13.000] 呃,
[01:05:13.000 --> 01:05:15.000] 在社区上我发现有一个人,
[01:05:15.000 --> 01:05:17.000] 他就是写了一篇文章,
[01:05:17.000 --> 01:05:22.000] 就是他用一些依赖解析器去解析速读问题,
[01:05:22.000 --> 01:05:23.000] 但是,
[01:05:23.000 --> 01:05:24.000] 啊,
[01:05:24.000 --> 01:05:26.000] 乍一看上去好像是一些啊,
[01:05:26.000 --> 01:05:28.000] 依赖解析器还能这么用吗?
[01:05:28.000 --> 01:05:29.000] 那些邪路的用法,
[01:05:29.000 --> 01:05:32.000] 而看完他的文章之后呢,
[01:05:32.000 --> 01:05:33.000] 就发现,
[01:05:33.000 --> 01:05:34.000] 哎,
[01:05:34.000 --> 01:05:36.000] 好像确实可以这么玩,
[01:05:36.000 --> 01:05:37.000] 然后,
[01:05:37.000 --> 01:05:38.000] 因为他里面没有,
[01:05:38.000 --> 01:05:39.000] 他的例子里面没有说,
[01:05:39.000 --> 01:05:40.000] 呃,
[01:05:40.000 --> 01:05:41.000] ppm执行的效果,
[01:05:41.000 --> 01:05:43.000] 所以我自己就用ppm去玩了一下,
[01:05:43.000 --> 01:05:45.000] 就是去解决一个速读,
[01:05:45.000 --> 01:05:47.000] 效果还行,
[01:05:47.000 --> 01:05:49.000] 就是也是解出来了,
[01:05:49.000 --> 01:05:50.000] 正确的结果,
[01:05:50.000 --> 01:05:52.000] 这个原理,
[01:05:52.000 --> 01:05:53.000] 呃,
[01:05:53.000 --> 01:05:54.000] 这个原理,
[01:05:54.000 --> 01:05:58.000] 速读问题跟依赖解析是有关系的,
[01:05:58.000 --> 01:06:00.000] 为什么能解决这个速读问题?
[01:06:01.000 --> 01:06:07.000] 因为他把这个速读问题转化成了一个依赖解析的一个模型,
[01:06:07.000 --> 01:06:08.000] 就是说,
[01:06:08.000 --> 01:06:12.000] 速读不是说一个一行一列不能出现重复的数字吗?
[01:06:12.000 --> 01:06:15.000] 然后一个小方块里面不能出现重复的数字,
[01:06:15.000 --> 01:06:16.000] 然后是1到9,
[01:06:16.000 --> 01:06:18.000] 必须各自出现一次,
[01:06:18.000 --> 01:06:20.000] 那么他就把这个解析,
[01:06:20.000 --> 01:06:21.000] 呃,
[01:06:21.000 --> 01:06:23.000] 换成了一个依赖解析的问题,
[01:06:23.000 --> 01:06:24.000] 这个是怎么做呢?
[01:06:24.000 --> 01:06:27.000] 就是他去把这个棋盘格子,
[01:06:27.000 --> 01:06:30.000] 9成9的棋盘格子化成了81个依赖,
[01:06:30.000 --> 01:06:32.000] 就是每一个格子其实都是一个依赖,
[01:06:32.000 --> 01:06:36.000] 那这个依赖可能的只有1到9,
[01:06:36.000 --> 01:06:39.000] 我们把这个1到9转化成这个依赖的版本,
[01:06:39.000 --> 01:06:41.000] 就是说这个依赖可能有1到9,
[01:06:41.000 --> 01:06:42.000] 这是9个版本,
[01:06:42.000 --> 01:06:44.000] 那每一个版本呢?
[01:06:44.000 --> 01:06:47.000] 他都有一些依赖的限制,
[01:06:47.000 --> 01:06:48.000] 比如说,
[01:06:48.000 --> 01:06:49.000] 呃,
[01:06:49.000 --> 01:06:50.000] 1-1这个格子,
[01:06:50.000 --> 01:06:52.000] 如果他的值是1的话,
[01:06:52.000 --> 01:06:54.000] 就是他的版本1,
[01:06:54.000 --> 01:06:55.000] 这个版本的包,
[01:06:55.000 --> 01:07:00.000] 他必须要求1-2的版本不能是1,
[01:07:00.000 --> 01:07:02.000] 1-3的版本不能是1,
[01:07:02.000 --> 01:07:03.000] 然后以此类推,
[01:07:03.000 --> 01:07:07.000] 然后且他必须要求2-1的版本,
[01:07:07.000 --> 01:07:09.000] 3-1的版本都不能是1,
[01:07:09.000 --> 01:07:11.000] 那么你就可以把它写成一个,
[01:07:11.000 --> 01:07:13.000] 一个依赖列表,
[01:07:13.000 --> 01:07:17.000] 对于1-1等于1的这个版本,
[01:07:17.000 --> 01:07:20.000] 他的依赖列表应该会有,
[01:07:20.000 --> 01:07:21.000] 呃,
[01:07:21.000 --> 01:07:24.000] 一行一列加上一个方格,
[01:07:24.000 --> 01:07:26.000] 这么多的一个依赖项,
[01:07:26.000 --> 01:07:30.000] 那每一个就是这个81个包的,
[01:07:30.000 --> 01:07:31.000] 81个包,
[01:07:31.000 --> 01:07:32.000] 每个包有9个版本,
[01:07:32.000 --> 01:07:34.000] 就是729个版本,
[01:07:34.000 --> 01:07:37.000] 每个版本他都指定一套一些依赖,
[01:07:37.000 --> 01:07:41.000] 就是把你这个解题的一些限制了,
[01:07:41.000 --> 01:07:43.000] 化成了这个依赖的表达。
[01:07:46.000 --> 01:07:47.000] 我听明白了,
[01:07:47.000 --> 01:07:50.000] 但是我不明白的一点是,
[01:07:50.000 --> 01:07:54.000] 依赖解析会支持那种线套吗?
[01:07:54.000 --> 01:07:57.000] 就比如说我只有在A这个版本等于什么的时候,
[01:07:57.000 --> 01:07:59.000] 我的B才有这些要求?
[01:08:03.000 --> 01:08:04.000] 依赖解析,
[01:08:04.000 --> 01:08:08.000] 依赖的限制其实就是对于某一个版本的包,
[01:08:08.000 --> 01:08:09.000] 你对这个版本,
[01:08:09.000 --> 01:08:12.000] 他的依赖的版本有哪些限制吗?
[01:08:12.000 --> 01:08:13.000] 对吧?
[01:08:13.000 --> 01:08:14.000] 那么我的,
[01:08:14.000 --> 01:08:15.000] 哦,
[01:08:15.000 --> 01:08:16.000] 对,
[01:08:16.000 --> 01:08:18.000] 那么就指定1-1的这个,
[01:08:18.000 --> 01:08:22.000] 这个包他会去依赖他同一行的所有的包,
[01:08:22.000 --> 01:08:24.000] 加上他同一类的所有的包,
[01:08:24.000 --> 01:08:26.000] 加上他同一个方格的所有包,
[01:08:26.000 --> 01:08:27.000] 就是每一个,
[01:08:27.000 --> 01:08:29.000] 每一个格子的依赖,
[01:08:29.000 --> 01:08:31.000] 他都有一些他的子依赖,
[01:08:31.000 --> 01:08:32.000] 对,
[01:08:32.000 --> 01:08:33.000] 哦,
[01:08:33.000 --> 01:08:34.000] 那,
[01:08:34.000 --> 01:08:35.000] 那就是说依赖解析器,
[01:08:35.000 --> 01:08:38.000] 他要支持你去限定依赖的依赖,
[01:08:38.000 --> 01:08:39.000] 对,
[01:08:39.000 --> 01:08:40.000] 对,
[01:08:40.000 --> 01:08:41.000] 可以这么说,
[01:08:43.000 --> 01:08:46.000] 那你这个实现是不是只要写那个,
[01:08:47.000 --> 01:08:48.000] 对,
[01:08:48.000 --> 01:08:53.000] 实现只需要去生成这729个包就可以。
[01:08:55.000 --> 01:08:56.000] 所以那个,
[01:08:56.000 --> 01:08:58.000] 就是依赖的写法,
[01:08:58.000 --> 01:09:01.000] 写依赖的时候可以支持不等于什么?
[01:09:01.000 --> 01:09:02.000] 可以,
[01:09:02.000 --> 01:09:03.000] 可以,
[01:09:03.000 --> 01:09:04.000] 可以支持不等于。
[01:09:07.000 --> 01:09:09.000] 这个很有意思,
[01:09:09.000 --> 01:09:10.000] 对,
[01:09:10.000 --> 01:09:11.000] 我觉得,
[01:09:11.000 --> 01:09:12.000] 没有,
[01:09:12.000 --> 01:09:14.000] 没有想到有这种,
[01:09:14.000 --> 01:09:16.000] 这两个问题相通的,
[01:09:16.000 --> 01:09:18.000] 但是感觉科普了一波,
[01:09:18.000 --> 01:09:19.000] 这个这个依赖解析。
[01:09:23.000 --> 01:09:24.000] 嗯,
[01:09:24.000 --> 01:09:29.000] 第二个有趣的事就是这个PDM的全名的这个问题,
[01:09:29.000 --> 01:09:35.000] 因为一开始我们这个PDM的全名是python developer master,
[01:09:35.000 --> 01:09:38.000] 那基于某些政治正确的原因呢,
[01:09:38.000 --> 01:09:40.000] 就有些人提出来说,
[01:09:40.000 --> 01:09:42.000] 最好不要叫master,
[01:09:42.000 --> 01:09:43.000] 呃,
[01:09:43.000 --> 01:09:44.000] 叫manager,
[01:09:44.000 --> 01:09:47.000] 而且manager更符合我们的直觉。
[01:09:49.000 --> 01:09:52.000] 当然有有这个意见就有反对意见,
[01:09:52.000 --> 01:09:54.000] 就说我觉得master挺好。
[01:09:54.000 --> 01:09:59.000] 就是我经常碰到这种社区的一些争议的时候,
[01:09:59.000 --> 01:10:02.000] 我个人是没有那么大的主见吧,
[01:10:02.000 --> 01:10:04.000] 就是我觉得都可以,
[01:10:04.000 --> 01:10:05.000] 其实。
[01:10:05.000 --> 01:10:08.000] 那最后的解决方法呢,
[01:10:08.000 --> 01:10:13.000] 就是我们把这个全名从比较明显的位置给引掉了,
[01:10:13.000 --> 01:10:18.000] 就是大家在比较明显的地方是看不到这个全名的解释,
[01:10:18.000 --> 01:10:19.000] 就是。
[01:10:21.000 --> 01:10:22.000] 对,
[01:10:22.000 --> 01:10:24.000] 就像大家只会说npm,
[01:10:24.000 --> 01:10:26.000] 如果说node package manager,
[01:10:26.000 --> 01:10:27.000] 对对对。
[01:10:31.000 --> 01:10:32.000] 对,
[01:10:32.000 --> 01:10:35.000] 我也觉得就算叫master应该也没什么问题,
[01:10:36.000 --> 01:10:37.000] 听众解释一下,
[01:10:37.000 --> 01:10:39.000] 就是可能有些听众不太了解,
[01:10:39.000 --> 01:10:40.000] 因为就是,
[01:10:40.000 --> 01:10:41.000] 呃,
[01:10:41.000 --> 01:10:43.000] 这个我觉得是美国人的一个政治正确吧,
[01:10:43.000 --> 01:10:46.000] 就是因为master有一个这种奴役主的意思,
[01:10:46.000 --> 01:10:49.000] 然后在美国这方面就非常敏感,
[01:10:49.000 --> 01:10:52.000] 就是像涉及到黑人历史的一些东西,
[01:10:52.000 --> 01:10:53.000] 那你叫master的话,
[01:10:53.000 --> 01:10:54.000] 就是,
[01:10:54.000 --> 01:10:55.000] 呃,
[01:10:55.000 --> 01:10:58.000] 大家会觉得说你虽然说你刚才说的不是那个意思,
[01:10:58.000 --> 01:11:00.000] 但毕竟有这样一个意思,
[01:11:00.000 --> 01:11:01.000] 就像中文里有些同音嘴,
[01:11:01.000 --> 01:11:02.000] 那,
[01:11:02.000 --> 01:11:03.000] 呃,
[01:11:03.000 --> 01:11:05.000] 就是会有一些这方面的,
[01:11:05.000 --> 01:11:06.000] 呃,
[01:11:06.000 --> 01:11:08.000] 就是有些人会觉得是一个问题。
[01:11:09.000 --> 01:11:10.000] 对,
[01:11:10.000 --> 01:11:13.000] 我觉得像master和那种master跟slim,
[01:11:13.000 --> 01:11:15.000] 放在一起pair来用的话,
[01:11:15.000 --> 01:11:17.000] 可能是有一些嫌疑啊,
[01:11:17.000 --> 01:11:21.000] 但是像Github branch跟pdm这个master,
[01:11:21.000 --> 01:11:23.000] 他没有提到,
[01:11:23.000 --> 01:11:24.000] 就是那个,
[01:11:24.000 --> 01:11:27.000] 他是可能是主或者是大师的意思,
[01:11:27.000 --> 01:11:28.000] 或者是,
[01:11:28.000 --> 01:11:29.000] 就是比较好意思,
[01:11:29.000 --> 01:11:31.000] 那你这个都觉得政治不正确的话,
[01:11:31.000 --> 01:11:35.000] 干脆把那个master从字眼里删掉好了。
[01:11:36.000 --> 01:11:37.000] 那就像中文,
[01:11:37.000 --> 01:11:39.000] 你把死从字眼里删掉,
[01:11:39.000 --> 01:11:41.000] 就变都变成s了,
[01:11:41.000 --> 01:11:42.000] 这是一个意思。
[01:11:42.000 --> 01:11:43.000] 对对对,
[01:11:43.000 --> 01:11:45.000] 所以我觉得这个太过了,
[01:11:45.000 --> 01:11:46.000] 就是,
[01:11:46.000 --> 01:11:47.000] 呃,
[01:11:47.000 --> 01:11:49.000] 这种场景他没有跟那个放在一起,
[01:11:49.000 --> 01:11:50.000] 不过也别抛弃了,
[01:11:50.000 --> 01:11:51.000] 这是一些个人想法。
[01:11:52.000 --> 01:11:54.000] 这个我们世界是这样子,
[01:11:54.000 --> 01:11:55.000] 对,
[01:11:55.000 --> 01:11:56.000] 呵呵。
[01:11:59.000 --> 01:12:00.000] 呃,
[01:12:00.000 --> 01:12:03.000] 然后我看还有那个之前说的,
[01:12:03.000 --> 01:12:04.000] 呃,
[01:12:04.000 --> 01:12:05.000] 用户反馈,
[01:12:05.000 --> 01:12:06.000] 呃,
[01:12:06.000 --> 01:12:07.000] 这个我可以介绍一下,
[01:12:07.000 --> 01:12:08.000] 就是先说,
[01:12:08.000 --> 01:12:09.000] 呃,
[01:12:09.000 --> 01:12:10.000] pdm2.0,
[01:12:10.000 --> 01:12:11.000] 呃,
[01:12:11.000 --> 01:12:13.000] 我记得你当时是发了一个,
[01:12:13.000 --> 01:12:14.000] 一个讨论帖,
[01:12:14.000 --> 01:12:15.000] 就是说,
[01:12:15.000 --> 01:12:18.000] 要不要把开普华二作为一个非默认项目,
[01:12:18.000 --> 01:12:19.000] 然后,
[01:12:19.000 --> 01:12:20.000] 呃,
[01:12:20.000 --> 01:12:21.000] 还发了一个投票,
[01:12:21.000 --> 01:12:23.000] 然后就大部分人还是支持,
[01:12:23.000 --> 01:12:25.000] 就是说把它作为非默认,
[01:12:25.000 --> 01:12:28.000] 然后有一个用户就是说,
[01:12:28.000 --> 01:12:32.000] 即使pdm没有开普华二的这个支持,
[01:12:32.000 --> 01:12:35.000] 就即使他是完全用不成env的,
[01:12:35.000 --> 01:12:38.000] 但他也是一个他的package manager更好的工具,
[01:12:38.000 --> 01:12:41.000] 就是列了1234567各种理由,
[01:12:41.000 --> 01:12:42.000] 然后我觉得,
[01:12:42.000 --> 01:12:43.000] 呃,
[01:12:43.000 --> 01:12:45.000] 这个是一看就是一个忠诚的用户,
[01:12:45.000 --> 01:12:46.000] 然后,
[01:12:46.000 --> 01:12:48.000] 然后以至于就是明晰把这个,
[01:12:48.000 --> 01:12:49.000] 呃,
[01:12:49.000 --> 01:12:50.000] 这些评论直接引用,
[01:12:50.000 --> 01:12:52.000] 放到了2.0的发布文章。
[01:12:55.000 --> 01:12:56.000] 呃,
[01:12:56.000 --> 01:12:57.000] 这就涉及到这个pdm,
[01:12:57.000 --> 01:13:01.000] 其实他最初的定位为什么叫这个master,
[01:13:01.000 --> 01:13:05.000] 就我希望它是一个包含你python开发,
[01:13:05.000 --> 01:13:09.000] 方方面面的一个一个一个工具,
[01:13:09.000 --> 01:13:12.000] 就是未来的计划,
[01:13:12.000 --> 01:13:15.000] 可能我设想中会有一个,
[01:13:15.000 --> 01:13:16.000] 呃,
[01:13:16.000 --> 01:13:18.000] 更强大的pdmnew吧,
[01:13:18.000 --> 01:13:22.000] 就是可以从一个任意的github仓库,
[01:13:22.000 --> 01:13:26.000] 或者说cookiecutty的一个模板生成一个,
[01:13:26.000 --> 01:13:28.000] 一个一个项目。
[01:13:28.000 --> 01:13:29.000] 嗯。
[01:13:31.000 --> 01:13:32.000] 对,
[01:13:32.000 --> 01:13:33.000] 没有这种,
[01:13:33.000 --> 01:13:37.000] 就是从github仓库直接生成模板。
[01:13:38.000 --> 01:13:39.000] 哦,
[01:13:39.000 --> 01:13:43.000] 因为这个我也是在node里面用过很久,
[01:13:43.000 --> 01:13:45.000] node他们所有的项目,
[01:13:45.000 --> 01:13:47.000] 他都是执行一条命令,
[01:13:47.000 --> 01:13:49.000] 就把那个整个项目直接建好,
[01:13:49.000 --> 01:13:50.000] 所有的,
[01:13:50.000 --> 01:13:51.000] 呃,
[01:13:51.000 --> 01:13:52.000] 对。
[01:13:53.000 --> 01:13:55.000] 就相当于比如说,
[01:13:55.000 --> 01:13:56.000] 呃,
[01:13:56.000 --> 01:13:57.000] 极端粒子,
[01:13:57.000 --> 01:13:58.000] 我有一个gist,
[01:13:58.000 --> 01:14:00.000] 然后就是那个gist,
[01:14:00.000 --> 01:14:01.000] 不知道大家用了没有,
[01:14:01.000 --> 01:14:02.000] 反正是一个,
[01:14:02.000 --> 01:14:03.000] 嗯,
[01:14:03.000 --> 01:14:04.000] github的功能,
[01:14:04.000 --> 01:14:06.000] 然后可以在上面写一些,
[01:14:06.000 --> 01:14:07.000] 呃,
[01:14:07.000 --> 01:14:08.000] 类似于脚本的代码,
[01:14:08.000 --> 01:14:09.000] 然后我有disk,
[01:14:09.000 --> 01:14:10.000] 然后不是一个正规的仓库,
[01:14:10.000 --> 01:14:12.000] 但是我里面定义了一个python函数,
[01:14:12.000 --> 01:14:15.000] 然后我可以拿pdm直接去import,
[01:14:15.000 --> 01:14:16.000] 然后执行这个函数。
[01:14:17.000 --> 01:14:18.000] 这样非常酷。
[01:14:18.000 --> 01:14:19.000] 嗯。
[01:14:22.000 --> 01:14:24.000] 那你觉得这个阻碍是什么?
[01:14:24.000 --> 01:14:28.000] 就是有什么技术问题要实现?
[01:14:28.000 --> 01:14:29.000] 呃,
[01:14:29.000 --> 01:14:31.000] 这个倒没有什么技术问题,
[01:14:31.000 --> 01:14:35.000] 这个主要是一个接受的问题,
[01:14:35.000 --> 01:14:37.000] 就是说如果大家都接受这个,
[01:14:37.000 --> 01:14:41.000] 那我们就按这个方法来,
[01:14:41.000 --> 01:14:43.000] 大家都按这种方法来建自己的仓库,
[01:14:43.000 --> 01:14:45.000] 那这个仓库可以直接用,
[01:14:45.000 --> 01:14:47.000] 被pdmnew所使用。
[01:14:50.000 --> 01:14:51.000] 嗯,
[01:14:51.000 --> 01:14:52.000] 因为我设想中是,
[01:14:52.000 --> 01:14:56.000] 它除了可以支持github仓库之外呢,
[01:14:56.000 --> 01:14:59.000] 它还可以支持一些现有的,
[01:14:59.000 --> 01:15:00.000] 呃,
[01:15:00.000 --> 01:15:01.000] 一些模板,
[01:15:01.000 --> 01:15:03.000] 比如说cookie cutter,
[01:15:03.000 --> 01:15:05.000] 它的那些模板仓库,
[01:15:05.000 --> 01:15:08.000] 因为有很多已经存在的模板,
[01:15:08.000 --> 01:15:09.000] 因为我们不像,
[01:15:09.000 --> 01:15:11.000] 就我不希望说,
[01:15:11.000 --> 01:15:14.000] 因为我的pdmnew导致这些旧的模板是不能用的,
[01:15:15.000 --> 01:15:20.000] 所以我还是希望尽可能去复用这些东西吧。
[01:15:22.000 --> 01:15:23.000] OK,
[01:15:23.000 --> 01:15:24.000] 呃,
[01:15:24.000 --> 01:15:26.000] 其实有点没太懂,
[01:15:26.000 --> 01:15:31.000] 那个为什么package manager和cookie cutter那些模板会有仓库,
[01:15:31.000 --> 01:15:33.000] 它那些不是更多的是一个,
[01:15:33.000 --> 01:15:35.000] 就是呃,
[01:15:35.000 --> 01:15:36.000] 文件,
[01:15:36.000 --> 01:15:38.000] 就是文件怎么组织的这种问题。
[01:15:38.000 --> 01:15:39.000] 啊,
[01:15:39.000 --> 01:15:40.000] 对,
[01:15:40.000 --> 01:15:43.000] 因为但是你要用一个cookie cutter模板,
[01:15:43.000 --> 01:15:45.000] 你就要装cookie cutter,
[01:15:45.000 --> 01:15:46.000] 是吧?
[01:15:46.000 --> 01:15:49.000] 就是我希望都放到pdm一条命令里面去做。
[01:15:50.000 --> 01:15:51.000] 哦,
[01:15:51.000 --> 01:15:52.000] 哦,
[01:15:52.000 --> 01:15:54.000] 那你这个想法有点杂。
[01:15:54.000 --> 01:15:55.000] 对,
[01:15:55.000 --> 01:15:56.000] 嗯,
[01:15:56.000 --> 01:15:59.000] 快速vna怎么会问你一些东西,
[01:15:59.000 --> 01:16:02.000] 然后就相当于给你生成一个project,
[01:16:02.000 --> 01:16:03.000] 对,
[01:16:03.000 --> 01:16:04.000] 对,
[01:16:04.000 --> 01:16:06.000] 它那个project很简单吧,
[01:16:06.000 --> 01:16:08.000] 而且也只有一个人能选。
[01:16:09.000 --> 01:16:10.000] 哦,
[01:16:10.000 --> 01:16:11.000] 我想起来,
[01:16:11.000 --> 01:16:13.000] 我之前尝试做过这个这个东西,
[01:16:13.000 --> 01:16:15.000] 就是你用一行命令会问一些东西,
[01:16:15.000 --> 01:16:17.000] 我之前做这个东西是因为。
[01:16:17.000 --> 01:16:19.000] 我之前还在写setup.py的,
[01:16:19.000 --> 01:16:22.000] 那个setup.py写起来非常非常痛苦,
[01:16:22.000 --> 01:16:23.000] 所以我希望,
[01:16:23.000 --> 01:16:24.000] 呃,
[01:16:24.000 --> 01:16:25.000] 他问我一些东西,
[01:16:25.000 --> 01:16:26.000] 我告诉他,
[01:16:26.000 --> 01:16:27.000] 呃,
[01:16:27.000 --> 01:16:28.000] 我的名字一代什么的,
[01:16:28.000 --> 01:16:30.000] 然后他生成这个setup.py。
[01:16:31.000 --> 01:16:32.000] 嗯,
[01:16:32.000 --> 01:16:34.000] 这个就是cookie cutter现有的功能,
[01:16:34.000 --> 01:16:37.000] 如果听众有不了解这个cookie cutter,
[01:16:37.000 --> 01:16:40.000] 它是一个项目模板工具。
[01:16:42.000 --> 01:16:43.000] 就比如说你,
[01:16:43.000 --> 01:16:44.000] 他会问你是fuzz,
[01:16:44.000 --> 01:16:45.000] 或者你是jungle,
[01:16:45.000 --> 01:16:46.000] 然后如果你是jungle的话,
[01:16:46.000 --> 01:16:48.000] 就给你生成一堆文件,
[01:16:48.000 --> 01:16:49.000] 文件名,
[01:16:49.000 --> 01:16:50.000] 就是空的文件,
[01:16:50.000 --> 01:16:51.000] 然后文件夹,
[01:16:51.000 --> 01:16:53.000] 你往里面填动就行。
[01:16:53.000 --> 01:16:54.000] 嗯,
[01:16:56.000 --> 01:16:57.000] 呃,
[01:16:57.000 --> 01:16:59.000] 然后另一个那个比较有意思的事情,
[01:16:59.000 --> 01:17:02.000] 就是pm有一个公司在赞助,
[01:17:02.000 --> 01:17:03.000] 是吧?
[01:17:04.000 --> 01:17:05.000] 这个,
[01:17:05.000 --> 01:17:07.000] 这个需要提吗?
[01:17:07.000 --> 01:17:08.000] 啊?
[01:17:08.000 --> 01:17:09.000] 这个需要提吗?
[01:17:09.000 --> 01:17:10.000] 我觉得还是挺值得的,
[01:17:10.000 --> 01:17:11.000] 是吧?
[01:17:12.000 --> 01:17:14.000] 因为这个后面也没有什么,
[01:17:14.000 --> 01:17:16.000] 后面也没有什么那个变化了,
[01:17:16.000 --> 01:17:17.000] 其实。
[01:17:19.000 --> 01:17:20.000] 就是他们,
[01:17:20.000 --> 01:17:21.000] 呃,
[01:17:21.000 --> 01:17:22.000] 就他们肯定在用,
[01:17:22.000 --> 01:17:23.000] 然后他们有没有,
[01:17:23.000 --> 01:17:25.000] 就是他们就直接给你,
[01:17:25.000 --> 01:17:26.000] 给你打一笔钱,
[01:17:26.000 --> 01:17:27.000] 就每个月打钱,
[01:17:27.000 --> 01:17:28.000] 还是就是说,
[01:17:28.000 --> 01:17:29.000] 啊,
[01:17:29.000 --> 01:17:29.000] ok,
[01:17:29.000 --> 01:17:30.000] 我们在用,
[01:17:30.000 --> 01:17:31.000] 然后,
[01:17:31.000 --> 01:17:32.000] 呃,
[01:17:32.000 --> 01:17:34.000] 你就是我们有一些需求之类的,
[01:17:34.000 --> 01:17:35.000] 然后有没有这样?
[01:17:35.000 --> 01:17:38.000] 就是我自己没有收到任何关于这个的通知,
[01:17:38.000 --> 01:17:41.000] 他们是一个monthly的一个sponsorship,
[01:17:43.000 --> 01:17:45.000] 我也不知道他们哪个人,
[01:17:45.000 --> 01:17:47.000] 可能哪个贡献者是他们公司的,
[01:17:47.000 --> 01:17:48.000] 也没有人给我透露过,
[01:17:48.000 --> 01:17:50.000] 不知道这回事。
[01:17:52.000 --> 01:17:54.000] 就是一个心怀感激的用户,
[01:17:54.000 --> 01:17:55.000] 对,
[01:17:56.000 --> 01:17:59.000] 可能是一个就是心怀感激的用户,
[01:17:59.000 --> 01:18:03.000] 说服了他们的雇主去赞助这个pm。
[01:18:05.000 --> 01:18:07.000] 方便透露一下他们那个金额有多少吗?
[01:18:08.000 --> 01:18:10.000] 每个月是10美元。
[01:18:12.000 --> 01:18:13.000] 10美元?
[01:18:14.000 --> 01:18:15.000] 每个月是,
[01:18:15.000 --> 01:18:16.000] 看一下,
[01:18:18.000 --> 01:18:20.000] 我记得应该是至少100美元,
[01:18:20.000 --> 01:18:21.000] 每个月是50,
[01:18:21.000 --> 01:18:22.000] 50,
[01:18:22.000 --> 01:18:23.000] 50,
[01:18:25.000 --> 01:18:26.000] 不错,
[01:18:26.000 --> 01:18:26.000] 不错,
[01:18:26.000 --> 01:18:28.000] 可以去吃几顿,
[01:18:28.000 --> 01:18:29.000] 吃顿好吗?
[01:18:30.000 --> 01:18:31.000] 好,
[01:18:31.000 --> 01:18:33.000] 那我们就进入下一个环节,
[01:18:33.000 --> 01:18:34.000] 呃,
[01:18:34.000 --> 01:18:36.000] 我们想聊一些更简短的话题,
[01:18:36.000 --> 01:18:39.000] 就是作为开源库的维护者,
[01:18:40.000 --> 01:18:41.000] 呃,
[01:18:41.000 --> 01:18:43.000] 比如说如何保持worklife balance,
[01:18:43.000 --> 01:18:44.000] 防止burn off,
[01:18:44.000 --> 01:18:47.000] 然后这个可能有些听众不了解,
[01:18:47.000 --> 01:18:50.000] 但是如果你是PDM用户的话,
[01:18:50.000 --> 01:18:52.000] 你会发现PDM发版本,
[01:18:52.000 --> 01:18:54.000] 然后修bug是非常勤快的,
[01:18:54.000 --> 01:18:57.000] 可能是应该是我用过的库里面,
[01:18:58.000 --> 01:18:59.000] 可能最勤的吧,
[01:18:59.000 --> 01:19:01.000] 然后第二可能是log session,
[01:19:01.000 --> 01:19:02.000] 然后,
[01:19:02.000 --> 01:19:03.000] 呃,
[01:19:03.000 --> 01:19:04.000] 我为什么这么,
[01:19:04.000 --> 01:19:05.000] 就我为什么知道,
[01:19:05.000 --> 01:19:07.000] 就因为我之前订了一个那个app,
[01:19:07.000 --> 01:19:08.000] tbt的bot,
[01:19:08.000 --> 01:19:10.000] 就是每次PDM发一个新版本,
[01:19:10.000 --> 01:19:13.000] 他会给我的telegram推送一个链接,
[01:19:13.000 --> 01:19:16.000] 然后就感觉过几天PDM就发一个版本,
[01:19:16.000 --> 01:19:17.000] 过几天又发了一个,
[01:19:17.000 --> 01:19:19.000] 然后每次都fix了好多问题,
[01:19:20.000 --> 01:19:21.000] 就是我有时候也是,
[01:19:21.000 --> 01:19:22.000] 已经有,
[01:19:22.000 --> 01:19:24.000] 已经有127个版本了,
[01:19:24.000 --> 01:19:25.000] 非常了不起,
[01:19:25.000 --> 01:19:30.000] 就我有时候也是在想明星是怎么有这么多精力去维护的,
[01:19:30.000 --> 01:19:33.000] 然后是怎么保证自己能够去,
[01:19:33.000 --> 01:19:34.000] 呃,
[01:19:34.000 --> 01:19:36.000] 就是比如说你还有小孩吗?
[01:19:36.000 --> 01:19:36.000] 对,
[01:19:36.000 --> 01:19:38.000] 在工作总是要照顾小孩,
[01:19:38.000 --> 01:19:42.000] 要去发PDM新版本是怎么兼顾这些事情呢?
[01:19:43.000 --> 01:19:44.000] 我说一下我个人吧,
[01:19:44.000 --> 01:19:48.000] 就是我每天早上起来会先看邮箱,
[01:19:49.000 --> 01:19:53.000] 我习惯会把那个github的那个notification全部点掉,
[01:19:53.000 --> 01:19:54.000] 如果有,
[01:19:55.000 --> 01:19:56.000] 如果有,
[01:19:56.000 --> 01:19:59.000] 比如说我觉得一看明显就是bug了,
[01:19:59.000 --> 01:20:04.000] 我就会一会儿如果打开电脑的时候就去开始修,
[01:20:05.000 --> 01:20:06.000] 几点起床?
[01:20:07.000 --> 01:20:08.000] 我起来还比较早吧,
[01:20:08.000 --> 01:20:10.000] 就是7点起床,
[01:20:10.000 --> 01:20:13.000] 然后8点钟就基本上吃完早饭了,
[01:20:13.000 --> 01:20:15.000] 什么都都搞完了,
[01:20:15.000 --> 01:20:17.000] 就可以去看邮箱,
[01:20:20.000 --> 01:20:21.000] 嗯,
[01:20:21.000 --> 01:20:22.000] 嗯,
[01:20:22.000 --> 01:20:23.000] 呃,
[01:20:23.000 --> 01:20:26.000] 然后关于发版频率这方面呢,
[01:20:26.000 --> 01:20:28.000] 可能也是个人强迫症吧,
[01:20:28.000 --> 01:20:33.000] 因为我觉得如果有那种明显影响到工,
[01:20:33.000 --> 01:20:35.000] 就是工具使用,
[01:20:35.000 --> 01:20:39.000] 甚至是影响到他要不要采纳PDM,
[01:20:39.000 --> 01:20:41.000] 这个是比较大的问题,
[01:20:41.000 --> 01:20:43.000] 如果早点修这个bug,
[01:20:43.000 --> 01:20:45.000] 他可能明天就用用上PDM了,
[01:20:47.000 --> 01:20:48.000] 对,
[01:20:48.000 --> 01:20:49.000] 我,
[01:20:49.000 --> 01:20:50.000] 我,
[01:20:50.000 --> 01:20:51.000] 我也是这么觉得,
[01:20:51.000 --> 01:20:55.000] 我觉得主要一个原因就是我们用action来发版,
[01:20:55.000 --> 01:20:57.000] 这个动作非常轻量,
[01:20:57.000 --> 01:20:59.000] 只要打一个tiger就行了,
[01:20:59.000 --> 01:21:02.000] 而且像我们主要用在命中的,
[01:21:02.000 --> 01:21:04.000] 没有什么压力,
[01:21:04.000 --> 01:21:06.000] 所以我也倾向于修了什么问题,
[01:21:06.000 --> 01:21:08.000] 就直接发一封发文,
[01:21:08.000 --> 01:21:09.000] 上网。
[01:21:12.000 --> 01:21:14.000] 但是就是我看PDM,
[01:21:14.000 --> 01:21:16.000] 因为修的问题还挺多的嘛,
[01:21:16.000 --> 01:21:18.000] 就是每一个小网友都会fix好多问题,
[01:21:18.000 --> 01:21:19.000] 然后,
[01:21:19.000 --> 01:21:20.000] 呃,
[01:21:20.000 --> 01:21:23.000] 就是这方面还是有需要挺多精力的,
[01:21:23.000 --> 01:21:24.000] 嗯,
[01:21:25.000 --> 01:21:29.000] 有的时候会把bugfix攒一攒,
[01:21:29.000 --> 01:21:31.000] 有的时候可能比较严重的bug,
[01:21:31.000 --> 01:21:33.000] 就修一个就直接发出去了。
[01:21:37.000 --> 01:21:38.000] 就是,
[01:21:38.000 --> 01:21:39.000] 或者说,
[01:21:39.000 --> 01:21:40.000] 嗯,
[01:21:40.000 --> 01:21:41.000] 我这样问吧,
[01:21:41.000 --> 01:21:44.000] 就是你说你在早一天的一开始,
[01:21:44.000 --> 01:21:45.000] 呃,
[01:21:45.000 --> 01:21:46.000] 在你去做,
[01:21:46.000 --> 01:21:48.000] 在你去上班之前,
[01:21:48.000 --> 01:21:49.000] 呃,
[01:21:49.000 --> 01:21:51.000] 来修一些比较明显的bug,
[01:21:51.000 --> 01:21:52.000] 对吗?
[01:21:52.000 --> 01:21:53.000] 还是,
[01:21:53.000 --> 01:21:54.000] 然后,
[01:21:54.000 --> 01:21:56.000] 那你下班之后呢,
[01:21:56.000 --> 01:21:58.000] 会继续去看这些bug?
[01:21:59.000 --> 01:22:01.000] 下班之后的话,
[01:22:01.000 --> 01:22:03.000] 其实不太看bug,
[01:22:03.000 --> 01:22:06.000] 但是如果有feature要做的话,
[01:22:06.000 --> 01:22:08.000] 可能下班之后再做。
[01:22:09.000 --> 01:22:10.000] 嗯,
[01:22:11.000 --> 01:22:12.000] 所以就是,
[01:22:12.000 --> 01:22:14.000] 所以你是在家工作还是在公司,
[01:22:14.000 --> 01:22:15.000] 就是因为,
[01:22:15.000 --> 01:22:16.000] 呃,
[01:22:16.000 --> 01:22:17.000] 这个也涉及到一些,
[01:22:17.000 --> 01:22:18.000] 呃,
[01:22:18.000 --> 01:22:20.000] 就是灵活性上的问题。
[01:22:21.000 --> 01:22:22.000] 呃,
[01:22:22.000 --> 01:22:24.000] 有一段时间是在家工作,
[01:22:24.000 --> 01:22:26.000] 但是现在是规律化的,
[01:22:26.000 --> 01:22:28.000] 都是在公司上班,
[01:22:28.000 --> 01:22:29.000] 但我也,
[01:22:30.000 --> 01:22:32.000] 我也不隐瞒的说吧,
[01:22:32.000 --> 01:22:36.000] 就是在公司我也会摸鱼去做这个NPM的维护。
[01:22:38.000 --> 01:22:40.000] 但还好就是在这个,
[01:22:40.000 --> 01:22:44.000] 因为我对这个包管理这些东西你熟悉以后,
[01:22:44.000 --> 01:22:47.000] 就觉得这些bug没有,
[01:22:47.000 --> 01:22:49.000] 没有说很难的,
[01:22:49.000 --> 01:22:51.000] 就是说你可能要想一想的,
[01:22:51.000 --> 01:22:53.000] 只有说怎么去做的一个问题,
[01:22:53.000 --> 01:22:55.000] 而不是说能不能做,
[01:22:55.000 --> 01:22:56.000] 会不会做。
[01:22:57.000 --> 01:22:58.000] OK。
[01:22:59.000 --> 01:23:00.000] 就是都可以,
[01:23:00.000 --> 01:23:01.000] 都可以重建,
[01:23:01.000 --> 01:23:03.000] 然后你大概也都知道怎么修,
[01:23:03.000 --> 01:23:04.000] 都是一些,
[01:23:04.000 --> 01:23:05.000] 大概都知道怎么修,
[01:23:05.000 --> 01:23:06.000] 就是换句话说,
[01:23:06.000 --> 01:23:08.000] 就是技术含量比较低。
[01:23:10.000 --> 01:23:11.000] 对,
[01:23:11.000 --> 01:23:13.000] 包管理里面就会有很多这种,
[01:23:13.000 --> 01:23:14.000] 呃,
[01:23:14.000 --> 01:23:15.000] 一些corner case,
[01:23:15.000 --> 01:23:17.000] 但其实主要是这些。
[01:23:17.000 --> 01:23:18.000] 对,
[01:23:18.000 --> 01:23:20.000] 因为这是一个比较特殊的领域吧,
[01:23:20.000 --> 01:23:22.000] 就是说如果你没有去,
[01:23:22.000 --> 01:23:24.000] 从来没有了解过包管理,
[01:23:24.000 --> 01:23:26.000] 从来没有了解过怎么打包,
[01:23:26.000 --> 01:23:27.000] 你可能不知道怎么回事,
[01:23:27.000 --> 01:23:29.000] 但是你了解过的话,
[01:23:29.000 --> 01:23:32.000] 这些bug就没有一个技术含量高的。
[01:23:35.000 --> 01:23:36.000] 嗯,
[01:23:36.000 --> 01:23:38.000] 但feature可能技术含量比较高,
[01:23:38.000 --> 01:23:40.000] 所以就是要晚上专心来做。
[01:23:40.000 --> 01:23:42.000] feature也不能说技术含量,
[01:23:42.000 --> 01:23:44.000] 它主要是一个设计的一个,
[01:23:44.000 --> 01:23:47.000] 如何设计是比较好的一个设计,
[01:23:47.000 --> 01:23:49.000] 这是一个设计的品牌问题。
[01:23:51.000 --> 01:23:52.000] 对,
[01:23:53.000 --> 01:23:54.000] 呃,
[01:23:54.000 --> 01:23:56.000] 这这种可以设计公司,
[01:23:56.000 --> 01:23:57.000] 那个我们可以剪掉,
[01:23:57.000 --> 01:23:58.000] 但是就是我,
[01:23:58.000 --> 01:24:00.000] 我想问一下就是你的,
[01:24:00.000 --> 01:24:03.000] 比如说你老板会知道或者说支持你去,
[01:24:03.000 --> 01:24:04.000] 呃,
[01:24:04.000 --> 01:24:07.000] 比如说甚至用一些在公司的时间来维护PDM。
[01:24:08.000 --> 01:24:09.000] 嗯,
[01:24:09.000 --> 01:24:11.000] 他们是不太管的。
[01:24:13.000 --> 01:24:14.000] 哇,
[01:24:14.000 --> 01:24:16.000] 这公司太好了。
[01:24:17.000 --> 01:24:18.000] 对,
[01:24:18.000 --> 01:24:19.000] 我不知道姓汤,
[01:24:19.000 --> 01:24:22.000] 如果你在公司去做的话会有什么问题。
[01:24:23.000 --> 01:24:24.000] 会有问题,
[01:24:25.000 --> 01:24:27.000] 我感觉也没什么问题,
[01:24:27.000 --> 01:24:28.000] 主要是没时间,
[01:24:28.000 --> 01:24:29.000] 对,
[01:24:29.000 --> 01:24:30.000] 这就是最大的问题。
[01:24:31.000 --> 01:24:32.000] 是的,
[01:24:32.000 --> 01:24:33.000] 嗯,
[01:24:33.000 --> 01:24:34.000] 对,
[01:24:34.000 --> 01:24:35.000] 那就是,
[01:24:35.000 --> 01:24:36.000] 呃,
[01:24:37.000 --> 01:24:38.000] 像你有没有遇到过,
[01:24:38.000 --> 01:24:42.000] 就是说你觉得的事情很多,
[01:24:42.000 --> 01:24:43.000] 然后没有时间修,
[01:24:43.000 --> 01:24:48.000] 或者你就觉得最近处于就是会不闹的这种状态的有过吗?
[01:24:50.000 --> 01:24:51.000] 嗯,
[01:24:51.000 --> 01:24:55.000] 不能闹的这种状态时不时就是都会有的吧,
[01:24:56.000 --> 01:25:00.000] 就是经经常就会有一些,
[01:25:01.000 --> 01:25:02.000] 呃,
[01:25:02.000 --> 01:25:10.000] 提的issue提的issue可能不是很不是很遵循那个提问的规范啊,
[01:25:10.000 --> 01:25:14.000] 或者说比较比较空的case,
[01:25:14.000 --> 01:25:16.000] 然后他觉得是你的错的这种,
[01:25:17.000 --> 01:25:19.000] 如果今天刚好心情不好的话,
[01:25:19.000 --> 01:25:21.000] 你会觉得很烦躁。
[01:25:24.000 --> 01:25:25.000] 嗯,
[01:25:27.000 --> 01:25:28.000] 呃,
[01:25:28.000 --> 01:25:30.000] 这就这就涉及到,
[01:25:30.000 --> 01:25:31.000] 呃,
[01:25:31.000 --> 01:25:36.000] 另外一个话题就是如何正确的这个提一属更好的提一属,
[01:25:36.000 --> 01:25:39.000] 那我们都知道提问的一所那个,
[01:25:40.000 --> 01:25:43.000] 就是说在这个提问的艺术之外的话,
[01:25:43.000 --> 01:25:46.000] 还有一些我觉得应该要注意的问题,
[01:25:46.000 --> 01:25:49.000] 一个是你提的issue,
[01:25:50.000 --> 01:25:52.000] 它是有有不同的类型的,
[01:25:52.000 --> 01:25:53.000] 一种是,
[01:25:54.000 --> 01:25:54.000] 呃,
[01:25:54.000 --> 01:25:56.000] 这个issue是一个热点的路径,
[01:25:56.000 --> 01:25:58.000] 就是说很容易复现的,
[01:25:58.000 --> 01:26:00.000] 就是在你的关键路径上,
[01:26:00.000 --> 01:26:02.000] 就是pdm log直接fail,
[01:26:02.000 --> 01:26:05.000] 那这种你只需要把问题描述清楚就可以了,
[01:26:05.000 --> 01:26:09.000] 那我相信这个maintainer也会会意识到,
[01:26:09.000 --> 01:26:11.000] 如果你说确实是一个bug的话,
[01:26:11.000 --> 01:26:12.000] 他会马上修复。
[01:26:12.000 --> 01:26:14.000] 第二种问题是,
[01:26:14.000 --> 01:26:18.000] 你这个issue只是在你的某些特定场景,
[01:26:18.000 --> 01:26:23.000] 甚至是你个人的一些场景上面会出现的问题,
[01:26:23.000 --> 01:26:24.000] 呃,
[01:26:24.000 --> 01:26:25.000] 就比如说吧,
[01:26:25.000 --> 01:26:26.000] 呃,
[01:26:26.000 --> 01:26:28.000] 比如说一个一个仓库,
[01:26:28.000 --> 01:26:31.000] 他提供了很多share的支持,
[01:26:31.000 --> 01:26:34.000] 那他没有你要用那个share,
[01:26:34.000 --> 01:26:35.000] 比如说partial,
[01:26:35.000 --> 01:26:37.000] 就是举个例子来说吧,
[01:26:37.000 --> 01:26:40.000] 就是说没有partial的支持,
[01:26:40.000 --> 01:26:42.000] 那你这时候呢,
[01:26:42.000 --> 01:26:46.000] 去提一个,
[01:26:46.000 --> 01:26:49.000] 去提一个说你这不支持partial,
[01:26:49.000 --> 01:26:50.000] 可能是不足够的,
[01:26:50.000 --> 01:26:52.000] 因为如果他想支持的话,
[01:26:52.000 --> 01:26:54.000] maintainer可能早就已经加上了,
[01:26:54.000 --> 01:26:55.000] 他为什么不支持,
[01:26:55.000 --> 01:26:57.000] 是因为他自己不用这个share,
[01:26:57.000 --> 01:26:58.000] 那这时候呢,
[01:26:58.000 --> 01:27:01.000] 最好是可以提供一个patch是比较,
[01:27:01.000 --> 01:27:03.000] 直接提供一个patch是比较理想。
[01:27:05.000 --> 01:27:06.000] 对,
[01:27:06.000 --> 01:27:07.000] 这个我也遇到过,
[01:27:07.000 --> 01:27:08.000] 对,
[01:27:08.000 --> 01:27:09.000] 而且,
[01:27:10.000 --> 01:27:11.000] 呃,
[01:27:11.000 --> 01:27:13.000] 根据tp的时候也不能,
[01:27:14.000 --> 01:27:16.000] 也也有一些比较,
[01:27:16.000 --> 01:27:18.000] 比较奇怪的情况,
[01:27:18.000 --> 01:27:22.000] 就是说你tp的时候必须去首先说服维护者,
[01:27:22.000 --> 01:27:24.000] 这是一个吧,
[01:27:24.000 --> 01:27:27.000] 并且你的修复方法是合理的,
[01:27:27.000 --> 01:27:28.000] 不仅是有效,
[01:27:28.000 --> 01:27:29.000] 而且要是合理的,
[01:27:29.000 --> 01:27:31.000] 比如说我之前遇到过一个问题,
[01:27:31.000 --> 01:27:33.000] 就是说一个用户提说,
[01:27:33.000 --> 01:27:36.000] 你的pdm的颜色在我的中端上不显示,
[01:27:38.000 --> 01:27:39.000] 他也,
[01:27:39.000 --> 01:27:42.000] 他也提供了很详细的说我在哪个中端,
[01:27:42.000 --> 01:27:44.000] 他的输出是什么,
[01:27:44.000 --> 01:27:47.000] 然后我依依在自己的电脑上去复现,
[01:27:47.000 --> 01:27:48.000] 复现不了,
[01:27:48.000 --> 01:27:50.000] 就说我也用这个中端,
[01:27:50.000 --> 01:27:51.000] 为什么我就没问题,
[01:27:51.000 --> 01:27:52.000] 但是他说,
[01:27:53.000 --> 01:27:54.000] 呃,
[01:27:54.000 --> 01:27:55.000] 根据事实表明,
[01:27:55.000 --> 01:27:56.000] 我加上一行代码,
[01:27:56.000 --> 01:27:57.000] 这个就work,
[01:27:57.000 --> 01:27:59.000] 这行代码是all system,
[01:27:59.000 --> 01:28:00.000] 然后控制不串,
[01:28:01.000 --> 01:28:03.000] 他直接提了一个patch,
[01:28:03.000 --> 01:28:05.000] 加一行代码all system,
[01:28:05.000 --> 01:28:06.000] 控制不串,
[01:28:07.000 --> 01:28:09.000] 然后这种这种修复方式,
[01:28:09.000 --> 01:28:11.000] 我是肯定不能接受的,
[01:28:11.000 --> 01:28:13.000] 因为你说不了为什么,
[01:28:13.000 --> 01:28:16.000] 也许你这这一行代码加上确实work,
[01:28:16.000 --> 01:28:20.000] 但是你说不了为什么这个东西能修复到这个问题,
[01:28:20.000 --> 01:28:22.000] 并且这个问题到底出在哪,
[01:28:22.000 --> 01:28:26.000] 那后来后来我经过一些stackoverflow的查找,
[01:28:26.000 --> 01:28:27.000] 我终于发现啊,
[01:28:27.000 --> 01:28:33.000] 他其实是因为他的那个中端上没有开这个virtual terminal的功能,
[01:28:35.000 --> 01:28:40.000] 然后解决方法其实就是要调一个比较复杂的windows的API,
[01:28:40.000 --> 01:28:42.000] 把这个virtual terminal功能打开,
[01:28:46.000 --> 01:28:49.000] 那所以最后这个fix就在pd很厉害,
[01:28:49.000 --> 01:28:50.000] 所以就不用fix,
[01:28:50.000 --> 01:28:51.000] 看那边解决,
[01:28:52.000 --> 01:28:54.000] 最后这个fix其实是,
[01:28:54.000 --> 01:28:58.000] 我把它切到reach之后就自动消失了这个问题,
[01:29:05.000 --> 01:29:09.000] 那就是比如说站在一个更高的角度看,
[01:29:09.000 --> 01:29:16.000] 你觉得维护pdm对你个人带来哪些好处或者坏处?
[01:29:19.000 --> 01:29:22.000] 好的方面当然是一些,
[01:29:22.000 --> 01:29:25.000] 比如说刚才的用户的积极反馈,
[01:29:25.000 --> 01:29:28.000] 会给你很大的心理单位和成就感,
[01:29:28.000 --> 01:29:31.000] 会觉得自己做了有用的事,
[01:29:31.000 --> 01:29:34.000] 让一些人的开发确实变得更容易了,
[01:29:37.000 --> 01:29:39.000] 坏的方面的话,
[01:29:39.000 --> 01:29:41.000] 维护开源软件,
[01:29:42.000 --> 01:29:43.000] 就是说刚才有一些,
[01:29:43.000 --> 01:29:46.000] 总是有一些chore的用户,
[01:29:46.000 --> 01:29:51.000] 他提的一些会让你心情会比较负面,
[01:29:51.000 --> 01:29:53.000] 带一些负面的情绪在这里。
[01:29:55.000 --> 01:29:58.000] 我自认为自己也不是一个特别平和的人,
[01:29:58.000 --> 01:30:01.000] 当然我也是努力在控制,
[01:30:01.000 --> 01:30:04.000] 所以难免会burn out。
[01:30:06.000 --> 01:30:11.000] OK,那我们今天差不多也就聊了这些内容,
[01:30:13.000 --> 01:30:15.000] 是非常感谢明星来,
[01:30:15.000 --> 01:30:17.000] 再次祝贺武生者说,
[01:30:18.000 --> 01:30:20.000] 诸位听众如果你听到这里的话,
[01:30:22.000 --> 01:30:23.000] 如果你还没有尝试PDM,
[01:30:23.000 --> 01:30:27.000] PDM是一个非常值得你去尝试的工具,
[01:30:30.000 --> 01:30:33.000] 并且明星有很多未来的计划,
[01:30:33.000 --> 01:30:35.000] 我们都可以期待一下。
[01:30:36.000 --> 01:30:39.000] 今天的武生者说就到这里,
[01:30:39.000 --> 01:30:41.000] 我们就跟大家打个招呼,
[01:30:41.000 --> 01:30:42.000] 然后就结束。
[01:30:43.000 --> 01:30:45.000] 各位听众,我们就下期再见,
[01:30:45.000 --> 01:30:47.000] 拜拜,下次再见。
[01:31:15.000 --> 01:31:18.000] 欢迎加入我们的Telegram群组和其他听众一起聊天,
[01:31:18.000 --> 01:31:22.000] 我们的推特是pythonhalter加一个下滑线,
[01:31:22.000 --> 01:31:25.000] Telegram群组的链接可以在我们的网站上找到,
[01:31:25.000 --> 01:31:27.000] 我们下期再见。