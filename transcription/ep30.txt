[00:00.000 --> 00:22.000] 感谢观看
[00:22.000 --> 00:25.000] 大家好,欢迎来到新一期的捕蛇者说
[00:25.000 --> 00:29.000] 这期我们非常荣幸请到了李辉来跟我们聊一聊
[00:29.000 --> 00:34.000] Flask 2.0以及参与开源和自由职业
[00:34.000 --> 00:38.000] 我们先请李辉来给大家打个招呼吧
[00:38.000 --> 00:39.000] 大家好,我是李辉
[00:39.000 --> 00:41.000] 很高兴能来参加捕蛇者说
[00:41.000 --> 00:45.000] 我最近正在写一本关于Python Web API的书
[00:45.000 --> 00:46.000] 不过也不算是最近了
[00:46.000 --> 00:48.000] 因为已经断了许多写了两年了
[00:48.000 --> 00:50.000] 另外也在开发一个基于Flask的API框架
[00:50.000 --> 00:52.000] 叫做API Flask
[00:52.000 --> 00:54.000] 能不能再详细的介绍一下你自己
[00:54.000 --> 00:57.000] 就是如果有听众不认识你的话
[00:57.000 --> 01:00.000] 我是Flask的维护者
[01:00.000 --> 01:05.000] 之前在PyCon也参加过很多次PyCon做演讲
[01:05.000 --> 01:07.000] 大概就这样吧
[01:07.000 --> 01:09.000] 行行,介绍非常简洁
[01:09.000 --> 01:13.000] 之后我们再来会深入的了解一下你的经历
[01:13.000 --> 01:18.000] 然后另外今天的几位主播是信涛
[01:18.000 --> 01:20.000] 来给大家打个招呼
[01:20.000 --> 01:22.000] 大家好
[01:22.000 --> 01:26.000] 信涛也是在66大处里面抽出
[01:26.000 --> 01:28.000] 百忙抽出时间来跟我们聊天
[01:28.000 --> 01:29.000] 是吧
[01:29.000 --> 01:30.000] 对反正就是非常繁忙
[01:30.000 --> 01:32.000] 然后温老师
[01:32.000 --> 01:34.000] Hello大家好
[01:34.000 --> 01:35.000] 我是Idan
[01:35.000 --> 01:37.000] 然后小白
[01:37.000 --> 01:38.000] 来打个招呼
[01:38.000 --> 01:39.000] Hello大家好
[01:39.000 --> 01:40.000] 我是小白
[01:40.000 --> 01:42.000] 对然后今天我们人数也是比较多
[01:42.000 --> 01:43.000] OK
[01:43.000 --> 01:46.000] 然后我们就开始第一个话题吧
[01:46.000 --> 01:48.000] 就是因为我们知道Flask
[01:48.000 --> 01:50.000] 它是一个开源项目
[01:50.000 --> 01:54.000] 然后李辉也是Flask团队的一员
[01:54.000 --> 01:56.000] 然后我们想先请他聊一聊
[01:56.000 --> 02:00.000] 是怎样从Flask的一个学习者
[02:00.000 --> 02:03.000] 然后最后成为Flask的维护者的
[02:03.000 --> 02:08.000] 其实我经历和其他可能大多数人都差不多
[02:08.000 --> 02:11.000] 我一开始学Python是在15年的年末
[02:11.000 --> 02:16.000] 那个时候我还在扬州大学对面的大专读大二
[02:16.000 --> 02:18.000] 一开始只是简单学了一些基础语法
[02:18.000 --> 02:20.000] 还有前端的一些内容
[02:20.000 --> 02:22.000] 当时并没有计算机相关的基础
[02:22.000 --> 02:24.000] 只是单纯的出于兴趣
[02:24.000 --> 02:27.000] 学Flask是在16年的暑假
[02:27.000 --> 02:29.000] 为什么会学Flask呢
[02:29.000 --> 02:32.000] 因为当时在知乎上看到了一个问题
[02:32.000 --> 02:34.000] 那是一个很有名的问题
[02:34.000 --> 02:37.000] 叫做Web开发还有前途吗
[02:37.000 --> 02:40.000] 然后一个很有名的知乎大V肖景墨
[02:40.000 --> 02:42.000] 他写了一篇回答
[02:42.000 --> 02:43.000] 他的回答里面分析了
[02:43.000 --> 02:46.000] 就是Web开发的一些现状和形式
[02:46.000 --> 02:49.000] 就推荐去学Flask
[02:49.000 --> 02:53.000] 然后推荐了一本书叫做Flask Web开发
[02:53.000 --> 02:56.000] 然后我就买了那本书开始学Flask
[02:56.000 --> 02:58.000] 断断续续花了很久才看完那本书
[02:58.000 --> 03:01.000] 中间看到一半的时候和朋友聊天
[03:01.000 --> 03:03.000] 朋友说就是你最近在干嘛
[03:03.000 --> 03:05.000] 说在学网站开发
[03:05.000 --> 03:07.000] 他就说他们公司正好想要做一个网站
[03:07.000 --> 03:09.000] 问我能不能做
[03:09.000 --> 03:11.000] 当时虽然我只是看了一半的书
[03:11.000 --> 03:12.000] 但是我说我可以做
[03:12.000 --> 03:14.000] 结果就开始做了那个网站
[03:14.000 --> 03:16.000] 花了大概有半年的时间吧
[03:16.000 --> 03:19.000] 断断续续修修改改做了很多的修改
[03:19.000 --> 03:21.000] 最后跟他要了1000块钱
[03:21.000 --> 03:22.000] 虽然只有一千块钱
[03:22.000 --> 03:24.000] 但是我觉得当时已经很多了
[03:24.000 --> 03:27.000] 因为我学的Flask学得也非常简单
[03:27.000 --> 03:31.000] 写的代码也有很多不优雅的视线
[03:31.000 --> 03:33.000] 接着就开始继续学Flask
[03:33.000 --> 03:36.000] 然后开始写文章写书
[03:36.000 --> 03:37.000] 因为时间有限嘛
[03:37.000 --> 03:40.000] 学编程基本上算是需要什么学什么
[03:40.000 --> 03:41.000] 需要多少学多少
[03:41.000 --> 03:45.000] 所以到现在还有很多东西需要去补课这样
[03:45.000 --> 03:49.000] 而参与开编也就是在写文章和写书之间
[03:49.000 --> 03:50.000] 同时做的事情
[03:50.000 --> 03:54.000] 这大概就是我学Python和Flask的过程
[03:56.000 --> 03:58.000] 感觉讲的有点简洁
[03:58.000 --> 04:00.000] 感觉只讲到了学习Flask
[04:00.000 --> 04:02.000] 然后用Flask做一个网站
[04:02.000 --> 04:07.000] 应该这个也是大多数人的一个状态吧
[04:07.000 --> 04:13.000] 但是中间关键这一步就是从一个使用者变到Country Builder
[04:13.000 --> 04:15.000] 这个好像忽略掉了
[04:15.000 --> 04:19.000] 其实就是当你不断的做一些贡献之后
[04:19.000 --> 04:21.000] 但这个是就到下一个话题了
[04:21.000 --> 04:24.000] 就是我开始参与开编了
[04:24.000 --> 04:28.000] 然后参与开编大概也是在16年
[04:28.000 --> 04:30.000] 那时候刚开始学Flask
[04:30.000 --> 04:33.000] 我在Github上的第一个PR是给一个扩展
[04:33.000 --> 04:37.000] Flask Bootstrap修复了一个Type
[04:37.000 --> 04:41.000] 然后第一个给Flask提的PR是在16年的12月
[04:41.000 --> 04:45.000] 然后我给他们的实例程序的一个模板文件里面
[04:45.000 --> 04:49.000] 它模板文件里面有一些P标签
[04:49.000 --> 04:51.000] 就是那paragraph
[04:51.000 --> 04:56.000] 但是我觉得可能P标签需要加上那个关闭符号
[04:56.000 --> 04:59.000] 然后我就提了一个PR给他们加上了
[04:59.000 --> 05:01.000] 但是我不知道就在HTML5里面
[05:01.000 --> 05:03.000] 不写那个关闭符号也是有效的
[05:03.000 --> 05:05.000] 所以这是我第一个PR
[05:05.000 --> 05:07.000] 然后被关掉了
[05:09.000 --> 05:11.000] 你被关掉之后是什么感觉
[05:11.000 --> 05:15.000] 就是不想再给Flask提代码了
[05:15.000 --> 05:17.000] 没有那个确实是我不知道
[05:17.000 --> 05:18.000] 这个很正常
[05:18.000 --> 05:20.000] 我当时也是很多东西都不太懂
[05:22.000 --> 05:24.000] 然后后来我就翻译了Flask Bootstrap
[05:24.000 --> 05:27.000] 这个项目的文档翻成中文了
[05:27.000 --> 05:29.000] 再往后其实所有的KM贡献
[05:29.000 --> 05:32.000] 都是围绕着我写的文章和书展开的
[05:32.000 --> 05:35.000] 比如说我写了一篇文章来介绍
[05:35.000 --> 05:37.000] 怎么用Flask来处理上传文件
[05:37.000 --> 05:41.000] 那肯定想写就是假如上传的是中文怎么办
[05:41.000 --> 05:46.000] 但是可能当时Flask Apploads这个扩展并不支持中文
[05:46.000 --> 05:49.000] 所以我很自然的就去想去给他添加支持
[05:50.000 --> 05:54.000] 很多类似的这样的PR都是从这样出来的
[05:54.000 --> 05:59.000] 再比如说因为我用Windows
[05:59.000 --> 06:02.000] 当时你用Windows来开发经常会遇到各种各样的问题
[06:02.000 --> 06:05.000] 所以我经常修一些Windows相关的bug
[06:05.000 --> 06:07.000] 包括Flask啦Zanksoic这些
[06:07.000 --> 06:09.000] 经常就只像这样的PR
[06:11.000 --> 06:14.000] 然后我在写书过程中几乎给我每一个
[06:14.000 --> 06:17.000] 在我书里介绍过的项目都贡献过代码
[06:17.000 --> 06:19.000] 大部分是Year Flask扩展
[06:19.000 --> 06:24.000] 然后接着我加入Palace是在18年的6月
[06:24.000 --> 06:28.000] 加入Palace起源就是当时我写的那本书
[06:28.000 --> 06:30.000] Flask Web开发实战
[06:30.000 --> 06:31.000] 当时快要上市了
[06:31.000 --> 06:34.000] 然后我想邀请一些人来给我书写推荐语
[06:34.000 --> 06:38.000] 我就去给Flask的维护者
[06:38.000 --> 06:40.000] 包括作者Armin Zolarkar
[06:40.000 --> 06:41.000] 还有David Lord
[06:41.000 --> 06:43.000] 还有Michael Greenberg
[06:43.000 --> 06:44.000] 给他们发邮件
[06:44.000 --> 06:46.000] 请他们来给我写推荐语
[06:46.000 --> 06:48.000] 当时我也是有点有点鲁莽
[06:48.000 --> 06:50.000] 因为Michael Greenberg
[06:50.000 --> 06:52.000] 他写了那本Flask Web开发嘛
[06:52.000 --> 06:54.000] 就是我看的入门书
[06:54.000 --> 06:57.000] 他的书其实和我的书是竞争关系
[06:57.000 --> 06:59.000] 而且当时他的书在中国出了第二版
[06:59.000 --> 07:02.000] 和我的书是在同一个月上市的
[07:02.000 --> 07:04.000] 然后我就邀请竞争对手的作者
[07:04.000 --> 07:06.000] 来给我写一个推荐语
[07:06.000 --> 07:08.000] 这当然是不在现实
[07:08.000 --> 07:10.000] 不过David Lord倒是
[07:10.000 --> 07:12.000] 同意给我写了一个推荐语
[07:13.000 --> 07:15.000] 他同意之后我就顺势跟他说
[07:15.000 --> 07:17.000] 我想加入Flask的团队
[07:17.000 --> 07:20.000] 就我跟他说了我之前做过什么
[07:20.000 --> 07:22.000] 然后我接下来会做什么
[07:22.000 --> 07:23.000] 就写了一封很长的邮件
[07:23.000 --> 07:25.000] 因为我之前已经做过
[07:25.000 --> 07:28.000] 对整个Flask社区做过很多的贡献
[07:28.000 --> 07:31.000] 然后我就应该比较顺利的
[07:31.000 --> 07:33.000] 他就邀请我加入了
[07:33.000 --> 07:35.000] 大概就这样一个过程
[07:37.000 --> 07:41.000] 就感觉还是比较主动的
[07:41.000 --> 07:43.000] 就是因为我知道
[07:43.000 --> 07:45.000] 像新涛加入MyCLI的时候
[07:45.000 --> 07:47.000] 他是别人邀请他去的
[07:49.000 --> 07:50.000] 因为很多时候
[07:50.000 --> 07:53.000] 很多事情你靠别人来邀请
[07:53.000 --> 07:55.000] 可能需要一个比较漫长的过程
[07:55.000 --> 07:56.000] 但是你主动一点
[07:56.000 --> 07:59.000] 可能会获得更多的机会
[08:02.000 --> 08:04.000] 那你在贡献的过程中
[08:04.000 --> 08:08.000] 有没有比如说有一个量变到质变的节点
[08:08.000 --> 08:10.000] 就是你感觉
[08:10.000 --> 08:14.000] OK 我好像能够成为一个Flask
[08:14.000 --> 08:17.000] 或者Flask ecosystem的maintainer
[08:17.000 --> 08:19.000] 的这样一个感觉
[08:19.000 --> 08:21.000] 对 其实一开始我加入的时候
[08:21.000 --> 08:24.000] 我也就是不太好意思说
[08:24.000 --> 08:26.000] 我是Flask的维护者
[08:26.000 --> 08:29.000] 我只是说我是Flask开发团队的成员
[08:29.000 --> 08:30.000] 因为当时我确实是
[08:30.000 --> 08:32.000] 那个organization的maverick
[08:32.000 --> 08:33.000] 因为当时我对Flask
[08:33.000 --> 08:35.000] 没有做出太多的贡献
[08:35.000 --> 08:36.000] 不过我一开始说
[08:36.000 --> 08:38.000] 我是Flask开发团队成员的时候
[08:38.000 --> 08:40.000] 还是有很多人来质疑你
[08:40.000 --> 08:42.000] 他们觉得你为什么是这个成员
[08:42.000 --> 08:45.000] 他们看不到你在哪里是这个成员
[08:45.000 --> 08:47.000] 直到我说我可以算是一个
[08:47.000 --> 08:50.000] 正式的维护者是在19年吧
[08:50.000 --> 08:52.000] 之所以说是正式成为这个维护者
[08:52.000 --> 08:57.000] 是因为19年做过一次团队的结构调整
[08:57.000 --> 08:59.000] 就是当时Pilots有很多的成员
[08:59.000 --> 09:02.000] 就在那GitHub上的组织里面
[09:02.000 --> 09:04.000] 当时做了一个调整是把很多
[09:04.000 --> 09:06.000] 就是以前贡献过的代码
[09:06.000 --> 09:08.000] 然后现在可能就是
[09:08.000 --> 09:11.000] 专注于别的事情的人分离出来
[09:11.000 --> 09:16.000] 当时还就是对Army要不要分离出来
[09:16.000 --> 09:19.000] 就有一些讨论和争吵
[09:19.000 --> 09:21.000] 当然每个项目最后分出来一个team
[09:21.000 --> 09:24.000] 最后就把我分到了Flask的team
[09:24.000 --> 09:25.000] 虽然之前我对Flask的仓库
[09:25.000 --> 09:27.000] 也有相应的权限
[09:27.000 --> 09:29.000] 但现在就做了分离之后
[09:29.000 --> 09:33.000] 大概只有五个人是Flask团队的成员
[09:33.000 --> 09:35.000] 而且那个时候我也处理了
[09:35.000 --> 09:37.000] 帮忙处理了很多的issue
[09:37.000 --> 09:39.000] 而且贡献了很多代码
[09:39.000 --> 09:42.000] 所以从19年开始我才觉得算是Flask的维护者
[09:46.000 --> 09:53.000] 我觉得李鹤的经历确实是感觉也比较
[09:53.000 --> 09:55.000] 就是感觉挺难复制的
[09:55.000 --> 09:58.000] 但好像又说起来又很自然
[09:58.000 --> 10:00.000] 就是有这种这样的感觉
[10:01.000 --> 10:03.000] 但其实我觉得是很容易复制的
[10:03.000 --> 10:05.000] 假如你也是像这样
[10:05.000 --> 10:07.000] 对很多个扩展
[10:07.000 --> 10:10.000] 包括Flask做了一些持续的贡献
[10:10.000 --> 10:13.000] 然后你可能也会获得这样的结果
[10:13.000 --> 10:16.000] 当然你可能不愿意去投入这个时间来做
[10:16.000 --> 10:18.000] 你不确定结果是什么样
[10:22.000 --> 10:24.000] 那你一开始参与开源的时候
[10:24.000 --> 10:28.000] 有期待说比如说我的最终期望得到的结果
[10:28.000 --> 10:31.000] 就是成为Flask团队的一员
[10:31.000 --> 10:34.000] 还是说就是走一步看一步呢
[10:34.000 --> 10:37.000] 当时一开始的时候我没有想太多
[10:37.000 --> 10:39.000] 而且我做的开源贡献
[10:39.000 --> 10:41.000] 我感觉都是比较自然的吧
[10:41.000 --> 10:43.000] 因为我写的书里需要介绍这个内容
[10:43.000 --> 10:46.000] 我自然需要去了解它
[10:46.000 --> 10:49.000] 了解它自然就很容易去遇到一些bug
[10:49.000 --> 10:51.000] 然后我肯定就要去解决掉
[10:51.000 --> 10:52.000] 因为我的书里要写它嘛
[10:52.000 --> 10:53.000] 不可能留着一个bug
[10:53.000 --> 10:55.000] 这样写出来也没有意义
[10:56.000 --> 10:57.000] 还有就是
[10:57.000 --> 10:59.000] 比如说我书里要介绍一些功能
[10:59.000 --> 11:01.000] 但是这个项目没有
[11:01.000 --> 11:03.000] 然后我这时候也想去给它添加出来
[11:03.000 --> 11:08.000] 比如说Flask WTF是一个表单处理库
[11:08.000 --> 11:10.000] 它当时不支持就是
[11:10.000 --> 11:13.000] 在你的表单验证错误的时候显示中文
[11:13.000 --> 11:14.000] 中文的错误消息
[11:15.000 --> 11:19.000] 但它本身它集成的那个WTForms是支持的
[11:19.000 --> 11:22.000] 所以当时我想写这么一张来介绍
[11:22.000 --> 11:24.000] 怎么才实现了一个中文错误消息
[11:24.000 --> 11:26.000] 所以我就先去给它贡献这个代码
[11:26.000 --> 11:27.000] 让它支持这个东西
[11:28.000 --> 11:30.000] 所以我觉得我的参与开源
[11:30.000 --> 11:34.000] 其实是写作的一个带来的副作用
[11:34.000 --> 11:36.000] 或者说意外收获吧
[11:38.000 --> 11:41.000] 我觉得应该很多人在了解到
[11:41.000 --> 11:44.000] 就是你是从初学者
[11:44.000 --> 11:47.000] 然后一步一步变成maintainer之后
[11:47.000 --> 11:52.000] 都会就觉得非常景仰你
[11:52.000 --> 11:56.000] 然后但是当你把这个过程拆解之后
[11:56.000 --> 11:57.000] 其实大家发现
[11:57.000 --> 11:59.000] 好像也并不是完全不能复制的
[11:59.000 --> 12:00.000] 就是这样子
[12:01.000 --> 12:05.000] 对其实网络很容易给人带来一些滤镜
[12:05.000 --> 12:08.000] 然后今天这个今天这个播客可能就是一个
[12:08.000 --> 12:10.000] 去除滤镜的一个过程
[12:11.000 --> 12:14.000] 也有可能是让滤镜加深
[12:14.000 --> 12:16.000] 不会
[12:17.000 --> 12:20.000] 那就是关于参与开源这部分
[12:20.000 --> 12:23.000] 各位主播有没有什么问题想问你回呢
[12:25.000 --> 12:27.000] 那我要不我来问一个问题吧
[12:27.000 --> 12:31.000] 就是palace组织你们知道palace为什么叫palace吗
[12:31.000 --> 12:33.000] 就这个名字为什么这样叫吗
[12:34.000 --> 12:36.000] 不知道这是一个单词吗
[12:37.000 --> 12:41.000] 对它的logo就是这个单词的意思
[12:41.000 --> 12:42.000] 它是一个名词
[12:43.000 --> 12:45.000] 就和flask的logo我不知道是什么一样
[12:45.000 --> 12:47.000] palace的logo我也不知道是什么
[12:49.000 --> 12:52.000] flask是后盘简陋的小床的意思
[12:52.000 --> 12:54.000] 就是那个东西
[12:54.000 --> 12:55.000] 因为很长时间我也不知道
[12:55.000 --> 12:57.000] 但是因为要参加播客嘛
[12:57.000 --> 12:58.000] 所以我提前做了一些功课
[12:58.000 --> 13:00.000] 我就问了一下Armijo
[13:00.000 --> 13:01.000] 然后他就跟我说
[13:01.000 --> 13:04.000] 这是其实一个隐藏的双关语
[13:04.000 --> 13:05.000] 就是palace在欧洲
[13:06.000 --> 13:09.000] 就是欧洲很流行用这种托盘
[13:09.000 --> 13:12.000] 这种木质的托盘来运载货物
[13:13.000 --> 13:14.000] 然后就这个这里的双关语
[13:14.000 --> 13:17.000] 就是用托盘来shift software
[13:18.000 --> 13:19.000] shift应该翻成交付吧
[13:19.000 --> 13:20.000] shift software
[13:20.000 --> 13:22.000] 就是这样一种双关语
[13:22.000 --> 13:24.000] ok
[13:24.000 --> 13:25.000] 有点意思
[13:26.000 --> 13:27.000] 对
[13:27.000 --> 13:30.000] 然后我还要在顺便说一下flask的logo问题
[13:31.000 --> 13:35.000] 就是我在paconchina从18年到20年
[13:35.000 --> 13:36.000] 已经说过三次了
[13:37.000 --> 13:38.000] 就是flask的logo到底是什么
[13:39.000 --> 13:40.000] 你们知道吗
[13:41.000 --> 13:43.000] 诶 它不是那个辣椒吗
[13:47.000 --> 13:49.000] 看来我这三年做的努力
[13:49.000 --> 13:52.000] 其实我还可以去清楚
[13:52.000 --> 13:54.000] 它是一个那个配出的那个东西是吧
[13:55.000 --> 13:56.000] 对对对
[13:56.000 --> 13:57.000] 放火药的一个
[13:58.000 --> 14:00.000] 这是一个非常普遍的误解
[14:00.000 --> 14:02.000] 就是认为flask的logo是一个辣椒
[14:03.000 --> 14:05.000] 然后我付出了很多的努力
[14:05.000 --> 14:07.000] 希望来消除这个误解
[14:08.000 --> 14:10.000] 就是说它是一个容器
[14:12.000 --> 14:14.000] 但其实呢我最近也才发现
[14:14.000 --> 14:15.000] 原来我也错了
[14:15.000 --> 14:16.000] 就是我花了三年的时间
[14:16.000 --> 14:20.000] 原来是用另一个误解来消除前一个误解
[14:21.000 --> 14:22.000] 我们之前没有和
[14:22.000 --> 14:24.000] 没有和Amazon的客户沟通过
[14:24.000 --> 14:25.000] 这个到底是什么
[14:25.000 --> 14:28.000] 我想当然了以为就是我看到的东西
[14:28.000 --> 14:30.000] 我之前一直介绍它是一个ponderhorn
[14:31.000 --> 14:33.000] 就是用动物的脚做成的容器
[14:34.000 --> 14:35.000] 一般是用来装火药粉末的
[14:36.000 --> 14:39.000] 因为你如果用google来搜索ponderhorn的话
[14:39.000 --> 14:41.000] 你会发现它们几乎是一模一样的
[14:42.000 --> 14:43.000] 图案是一模一样的
[14:43.000 --> 14:45.000] 但是我最近才想到它的
[14:45.000 --> 14:47.000] 它的logo里面有一句slogan
[14:48.000 --> 14:50.000] 是one job at a time
[14:51.000 --> 14:53.000] 我直译就把它翻译成了一次一滴
[14:54.000 --> 14:56.000] 然后我就想到了whiskey
[14:56.000 --> 14:58.000] 就是WSJI这个标准
[14:58.000 --> 15:00.000] 为什么喜欢被读作whiskey
[15:01.000 --> 15:03.000] 然后为什么这个bottle这个框架
[15:03.000 --> 15:04.000] 然后flask这个框架
[15:04.000 --> 15:06.000] 它们都是用容器来做名字
[15:07.000 --> 15:08.000] 然后想到它们原来是
[15:08.000 --> 15:10.000] 是要装whiskey的
[15:10.000 --> 15:12.000] 就是Python的那个协议whiskey
[15:12.000 --> 15:14.000] 它们要用来装whiskey
[15:15.000 --> 15:16.000] 然后我就想到
[15:16.000 --> 15:19.000] 这不会是一个用来喝酒的容器吧
[15:19.000 --> 15:21.000] 然后我就又去问了Armin Dronacker
[15:22.000 --> 15:23.000] 他告诉我这是一个drinking horn
[15:23.000 --> 15:25.000] 不是一个ponderhorn
[15:25.000 --> 15:26.000] 就是用来喝酒的容器
[15:28.000 --> 15:30.000] 所以我这一次在这个博客
[15:30.000 --> 15:32.000] 应该是彻底给出了一个正确答案
[15:34.000 --> 15:38.000] 是 这个应该是比较确凿
[15:38.000 --> 15:39.000] 那我很好奇
[15:39.000 --> 15:42.000] 他难道没有一个就是解释
[15:42.000 --> 15:43.000] 就是说他到底是什么
[15:43.000 --> 15:44.000] 就一个文档之类的
[15:45.000 --> 15:46.000] 没有
[15:47.000 --> 15:48.000] OK
[15:51.000 --> 15:53.000] 应该是中文网络上
[15:53.000 --> 15:57.000] 第一次有人正确解释flask logo的含义
[15:58.000 --> 15:59.000] 也许吧
[16:00.000 --> 16:02.000] 就在不慎的说 独家
[16:04.000 --> 16:06.000] 我们这期标题就可以知道
[16:06.000 --> 16:09.000] 你知道flask logo代表什么吗
[16:12.000 --> 16:13.000] 原来是这样子
[16:14.000 --> 16:15.000] OK
[16:16.000 --> 16:18.000] 那关于这个参与开源
[16:18.000 --> 16:19.000] 我们其实也聊了不少
[16:19.000 --> 16:21.000] 然后就下一个主题
[16:21.000 --> 16:24.000] 我们想聊一下flask的社区
[16:25.000 --> 16:27.000] 然后我们还是先请李辉
[16:27.000 --> 16:29.000] 给一个简单的介绍吧
[16:29.000 --> 16:30.000] 就是概况
[16:32.000 --> 16:33.000] 社区的话
[16:33.000 --> 16:35.000] 其实我想先从就是最近发生了一件
[16:35.000 --> 16:37.000] 比较有意思的事情说起
[16:37.000 --> 16:39.000] 就是flask上火星了
[16:39.000 --> 16:40.000] 有很多人
[16:40.000 --> 16:41.000] 比如说在Github上
[16:41.000 --> 16:44.000] 大概有一万两千个人会有一个新的徽章
[16:44.000 --> 16:47.000] 就是叫做Github Mars 2020
[16:47.000 --> 16:49.000] Helicopter Contributor
[16:49.000 --> 16:52.000] 就是如果你贡献的项目被用作了
[16:52.000 --> 16:54.000] 火星上的那个直升机的系统里面
[16:54.000 --> 16:56.000] 那么你就获得这个徽章
[16:57.000 --> 16:59.000] 那个系统当然大部分的代码是用
[16:59.000 --> 17:01.000] 它是一个被修改过的
[17:01.000 --> 17:03.000] 自定制的一个Linux发行板
[17:03.000 --> 17:07.000] 其中大部分是用来C++写的
[17:07.000 --> 17:10.000] 但有一小部分是用Python写的
[17:10.000 --> 17:13.000] 而且其中有一个Ground Data System
[17:13.000 --> 17:15.000] 就是一个地面数据系统
[17:15.000 --> 17:19.000] 应该是那个直升机跟地面进行数据交互的
[17:19.000 --> 17:22.000] 但我不知道是不是从火星和地球之间的交互
[17:22.000 --> 17:25.000] 反正就这样一个交互是用flask写的
[17:25.000 --> 17:27.000] 然后感觉还挺有意思
[17:27.000 --> 17:30.000] 因为很多给flask贡献过代码的人
[17:30.000 --> 17:32.000] 都会获得这个徽章
[17:32.000 --> 17:35.000] 它是官方说的这个时候flask写的吗
[17:35.000 --> 17:36.000] 还是说
[17:37.000 --> 17:39.000] 它官方给出了一份代码
[17:39.000 --> 17:41.000] 这个代码是NASA开发的
[17:41.000 --> 17:43.000] NASA在GitHub上开源了这个项目
[17:43.000 --> 17:46.000] 就是一个叫F'的项目
[17:47.000 --> 17:48.000] 原来如此
[17:48.000 --> 17:50.000] 对 其实我也有那个徽章
[17:50.000 --> 17:53.000] 因为那个Cpython也是它的一个依赖
[17:53.000 --> 17:55.000] 所以只要你给Cpython贡献过
[17:55.000 --> 17:56.000] 也是有徽章
[17:56.000 --> 17:58.000] 对对对 它包含两部分
[17:58.000 --> 18:01.000] 就是Python那部分是一个工具体
[18:01.000 --> 18:05.000] 然后flask那部分是一个数据系统的API
[18:06.000 --> 18:08.000] 但是就是在这一点背后
[18:08.000 --> 18:10.000] 有一个比较尴尬的事情
[18:10.000 --> 18:12.000] 就是它写的这个API是
[18:12.000 --> 18:14.000] 里面用了两个扩展
[18:14.000 --> 18:17.000] 一个扩展是flask-restful
[18:17.000 --> 18:19.000] 用来开发API的一个扩展
[18:19.000 --> 18:21.000] 另一个扩展是flask-upload
[18:21.000 --> 18:23.000] 然后这两个扩展
[18:23.000 --> 18:26.000] 其实维护状态都是很糟糕的
[18:26.000 --> 18:28.000] 比如说flask-restful
[18:28.000 --> 18:31.000] 它的核心组件已经被deprecated了
[18:31.000 --> 18:33.000] 就是不推荐使用了
[18:33.000 --> 18:35.000] 然后flask-upload是一个
[18:35.000 --> 18:36.000] 怎么说呢
[18:36.000 --> 18:39.000] 是一个已经失去维护很多年的项目了
[18:39.000 --> 18:40.000] 它的最后一个commit
[18:40.000 --> 18:41.000] 还是我提交的
[18:41.000 --> 18:45.000] 就是添加了中文文件名支持的那个commit
[18:45.000 --> 18:47.000] 是我在17年1月份提交的
[18:47.000 --> 18:49.000] 它在20年被合并了
[18:49.000 --> 18:52.000] 但是合并之后就没有任何新的贡献了
[18:52.000 --> 18:54.000] 所以我觉得这可能是一个
[18:54.000 --> 18:56.000] 比较普遍的现象吧
[18:56.000 --> 19:00.000] 就是在开源社区有很多被抛弃的项目
[19:00.000 --> 19:03.000] 就是可能一个维护者
[19:03.000 --> 19:05.000] 他在一个时间内做了一个项目
[19:05.000 --> 19:07.000] 然后短期内获得了一些关注
[19:07.000 --> 19:08.000] 但是慢慢地
[19:08.000 --> 19:11.000] 他的生活重心可能就发生了变化
[19:11.000 --> 19:12.000] 然后这个项目可能就
[19:12.000 --> 19:14.000] 有很大的可能就会被失去维护
[19:14.000 --> 19:16.000] 比如说他被裁员了
[19:16.000 --> 19:18.000] 或者说去转行送外卖了
[19:18.000 --> 19:23.000] 然后这个时候这个项目可能就没有人管了
[19:23.000 --> 19:24.000] 是
[19:24.000 --> 19:28.000] 我也放弃维护了很多项目
[19:28.000 --> 19:30.000] 其实就很多东西
[19:30.000 --> 19:33.000] 我现在自己不用就很难去维护了
[19:33.000 --> 19:36.000] 对
[19:36.000 --> 19:38.000] 像那个对
[19:38.000 --> 19:40.000] 其实很多框架
[19:40.000 --> 19:42.000] 包括一些很热门的
[19:42.000 --> 19:44.000] 它都会出现这种问题
[19:44.000 --> 19:46.000] 我觉得怎么说
[19:46.000 --> 19:48.000] 这个也是不可避免的吧
[19:48.000 --> 19:49.000] 所以另一方面
[19:49.000 --> 19:52.000] 其实要求我们在选开源框架的时候
[19:52.000 --> 19:56.000] 我们非常就更看重维护这块
[19:56.000 --> 20:03.000] 维护团队他们是不是有一个这种组织
[20:03.000 --> 20:07.000] 然后就这样可以避免单点失效的问题
[20:07.000 --> 20:09.000] 对你说这个就确实很重要
[20:09.000 --> 20:10.000] 然后当时我的
[20:10.000 --> 20:14.000] 我这两年一直想做的就是这样一个东西
[20:14.000 --> 20:18.000] 然后我想我一开始的计划是创建一个叫做FLASKX的组织
[20:18.000 --> 20:21.000] 然后把这些失去的维护的扩展全都FOC过来
[20:21.000 --> 20:23.000] 给他们的名字后面加一个X
[20:23.000 --> 20:26.000] 然后再找这些人来一起维护
[20:26.000 --> 20:28.000] 但是一直没有付出行动
[20:28.000 --> 20:30.000] PALACE团队里面也有过几次讨论
[20:30.000 --> 20:33.000] 后来都不了了之了
[20:33.000 --> 20:40.000] 我觉得这种第三方的扩展是不是就应该
[20:40.000 --> 20:43.000] 他不维护了就不维护了
[20:43.000 --> 20:46.000] 如果这个东西真的有人需要的话
[20:46.000 --> 20:49.000] 就可能会有一些新的扩展出来
[20:49.000 --> 20:52.000] 比如说像一些FORMS相关的东西
[20:52.000 --> 20:53.000] 现在用的比较少了
[20:53.000 --> 20:56.000] 可能没人维护了
[20:56.000 --> 20:58.000] 也不需要再继续维护了吧
[20:58.000 --> 21:00.000] 可能现在都用API比较多
[21:00.000 --> 21:03.000] 那一部分扩展会多起来
[21:03.000 --> 21:07.000] 但是你像一些安全性更新什么的
[21:07.000 --> 21:09.000] 就是可能还是有必要
[21:09.000 --> 21:11.000] 不然的话
[21:11.000 --> 21:13.000] 而且还有一个问题
[21:13.000 --> 21:15.000] 就是就是就是PiPi他的名字
[21:15.000 --> 21:17.000] 你一旦占用了就没有办法再使用
[21:17.000 --> 21:22.000] 所以其实这给后续我想做一个
[21:22.000 --> 21:23.000] 就另起炉灶
[21:23.000 --> 21:24.000] 其实带来很大的麻烦
[21:24.000 --> 21:26.000] 我觉得
[21:26.000 --> 21:30.000] 对对比如说就是有一个叫做FLASK BOOSTRAP的项目
[21:30.000 --> 21:32.000] 然后他就他就一直都很流行
[21:32.000 --> 21:35.000] 但是就是没有维护了
[21:35.000 --> 21:38.000] 因为他的维护者你联系不到他
[21:38.000 --> 21:40.000] 他的Github上没有邮件地址
[21:40.000 --> 21:44.000] 然后你在Github仓库里面去按了他
[21:44.000 --> 21:45.000] 他也不回复
[21:45.000 --> 21:47.000] 所以你也不知道发生了什么
[21:47.000 --> 21:49.000] 然后我就写了一个
[21:49.000 --> 21:51.000] 另一个库档来替代他
[21:51.000 --> 21:52.000] 他叫FLASK BOOSTRAP
[21:52.000 --> 21:55.000] 然后我就改名叫BOOSTRAP FLASK
[21:55.000 --> 22:02.000] 我觉得那个名字不能替换也是合理的吧
[22:02.000 --> 22:06.000] 因为比如说现在有很多项目依赖了那个FLASK BOOSTRAP
[22:06.000 --> 22:07.000] 如果你把它更新了
[22:07.000 --> 22:10.000] 可能是几个项目部署一次的话
[22:10.000 --> 22:12.000] 就依赖权都被打乱了
[22:12.000 --> 22:17.000] 对但是Pyper有一个就是相关的规定
[22:17.000 --> 22:18.000] 就是你可以去申请
[22:18.000 --> 22:22.000] 就是就是恢复这个名把这个名字要过来这样
[22:22.000 --> 22:24.000] 你可以去发issue申请
[22:24.000 --> 22:30.000] 那他是不是给这个库下载量不多
[22:30.000 --> 22:31.000] 如果下载量多的话
[22:31.000 --> 22:33.000] 如果Pyper这样做
[22:33.000 --> 22:38.000] 对对对需要这个库可能很久都没有发过release
[22:38.000 --> 22:39.000] 这样的状态
[22:39.000 --> 22:43.000] 或者你可以证明他的维护者已经挂掉了
[22:43.000 --> 22:51.000] 说起来我两天之前就之前写了一个PinTop的东西
[22:51.000 --> 22:55.000] 就是可以Pin多个IP同时显示
[22:55.000 --> 22:56.000] 就跟HTOP一样
[22:56.000 --> 22:58.000] 然后我已经很久不用了
[22:58.000 --> 23:04.000] 就之前用主要是用来测几个服务器的那个速度
[23:04.000 --> 23:06.000] 但现在人都不在国内了
[23:06.000 --> 23:07.000] 所以就基本用不到
[23:07.000 --> 23:13.000] 然后其实好多人都在那个东西好像有问题了一段时间了
[23:13.000 --> 23:16.000] 就是我里面有一个依赖没有限制他的版本
[23:16.000 --> 23:20.000] 然后那个作者发了一个新的版本
[23:20.000 --> 23:22.000] 他里面的API全都变了
[23:22.000 --> 23:26.000] 所以后面安装的人全都用不了这个这个东西
[23:26.000 --> 23:29.000] 然后我我两天前就给他修了
[23:29.000 --> 23:30.000] 修的特别痛苦
[23:30.000 --> 23:31.000] 我得找出来
[23:31.000 --> 23:35.000] 我因为我自己都不知道上一个可用的版本是什么
[23:35.000 --> 23:41.000] 你知道吗就是因为他那个setup.py里面就写了一个那个包的名字
[23:41.000 --> 23:46.000] 然后就从他的release找出来那些release记录一个一个的去试
[23:46.000 --> 23:52.000] 最后是试出来一个19年的一个发布是可以用
[23:52.000 --> 23:57.000] 正好我已经已经有两年没有碰这个东西
[23:57.000 --> 23:58.000] 然后我就把它修好了
[23:58.000 --> 24:03.000] 是这其实也是也是Flask社区的一个问题
[24:03.000 --> 24:05.000] 比如说我跟你说Flask社区很庞大
[24:05.000 --> 24:07.000] 有很多扩展可以用
[24:07.000 --> 24:11.000] 但是可能大部分扩展都有这样一个维护问题
[24:11.000 --> 24:18.000] 再比如说你像Django它的大部分功能都是由Django整个官方来开发来维护
[24:18.000 --> 24:21.000] 而且因为他们也也很有钱嘛
[24:21.000 --> 24:25.000] 所以可以很稳定的来支持这些东西
[24:25.000 --> 24:29.000] 但是Flask就不太容易能做到这样
[24:29.000 --> 24:34.000] 其实Django主要的部分像Farm跟OM之类的是他们自己的
[24:34.000 --> 24:38.000] 也有很多不在他们的那个主代码库里面
[24:38.000 --> 24:41.000] 一些Django杠什么的扩展
[24:41.000 --> 24:45.000] 其实这种扩展你如果需要的时候你去找起来
[24:45.000 --> 24:48.000] 也有很多很多不能用的
[24:48.000 --> 24:53.000] 就比如说就之前很多人都不想再搭一套那个job queue的系统
[24:53.000 --> 24:57.000] 像Salary他们想直接用数据库轮悬来做一个queue
[24:57.000 --> 25:00.000] 这种东西你如果去搜的话
[25:00.000 --> 25:01.000] 你会发现有很多很多
[25:01.000 --> 25:04.000] 但是大部分都不能用都不好用
[25:04.000 --> 25:06.000] 不过呢
[25:06.000 --> 25:08.000] 虽然Flask社区现在有这样的问题
[25:08.000 --> 25:10.000] 但是大家不用担心
[25:10.000 --> 25:12.000] 因为我们已经找到了解决方案
[25:12.000 --> 25:16.000] 就是我们最近成立了一个叫做Flask Community Work Group
[25:16.000 --> 25:19.000] 就是一个Flask社区工作小组
[25:19.000 --> 25:22.000] 然后这个工作小组的一个主要的目的
[25:22.000 --> 25:26.000] 就是把这些失去维护的扩展要过来
[25:26.000 --> 25:29.000] 然后用一个团队来维护它
[25:29.000 --> 25:31.000] 但是和Palace官方无关
[25:31.000 --> 25:33.000] 因为是一个社区成立的一个小组
[25:33.000 --> 25:36.000] 这应该可以很大概率的解决这个问题
[25:36.000 --> 25:42.000] 你算是这个主导这个Community Work Group的人吗
[25:42.000 --> 25:45.000] 我应该是可以做这个事情的
[25:45.000 --> 25:47.000] 但是呢因为我的英语不太好
[25:47.000 --> 25:49.000] 所以我没有办法主持会议
[25:49.000 --> 25:51.000] 所以我不能做主导
[25:51.000 --> 25:53.000] 但我会做一些建议
[25:53.000 --> 25:56.000] 我会做一些就在里面做一些事情
[25:56.000 --> 25:59.000] 因为他们也需要一个Palace成员加入他们
[25:59.000 --> 26:03.000] 所以我就是唯一一个加入他们的Palace成员
[26:03.000 --> 26:06.000] 我觉得其实我觉得这种事情怎么说
[26:06.000 --> 26:09.000] 随着开源软件就使用的越来越广泛
[26:09.000 --> 26:11.000] 参与的人越来越多
[26:11.000 --> 26:15.000] 然后大家总会找到解决方案
[26:15.000 --> 26:19.000] 其实我不是特别担心
[26:19.000 --> 26:21.000] 我还记得我之前很早
[26:21.000 --> 26:24.000] 就是刚刚开始学web开发的时候
[26:24.000 --> 26:28.000] 然后其实就面临着一个困境
[26:28.000 --> 26:31.000] 就是Flask就本身它不会内置很多这种
[26:31.000 --> 26:33.000] 我们所谓的battery
[26:33.000 --> 26:36.000] 然后呢你会发现extension有很多
[26:36.000 --> 26:38.000] 但是你又不知道怎么选
[26:38.000 --> 26:41.000] 然后维护的频率呢有的又很低
[26:41.000 --> 26:43.000] 对然后就会觉得成本很高
[26:43.000 --> 26:46.000] 然后在当时是把我劝退了
[26:46.000 --> 26:49.000] 然后比如说后来我又开始做Flask
[26:49.000 --> 26:53.000] 其实是因为我已经有很多这种经验和基础了
[26:53.000 --> 26:55.000] 我觉得没有也OK
[26:55.000 --> 26:58.000] 就是大不了我可以自己写
[26:58.000 --> 27:04.000] 就是比如说一些和特别的OS相关的东西之类的
[27:04.000 --> 27:07.000] 就是可能我选不到一个我特别喜欢的
[27:07.000 --> 27:08.000] 我可以自己写
[27:08.000 --> 27:13.000] 但是对初学者来说可能他要选一个extension之类的
[27:13.000 --> 27:14.000] 我觉得还是有成本
[27:14.000 --> 27:17.000] 因为他可能完全不知道生态是什么
[27:17.000 --> 27:21.000] 感觉是不是可以有一个那样的网站
[27:21.000 --> 27:25.000] 就是列出来Flask的一些extension
[27:25.000 --> 27:29.000] 然后按照使用人数代码质量
[27:29.000 --> 27:32.000] 跟发布周期来评分这样的东西
[27:32.000 --> 27:35.000] 其实PyPi是有很多这样的三方网站
[27:35.000 --> 27:39.000] 就是你可以在一些PyPi的那个
[27:39.000 --> 27:44.000] 就是三方网站上去查到那个包的评价下载数量
[27:44.000 --> 27:50.000] Flask在之前它的官方文档里是有这么一个页面
[27:50.000 --> 27:53.000] 就叫做extensions registry
[27:53.000 --> 27:56.000] 然后来可能就因为很多扩展是维护了
[27:56.000 --> 27:59.000] 就这个列表可能已经就是不太好了
[27:59.000 --> 28:00.000] 没有长久更新
[28:00.000 --> 28:02.000] 所以后来就去掉了
[28:02.000 --> 28:05.000] 是就这种东西
[28:05.000 --> 28:10.000] 我觉得你怎么保持它最新是非常难的一个事情
[28:10.000 --> 28:14.000] 而且你怎么保证就是你的
[28:14.000 --> 28:17.000] 它的那个评分是可信的
[28:17.000 --> 28:19.000] 对吧就是万一他那个地方
[28:19.000 --> 28:22.000] 比如说他有一个很重要的什么指标
[28:22.000 --> 28:23.000] 没有考虑到
[28:23.000 --> 28:25.000] 然后他可能比如说只看star
[28:25.000 --> 28:27.000] 但是没有看最近commit
[28:27.000 --> 28:29.000] 那就会出现偏差
[28:29.000 --> 28:31.000] 就很难讲
[28:31.000 --> 28:34.000] 反正这个事情我感觉还是
[28:34.000 --> 28:38.000] 还是一个整个软件开发的业界
[28:38.000 --> 28:40.000] 需要摸索出一些最佳实践吧
[28:40.000 --> 28:45.000] 可能现在有没有类似发行板这种东西
[28:45.000 --> 28:49.000] 就是他把flask的flask跟他的一些扩展
[28:49.000 --> 28:51.000] 打包成一个类似john的东西
[28:51.000 --> 28:55.000] 应该是有的
[28:55.000 --> 28:58.000] 有一些就是比较大的二次框架
[28:58.000 --> 29:00.000] 比如说dash
[29:00.000 --> 29:02.000] 就是他把flask包装起来
[29:02.000 --> 29:05.000] 然后添加了一些就是类似于图表库
[29:05.000 --> 29:07.000] 还有就是机器学习那部分的内容
[29:07.000 --> 29:10.000] 然后就给你生成一个自动生成一个界面
[29:10.000 --> 29:12.000] 或者后台这样
[29:12.000 --> 29:14.000] 怎么写dash吗
[29:14.000 --> 29:17.000] dash就是dash
[29:17.000 --> 29:21.000] 我感觉好像就是不同的领域都有这种
[29:21.000 --> 29:23.000] 一个大而全的框架
[29:23.000 --> 29:26.000] versus一个就是小而精的框架
[29:26.000 --> 29:27.000] 加一堆扩展
[29:27.000 --> 29:30.000] 比如说前端也有angular
[29:30.000 --> 29:32.000] versus react对吧
[29:32.000 --> 29:34.000] 其实也是angular就类似于jungle
[29:34.000 --> 29:36.000] 然后react就像flask
[29:36.000 --> 29:38.000] 有点这种感觉
[29:38.000 --> 29:41.000] 对这个是flask一个比较好的点
[29:41.000 --> 29:44.000] 虽然很多人说你用flask
[29:44.000 --> 29:46.000] 最后也是自己造了一个jungle出来
[29:46.000 --> 29:50.000] 但是你用flask可以就是造一个你喜欢的jungle
[29:50.000 --> 29:52.000] 你喜欢的一个定制版的jungle
[29:52.000 --> 29:55.000] 而不是说官方讲对给你的那个版本
[29:55.000 --> 29:59.000] 怪不得我每次用react那么痛苦
[29:59.000 --> 30:04.000] 就是因为我不喜欢自己去组装那些东西
[30:04.000 --> 30:06.000] 就比如说react,rotor
[30:06.000 --> 30:08.000] 现在还好
[30:08.000 --> 30:10.000] 之前每次用的时候都得看半天
[30:10.000 --> 30:13.000] 就是你要自己去配置一些路由啊
[30:13.000 --> 30:14.000] 硕士化什么的
[30:14.000 --> 30:17.000] 但其实现在像很多公司都有
[30:17.000 --> 30:19.000] 至少我在过的两家公司
[30:19.000 --> 30:23.000] 都有一些内部的一些前端的框架
[30:23.000 --> 30:24.000] 虽然他们都是基于react
[30:24.000 --> 30:27.000] 但是你就是npm安装一个东西
[30:27.000 --> 30:29.000] 它里面的路由啊
[30:29.000 --> 30:33.000] 就是前端开发的proxy等等一些东西吧
[30:33.000 --> 30:35.000] 还有就是一些sidebar
[30:35.000 --> 30:36.000] 它都给你设置好了
[30:36.000 --> 30:38.000] 就你添加路由的话
[30:38.000 --> 30:41.000] 你不用去添加react,rotor那种方式
[30:41.000 --> 30:43.000] 你只需要设定好一个
[30:43.000 --> 30:46.000] 这个这个UI对应这个页面
[30:46.000 --> 30:48.000] 然后它那些侧边栏
[30:48.000 --> 30:51.000] 自动就是你点到这个页面
[30:51.000 --> 30:54.000] 自动在侧边栏的菜单自动高亮啊什么的
[30:54.000 --> 30:55.000] 这种全都弄好
[30:55.000 --> 30:57.000] 好像每个公司都有一套
[30:57.000 --> 31:03.000] audiobook开源的叫uimgf
[31:03.000 --> 31:05.000] 其实写前端应该不多
[31:05.000 --> 31:06.000] 太幸福了
[31:06.000 --> 31:09.000] 是行
[31:09.000 --> 31:13.000] 那我们聊了一些就是关于flask社区的
[31:13.000 --> 31:14.000] 然后李慧
[31:14.000 --> 31:17.000] 我看你还提了一点是那个hello flask社区
[31:17.000 --> 31:19.000] 你要不聊一下这个
[31:19.000 --> 31:24.000] 对hello flask社区是我在算是在国内创建的一个社区吧
[31:24.000 --> 31:28.000] 那我也我也不是很很想把它叫做一个社区
[31:28.000 --> 31:31.000] 因为因为它可能里面掺杂了一些我
[31:31.000 --> 31:33.000] 我写的书啦文章啦这些东西
[31:33.000 --> 31:34.000] 可能上掺杂一些个人利益
[31:34.000 --> 31:36.000] 所以我就我可以把那个论坛
[31:36.000 --> 31:38.000] 然后抽离出来作为一个社区
[31:38.000 --> 31:41.000] 因为那个论坛确实一个很纯粹的东西
[31:41.000 --> 31:45.000] 虽然论坛的用户数量可能还没有QQ群成员的一半多
[31:45.000 --> 31:48.000] 我只要用它来收集读者的提问
[31:48.000 --> 31:51.000] 当你写了一些文章和书之后
[31:51.000 --> 31:53.000] 就会有各种各样的提问
[31:53.000 --> 31:55.000] 从各种渠道送过来
[31:55.000 --> 31:59.000] 一开始我可能就是也许会去处理
[31:59.000 --> 32:01.000] 然后一个提问可能会处理很久
[32:01.000 --> 32:03.000] 但是慢慢的一旦多了起来
[32:03.000 --> 32:05.000] 我就根本就没有精力去处理了
[32:05.000 --> 32:07.000] 所以现在有人提问的话
[32:07.000 --> 32:10.000] 我一般会跟他说麻烦你发到论坛
[32:10.000 --> 32:12.000] 然后怎么怎么写提供哪些信息
[32:12.000 --> 32:14.000] 一般都会这样说
[32:14.000 --> 32:16.000] 而且这会起到一个过滤的作用
[32:16.000 --> 32:18.000] 就是有一部分人他会比较懒
[32:18.000 --> 32:22.000] 因为他直接用QQ或者那个知乎的私信什么
[32:22.000 --> 32:24.000] 给你发一个问题可能非常方便
[32:24.000 --> 32:26.000] 给你截一个图
[32:26.000 --> 32:27.000] 问你为什么不行了
[32:27.000 --> 32:29.000] 为什么报这个错
[32:29.000 --> 32:32.000] 然后如果你让他去写到那个论坛上
[32:32.000 --> 32:34.000] 然后告诉他用纯文本写
[32:34.000 --> 32:36.000] 然后要把致灵帖读一遍
[32:36.000 --> 32:38.000] 知道怎么正确提问
[32:38.000 --> 32:40.000] 他可能就放弃了
[32:40.000 --> 32:43.000] 而且那个论坛是在国外的嘛
[32:43.000 --> 32:45.000] 服务器在国外
[32:45.000 --> 32:47.000] 可能有一部分人访问是比较慢的
[32:47.000 --> 32:49.000] 然后又有一部分人放弃了
[32:49.000 --> 32:51.000] 所以最后提问的人其实很少
[32:51.000 --> 32:53.000] 而且这样频率比较低
[32:53.000 --> 32:55.000] 我就每个都能处理过来
[32:58.000 --> 32:59.000] 有点意思
[33:00.000 --> 33:02.000] 那就是那比如说有一个提问
[33:02.000 --> 33:04.000] 我反馈了一个你书里的问题
[33:04.000 --> 33:08.000] 那但你书难道你你书又不能更新
[33:08.000 --> 33:09.000] 这玩意怎么怎么办呢
[33:09.000 --> 33:10.000] 就是怎么解决
[33:11.000 --> 33:13.000] 我书是可以更新的
[33:13.000 --> 33:16.000] 因为他每次重印都是可以更新内容
[33:16.000 --> 33:17.000] 是吗
[33:17.000 --> 33:18.000] 对
[33:18.000 --> 33:20.000] 所以你看我网站上会有一个刊物
[33:20.000 --> 33:25.000] 然后每一个版本都会有在放在GitHub上的一个刊物列表
[33:25.000 --> 33:28.000] 重印10次就会有10次迭代
[33:28.000 --> 33:29.000] 这还挺有意思
[33:29.000 --> 33:30.000] 我第一次知道
[33:30.000 --> 33:34.000] 我还以为那个什么第几版就是唯一的更新的机会
[33:34.000 --> 33:36.000] 当然你也可以不做
[33:36.000 --> 33:37.000] 但是这个是可选的
[33:37.000 --> 33:40.000] 就是假如你想做的话是可以更新
[33:40.000 --> 33:43.000] 但是你不能就是大幅的变动
[33:43.000 --> 33:46.000] 就是这一页还要这一页的改动要控制在这一页
[33:46.000 --> 33:48.000] 就这样的东西
[33:48.000 --> 33:50.000] 不然有排版问题
[33:50.000 --> 33:51.000] 对对对
[33:51.000 --> 33:53.000] OK了解
[33:53.000 --> 33:55.000] 所以在就是书发布以后
[33:55.000 --> 33:58.000] 我可能我感觉自己就像是变成了一个客服
[33:58.000 --> 34:00.000] 就是就是好多读者来问问题
[34:01.000 --> 34:05.000] 因为你写了一本书就像是怎么说呢
[34:05.000 --> 34:08.000] 就有一种游戏的名字叫做大家来找碴
[34:08.000 --> 34:11.000] 然后就相当于你host了一个大家来找碴游戏
[34:11.000 --> 34:13.000] 每一个读者都可能来问你问题
[34:13.000 --> 34:19.000] 而且在这我想就是呼吁一下呼吁一下想提问的人
[34:20.000 --> 34:22.000] 然后我想说三点
[34:22.000 --> 34:23.000] 第一点呢
[34:23.000 --> 34:25.000] 就是息字如金的那种
[34:25.000 --> 34:27.000] 就是不愿意说很多信息的人
[34:27.000 --> 34:28.000] 那我就不说了
[34:28.000 --> 34:32.000] 他们可能也没有兴趣去读什么提问的智慧之类这些东西
[34:33.000 --> 34:36.000] 第二点就是xy problem的问题
[34:36.000 --> 34:38.000] 就是xy问题你们知道吗
[34:39.000 --> 34:41.000] 知道我们以前讲过
[34:41.000 --> 34:44.000] 对有大量的人在提这种问题
[34:44.000 --> 34:48.000] 就让你很难去知道它原始的问题到底是什么
[34:49.000 --> 34:50.000] 所以如果你想提问的话
[34:50.000 --> 34:52.000] 你就把你的原始问题提出来
[34:53.000 --> 34:54.000] 而不要去抽象出来
[34:54.000 --> 34:57.000] 你以为的一个解决方案遇到的问题
[34:58.000 --> 35:00.000] 是然后另一个就是
[35:00.000 --> 35:02.000] 就是不要说你好
[35:02.000 --> 35:04.000] 就是no hello
[35:04.000 --> 35:08.000] 很多人就提问就先过来上来就问大佬你好
[35:08.000 --> 35:10.000] 然后要么问大佬在吗
[35:10.000 --> 35:12.000] 我有个问题想请教
[35:14.000 --> 35:16.000] 不是但你在论坛里面的话
[35:16.000 --> 35:19.000] 他即使在他问题前面说一个大佬你好
[35:19.000 --> 35:21.000] 也无伤大雅应该
[35:22.000 --> 35:24.000] 但很多人是在QQ或者微信上
[35:24.000 --> 35:26.000] 或者知乎私信这种地方
[35:26.000 --> 35:28.000] 然后发一个消息过来问在吗
[35:29.000 --> 35:32.000] 等会儿所以你这些还是会回的
[35:32.000 --> 35:33.000] 我以为你们就不回了
[35:34.000 --> 35:37.000] 因为怎么说呢
[35:37.000 --> 35:39.000] 虽然这是一个大家来找茬游戏
[35:39.000 --> 35:41.000] 但是很有可能是真的你错了
[35:41.000 --> 35:43.000] 就是比如说你的书里面写错了
[35:43.000 --> 35:44.000] 你的程序有bug
[35:44.000 --> 35:46.000] 所以我就不想就是错过
[35:46.000 --> 35:48.000] 可能这潜在的一个机会
[35:48.000 --> 35:49.000] 修正的机会
[35:49.000 --> 35:51.000] 这还是会回的
[35:51.000 --> 35:53.000] 对这些问题好像我都遇到过
[35:53.000 --> 35:57.000] 就我们就是我们的工作
[35:57.000 --> 36:00.000] 就是其实就是要回答用户的问题
[36:00.000 --> 36:04.000] 那么我的问题跟你会是刚刚说的这些东西
[36:04.000 --> 36:07.000] 尤其是经常有人问哈喽什么的
[36:07.000 --> 36:10.000] 就让你回就等着你回
[36:10.000 --> 36:12.000] 他不继续往下说
[36:12.000 --> 36:14.000] 然后刚刚就是除了这些
[36:14.000 --> 36:16.000] 还有一些是没有提到的
[36:16.000 --> 36:18.000] 就是有些人的问题就很奇怪
[36:18.000 --> 36:21.000] 他问了你之后他跟你说明白了
[36:21.000 --> 36:23.000] 然后你给他就解决
[36:23.000 --> 36:24.000] 跟他说是不是这样是不是这样
[36:24.000 --> 36:25.000] 是不是这样
[36:25.000 --> 36:27.000] 就过了半天就说没事了
[36:27.000 --> 36:28.000] 我的问题解决了
[36:28.000 --> 36:30.000] 就就经常是这样
[36:30.000 --> 36:34.000] 就是就是他问你一个问题
[36:34.000 --> 36:40.000] 然后你问他就是你在问你在让他提供一些更多的细节
[36:40.000 --> 36:42.000] 然后对着跟你说问题解决了
[36:42.000 --> 36:45.000] 所以有的时候就是别人问你问题
[36:45.000 --> 36:46.000] 你比较忙
[36:46.000 --> 36:47.000] 你就可以不管过一段时间
[36:47.000 --> 36:50.000] 他会跟你说他的问题已经解决了
[36:50.000 --> 36:52.000] 对对对这这也是我的一个经验之谈
[36:52.000 --> 36:54.000] 就是当有人问你问题的时候
[36:54.000 --> 36:56.000] 你先晾着第二天再回答
[36:56.000 --> 36:57.000] 第二天问他
[36:57.000 --> 36:58.000] 不用立即回答
[36:58.000 --> 37:01.000] 然后他就直接告诉你啊没事了解决了
[37:01.000 --> 37:05.000] 而且而且会对而且会给你造成一个错觉
[37:05.000 --> 37:08.000] 就是你就是用来专门回答问题的
[37:08.000 --> 37:09.000] 其实不是的
[37:09.000 --> 37:12.000] 其实我们回答问题有一个专门的channel
[37:12.000 --> 37:13.000] 你应该在那里问
[37:13.000 --> 37:17.000] 所以就一开始我回答太太快了
[37:17.000 --> 37:21.000] 导致这些人遇到什么事都都过来问我
[37:21.000 --> 37:24.000] 就本来就完全不应该问那些事情
[37:24.000 --> 37:26.000] 就比如说python
[37:26.000 --> 37:29.000] 他们我这边安装这个库对不对
[37:29.000 --> 37:30.000] 这种问题
[37:30.000 --> 37:32.000] 然后你就让他敲一下paylist
[37:32.000 --> 37:35.000] 你看一下版本你告诉他对了
[37:35.000 --> 37:39.000] 然后就是我后来我也是跟李贵一样
[37:39.000 --> 37:40.000] 就是我们后来写了一些教程
[37:40.000 --> 37:43.000] 然后我们问题必须在教程下面的评论里问
[37:43.000 --> 37:45.000] 这样的话别人也能看到
[37:45.000 --> 37:49.000] 但是但是其实也是吧
[37:49.000 --> 37:51.000] 就是他如果真的私信你的话
[37:51.000 --> 37:52.000] 还是得回的
[37:52.000 --> 37:55.000] 毕竟毕竟那个对吧
[37:55.000 --> 37:56.000] 他现在工作
[37:56.000 --> 37:58.000] 是
[37:58.000 --> 38:02.000] 感觉你们SRE工作范围非常广
[38:02.000 --> 38:04.000] 嗯
[38:04.000 --> 38:06.000] 回答问题确实比较痛苦
[38:06.000 --> 38:09.000] 主要是很多人都不知道应该怎么问
[38:09.000 --> 38:13.000] 我刚才想说那个问别人问题
[38:13.000 --> 38:14.000] 然后马上解决这事
[38:14.000 --> 38:16.000] 我其实干过
[38:16.000 --> 38:19.000] 对
[38:19.000 --> 38:21.000] 行
[38:21.000 --> 38:22.000] 好
[38:22.000 --> 38:26.000] 其实我们这里还有一个
[38:26.000 --> 38:30.000] 关于前面讲到的话题的一个问题是小白提的
[38:30.000 --> 38:32.000] 要不你来说一下
[38:32.000 --> 38:33.000] 对
[38:33.000 --> 38:37.000] 然后我其实也是想做一些开源方面的东西
[38:37.000 --> 38:41.000] 但是我不太清楚就是具体应该怎么入手
[38:41.000 --> 38:46.000] 假如我想参与一个已经成熟迭代的开源项目的话
[38:46.000 --> 38:50.000] 我做的一个假设就是我想参与这个Vlask的开发
[38:50.000 --> 38:52.000] 然后有四种情况
[38:52.000 --> 38:54.000] 然后第一个就是我找到了一个bug
[38:54.000 --> 38:56.000] 第二个就是我找到了一个bug
[38:56.000 --> 38:58.000] 并且提出了一种解决方案
[38:58.000 --> 39:02.000] 然后第三个就是我有一种新的特性想要添加进去
[39:02.000 --> 39:06.000] 然后第四个就是我想持续的为Vlask提供代码
[39:06.000 --> 39:07.000] 这四个情况
[39:07.000 --> 39:10.000] 然后分别应该做什么样的反应呢
[39:10.000 --> 39:14.000] 这四个问题其实也都比较简单
[39:14.000 --> 39:17.000] 就是比如说你找到了一个bug
[39:17.000 --> 39:21.000] 那么你很自然就会去提交一个issue
[39:21.000 --> 39:24.000] 当然你提交的时候要写清楚你这个bug
[39:24.000 --> 39:28.000] 就是提供一个最小的可复现的一个例子
[39:28.000 --> 39:30.000] 然后详细地描述一下
[39:30.000 --> 39:33.000] 如果你找到了一个bug并且实现了一种解决方案
[39:33.000 --> 39:35.000] 那么就可以提交一个PR来修复它
[39:35.000 --> 39:39.000] 然后同时可以创建一个issue来描述这个bug
[39:39.000 --> 39:42.000] 但是注意就是对Vlask来说
[39:42.000 --> 39:46.000] 它是有维护分支和主分支的这样一个区分
[39:46.000 --> 39:49.000] 如果修复bug的话是要把那个best branch
[39:49.000 --> 39:52.000] 要是最新的维护分支
[39:52.000 --> 39:54.000] 以那个.x结尾的
[39:54.000 --> 39:57.000] 比如说2.0.x
[39:57.000 --> 40:00.000] 然后如果你想要实现一个新的特性的话
[40:00.000 --> 40:04.000] 一般来说你可以先创建一个issue来讨论
[40:04.000 --> 40:08.000] 因为不太确定这个PR是否会被接受
[40:08.000 --> 40:11.000] 当然你也可以把PR直接创建出来
[40:11.000 --> 40:14.000] 这样可能会被接受的可能性更大一些
[40:14.000 --> 40:17.000] 你要做好就是这个PR会被关闭的准备
[40:17.000 --> 40:21.000] 而且这个best branch要是慢分支
[40:21.000 --> 40:25.000] 至于你想持续为Vlask提供代码的话
[40:25.000 --> 40:28.000] 最简单的就是发现问题然后解决问题
[40:28.000 --> 40:30.000] 所以说你可以关注这个项目
[40:30.000 --> 40:33.000] 就是watch这个仓库
[40:33.000 --> 40:34.000] 然后关注社区动态
[40:34.000 --> 40:37.000] 比如说和用户待在一起
[40:37.000 --> 40:41.000] 或者你开发一个和Vlask有很强依赖的项目
[40:41.000 --> 40:42.000] 或者是做一个竞品
[40:42.000 --> 40:45.000] 这样你就会非常关注Vlask的内部设计
[40:45.000 --> 40:48.000] 以及它的行为是否符合预期
[40:48.000 --> 40:51.000] 所以很容易做出一个这样的贡献出来
[40:51.000 --> 40:54.000] 好的谢谢
[40:54.000 --> 40:55.000] 行
[40:55.000 --> 41:03.000] 我们聊完了开源贡献以及社区相关的一些话题
[41:03.000 --> 41:06.000] 接下来就是聊一下本期另外一个重点话题
[41:06.000 --> 41:08.000] 就是Vlask 2.0
[41:08.000 --> 41:13.000] 众所周知Vlask刚刚发布了另外一个大版本2.0
[41:13.000 --> 41:18.000] 众所周知1.0到2.0肯定是一个跨越性的版本
[41:18.000 --> 41:22.000] 我看change log也是非常长
[41:22.000 --> 41:29.000] 还是先请李辉简单介绍一下Vlask 2.0的一些主要新特性
[41:29.000 --> 41:32.000] 或者是一些改善
[41:32.000 --> 41:36.000] Vlask 2.0其实有很多change log
[41:36.000 --> 41:39.000] 其实我之前写文章介绍过
[41:39.000 --> 41:43.000] 所以我这里可能就介绍几个比较主要的新特性
[41:43.000 --> 41:45.000] 比如说嵌套蓝本
[41:45.000 --> 41:50.000] 就是说你可以用蓝本来把程序模块化
[41:50.000 --> 41:55.000] 然后现在你可以在蓝本之中再创建一些新的蓝本
[41:55.000 --> 41:58.000] 就是可以无限的嵌套下去
[41:58.000 --> 42:04.000] 这样就可以给那些非常大的程序做一些非常深度的模块化处理
[42:04.000 --> 42:07.000] 之前是你的模块必须是扁平的
[42:07.000 --> 42:10.000] 就比如说有一个用户模块
[42:10.000 --> 42:13.000] 用户里面假如说有一个全线模块的话
[42:13.000 --> 42:15.000] 就不能在用户模块里面
[42:15.000 --> 42:21.000] 对你只能有一层蓝本或者说蓝图吧
[42:21.000 --> 42:24.000] 那个蓝图在Vlask里是指什么
[42:24.000 --> 42:26.000] Blueprint
[42:26.000 --> 42:30.000] 就它在Vlask里面是指的一个什么意思
[42:30.000 --> 42:33.000] 就相当于是一个子程序的概念
[42:33.000 --> 42:36.000] 类比Django的APP
[42:36.000 --> 42:40.000] APP也是不能嵌套
[42:40.000 --> 42:43.000] 那它只是程序的一个嵌套
[42:43.000 --> 42:45.000] 那就是说你写代码
[42:45.000 --> 42:47.000] 就比如说那些.py文件的话
[42:47.000 --> 42:49.000] 也是可以嵌套的
[42:49.000 --> 42:50.000] 对吧
[42:50.000 --> 42:51.000] 这个应该没有问题
[42:51.000 --> 42:54.000] 对文件组织你可以没有什么限定
[42:54.000 --> 42:57.000] 对这个地方我其实有一个疑问
[42:57.000 --> 43:03.000] 就是我看了那个叫什么升级的日志
[43:03.000 --> 43:06.000] 然后我搞不太懂它这种嵌套蓝本
[43:06.000 --> 43:08.000] 它要解决的一个本质问题是什么
[43:08.000 --> 43:12.000] 就这样无限拆分这个东西的话
[43:12.000 --> 43:16.000] 它有什么具体的一个应用场景吗
[43:16.000 --> 43:18.000] 应用场景大概就是
[43:18.000 --> 43:19.000] 就是说很大的项目
[43:19.000 --> 43:22.000] 你可以再做深进一步的拆分
[43:22.000 --> 43:25.000] 就比如说你有一个程序
[43:25.000 --> 43:29.000] 分成了前端前台后台这样两个蓝本
[43:29.000 --> 43:32.000] 然后你在前台里面可能又会有用户界面
[43:32.000 --> 43:35.000] 或者说后台就是其他的界面这样的东西
[43:35.000 --> 43:39.000] 就可以都可以分区分开了
[43:39.000 --> 43:41.000] 我能理解
[43:41.000 --> 43:46.000] 因为你像在大公司里面遇到的项目规模都是很大的
[43:46.000 --> 43:49.000] 就是我可以想象这个
[43:49.000 --> 43:53.000] 如果发展到一定程度是会需要这样的东西
[43:53.000 --> 43:57.000] 那它这个东西一旦达到这种体
[43:57.000 --> 43:59.000] 就是叫怎么说
[43:59.000 --> 44:01.000] 一旦达到这种体系的话
[44:01.000 --> 44:05.000] 直接把它给拆分成两个新的Flask应用不行吗
[44:05.000 --> 44:07.000] 新的Flask应用也是可以的
[44:07.000 --> 44:11.000] 但是这蓝本的好处就是在同一个程序内
[44:11.000 --> 44:15.000] 你可以就是共享或者说去互相去引用
[44:15.000 --> 44:21.000] 比如说你想从某一个页面跳转到另一个蓝本
[44:21.000 --> 44:23.000] 然后那个里面的一个页面
[44:23.000 --> 44:30.000] 你可以直接在这个蓝本里面去写一个函数来生成到那个蓝本的URL
[44:30.000 --> 44:33.000] 还有些好处就是你在同一个程序内
[44:33.000 --> 44:36.000] 不同的蓝本可以共享很多信息
[44:36.000 --> 44:38.000] 比如说程序的配置了
[44:38.000 --> 44:40.000] 好像跟那个async
[44:40.000 --> 44:46.000] 就是ASGI里面的那个application有点像
[44:46.000 --> 44:48.000] ASGI里面就是application
[44:48.000 --> 44:51.000] 全都是一套一层一层的
[44:51.000 --> 44:54.000] 就是相同的一个application
[44:54.000 --> 44:56.000] 但是它就是用的比较多
[44:56.000 --> 45:00.000] 蓝本应该在一个app里面会比较少
[45:00.000 --> 45:02.000] 算来几个吧
[45:04.000 --> 45:07.000] 然后另一个比较大的改动
[45:07.000 --> 45:10.000] 就是添加了一个比较有限的async支持
[45:10.000 --> 45:13.000] 它为什么叫limited
[45:13.000 --> 45:18.000] 因为它不是一个完整的基于ASGI
[45:18.000 --> 45:20.000] 就ASGI的这样一个实现
[45:20.000 --> 45:23.000] 而是说是一个折中的一个方案
[45:23.000 --> 45:27.000] 就是说它是基于ASGI ref
[45:27.000 --> 45:32.000] 就是django做ASGI支持的那个库来做一个转换
[45:32.000 --> 45:35.000] 这样就可以实现向后限容
[45:35.000 --> 45:37.000] 比如说你一个试图函数
[45:37.000 --> 45:39.000] 它在内部可以做一个判断
[45:39.000 --> 45:42.000] 就比如说你是一个普通的试图函数
[45:42.000 --> 45:44.000] 它就直接把这个返回去
[45:44.000 --> 45:46.000] 就直接调用然后返回了
[45:46.000 --> 45:49.000] 但如果是一个就是协程的话
[45:49.000 --> 45:52.000] 那它可能会做进一步的去做转换处理
[45:52.000 --> 45:54.000] 然后额外以后再返回
[45:54.000 --> 46:00.000] 所以它本质上还是一个同步的应用对吧
[46:00.000 --> 46:02.000] 就是说反正这个应用部署的时候
[46:02.000 --> 46:06.000] 还是要用WSGI类似的服务器来部署它
[46:06.000 --> 46:08.000] 可以用ASGI服务器部署
[46:08.000 --> 46:11.000] 但是你要用ASGI ref提供的中间键
[46:11.000 --> 46:12.000] 来做一个转换
[46:12.000 --> 46:16.000] 但是就是那他是怎么实现判断
[46:16.000 --> 46:19.000] 如果是同步的就用同步的序调
[46:19.000 --> 46:21.000] 判断异步的是在用异步的呢
[46:21.000 --> 46:23.000] 他很简单
[46:23.000 --> 46:26.000] 他就用那个inspect的那个
[46:26.000 --> 46:28.000] isCoreCorrecting的那个function
[46:28.000 --> 46:30.000] 那个判断来做
[46:30.000 --> 46:32.000] 性能会有损失
[46:32.000 --> 46:37.000] 当然他只能说你可以用async这些语法
[46:37.000 --> 46:40.000] 当然他提供的性能也是相对于同步是有提升
[46:40.000 --> 46:46.000] 但可能是相对于完全基于ASGI的要稀少很多
[46:46.000 --> 46:50.000] 他当然是我们是想把它作为一个过渡阶段
[46:50.000 --> 46:55.000] 因为你像Django他有一个就是有一个庞大的团队
[46:55.000 --> 46:56.000] 然后有一个基金会支持
[46:56.000 --> 46:59.000] 他可以有很大的投入很大的人力来做这个
[46:59.000 --> 47:02.000] 就很容易做一个比较完美的解决方案
[47:02.000 --> 47:08.000] 但因为Flask目前这个async支持只是由Phil这一个人来完成了
[47:08.000 --> 47:11.000] 所以只能临时做一个这样一个折衷方案
[47:11.000 --> 47:17.000] 而且完全的ASGI支持可能是要在ZankSorg里面做到
[47:17.000 --> 47:21.000] 但因为ZankSorg是一个主要是基于Whiskey做的一个东西嘛
[47:21.000 --> 47:25.000] 所以要做这样的兼容和转换需要费很大的劲
[47:25.000 --> 47:27.000] 而同时Flask也提供了一个
[47:27.000 --> 47:28.000] 等于说替代选项嘛
[47:28.000 --> 47:31.000] 就是Quart
[47:31.000 --> 47:35.000] Quart就是一个完全异步的Flask的实现
[47:35.000 --> 47:38.000] 它和Flask的API完全保持一致
[47:38.000 --> 47:41.000] 所以说如果你对异步的需求比较小
[47:41.000 --> 47:47.000] 可能你只是就是写一些很少的地方需要用到async
[47:47.000 --> 47:49.000] 那你可以用现在的Flask
[47:49.000 --> 47:53.000] 如果你就是几乎所有的使用场景都是在async下面
[47:53.000 --> 47:55.000] 那你可以用Quart
[47:55.000 --> 48:01.000] 这个Quart它主要提供的优势是什么呀
[48:01.000 --> 48:03.000] 因为我之前不太了解这个
[48:03.000 --> 48:08.000] 优势它就是一个完整的基于ASCII的Flask实现
[48:08.000 --> 48:16.000] 我其实还比较喜欢现在的这种过渡实现
[48:16.000 --> 48:25.000] 因为我其实前段时间用ASGI比较多嘛
[48:25.000 --> 48:30.000] 对然后我会觉得遇到一些很麻烦的事情
[48:30.000 --> 48:35.000] 就是我会觉得就是这个模型抽象的会让很多web开发者很难受
[48:35.000 --> 48:39.000] 对然后我展开讲一个事情
[48:39.000 --> 48:42.000] 就是其实ASGI它的设计
[48:42.000 --> 48:45.000] 我会觉得ASGI的设计没什么问题
[48:45.000 --> 48:48.000] 但是基于ASGI这套的web框架
[48:48.000 --> 48:51.000] 他们的抽象层有些诡异
[48:51.000 --> 48:55.000] 就ASGI它其实是我整个的这种
[48:55.000 --> 48:57.000] 进来的是一个理由嘛
[48:57.000 --> 49:03.000] 相当于是然后我把比如说我有一个request
[49:03.000 --> 49:06.000] 然后它本身是一个流
[49:06.000 --> 49:08.000] 然后我可能在需要的地方
[49:08.000 --> 49:14.000] 然后去比如说去读取一下这个流对象的信息
[49:14.000 --> 49:18.000] 就是在HTTP上如果简单的说是这样的话
[49:18.000 --> 49:22.000] 然后所有的基于ASGI的web框架
[49:22.000 --> 49:24.000] 就有一个很麻烦的事情是什么呢
[49:24.000 --> 49:28.000] 就是当我去处理一个HTTP请求的时候
[49:28.000 --> 49:30.000] 我第一步一定是先receive
[49:30.000 --> 49:34.000] 就是先去把这个流里的信息读出来
[49:34.000 --> 49:36.000] 但是目前ASINC的实现
[49:36.000 --> 49:39.000] 就会导致我之前提到的那个专业件问题
[49:39.000 --> 49:42.000] 就比如说当我的系统上有某个层面
[49:42.000 --> 49:45.000] 想要对所有的进入的request
[49:45.000 --> 49:50.000] 或response的内容做一个读取或判断的时候
[49:50.000 --> 49:51.000] 其实是做不到的
[49:51.000 --> 49:55.000] 对就是因为流的对象它不是一个密等的
[49:55.000 --> 49:59.000] 比如说我流read一次拿到一个content
[49:59.000 --> 50:01.000] 我是不能接着再去read的
[50:01.000 --> 50:04.000] 对就比如说我需要在middleware层
[50:04.000 --> 50:08.000] 比如说记录所有的request请求的详细信息
[50:08.000 --> 50:11.000] 那我在middleware的时候就要去read它
[50:11.000 --> 50:16.000] 然后对然后我read
[50:16.000 --> 50:20.000] 就相当于是之前是框架给你读了
[50:20.000 --> 50:23.000] 现在要交给你应用自己读
[50:23.000 --> 50:25.000] 对然后比如说你写middleware
[50:25.000 --> 50:26.000] 如果你这么做了
[50:26.000 --> 50:28.000] 那你所有的试图函数都read不到
[50:28.000 --> 50:30.000] 这个request的东西了
[50:30.000 --> 50:32.000] 对然后目前其实常见的
[50:32.000 --> 50:34.000] 我看web框架就两条路
[50:34.000 --> 50:36.000] 一条是说你自己
[50:36.000 --> 50:39.000] 它会提供一个root class的选项
[50:39.000 --> 50:42.000] 它跟你说这个middleware是ASGI的middleware
[50:42.000 --> 50:45.000] 虽然我是一个web framework
[50:45.000 --> 50:46.000] 我是一个web框架
[50:46.000 --> 50:50.000] 但是我的middleware还是ASGI的middleware
[50:50.000 --> 50:54.000] 对然后你可以在root class上去做操作
[50:54.000 --> 50:57.000] 然后你把这个读好的request往下传
[50:57.000 --> 50:58.000] 这是一种方式
[50:58.000 --> 51:00.000] 另外一种方式就是
[51:00.000 --> 51:02.000] 我之前可能想过说你自己hack
[51:02.000 --> 51:05.000] 就是你把这个留的对象给代理一下
[51:05.000 --> 51:06.000] 你中间读出来之后
[51:06.000 --> 51:09.000] 同时塞到一个类似于pack这种东西
[51:09.000 --> 51:14.000] 然后再把这个pack这个东西hack回原来的request里
[51:14.000 --> 51:16.000] 保证你的试团说是没问题的
[51:16.000 --> 51:22.000] 对但是我会觉得这可能是一种抽象上的不必要
[51:22.000 --> 51:26.000] 对会给开发者造成一些麻烦
[51:26.000 --> 51:28.000] 你刚才说你比较喜欢它
[51:28.000 --> 51:30.000] 现在的实现方式呢
[51:30.000 --> 51:33.000] 它就是是已经帮你refill好了吗
[51:33.000 --> 51:35.000] 我没具体了解
[51:35.000 --> 51:37.000] 但是我刚刚看了一下它那个blog
[51:37.000 --> 51:38.000] 它有个case
[51:38.000 --> 51:41.000] 就是它还是直接使用原来的这种
[51:41.000 --> 51:44.000] 就是说request.get啊
[51:44.000 --> 51:46.000] 对这种
[51:46.000 --> 51:48.000] 我们先来说一下
[51:48.000 --> 51:52.000] 就是我们要介绍的最后一个flask的新特性
[51:52.000 --> 51:55.000] 就是添加了一些快捷路由装饰器
[51:55.000 --> 51:58.000] 就是你之前可能会写app.route
[51:58.000 --> 52:01.000] 然后加一个method关键字来指定
[52:01.000 --> 52:04.000] 它要接受哪一个http方法
[52:04.000 --> 52:06.000] 比如说加一个post
[52:06.000 --> 52:09.000] 然后现在你可以直接写app.post
[52:09.000 --> 52:11.000] 或app.get
[52:11.000 --> 52:13.000] 然后这些方法现在就有了
[52:13.000 --> 52:16.000] 其实flask在那个test client
[52:16.000 --> 52:18.000] 就是做测试的那客户端里面
[52:18.000 --> 52:21.000] 之前很早就有这几个方法
[52:21.000 --> 52:26.000] 但是一直没有支持用到试图函数上面
[52:26.000 --> 52:28.000] 所以这个特性
[52:28.000 --> 52:30.000] 这个特性其实本来是应该是我来加上的
[52:30.000 --> 52:33.000] 这可能只是一个很简单的东西
[52:33.000 --> 52:35.000] 然后在一次会议上
[52:35.000 --> 52:38.000] PALS会议上我就提出了想加这个东西嘛
[52:38.000 --> 52:41.000] 因为现在flask的app很流行
[52:41.000 --> 52:46.000] 然后既然其他框架可以抄我们的
[52:46.000 --> 52:48.000] 就是借鉴吧
[52:48.000 --> 52:50.000] 用那个装饰器来做路由
[52:50.000 --> 52:52.000] 那我们为什么不能抄回来呢
[52:52.000 --> 52:53.000] 就加一个
[52:53.000 --> 52:56.000] 只是加一层语法堂包装而已
[52:56.000 --> 52:58.000] 然后就被回绝了嘛
[52:58.000 --> 53:02.000] David觉得这就是一个不必要的抽象
[53:02.000 --> 53:05.000] 然后增加了就是app的负担
[53:05.000 --> 53:08.000] 可能新用户会觉得我应该用哪一个呢
[53:08.000 --> 53:11.000] 应该用app.get还是app.root
[53:11.000 --> 53:13.000] 他们可能会产生一些困惑
[53:13.000 --> 53:14.000] 因为其实我当时
[53:14.000 --> 53:17.000] 我当时有很多想要反驳的点
[53:17.000 --> 53:19.000] 但是因为我英语问题嘛
[53:19.000 --> 53:23.000] 我说到最后说出来就只是OK I see
[53:23.000 --> 53:26.000] 最后就没有去做这个东西
[53:26.000 --> 53:27.000] 但后来过了一段时间
[53:27.000 --> 53:29.000] 另一个成员就是Phil
[53:29.000 --> 53:31.000] 他直接提了一个PR
[53:31.000 --> 53:33.000] 然后做了一些解释
[53:33.000 --> 53:34.000] 后来开了一次会
[53:34.000 --> 53:36.000] 然后又做了些讨论
[53:36.000 --> 53:38.000] 最终还是被合并了
[53:38.000 --> 53:40.000] 还是加了进去
[53:40.000 --> 53:45.000] 我特别喜欢这个feature
[53:45.000 --> 53:47.000] 我觉得这个很方便
[53:47.000 --> 53:50.000] 因为节省了你打很多东西出来
[53:50.000 --> 53:54.000] 我喜欢这个feature可能是另外一个角度
[53:54.000 --> 53:56.000] 我可以举个例子
[53:56.000 --> 54:01.000] 就是我不太喜欢那个UIL prefix
[54:01.000 --> 54:03.000] 就是它过于隐视
[54:03.000 --> 54:06.000] 就比如说当我看到一个
[54:06.000 --> 54:09.000] 比如说我看到一个blueprint root
[54:09.000 --> 54:11.000] 然后就是它注册的时候
[54:11.000 --> 54:14.000] 它看到的这个UIL path
[54:14.000 --> 54:16.000] 可能它不是真正的UIL path
[54:16.000 --> 54:20.000] 对就是我看一个视图函数
[54:20.000 --> 54:22.000] 它的path其实是它的prefix
[54:22.000 --> 54:24.000] 加上它的path
[54:24.000 --> 54:26.000] 当你的项目变得特别大的时候
[54:26.000 --> 54:29.000] 你可能就会比较混乱
[54:29.000 --> 54:33.000] 这只是我过去维护的一些经验
[54:33.000 --> 54:38.000] 然后可能会改善这种情况的一个方法
[54:38.000 --> 54:40.000] 可能就是在注册的时候
[54:40.000 --> 54:42.000] 统一给他们加prefix
[54:42.000 --> 54:44.000] 因为你在实例化一个蓝本的时候
[54:44.000 --> 54:46.000] 也是可以加prefix
[54:46.000 --> 54:49.000] 但如果你在统一的注册的地方
[54:49.000 --> 54:51.000] 因为所有蓝本都在一起注册
[54:51.000 --> 54:54.000] 这个时候你加prefix可能会更清晰一点
[54:54.000 --> 54:56.000] 有可能
[54:56.000 --> 55:02.000] 我之前维护一个大型的python项目的时候
[55:02.000 --> 55:04.000] 比如说会有同学跟我说
[55:04.000 --> 55:06.000] 这个UIL我怎么搜不到
[55:06.000 --> 55:09.000] 或者是我搜了一部分
[55:09.000 --> 55:10.000] 我发现我改错了
[55:10.000 --> 55:12.000] 因为prefix不一样
[55:12.000 --> 55:14.000] 对
[55:14.000 --> 55:16.000] 就是他可能要自己有个映射
[55:16.000 --> 55:18.000] 能去找到对应的
[55:18.000 --> 55:22.000] 张工好像可以把所有的prefix
[55:22.000 --> 55:24.000] 对应的那个给你列出来
[55:24.000 --> 55:28.000] 我感觉写一个插件类似的东西应该能做到
[55:28.000 --> 55:32.000] flask有一个内置的flask root
[55:32.000 --> 55:35.000] 是可以把所有的路由列出来的
[55:35.000 --> 55:39.000] 所以结论还是应该先创建一个pr
[55:39.000 --> 55:41.000] 再去提feature request
[55:41.000 --> 55:43.000] 对
[55:43.000 --> 55:48.000] 然后后来我就觉得可能下次就直接先提条pr吧
[55:48.000 --> 55:52.000] 因为我觉得好像就是每次我提出来一些事情
[55:52.000 --> 55:54.000] 虽然可能当时被拒绝了
[55:54.000 --> 55:57.000] 但最终还是会按照我的说法来做
[55:57.000 --> 55:59.000] 比如说我想
[55:59.000 --> 56:02.000] 我觉得我们应该把那个kitab上的discussion
[56:02.000 --> 56:03.000] 把那个打开
[56:03.000 --> 56:08.000] 然后因为之前很多用户可能就用那个issue tracker来提问
[56:08.000 --> 56:10.000] 提问之后我们都会跟他说
[56:10.000 --> 56:12.000] 请你到stackoverflow上去问
[56:12.000 --> 56:13.000] 然后就关掉了
[56:13.000 --> 56:17.000] 我觉得这就是不是很用户友好的一种做法
[56:17.000 --> 56:19.000] 假如我们开了那个discussion
[56:19.000 --> 56:22.000] 就可以把这个issue给transfer转换过去
[56:22.000 --> 56:24.000] 然后当时也被拒绝了
[56:24.000 --> 56:31.000] 然后因为他们说可能就是会引起太多不必要的讨论
[56:31.000 --> 56:35.000] 就是而且每个watcher可能他会被提醒
[56:35.000 --> 56:37.000] 如果他没有去自定义设置的话
[56:37.000 --> 56:38.000] 如果讨论太多
[56:38.000 --> 56:42.000] 可能就会让他的kitab的通知变很乱
[56:42.000 --> 56:45.000] 然后最近那个打开了
[56:45.000 --> 56:46.000] 最近也打开了
[56:46.000 --> 56:56.000] 是可能也是就是要要有一定话语权
[56:56.000 --> 56:59.000] 他们才会重更重视你的意见
[56:59.000 --> 57:03.000] 我觉得不是是英语要学好才行
[57:03.000 --> 57:07.000] 那你们讨论一般难道不都是写邮件吗
[57:07.000 --> 57:09.000] 就是也也也有开会
[57:09.000 --> 57:12.000] 每个月都会有一次约会
[57:12.000 --> 57:17.000] 然后我们加了这个功能以后
[57:17.000 --> 57:20.000] 就是第一次在reddit上面去分享
[57:20.000 --> 57:23.000] 就是发了那个pre-release版本
[57:23.000 --> 57:27.000] 结果下面就有一大批fastAPI用户
[57:27.000 --> 57:28.000] 然后跳出来
[57:28.000 --> 57:32.000] 然后因为他可能在语法上就是非常接近
[57:32.000 --> 57:35.000] 因为fastAPI之前他也是路由装置器
[57:35.000 --> 57:39.000] 然后也用这些app.get app.post这些东西
[57:39.000 --> 57:45.000] 然后还有很多人会来问flask会支持请求的自动验证吗
[57:45.000 --> 57:47.000] 会不会支持openAPI什么这些东西
[57:47.000 --> 57:49.000] 就是fastAPI有的功能
[57:49.000 --> 57:50.000] 他都会过来问
[57:50.000 --> 57:52.000] 就导致那个reddit讨论下面
[57:52.000 --> 57:56.000] 好多好多就和fastAPI相关的东西
[57:56.000 --> 58:00.000] 让我们就就感觉很无奈
[58:00.000 --> 58:02.000] 因为他们两个毕竟
[58:02.000 --> 58:05.000] 我在那个文章里面基本上已经说了很多了
[58:05.000 --> 58:07.000] 他们他们是一个
[58:07.000 --> 58:10.000] 不同等级或说不同面向
[58:10.000 --> 58:13.000] focus在不同的领域的一个框架
[58:13.000 --> 58:14.000] 如果这样比较的话
[58:14.000 --> 58:17.000] 其实不是很公平
[58:17.000 --> 58:19.000] 你要不简单再介绍一下你那篇文章
[58:19.000 --> 58:22.000] 虽然我看过
[58:22.000 --> 58:23.000] 可以
[58:23.000 --> 58:28.000] 就是说flask是一个通用型框架
[58:28.000 --> 58:32.000] 然后stylator也是一个通用型框架
[58:32.000 --> 58:36.000] 结果有一个人用stylator加了些包装
[58:36.000 --> 58:39.000] 给他改了一个名字叫做fastAPI
[58:39.000 --> 58:41.000] 结果吸引过来很大一批人
[58:41.000 --> 58:44.000] 他们可能就非常热衷于这个东西
[58:44.000 --> 58:48.000] 他们就拿fastAPI去和flask做比较
[58:48.000 --> 58:52.000] 比如说就是fastAPI有很多flask没有的功能
[58:52.000 --> 58:55.000] 让他们就觉得他们是一个同等的框架
[58:55.000 --> 58:59.000] 但其实fastAPI是在stylator之上的一个框架
[58:59.000 --> 59:04.000] 所以这种这种比较是不对等的
[59:04.000 --> 59:09.000] 我感觉好像你那篇文章也发出来之后
[59:09.000 --> 59:11.000] 也有一些评论
[59:11.000 --> 59:16.000] 可能质疑你这样一定要对等的比较
[59:16.000 --> 59:18.000] 是不是有意义
[59:18.000 --> 59:19.000] 怎么说呢
[59:19.000 --> 59:21.000] 我其实还是蛮能理解
[59:21.000 --> 59:23.000] 因为你确实从用户角度来讲
[59:23.000 --> 59:27.000] 他们就可能有的用户都不知道stylator是什么
[59:27.000 --> 59:30.000] 反正你用的是fastAPI
[59:30.000 --> 59:32.000] 然后用的是flask
[59:32.000 --> 59:39.000] 对就是可能也不能太责怪大家把这两个比较吧
[59:39.000 --> 59:40.000] 我觉得
[59:40.000 --> 59:43.000] 对我其实也没有去责怪或者怎么样
[59:43.000 --> 59:48.000] 我只是想更多的写给就是喜欢拿出来比较的人
[59:48.000 --> 59:50.000] 因为很多喜欢写文章的人
[59:50.000 --> 59:52.000] 他们可能为了更吸引人
[59:52.000 --> 59:54.000] 然后就把这两个东西拎出来
[59:54.000 --> 59:58.000] 包括可能在中国更多的是在公众号上面
[59:58.000 --> 01:00:01.000] 在英文可能就是medium上面
[01:00:01.000 --> 01:00:03.000] 就很多这样的人
[01:00:03.000 --> 01:00:04.000] 嗯
[01:00:04.000 --> 01:00:06.000] 它到底是个什么东西
[01:00:06.000 --> 01:00:09.000] 也是一个也算是一个框架是吧
[01:00:09.000 --> 01:00:11.000] 它是一个API框架
[01:00:11.000 --> 01:00:13.000] 就是专注于写API嘛
[01:00:13.000 --> 01:00:16.000] 然后他把他基于一个通用性框架
[01:00:16.000 --> 01:00:18.000] 然后添加了请求验证
[01:00:18.000 --> 01:00:20.000] 是基于pydentic来做
[01:00:20.000 --> 01:00:23.000] 相当于是一个你说
[01:00:23.000 --> 01:00:24.000] 对
[01:00:24.000 --> 01:00:26.000] 然后添加了就是openAPI支持
[01:00:26.000 --> 01:00:30.000] 可以自动把你的所有的信息抓取过来
[01:00:30.000 --> 01:00:32.000] 就像你所有的试图函数抓取过来
[01:00:32.000 --> 01:00:34.000] 生成一个openAPI spec
[01:00:34.000 --> 01:00:35.000] 嗯
[01:00:35.000 --> 01:00:39.000] 相当于是一个基于starletter的发行板
[01:00:39.000 --> 01:00:40.000] 然后专注于API
[01:00:40.000 --> 01:00:44.000] 继承了openAPI验证了swagger这个东西
[01:00:44.000 --> 01:00:45.000] 对对对
[01:00:45.000 --> 01:00:49.000] 然后我是觉得他这个项目就是
[01:00:49.000 --> 01:00:50.000] 嗯
[01:00:50.000 --> 01:00:52.000] 我说不上讨厌吧
[01:00:52.000 --> 01:00:56.000] 就是给我一种就是很过火的宣传
[01:00:56.000 --> 01:00:57.000] 那种炒作的氛围
[01:00:57.000 --> 01:01:00.000] 所以说他的那个high performance
[01:01:00.000 --> 01:01:02.000] 其实他并没有做任何的事情
[01:01:02.000 --> 01:01:05.000] 就是他的high performance是来源于UV
[01:01:05.000 --> 01:01:07.000] 跟starletter的
[01:01:07.000 --> 01:01:08.000] 对对对
[01:01:08.000 --> 01:01:12.000] 就是他那个high performance
[01:01:12.000 --> 01:01:15.000] 那个宣传语是就是很有问题的嘛
[01:01:15.000 --> 01:01:18.000] 就是什么可以和go和nojs比较
[01:01:18.000 --> 01:01:21.000] 但其实并不能
[01:01:21.000 --> 01:01:25.000] 其实他他他英文用的是unpair
[01:01:25.000 --> 01:01:27.000] unpairwith go and
[01:01:27.000 --> 01:01:28.000] 但是呢
[01:01:28.000 --> 01:01:30.000] 这个中文他翻译成
[01:01:30.000 --> 01:01:33.000] 可以go比肩的极高性的
[01:01:33.000 --> 01:01:35.000] 因为他作者不懂中文
[01:01:35.000 --> 01:01:36.000] 我可以理解
[01:01:36.000 --> 01:01:37.000] 他英文
[01:01:37.000 --> 01:01:38.000] 但有人提出他的质疑嘛
[01:01:38.000 --> 01:01:40.000] 就说你怎么可能和go一样
[01:01:40.000 --> 01:01:41.000] 性能一样呢
[01:01:41.000 --> 01:01:43.000] 然后那个作者就出来解释了
[01:01:43.000 --> 01:01:47.000] 他他放了一个韦氏词典的链接
[01:01:47.000 --> 01:01:49.000] 说unpairof这个词的意思
[01:01:49.000 --> 01:01:51.000] 其实是comparable
[01:01:51.000 --> 01:01:52.000] 就是可比较的
[01:01:52.000 --> 01:01:56.000] 就说你我不是说把这个files API和go直接比较
[01:01:56.000 --> 01:01:59.000] 而是说go里面有很多web框架
[01:01:59.000 --> 01:02:01.000] 有一些可能比较快
[01:02:01.000 --> 01:02:02.000] 有一些比较慢
[01:02:02.000 --> 01:02:04.000] 而我的这个files API呢
[01:02:04.000 --> 01:02:06.000] 和他他那里面比较慢的一些
[01:02:06.000 --> 01:02:07.000] 是可以比较的
[01:02:07.000 --> 01:02:09.000] 可能有一些是不相上下的
[01:02:09.000 --> 01:02:11.000] 所以我就说unpairwith
[01:02:11.000 --> 01:02:13.000] 就这样用了一个unpairwith
[01:02:13.000 --> 01:02:17.000] 我我因为我用过我用过files API嘛
[01:02:17.000 --> 01:02:20.000] 就是确实是他虽然包了一层
[01:02:20.000 --> 01:02:21.000] 但是我经常要查东西
[01:02:21.000 --> 01:02:24.000] 我要去翻starlet的文档
[01:02:24.000 --> 01:02:27.000] 看一下这个东西到底有啥方法
[01:02:27.000 --> 01:02:29.000] 对然后我要咋用之类的
[01:02:29.000 --> 01:02:32.000] 对因为他其实只是包了一个
[01:02:32.000 --> 01:02:35.000] 更偏tutorial的各种指南呀
[01:02:35.000 --> 01:02:36.000] 方式呀之类的
[01:02:36.000 --> 01:02:37.000] 你真正用起来的时候
[01:02:37.000 --> 01:02:39.000] 很多时候你要去翻什么starlet
[01:02:39.000 --> 01:02:43.000] pandetic这些的文档
[01:02:43.000 --> 01:02:46.000] 这个东西比较吸引我的
[01:02:46.000 --> 01:02:49.000] 就是那个他自动生成openAPI的
[01:02:49.000 --> 01:02:52.000] 那个这个我感觉很强大
[01:02:52.000 --> 01:02:56.000] 因为之前我写API写这些都都比较头疼
[01:02:56.000 --> 01:03:01.000] 之前有个jongo-y什么的
[01:03:01.000 --> 01:03:04.000] 就yet another什么generator
[01:03:04.000 --> 01:03:07.000] 他们那些就是给你定义了很多
[01:03:07.000 --> 01:03:09.000] python的那些函数啊class啊
[01:03:09.000 --> 01:03:12.000] 用来让你生成你openAPI的specific
[01:03:12.000 --> 01:03:14.000] 结果那个超级难写
[01:03:14.000 --> 01:03:17.000] 就是你要定义好那个API的那个格式
[01:03:17.000 --> 01:03:19.000] 让starlet能正确显示出来
[01:03:19.000 --> 01:03:21.000] 你要写很多很多的代码
[01:03:21.000 --> 01:03:26.000] 你要引入很多的query params啊
[01:03:26.000 --> 01:03:29.000] 就是各种来来表达的结果
[01:03:29.000 --> 01:03:31.000] 我不知道他这个是怎么做的
[01:03:31.000 --> 01:03:32.000] 就是你直接写函数
[01:03:32.000 --> 01:03:34.000] 他就能自动帮你生成出来
[01:03:34.000 --> 01:03:37.000] 这个其实我没有去看fastAPI的代码
[01:03:37.000 --> 01:03:40.000] 但是就从flask角度来说的话
[01:03:40.000 --> 01:03:41.000] 这个其实并不复杂
[01:03:41.000 --> 01:03:46.000] 就是说比如说flask会有一个URL map
[01:03:46.000 --> 01:03:49.000] 来存储所有的这样的一些路由
[01:03:49.000 --> 01:03:52.000] 然后你对这些所有路由做一个迭代
[01:03:52.000 --> 01:03:55.000] 然后就可以获得所有的实际函数的信息
[01:03:55.000 --> 01:03:59.000] 然后把他们根据openAPI的格式来生成一个字典
[01:03:59.000 --> 01:04:02.000] 对因为我就是补充吧
[01:04:02.000 --> 01:04:04.000] 因为我用过它
[01:04:04.000 --> 01:04:07.000] 对就是它其实是引入了pandantic这个项目
[01:04:07.000 --> 01:04:12.000] 然后这个项目就是它会需要你手动显示声明
[01:04:12.000 --> 01:04:15.000] 我的model的各个字段的属性啊之类的
[01:04:15.000 --> 01:04:17.000] 我用那个typeinit来注解一下
[01:04:17.000 --> 01:04:18.000] 我有一个class
[01:04:18.000 --> 01:04:20.000] 它的属性A属性是什么类型
[01:04:20.000 --> 01:04:22.000] B属性是什么类型
[01:04:22.000 --> 01:04:24.000] 然后我在试图函数声明的时候
[01:04:24.000 --> 01:04:25.000] 我需要显示的注册
[01:04:25.000 --> 01:04:28.000] 这个试图函数接收的是什么参数
[01:04:28.000 --> 01:04:30.000] 比如说一个list的刚才那个class
[01:04:30.000 --> 01:04:31.000] 或者什么的
[01:04:31.000 --> 01:04:34.000] 然后它的response是什么model
[01:04:34.000 --> 01:04:37.000] 对就是也是刚才定义的pandantic的model
[01:04:37.000 --> 01:04:39.000] 所以说它会有类型信息
[01:04:39.000 --> 01:04:41.000] 然后它会根据你这些信息
[01:04:41.000 --> 01:04:43.000] 因为你在代码里其实显示声明了
[01:04:43.000 --> 01:04:44.000] 输入输出的model是什么
[01:04:44.000 --> 01:04:47.000] 它会自动给你生成你的model
[01:04:47.000 --> 01:04:52.000] OK那这个跟那个Jungle的rest framework没什么区别
[01:04:52.000 --> 01:04:53.000] 就是我想知道
[01:04:53.000 --> 01:04:56.000] 假如说我比如说我自己写一个试图函数
[01:04:56.000 --> 01:04:57.000] 然后拿到request
[01:04:57.000 --> 01:04:59.000] 比如说我用request.body
[01:04:59.000 --> 01:05:01.000] 然后pass成json
[01:05:01.000 --> 01:05:04.000] 或者request.queryparams
[01:05:04.000 --> 01:05:07.000] 然后从那个url里面
[01:05:07.000 --> 01:05:09.000] 在试图内部取出来一个key
[01:05:09.000 --> 01:05:11.000] 这样的话它能生成吗
[01:05:11.000 --> 01:05:12.000] 不能
[01:05:12.000 --> 01:05:17.000] 那就跟rest framework其实没有太大的区别
[01:05:17.000 --> 01:05:18.000] 对
[01:05:18.000 --> 01:05:26.000] DRF是基于OpenAPI做的文档吗
[01:05:26.000 --> 01:05:27.000] 应该不是
[01:05:27.000 --> 01:05:31.000] 它有个插件好像可以
[01:05:31.000 --> 01:05:33.000] DRF有很多选择
[01:05:33.000 --> 01:05:35.000] 它有好多插件
[01:05:35.000 --> 01:05:39.000] 但是你如果把那个serializer给声明好的话
[01:05:39.000 --> 01:05:40.000] 它有很多插件
[01:05:40.000 --> 01:05:44.000] 你把它那些插件都可以去读
[01:05:44.000 --> 01:05:46.000] 你的模型的定义
[01:05:46.000 --> 01:05:48.000] 然后给你生成一些
[01:05:48.000 --> 01:05:53.000] 我有一个看法就是关于FastAPI的
[01:05:53.000 --> 01:05:55.000] 因为我一开始选题也在用它
[01:05:55.000 --> 01:05:57.000] 但是最近在先出
[01:05:57.000 --> 01:05:58.000] 对
[01:05:58.000 --> 01:06:01.000] 因为我会觉得FastAPI它找的市场特别好
[01:06:01.000 --> 01:06:04.000] 就是其实现在主流的开发都是前后端分离的
[01:06:04.000 --> 01:06:07.000] 就是后端其实确实是面向API开发的
[01:06:07.000 --> 01:06:09.000] 就是说我的API的设计
[01:06:09.000 --> 01:06:11.000] 然后我还加逻辑
[01:06:11.000 --> 01:06:12.000] 对
[01:06:12.000 --> 01:06:14.000] 然后它其实把Starlight包了之后
[01:06:14.000 --> 01:06:16.000] 完成了一个很大的更需
[01:06:16.000 --> 01:06:18.000] 就是我把你的API开发这块
[01:06:18.000 --> 01:06:21.000] 我给你说引入Pandetic
[01:06:21.000 --> 01:06:22.000] 对
[01:06:21.000 --> 01:06:23.000] 然后自动给你生成文档
[01:06:23.000 --> 01:06:24.000] 对
[01:06:23.000 --> 01:06:25.000] 其实我当然选这个一大吸引点
[01:06:25.000 --> 01:06:26.000] 也是说它自动生成文档
[01:06:26.000 --> 01:06:27.000] 因为写文档其实很麻烦
[01:06:27.000 --> 01:06:30.000] 而且还要和代码同步更新
[01:06:30.000 --> 01:06:31.000] 对
[01:06:30.000 --> 01:06:37.000] 然后所以它可能会需求群体比较庞大
[01:06:37.000 --> 01:06:38.000] 对
[01:06:38.000 --> 01:06:41.000] 很多人确实需要一个我能开箱机用的
[01:06:41.000 --> 01:06:43.000] 面向API开发的这么一个东西
[01:06:44.000 --> 01:06:47.000] 但是我用下来我会觉得限制还蛮多的
[01:06:47.000 --> 01:06:50.000] 然后我就自己再往外进
[01:06:50.000 --> 01:06:52.000] 具体是什么限制呢
[01:06:52.000 --> 01:06:53.000] 就是我刚才提到
[01:06:53.000 --> 01:06:55.000] 比如说它的Middleware很麻烦
[01:06:55.000 --> 01:06:57.000] 其实对
[01:06:57.000 --> 01:07:00.000] 然后以及说它的文档
[01:07:00.000 --> 01:07:05.000] 然后需要我去各种翻Pandetic
[01:07:05.000 --> 01:07:07.000] 或者是Starlight
[01:07:07.000 --> 01:07:08.000] 其实也还好
[01:07:08.000 --> 01:07:09.000] 但是还是有成本的
[01:07:09.000 --> 01:07:12.000] 然后再就是我觉得还有一个不是它的问题
[01:07:12.000 --> 01:07:15.000] 就是Async
[01:07:15.000 --> 01:07:17.000] 就如果采用纯Async
[01:07:17.000 --> 01:07:20.000] 就是其实我会觉得Starlight
[01:07:20.000 --> 01:07:21.000] Starlight它对
[01:07:23.000 --> 01:07:26.000] 就是HTTP这个分层的抽象做的还是不太好
[01:07:26.000 --> 01:07:29.000] 就会导致它是一个纯Async开发的模型
[01:07:30.000 --> 01:07:32.000] 就导致我开发过程中会有很多麻烦
[01:07:32.000 --> 01:07:36.000] 就这个麻烦主要还是说生态不够好
[01:07:37.000 --> 01:07:39.000] 对我选用各种第三方库的时候
[01:07:39.000 --> 01:07:41.000] 我发现那些第三方库都有问题
[01:07:41.000 --> 01:07:42.000] 然后我给两个
[01:07:42.000 --> 01:07:44.000] 我一共选了三个第三方库
[01:07:44.000 --> 01:07:45.000] 其中有俩有问题
[01:07:45.000 --> 01:07:46.000] 我去给他们TPR
[01:07:46.000 --> 01:07:49.000] 结果我主要的精力不在我自己的项目开发里
[01:07:50.000 --> 01:07:52.000] 在于说我先自己搞一个内部的库
[01:07:52.000 --> 01:07:55.000] 然后用同时给他们去TPR
[01:07:55.000 --> 01:07:57.000] 然后想办法让他们合
[01:07:58.000 --> 01:07:59.000] 对然后我会觉得
[01:07:59.000 --> 01:08:05.000] 是所以因为这种这种对比不是很公平吗
[01:08:05.000 --> 01:08:08.000] 然后我就就做了一个API Flask
[01:08:08.000 --> 01:08:11.000] 它基本上可以说是跟FastAPI
[01:08:11.000 --> 01:08:15.000] 基本功能相同的一个框架
[01:08:15.000 --> 01:08:19.000] 但也是基于Flask做了另一层包装
[01:08:19.000 --> 01:08:21.000] 相当于它基于Starlight做的包装
[01:08:23.000 --> 01:08:25.000] 然后像文档自动生成了
[01:08:25.000 --> 01:08:27.000] 请求自动验证了
[01:08:27.000 --> 01:08:29.000] 这些基本上都可以做了
[01:08:30.000 --> 01:08:33.000] 但我感觉就是FastAPI成功
[01:08:33.000 --> 01:08:35.000] 还有一个原因就是它起了一个好名字
[01:08:39.000 --> 01:08:41.000] 然后你已经没有办法占用这个名字
[01:08:41.000 --> 01:08:43.000] 所以就API Flask
[01:08:43.000 --> 01:08:45.000] 然后Flask是什么东西
[01:08:47.000 --> 01:08:49.000] 对我觉得本来可能EasyAPI
[01:08:49.000 --> 01:08:52.000] 可能是另一个更没有文化
[01:08:52.000 --> 01:08:53.000] 然后更好的名字
[01:08:53.000 --> 01:08:55.000] 但是其实被占用了
[01:08:55.000 --> 01:09:00.000] 所以然后其实说到一个更大的问题
[01:09:00.000 --> 01:09:04.000] 就是我其实最近有读了两篇文章
[01:09:04.000 --> 01:09:08.000] 就是质疑async本身是不是有意义
[01:09:08.000 --> 01:09:13.000] 就是反正那篇文章
[01:09:13.000 --> 01:09:15.000] 以及他引用那篇文章的结论
[01:09:15.000 --> 01:09:20.000] 其实可能sync反而是更快的
[01:09:20.000 --> 01:09:22.000] 我觉得有一篇你们可能看过
[01:09:22.000 --> 01:09:26.000] 就是那个什么12 requests那个东西
[01:09:26.000 --> 01:09:29.000] async配置是not faster是吧
[01:09:29.000 --> 01:09:31.000] 对他还提到另外一篇
[01:09:31.000 --> 01:09:34.000] 就是一个async的
[01:09:34.000 --> 01:09:36.000] 就是他用async搭的框架
[01:09:36.000 --> 01:09:39.000] 然后只能每秒serve12个请求
[01:09:39.000 --> 01:09:41.000] 在实际的场景下
[01:09:42.000 --> 01:09:45.000] 对反正他结论可能就是说
[01:09:45.000 --> 01:09:47.000] 你就多核多线程
[01:09:47.000 --> 01:09:49.000] 然后可能其实更快
[01:09:49.000 --> 01:09:52.000] 对然后我感觉
[01:09:52.000 --> 01:09:54.000] 对我感觉说的挺对的
[01:09:54.000 --> 01:09:56.000] 尤其他里面提到一个特别有
[01:09:56.000 --> 01:09:58.000] 特别make sense的点
[01:09:58.000 --> 01:10:02.000] 就是说现在那些很多的benchmark
[01:10:02.000 --> 01:10:05.000] 对比async和非async框架
[01:10:05.000 --> 01:10:07.000] 但是那个benchmark本身是有问题的
[01:10:07.000 --> 01:10:09.000] 首先他可能不是真实场景
[01:10:09.000 --> 01:10:10.000] 他就是一个hello world
[01:10:10.000 --> 01:10:13.000] 其次他可能就是他发现
[01:10:13.000 --> 01:10:15.000] 很多这种benchmark里面
[01:10:15.000 --> 01:10:17.000] 那个同步框架
[01:10:17.000 --> 01:10:20.000] 他都只用了单核单线程
[01:10:20.000 --> 01:10:22.000] 那你肯定就不行了对吧
[01:10:22.000 --> 01:10:25.000] 这个就肯定是这个对比就很不公平
[01:10:25.000 --> 01:10:27.000] 所以我觉得反正那两篇文章
[01:10:27.000 --> 01:10:29.000] 我也会链接在shownotes里面
[01:10:29.000 --> 01:10:32.000] 可以就是听众们也可以看一看
[01:10:32.000 --> 01:10:34.000] 就有点无关的
[01:10:34.000 --> 01:10:36.000] 反正就是突然想到了
[01:10:36.000 --> 01:10:40.000] 我越来越在加强这种倾向
[01:10:41.000 --> 01:10:43.000] 但是之后可以再看
[01:10:43.000 --> 01:10:48.000] 是ok那关于flask2.0
[01:10:48.000 --> 01:10:50.000] 你觉得还有什么要聊的吗
[01:10:50.000 --> 01:10:54.000] 其他功能可能有很多可以拿出来说了
[01:10:54.000 --> 01:10:56.000] 但是时间有限
[01:10:56.000 --> 01:10:58.000] 我们就只谈这三个功能
[01:10:58.000 --> 01:11:00.000] 因为我想其实收集一下
[01:11:00.000 --> 01:11:03.000] 你们觉得flask有什么问题吗
[01:11:03.000 --> 01:11:05.000] 但不确定你们有没有
[01:11:05.000 --> 01:11:07.000] 就是平时用的不是很多
[01:11:07.000 --> 01:11:10.000] 可能不会有太多的想法
[01:11:10.000 --> 01:11:12.000] 我提一个吧
[01:11:12.000 --> 01:11:14.000] 因为我最近在用
[01:11:14.000 --> 01:11:16.000] 我觉得其实也是之前说的
[01:11:16.000 --> 01:11:20.000] 其实对我来说flask找extension是一个
[01:11:21.000 --> 01:11:22.000] 比较难的问题
[01:11:22.000 --> 01:11:24.000] 就比如说如果我选jungle
[01:11:24.000 --> 01:11:28.000] 我其实可以省略很多调研阶段
[01:11:28.000 --> 01:11:30.000] 官方有我就用官方的
[01:11:30.000 --> 01:11:31.000] 这是我的态度
[01:11:31.000 --> 01:11:33.000] 但是对flask来说
[01:11:33.000 --> 01:11:36.000] 大量的东西都是我去搜
[01:11:36.000 --> 01:11:38.000] 外加best practice
[01:11:38.000 --> 01:11:40.000] 然后就是其实很少有一个说
[01:11:40.000 --> 01:11:43.000] 统一的地方推荐来减少我的决策成本
[01:11:43.000 --> 01:11:45.000] 就会导致我每次选一个东西的时候
[01:11:45.000 --> 01:11:48.000] 其实还是挺麻烦的
[01:11:48.000 --> 01:11:50.000] 因为我也担心我自己搜的不够
[01:11:50.000 --> 01:11:52.000] 对
[01:11:52.000 --> 01:11:55.000] 然后会觉得它可能对我来说是一个
[01:11:55.000 --> 01:11:57.000] 当我想去找库的时候
[01:11:57.000 --> 01:11:59.000] 是一个麻烦的点
[01:11:59.000 --> 01:12:00.000] 就是自己写肯定没啥问题
[01:12:00.000 --> 01:12:02.000] 因为它很灵活
[01:12:02.000 --> 01:12:03.000] 对
[01:12:03.000 --> 01:12:08.000] 这个问题其实我们flask community workgroup
[01:12:08.000 --> 01:12:11.000] 也有做这样一个列表
[01:12:11.000 --> 01:12:14.000] 就是flask扩展一些推荐列表
[01:12:14.000 --> 01:12:18.000] 然后palace官方也新创建了一个组织
[01:12:18.000 --> 01:12:20.000] 就是类似于一个社区组织
[01:12:20.000 --> 01:12:23.000] 然后就是来收纳一些比较核心的项目
[01:12:23.000 --> 01:12:25.000] 比如说flask SQL ACME
[01:12:25.000 --> 01:12:27.000] 是就是官方来维护的
[01:12:27.000 --> 01:12:29.000] 然后flask WTF
[01:12:29.000 --> 01:12:32.000] 最近也是合并到了WTForms
[01:12:32.000 --> 01:12:35.000] 这一切可能会稍微往好的方向
[01:12:35.000 --> 01:12:37.000] 转向了一点
[01:12:37.000 --> 01:12:40.000] 这个其实稍后我们可以做一个调查问卷
[01:12:40.000 --> 01:12:42.000] 然后放到信箱里面
[01:13:01.000 --> 01:13:03.000] 好本期捕蛇者说的播客就到这里
[01:13:03.000 --> 01:13:04.000] 感谢您的收听
[01:13:04.000 --> 01:13:06.000] 本期内容中提到的资料链接
[01:13:06.000 --> 01:13:08.000] 都会放到我们的网站上
[01:13:08.000 --> 01:13:11.000] 我们的网址是pythonhunter.org
[01:13:11.000 --> 01:13:13.000] 由于我们主播的知乎账号被禁
[01:13:13.000 --> 01:13:16.000] 所以以后的更新都不会再发布到知乎上
[01:13:16.000 --> 01:13:18.000] 请您留意
[01:13:18.000 --> 01:13:21.000] 推荐您使用办用型客户单订阅我们的播客
[01:13:21.000 --> 01:13:23.000] 也欢迎您关注我们的推特
[01:13:23.000 --> 01:13:24.000] 加入我们的Telegram群组
[01:13:24.000 --> 01:13:26.000] 和其他听众一起聊天
[01:13:26.000 --> 01:13:30.000] 我们的推特是pythonhunter加一个下滑线
[01:13:30.000 --> 01:13:31.000] Telegram群组的链接
[01:13:31.000 --> 01:13:33.000] 可以在我们的网站上找到
[01:13:33.000 --> 01:13:36.000] 我们下期再见
