[00:00.000 --> 00:01.540] 那我們現在開始
[00:01.540 --> 00:08.960] 請大家回复黃俊孫的 gridrewr Minecraft玩意
[00:26.360 --> 00:27.180] 請大家點讚分享
[00:27.180 --> 00:27.800] 比方今天的視頻
[00:27.800 --> 00:30.400] 欢迎来到最新一期的补收者说
[00:30.400 --> 00:35.240] 这一期我们请到了高天来聊一聊他正在做的一个
[00:35.240 --> 00:39.400] Python debugging和profiling的软件叫做Viz Tracer
[00:39.400 --> 00:44.080] 然后高天的话是我高中和大学的学长
[00:44.080 --> 00:47.040] 同时也是知乎的一名网红
[00:47.040 --> 00:48.440] 然后如果没记错的话
[00:48.440 --> 00:50.680] 没记错的话应该是有十几万的粉丝对吧
[00:50.680 --> 00:53.320] 然后我们先来请高天自我介绍一下
[00:53.320 --> 00:54.680] 大家好
[00:54.680 --> 00:55.760] 我叫高天
[00:55.760 --> 01:00.480] 然后我是Like9M的高中还有大学的学长
[01:00.480 --> 01:01.599] 比他正好高一届
[01:01.599 --> 01:03.440] 然后现在在Greenhouse工作
[01:03.440 --> 01:05.759] 我们公司做的东西说实话比较底层
[01:05.759 --> 01:06.920] 跟Python关系比较少
[01:06.920 --> 01:09.520] 然后所以我平常自己的时候
[01:09.520 --> 01:11.000] 自己一个人的时候写一写Python
[01:11.000 --> 01:13.800] 然后最近正好做了Viz Tracer
[01:13.800 --> 01:16.640] 跟Like9M他做的一个Cyberbrain的项目
[01:16.640 --> 01:17.960] 其实多少有些类似的地方
[01:17.960 --> 01:21.320] 然后可能这也是他对我这个项目稍微有点感兴趣的原因
[01:21.320 --> 01:24.440] 然后今天很高兴能给大家介绍一下这个项目
[01:24.440 --> 01:28.240] 然后带着大家了解一下这个到底是个什么东西
[01:28.240 --> 01:31.920] 然后也希望大家听过这个项目之后有机会可以去试用一下
[01:31.920 --> 01:35.200] 然后知乎算是一个业余爱好吧
[01:35.200 --> 01:36.000] 在上面答答题
[01:36.000 --> 01:38.080] 然后有一些关注者也就这样
[01:38.080 --> 01:39.000] 好谢谢高天
[01:39.000 --> 01:43.479] 然后我们的另外两位主播是小白和Adam来给大家打个招呼
[01:43.479 --> 01:44.880] 嗯哈喽大家好
[01:44.880 --> 01:45.720] 我是小白
[01:45.720 --> 01:47.320] 哈喽大家好
[01:47.320 --> 01:48.960] 哈喽大家好
[01:48.960 --> 01:49.800] 我是Adam
[01:49.800 --> 01:51.000] 好久不见
[01:51.000 --> 01:56.760] 对文老师上一期节目应该还是上一次上节目应该还是Python3那期对吧
[01:56.760 --> 02:01.240] 对的是不是录制都感觉是半年以前了
[02:01.240 --> 02:03.040] 然后还挺久的
[02:03.040 --> 02:08.199] 就是纪念了一下Python2彻底的退役
[02:08.199 --> 02:09.720] 对那应该是4月份了
[02:09.720 --> 02:12.200] 因为4月份是那个最后一个Python2
[02:12.200 --> 02:16.360] 对大概有半年没有和大家见面了
[02:16.360 --> 02:18.520] 嗯对面也很奇怪
[02:18.520 --> 02:20.000] 我们从来没有见面过
[02:20.000 --> 02:25.720] 还是见过的那个去年Python线下还是和一些听众见过
[02:25.720 --> 02:29.160] 对我是说和我们的听众可能有见过
[02:29.160 --> 02:32.480] 对然后也是欢迎文老师再次回到节目
[02:32.480 --> 02:34.920] 然后小白的话应该是来的挺多的
[02:34.920 --> 02:36.640] 给大家打个招呼吧
[02:36.640 --> 02:38.160] 哈喽大家好
[02:38.160 --> 02:39.000] 我是小白
[02:39.000 --> 02:44.640] 对然后小白最近应该是在筹划一下关于Python的一些事情对吧
[02:44.640 --> 02:49.520] 对是做一些宣讲类的一些资料准备吧
[02:49.520 --> 02:51.600] 对然后我知道你也是挺忙的
[02:51.600 --> 02:53.800] 所以还是感谢你抽出时间过来
[02:53.800 --> 02:55.880] OK然后的话
[02:55.880 --> 02:59.640] 对最后之后也会让你再介绍一下Python的情况
[02:59.640 --> 03:02.600] 对然后我们就说要聊到那个
[03:02.600 --> 03:06.360] 今天的主要话题就是一个叫做Vis Tracer的工具
[03:06.360 --> 03:13.120] Vis Tracer它的那个全拼是Viz Tracer
[03:13.120 --> 03:16.480] 就是前面应该是Visualization Tracer的意思吧
[03:16.480 --> 03:18.600] 要不高天你先解释一下这是什么意思
[03:18.600 --> 03:22.239] 对Vis Tracer就是Visualization的意思
[03:22.239 --> 03:24.239] 它本质上是一个tracing工具
[03:24.239 --> 03:26.920] 但是它跟其他很多的相对来说比较
[03:26.920 --> 03:30.600] 年龄比较大比较这个历史悠久的tracing工具不太一样的是
[03:30.600 --> 03:33.519] 它可以把它的trace的情况给visualize上
[03:33.519 --> 03:36.240] 它可以充分利用屏幕的这个二维的功能
[03:36.240 --> 03:38.920] 因为很多的command line的这个tools
[03:38.920 --> 03:40.120] 它实际上都是一维的
[03:40.120 --> 03:42.880] 它都是从上到下只有这么一个维度
[03:42.880 --> 03:47.560] 然后Vis Tracer的话它用的是Chrome的那个tracing的frontend
[03:47.560 --> 03:51.160] 然后它会把整个的这个每个process每个thread
[03:51.160 --> 03:53.800] 都可以整个的列在这个timeline上
[03:53.800 --> 03:57.200] 所以你可以同时看到不同的process不同的thread
[03:57.200 --> 03:59.800] 同一个时间段它都在发生什么
[03:59.800 --> 04:01.480] 你们大概是这个意思
[04:01.480 --> 04:06.040] 就是我觉得这样讲还是有点抽象了对吧
[04:06.040 --> 04:10.720] 然后我们其实会在那个show notes里放一个图
[04:10.720 --> 04:14.200] 就是比如说如果你想trace一个计算
[04:14.200 --> 04:16.640] Fibonacci数列的这样一个程序
[04:16.640 --> 04:21.640] 然后它就会就是给你渲染出一个这种图
[04:21.640 --> 04:25.840] 然后要不高天你来就是给听众们大致描述一下
[04:25.840 --> 04:26.840] 这个图长什么样
[04:26.840 --> 04:28.240] 然后好像大家有个概念
[04:28.240 --> 04:31.159] ok其实如果大家那个感兴趣
[04:31.159 --> 04:33.520] 如果听到这一块你觉得我好像听不太明白感兴趣的话
[04:33.520 --> 04:35.719] 大家可以去那个vis tracer的那个Github主页
[04:35.719 --> 04:37.440] 然后有一个demo的链接
[04:37.440 --> 04:41.560] 大家点进去之后会有若干个我跑的demo链接
[04:41.560 --> 04:43.479] 大家就只要有浏览器就能直接看
[04:43.479 --> 04:44.680] 不需要下载任何东西
[04:44.680 --> 04:46.880] 然后是直接是HTML格式的
[04:46.880 --> 04:54.040] 它的整个长的形状大概就是它会横向横轴
[04:54.040 --> 04:57.240] X轴是一个timeline是不同的时间点
[04:57.240 --> 05:01.400] 从零时刻一直到可能那个最后运行完的时刻
[05:01.400 --> 05:03.320] 它是一个真实的时间轴
[05:03.320 --> 05:10.360] 然后每一个thread是一个这么一个小的横向的框
[05:10.360 --> 05:13.120] 然后每一个thread里面基本上就是call stack
[05:13.120 --> 05:16.760] 就是最开始这个root是一个什么function开始call的
[05:16.760 --> 05:20.800] 然后每一个function在哪一个时间点call了另外的function
[05:20.800 --> 05:25.960] vis tracer最核心的表现内容是function entry和function exit
[05:25.960 --> 05:28.280] 就是这个函数什么时候被调用
[05:28.280 --> 05:29.720] 然后什么时候结束
[05:29.720 --> 05:34.160] 然后通过它有一个call stack这个图的感觉
[05:34.160 --> 05:39.760] 可以看到每一个函数都分别在什么时刻调用了其他的函数
[05:39.760 --> 05:44.760] 所以说如果你看一个比如说一个费布纳切数列的一个
[05:44.760 --> 05:47.560] 这个recursive implementation的话
[05:47.560 --> 05:53.719] 你就能看到这个一个函数一个费布纳切下靠了两个
[05:53.719 --> 05:55.360] 然后这两个每个又靠两个
[05:55.360 --> 05:57.159] 然后又靠两个一直到base case
[05:57.159 --> 05:58.120] 然后最后返回
[05:58.120 --> 06:03.400] 就是一个上面有很多function entry的这么一个图
[06:04.520 --> 06:05.800] 说起来确实比较抽象
[06:05.800 --> 06:08.960] 如果大家听到这的时候看一下那个demo
[06:08.960 --> 06:13.039] 应该就很容易理解到底是什么样的一个样子了
[06:15.039 --> 06:18.280] 对其实我第一眼看那个图的时候也是有点迷惑
[06:18.280 --> 06:22.840] 我不知道就是小白和Adam你们能不能看懂他那个图到底是什么意思
[06:22.840 --> 06:28.479] 因为我之前有用过一些这种类似的工具了
[06:28.479 --> 06:32.799] 对其实我目前看起来还是比较清晰的
[06:32.800 --> 06:39.200] 对就是它其实就相与我的这个调用的关系怎么深入
[06:39.200 --> 06:41.400] 以及说当我return回来之后
[06:41.400 --> 06:43.880] 我下一步从时间上会往哪转移
[06:43.880 --> 06:49.880] 对其实是一个比较方便的寻找我们所谓的时间瓶颈
[06:49.880 --> 06:50.560] 对吧
[06:50.560 --> 06:52.240] 就是它不一定是说CPU性能
[06:52.240 --> 06:54.720] 就是我可以找到一个较长的那个块
[06:54.720 --> 06:59.000] 其实通过这个图就能比较方便的找到一些瓶颈所在
[06:59.000 --> 07:02.880] 你之前用的是一个什么工具呢
[07:02.880 --> 07:09.440] 我之前用的是Uber出的一个工具叫啥来着
[07:09.440 --> 07:12.480] 我之前对PiFlame对
[07:12.480 --> 07:16.440] PiFlame这个形式会有些类似
[07:16.440 --> 07:25.080] 对它我不太确认就是你刚刚聊到这个frame graph
[07:25.080 --> 07:31.440] 就是主要是指这个图形的样式还是说
[07:31.440 --> 07:34.680] 它是一种比如说要包含的占行器也要一致吗
[07:34.680 --> 07:41.479] 是这样就是我这个Vtracer给这个图跟这个flame graph确实很像
[07:41.479 --> 07:43.400] 也就是我们平常说的火焰图
[07:43.400 --> 07:45.120] 但是他们有一个很不一样的地方
[07:45.120 --> 07:50.880] flame graph实际上是没有给出任何的函数调用的先后关系的
[07:50.880 --> 07:54.760] 它给出的是函数比如说A调用过B
[07:54.760 --> 07:56.560] 然后B调用过C
[07:56.560 --> 08:01.480] 然后它给的是一个summarize是一个总结性的信息
[08:01.480 --> 08:08.360] 就是说OK这个B在被A调用的情况下一共花了多少时间
[08:08.360 --> 08:11.080] 它可能被调用了100次可能会调用了1000次
[08:11.080 --> 08:12.920] 但是它只出现一下
[08:12.920 --> 08:16.120] 然后它的长度是它占的总时间数
[08:16.120 --> 08:19.680] 这个是flame graph非常适合用来profile
[08:19.680 --> 08:22.360] 你可以看到有一个函数很长
[08:22.360 --> 08:24.360] 就说明它占用的时间很长
[08:24.360 --> 08:30.520] 然后它能非常好的显示出来函数之间的调用关系
[08:30.520 --> 08:36.840] 但是Vtracer它给出的信息是每一个函数在什么时刻被调用过
[08:36.840 --> 08:37.800] 一个简单的例子
[08:37.800 --> 08:39.840] 比如说我只有两个函数A调用B
[08:39.840 --> 08:42.560] 有一个for loop这个A调用了100次B
[08:42.560 --> 08:44.120] 那么在flame graph上
[08:44.120 --> 08:45.200] 上面只有两个entry
[08:45.200 --> 08:47.040] 一个是A一个是B
[08:47.040 --> 08:50.880] B上那个时间就是它这100次的总时间
[08:50.880 --> 08:52.680] 而A那个时间就是B的时间
[08:52.680 --> 08:55.920] 再加上A里面一些调用的开支或者什么东西的一个时间
[08:55.920 --> 08:57.439] 但是如果是在Vtracer的话
[08:57.439 --> 08:59.000] 你看到的是一个A
[08:59.000 --> 09:01.280] 然后下面有100个B的entry
[09:01.280 --> 09:04.120] 每一个entry都是这个时刻调用了B
[09:04.120 --> 09:04.920] 然后结束了
[09:04.920 --> 09:06.400] 这个时刻调用了B结束了
[09:06.400 --> 09:09.239] 你会在A下面看到100个小框框
[09:11.079 --> 09:12.120] okok
[09:12.120 --> 09:16.239] 那可能是我刚才理解有问题
[09:16.239 --> 09:18.760] 对我可能把那个图就直接当成了火焰图
[09:18.760 --> 09:21.079] 因为我在看那个Vtracer的demo
[09:21.080 --> 09:24.040] 它确实有点像火焰图
[09:24.040 --> 09:26.320] 然后我总结一下刚才高天说的
[09:26.320 --> 09:28.960] 其实就是说火焰图的话
[09:28.960 --> 09:30.880] 你是看到某一个函数
[09:30.880 --> 09:34.680] 它在某一个函数用的总时间是多少
[09:34.680 --> 09:37.000] 就是不管它调用了多少次
[09:37.000 --> 09:42.000] 但是呢Vtracer可以让你看到每次调用花多少时间
[09:42.000 --> 09:44.200] 以及每次调用的时间的先后顺序
[09:44.200 --> 09:44.680] 对吧
[09:44.680 --> 09:46.280] 就是这么一个情况
[09:46.280 --> 09:46.960] 对
[09:46.960 --> 09:51.120] 所以说那个Vtracer展现出来的信息会更多一些
[09:51.120 --> 09:52.440] 如果是你profiling的话
[09:52.440 --> 09:53.680] 有时候火焰图会更好
[09:53.680 --> 09:55.520] 因为你看到的是一个总结性的信息
[09:55.520 --> 09:57.880] 但是Vtracer除了可以拿来profiling之外
[09:57.880 --> 10:00.280] 它还可以拿来理解这个函数
[10:00.280 --> 10:02.040] 就是这些函数哪个先运行
[10:02.040 --> 10:02.920] 哪个后运行
[10:02.920 --> 10:04.560] 哪个在哪个之前运行
[10:04.560 --> 10:06.040] 然后这一次运行的时候
[10:06.040 --> 10:07.000] 它调用了哪些函数
[10:07.000 --> 10:07.840] 下一次运行的时候
[10:07.840 --> 10:08.760] 它调用了哪些函数
[10:08.760 --> 10:14.480] 实际上你是可以看到你整个code的execution的整个过程
[10:14.480 --> 10:16.560] 就是它运行的这个过程中
[10:16.560 --> 10:18.719] 每一个时间点都运行了哪个函数
[10:18.719 --> 10:21.119] 而不仅仅是函数运行了多长时间
[10:21.119 --> 10:23.280] 对
[10:26.280 --> 10:32.119] 对我个人觉得Vtracer它的就是这种可视化的形式是非常直观的
[10:32.119 --> 10:34.079] 比火焰图更加直观一些
[10:34.079 --> 10:35.040] 对
[10:35.040 --> 10:37.760] 然后的话
[10:37.760 --> 10:42.479] 你要不要来简单介绍一下Vtracer还有哪些feature
[10:42.480 --> 10:46.680] 对Vtracer的核心的展示点
[10:46.680 --> 10:49.600] 当然是所谓的function entry exit
[10:49.600 --> 10:51.280] 然后大家可能刚开始的时候不熟悉
[10:51.280 --> 10:54.160] 但是因为我是自己公司有这么一个工具
[10:54.160 --> 10:57.000] 然后熟了之后你就会觉得这个东西其实很好用
[10:57.000 --> 10:58.280] 因为它可以帮你理解代码
[10:58.280 --> 10:59.960] 这个是最基础的功能
[10:59.960 --> 11:01.280] 然后在这基础之上
[11:01.280 --> 11:06.480] Vtracer其实还开发了很多其他的很有蛮有趣的功能
[11:06.480 --> 11:10.600] 比如说它可以产生variable的log
[11:10.600 --> 11:13.440] 然后Vtracer的很多功能
[11:13.440 --> 11:17.400] 一个比较强大的点在于它是不用你去修改你的原代码的
[11:17.400 --> 11:19.200] 就是你的原代码一笔都不用动
[11:19.200 --> 11:20.120] 就在那摆着
[11:20.120 --> 11:22.960] 你直接用Vtracer去调用你的原代码就可以了
[11:22.960 --> 11:24.880] 然后给Vtracer不同的option
[11:24.880 --> 11:26.400] 在command line上给不同的option
[11:26.400 --> 11:28.200] 它就可以有不同的功能
[11:28.200 --> 11:31.160] 我比较喜欢的一个是可以记录variable
[11:31.160 --> 11:33.680] 就是比如说我有一个variable叫a
[11:33.680 --> 11:36.320] 然后每一次这个variable被assign的时候
[11:36.320 --> 11:38.080] 它可能是在一个函数里面被assign
[11:38.080 --> 11:39.840] 它可能是在两个函数里面被assign
[11:39.840 --> 11:41.600] 它可能在很多个函数里面被assign
[11:41.600 --> 11:43.840] 每一次这个a被assign的时候
[11:43.840 --> 11:46.200] 都给你记录一下a被assign成了什么
[11:46.200 --> 11:49.000] 这个可以通过非常非常简单的事情来完成
[11:49.000 --> 11:52.320] 然后这个记录variable这件事情
[11:52.320 --> 11:54.960] 它还可以用regular expression
[11:54.960 --> 11:56.960] 就是它可以直接用regex去match
[11:56.960 --> 11:59.760] 就比如说你可以写一个regex说
[11:59.760 --> 12:04.480] OK所有的形如a什么东西的variable
[12:04.480 --> 12:07.080] 都要在它被assign的时候要记录一下
[12:07.080 --> 12:08.320] 这也是非常方便的
[12:08.320 --> 12:16.440] 然后还有Vtracer它可以记录这个attribute
[12:16.440 --> 12:18.000] 就是比如说我们常见的
[12:18.000 --> 12:20.040] 可能是一个class里面有个attribute
[12:20.040 --> 12:23.040] 但是靠写这个attribute的时候
[12:23.040 --> 12:26.920] 可能它这个object叫什么都有可能
[12:26.920 --> 12:28.960] 它可能是内部self点什么
[12:28.960 --> 12:31.520] 这个self点a然后写进去的
[12:31.520 --> 12:33.560] 或者是它可能比如说是在外部的
[12:33.560 --> 12:34.840] 它可能有个别的名字对吧
[12:34.840 --> 12:36.200] 有个叫object.a
[12:36.200 --> 12:40.600] 我们也可以通过这个option
[12:40.600 --> 12:43.360] 就是叫logattribute
[12:43.360 --> 12:45.440] 去把这个attribute给记录下来
[12:45.440 --> 12:47.320] 每一次写attribute都记录下来
[12:47.320 --> 12:50.720] 然后还有比如说你有可能
[12:50.720 --> 12:53.640] 因为这个Vtracer确实它的记录的东西比较多
[12:53.640 --> 12:54.520] 你可能觉得太多了
[12:54.520 --> 12:55.160] 我不需要这么多
[12:55.160 --> 12:57.240] 我只需要很浅的这个占
[12:57.240 --> 12:58.520] 太深的占我不需要
[12:58.520 --> 13:00.240] 那么它可以提供很多filter
[13:00.240 --> 13:02.760] 把你不想要的内容都filter掉
[13:02.760 --> 13:04.320] 比如最简单的就是
[13:04.320 --> 13:09.200] 我可以只关注几个文件里面的内容
[13:09.200 --> 13:12.360] 比如说我只想看我自己写的代码
[13:12.360 --> 13:15.280] 这个的运行情况
[13:15.280 --> 13:17.320] 我不在乎我调用的那些酷函数
[13:17.320 --> 13:19.560] 我可以直接把那些酷函数都filter掉
[13:19.560 --> 13:25.920] 然后或者说我只在意这个stack深度为10以内的事情
[13:25.920 --> 13:28.440] 太远的就是stack深度太深的东西
[13:28.440 --> 13:29.200] 我觉得太细了
[13:29.200 --> 13:30.760] 我对我来暂时来说没有用
[13:30.760 --> 13:32.120] 我也可以做到这件事情
[13:32.120 --> 13:35.200] 然后还有一些功能
[13:35.200 --> 13:37.000] 其实还有一些功能
[13:37.000 --> 13:39.360] 其实是我可以通过修改原代码
[13:39.360 --> 13:42.520] 然后达到一些更复杂的功能
[13:42.520 --> 13:45.640] 比如说因为Google的frontend
[13:45.640 --> 13:50.040] 它本身支持log number和object
[13:50.040 --> 13:53.040] 就是它自己前端支持了一些比较酷的东西
[13:53.040 --> 13:54.600] 你可以记录一个数据
[13:54.600 --> 13:56.720] 比如说我在demo里面举了一个例子
[13:56.720 --> 13:59.720] 就是在你做这个gradient descent的时候
[13:59.720 --> 14:03.760] 你可以记录单独记录一轨是你的cost function
[14:03.760 --> 14:06.480] 就是你可以看到随着你的t度下降
[14:06.480 --> 14:10.560] 你的cost function在时间上是怎么一点一点往下走的
[14:10.560 --> 14:12.280] 这个你是可以记录下来的
[14:12.280 --> 14:17.320] 然后你也可以在每一次就通过继承
[14:17.320 --> 14:21.400] 这个vobject这个class
[14:21.400 --> 14:27.040] 你可以在每一次写入某一个特定attribute的时候
[14:27.040 --> 14:30.000] 都把整个的object给记录下来
[14:30.000 --> 14:33.439] 所以说其实feature还蛮多的
[14:33.439 --> 14:34.319] 如果大家感兴趣的话
[14:34.319 --> 14:36.480] 我基本上都列在什么上面
[14:36.480 --> 14:40.280] 基本上都列在我的Github这个配置上面
[14:40.280 --> 14:42.199] 所以说大家如果感兴趣的话可以去看一看
[14:42.199 --> 14:46.000] 然后我们接下来可能会聊一些稍微细一点的feature
[14:46.000 --> 14:47.520] 所以可能也会提到
[14:47.520 --> 14:48.839] feature还是蛮多的
[14:48.839 --> 14:50.760] 对就在我们深入之前
[14:50.760 --> 14:53.040] 就是我想来问一下
[14:53.040 --> 14:55.760] 比如说我现在就是有一个程序
[14:55.760 --> 14:56.920] 然后它跑得比较慢
[14:56.920 --> 14:59.880] 那我想用VizTracer来检测一下
[14:59.880 --> 15:02.240] 它到底是为什么慢的话要怎么做
[15:02.240 --> 15:07.360] 这是我开发时候的一个很注重的点
[15:07.360 --> 15:10.040] 我希望这个过程变得特别特别特别简单
[15:10.040 --> 15:11.719] 所以说你只需要做两步
[15:11.719 --> 15:14.120] 第一步叫pip install viztracer
[15:14.120 --> 15:18.719] 然后第二步是viztracer你的script就可以了
[15:18.719 --> 15:21.120] 就是比如说你这个函数叫script.py
[15:21.120 --> 15:21.360] 对不对
[15:21.360 --> 15:24.240] 你平常运行的时候就用的python script.py
[15:24.240 --> 15:27.520] 然后你现在只需要把python变成viztracer
[15:27.520 --> 15:29.760] 变成viztracer script.py
[15:29.760 --> 15:30.920] 然后运行完了之后
[15:30.920 --> 15:34.480] 你在当前的current working directory
[15:34.480 --> 15:36.440] 就是在你当前的文件夹下
[15:36.440 --> 15:41.360] 就会产生一个叫result.html的这么一个网页文件
[15:41.360 --> 15:43.080] 它是一个standalone的网页文件
[15:43.080 --> 15:44.320] 它没有任何的dependency
[15:44.320 --> 15:46.640] 你只需要用chrome打开这个网页文件
[15:46.640 --> 15:48.360] 你就能看到你的log了
[15:48.360 --> 15:50.640] 然后这个log你想知道哪慢
[15:50.640 --> 15:51.600] 一般情况下
[15:51.600 --> 15:53.360] 如果你这个有一个很明确的慢的地方
[15:53.360 --> 15:55.600] 你就会看到一个大长块
[15:55.600 --> 15:57.920] 就是这个块里面都在运行这件事情
[15:57.920 --> 15:59.120] 那你就可以先去说
[15:59.120 --> 16:00.880] ok这个大长块为什么这么长
[16:00.880 --> 16:03.400] 我研究研究是不是这个大长块里面有什么东西
[16:03.400 --> 16:05.800] 我可以把它变得更快的
[16:05.800 --> 16:09.040] 这个是我用viztracer来profiling的一般的方法
[16:09.040 --> 16:11.000] 那我有个问题
[16:11.000 --> 16:14.200] 就是刚才提到viztracer和火焰图的这样的区别
[16:14.200 --> 16:15.600] 那像火焰图的话
[16:15.600 --> 16:17.480] 它可以给你显示累积的时间
[16:17.480 --> 16:19.040] 但viztracer是每次的
[16:19.040 --> 16:21.880] 比如说有个函数它可能耗时比较短
[16:21.880 --> 16:23.320] 但是它调用次数很多
[16:23.320 --> 16:27.080] 那这个用viztracer要怎么来发现这件事情
[16:27.080 --> 16:30.520] 这个也是一个你直观上的事情
[16:30.520 --> 16:35.960] 因为viztracer它会把每一个函数名hash到一个color上
[16:35.960 --> 16:37.280] hash到一个颜色上
[16:37.280 --> 16:38.880] 所以说在viztracer看来
[16:38.880 --> 16:41.040] 如果你有一个函数调用的次数特别多
[16:41.040 --> 16:44.960] 你就会看到很多很多很多那个颜色在同一个地方出现
[16:44.960 --> 16:48.040] 你就会知道是这个函数被调用了非常多次
[16:48.040 --> 16:49.240] 我就可以去思考
[16:49.240 --> 16:51.680] 那么我就可以去思考
[16:51.680 --> 16:54.280] 这个函数是不是被调用的次数太多了
[16:54.280 --> 16:55.640] 跟火焰图各有优劣
[16:55.640 --> 16:56.319] 火焰图的话
[16:56.319 --> 16:58.079] 你可以非常迅速的找到
[16:58.079 --> 16:59.599] ok这个东西暂时太多
[16:59.599 --> 17:00.760] 但是在火焰图上
[17:00.760 --> 17:02.719] 你是不能直观的感受到
[17:02.719 --> 17:05.119] 到底是这个函数调用的次数太多
[17:05.119 --> 17:07.480] 还是这个函数里面太慢了
[17:07.480 --> 17:08.560] 这两种都有可能
[17:08.560 --> 17:11.200] 但是这两种对应的修改方式是不一样的
[17:11.200 --> 17:13.200] 这个函数调用次数太多
[17:13.200 --> 17:14.359] 可能是你算法有问题
[17:14.359 --> 17:15.800] 可能是你复杂度有问题
[17:15.800 --> 17:17.480] 但是这个函数里面太慢了
[17:17.480 --> 17:18.839] 可能你里面要做一些
[17:18.839 --> 17:20.760] 比如说micro optimization
[17:20.760 --> 17:23.680] 所以这个是Viz Tracer
[17:23.680 --> 17:25.680] 其实在这种某种程度上来说
[17:25.680 --> 17:26.800] 他在这个方面
[17:26.800 --> 17:28.640] 他会给你的理解
[17:28.640 --> 17:32.680] 就是你可能会需要花更多的时间去想
[17:32.680 --> 17:33.840] 这个到底为什么
[17:33.840 --> 17:35.440] 但是他给你提供的信息更多
[17:35.440 --> 17:37.280] 你可能理解会更深入一些
[17:37.280 --> 17:39.480] 嗯嗯是
[17:39.480 --> 17:43.480] 对就是他的信息比火焰图还是更多一些
[17:43.480 --> 17:44.080] 对吧
[17:44.080 --> 17:45.480] 嗯对丰富不少
[17:45.480 --> 17:46.879] 是
[17:46.879 --> 17:48.280] ok
[17:48.280 --> 17:52.399] 然后像小白和Adam
[17:52.399 --> 17:55.600] 你们有没有什么就是关于Viz Tracer使用方面的问题
[18:00.280 --> 18:05.720] 我刚才听高天老师又重新描述了一下这个项目
[18:05.720 --> 18:10.879] 对我会发现这个和我之前用过的有一个东西有类比
[18:10.879 --> 18:12.280] 当然他不是python
[18:12.280 --> 18:15.600] 对就是其实在一些这种微服务环境里
[18:15.600 --> 18:20.000] 其实我们都会去应用一个这种分布式追踪的技术
[18:20.000 --> 18:20.879] Open Tracing
[18:20.879 --> 18:25.800] 对他其实相当于是完整的在记录说这一个请求
[18:25.800 --> 18:30.760] 他会经历各个服务的这么一个流程也好
[18:30.760 --> 18:31.679] 占比也好
[18:31.679 --> 18:32.600] 次数也好
[18:32.600 --> 18:34.480] 他也是一条时间轴
[18:34.480 --> 18:35.120] 对
[18:35.120 --> 18:37.520] 然后我可以看我经历了哪一些
[18:37.520 --> 18:40.000] 然后他内部的时间也是什么样的
[18:40.000 --> 18:43.320] 那目前看起来就是Viz Tracer
[18:43.320 --> 18:49.080] 在我看来他可能有一个类似的就是在python层面
[18:49.080 --> 18:53.800] 他应该是可以记录我整个执行过程中的我的时间线的记录
[18:53.800 --> 18:56.200] 以及说我往下迭代的这个深度
[18:56.200 --> 19:00.679] 对那我想问一下高天老师就是这个网页的工具
[19:00.679 --> 19:02.200] 我现在也在看这个demo
[19:02.200 --> 19:06.399] 对他是可以做一些下层次的展开的吗
[19:06.399 --> 19:09.679] 就比如说我从A然后调用了B
[19:09.679 --> 19:11.200] 然后从B调用了C
[19:11.200 --> 19:19.040] 然后我能否在这个HTML文件这个地方只选择看C内部的一些记录
[19:19.040 --> 19:23.840] 我这个frontend是Google的frontend
[19:23.840 --> 19:28.960] 一般来说如果我要看某一个东西之下的话
[19:28.960 --> 19:31.440] 我就直接给他zoom in到那个地方去
[19:31.440 --> 19:34.920] 所以他是支持的是吗
[19:34.920 --> 19:36.560] 因为我可能没找到这个操作
[19:36.560 --> 19:37.760] 所以我比较好奇
[19:37.760 --> 19:41.360] ASDW
[19:41.360 --> 19:44.320] 这是一个特别隐蔽的事
[19:44.320 --> 19:46.720] 就是我还特意写到了我的那个github
[19:46.720 --> 19:48.320] 因为我发现好多人其实会不知道
[19:48.320 --> 19:49.600] 他就觉得这太细了
[19:49.600 --> 19:50.280] 什么都看不见
[19:50.280 --> 19:53.560] 然后你按W就zoom in进去了
[19:53.560 --> 19:56.960] 那其实已经实现了我想要的需求
[19:56.960 --> 20:01.480] 对就是我可以在整个的流程里去关注某一个更细节部分
[20:01.480 --> 20:02.760] 对对对对这个是很重要的
[20:02.760 --> 20:04.360] 如果只有很大的一个图的话
[20:04.360 --> 20:06.560] 那确实帮助就是比较小
[20:06.560 --> 20:08.960] 对我刚用鼠标来回点
[20:08.960 --> 20:11.200] 我发现我没有找到
[20:11.200 --> 20:14.080] 对确实这个是对对这个frontend确实有这个
[20:14.080 --> 20:15.200] 他不是很明确
[20:15.200 --> 20:17.600] 然后他的zoom in的钮其实也不明确
[20:17.600 --> 20:19.879] 就是还还还挺诡异的
[20:19.879 --> 20:24.879] 嗯对那那小白呢
[20:24.879 --> 20:30.720] 哦我我看这个这个应该就是跟那个chrome
[20:30.720 --> 20:37.360] 然后那个性能检测的那个工具是一样的一个东西吧
[20:37.360 --> 20:38.640] 呃前端是一模一样的
[20:38.640 --> 20:40.640] 前端就是用的chrome的那个工具
[20:40.640 --> 20:42.040] 哦我看着就眼熟
[20:42.040 --> 20:46.200] 因为我之前我我可能python的那个分析用的比较少
[20:46.200 --> 20:47.480] 但是我我也做前端
[20:47.480 --> 20:52.440] 然后我可能就是经常用那个chrome的那个性能分析
[20:52.440 --> 20:54.040] 然后所以说我感觉很眼熟
[20:54.040 --> 21:01.720] 对感觉对感觉就是嗯对你说你说
[21:01.720 --> 21:07.480] 没事我就说就是这两个东西的应该是这个ui应该是一套的
[21:07.480 --> 21:14.280] 对对然后我我有个问题想再问一下高天老师
[21:14.280 --> 21:17.320] 就是刚才其实有聊到这个变量的捕捉吗
[21:17.320 --> 21:24.240] 嗯对就是就是在当时的现场捕捉当时这个某些变量的值
[21:24.240 --> 21:27.280] 嗯对刚刚有有提到这么一个feature
[21:27.280 --> 21:29.720] 我想问一下就是这个是需要手动声明的
[21:29.720 --> 21:31.560] 还是说像centry那样
[21:31.560 --> 21:36.120] 就是我把当前的这个locals都自动的做捕捉
[21:36.120 --> 21:44.879] 嗯是呃捕捉变量的话是你要在command line上面输入你要捕捉哪个变量
[21:44.879 --> 21:46.879] 或者是形如什么的变量
[21:46.880 --> 21:48.000] 就是可以用regex
[21:48.000 --> 21:50.000] ok
[21:50.000 --> 21:54.160] 对就不指定就不捕捉呗
[21:54.160 --> 21:58.240] 就是对不指定不捕捉这个呃很大的一个考虑是overhead
[21:58.240 --> 22:01.520] 呃因为捕捉变量这件事是有overhead的
[22:01.520 --> 22:08.360] 然后呃然后说回刚才那个就提到的用的chrome的这个前端
[22:08.360 --> 22:16.680] 我是觉得chrome他提供了很多这种就是非常好的现成的呃来来做debug的工具
[22:16.680 --> 22:19.840] 就是包括他的那个呃dev tools console
[22:19.840 --> 22:26.360] 我在做cyber brain的时候试图找一个能跟他提供相同或者更多功能的东西
[22:26.360 --> 22:29.120] 就比如说你输一个javascript的object打进去
[22:29.120 --> 22:31.640] 他就能让你去展开里面的属性
[22:31.640 --> 22:32.880] 然后看里面的值
[22:32.880 --> 22:37.320] 包括比如说你有一个很大呃有很多元素的一个array
[22:37.320 --> 22:38.640] 他都可以完整的显示
[22:38.640 --> 22:40.320] 但是我就找不到这样一个东西
[22:40.320 --> 22:42.960] 就他这套真的是做的特别完善
[22:42.960 --> 22:46.880] 我觉得所以也是给开发者节省了很多时间
[22:46.880 --> 22:53.440] 嗯确实是就chrome这个呃这个前端基本上满足了我绝大部分的需求了
[22:53.440 --> 22:58.280] 他有一个呃就是做vstracer做到呃就一旦你脱离这个toy的阶段
[22:58.280 --> 23:00.600] 去开始尝试跑一些大的program的话
[23:00.600 --> 23:04.040] 你就会发现其实前端的性能也会是一个瓶颈
[23:04.040 --> 23:09.240] 所以说如果你自己做出来的东西可能呃展示小内容的时候是没有区别的
[23:09.240 --> 23:14.240] 但是一旦开始展示几十个几十几十万个entry的东西的时候
[23:14.240 --> 23:16.080] 你可能就会网页会直接崩溃
[23:16.080 --> 23:17.880] 但google东西做的还是比较扎实
[23:17.880 --> 23:21.160] 所以就是你在打开的时候他虽然会耗一定的时间
[23:21.160 --> 23:22.360] 但是基本上打的开
[23:22.360 --> 23:25.440] 嗯就是这个还是对我来说很关键
[23:25.440 --> 23:27.560] 对是的
[23:27.560 --> 23:32.920] 呃然后我们聊完了vstracer的一些功能
[23:32.920 --> 23:34.840] 再来聊聊聊他的工作原理
[23:34.840 --> 23:39.040] 呃就是呃这个可能比较底层啊
[23:39.040 --> 23:40.720] 然后先给听众们提个醒
[23:40.720 --> 23:43.879] 就是涉及到一些python的里面的高级功能
[23:43.879 --> 23:51.320] 然后呃所以然后我看高田写的介绍是他用了一个python的函数
[23:51.320 --> 23:52.920] 叫做setprofile是吧
[23:52.920 --> 23:56.600] 呃对呃这个我们可以这个有浅入深
[23:56.600 --> 23:57.960] 从最简单的开始说最简单的
[23:57.960 --> 24:00.399] 我相信如果大家对python稍微有一点点了解的话
[24:00.399 --> 24:01.360] 都能玩的溜啊
[24:01.360 --> 24:04.800] 就是python本身自己带一个叫setprofile的函数
[24:04.800 --> 24:08.320] 然后这个函数呢其实也很很很很很简单
[24:08.320 --> 24:12.600] 就是说每一次函数在被调用和return的时候
[24:12.600 --> 24:15.720] 这个函数都会像hook一样被call一下
[24:15.720 --> 24:16.679] 呃就这么简单
[24:16.679 --> 24:19.760] 就是说所以说这个函数被call一下是哪个函数被call一下
[24:19.760 --> 24:24.760] 就是这个呃你setprofile函数可以给一个callback
[24:24.760 --> 24:25.480] 嗯
[24:25.480 --> 24:27.159] setprofile函数可以给一个callback
[24:27.159 --> 24:33.080] 然后这个callback在每一次呃任何python里面任何一个函数被调用和return的时候
[24:33.080 --> 24:35.000] 都会先call一下这个callback
[24:35.000 --> 24:41.160] 然后并且告诉这个callback是简单的来说就是呃这些呃现在当前的信息
[24:41.160 --> 24:43.080] 呃细致点说就是frame了
[24:43.080 --> 24:45.760] 但是基本上就告诉你哎哪个函数被调用了
[24:45.760 --> 24:46.800] 哪个函数结束了
[24:46.800 --> 24:48.680] 所以说实际上你只要连上这个callback
[24:48.680 --> 24:51.200] 你就可以做一个最最最简单版本的viz tracer
[24:51.200 --> 24:52.360] 你就连上它
[24:52.360 --> 24:54.280] 然后你把这个数都打下来
[24:54.280 --> 24:59.080] 你按照那个chrome的那个trace event的形式把它打下来
[24:59.080 --> 24:59.240] 哎
[24:59.240 --> 25:02.840] 你就自己做了一个非常非常非常简单的viz tracer是可以用的
[25:02.840 --> 25:05.040] 尤其是对于toy project来说是足够用的
[25:05.040 --> 25:06.040] 嗯哼
[25:06.959 --> 25:11.679] 对呃然后呃就补充一点刚才那个就是呃
[25:11.679 --> 25:15.760] 它的callback拿到信息还包括函数还包括程序执行到了哪里
[25:15.760 --> 25:18.879] 以及当前的所有的呃局部变量啊
[25:18.879 --> 25:20.720] 全局变量这些你都可以拿得到
[25:20.720 --> 25:23.159] 对对那你说这个是最简单版本
[25:23.159 --> 25:25.480] 那现在是不是已经不是这样实现的了呢
[25:25.480 --> 25:28.919] 呃我只有这个第一个版本用的是这个呃这个python
[25:28.919 --> 25:31.800] 这个set profile这个函数呢最大的问题
[25:31.800 --> 25:35.720] 对于一个呃相对成熟一点project来说就是overhead
[25:35.720 --> 25:37.520] 就是你一旦用了这个东西的话
[25:37.520 --> 25:41.720] 你你想因为你的你的函数调用可能呃频率很高
[25:41.720 --> 25:45.720] 然后你如果callback进的是一个python的函数的话
[25:45.720 --> 25:48.800] 它的这个这个呃overhead就非常非常大
[25:48.800 --> 25:53.000] 在worst case情况下可能达能达到几十倍的这个overhead
[25:53.000 --> 25:54.000] 就很夸张
[25:54.000 --> 25:57.399] 所以说呃我基本上在第就是没几个版本的时候
[25:57.399 --> 25:59.399] 我就开始转入c了
[25:59.399 --> 26:01.200] 呃就是c
[26:01.200 --> 26:05.600] 就是python c python的这个api里面也给了一个这个
[26:05.600 --> 26:09.000] 基本上跟set profile等价的这么一个c函数
[26:09.000 --> 26:11.400] 然后你可以给一个c的callback
[26:11.400 --> 26:16.400] 然后在呃在c的层面做就比在python的层面做速度要快非常多
[26:16.400 --> 26:21.200] 所以现在的vtracer实际上是用的c api里面的set profile
[26:21.200 --> 26:24.000] 嗯那它具体能快多少呢
[26:24.000 --> 26:28.200] 呃呃worst case的情况下我我自己做个benchmark
[26:28.200 --> 26:31.600] 呃worst case情况下就是一个纯费那些数列之类的
[26:31.600 --> 26:33.600] 就是这种呃函数里几乎什么都没有
[26:33.600 --> 26:35.600] 就纯recursive的情况下
[26:35.600 --> 26:39.600] 呃呃python大概能到可能要30到50倍的overhead
[26:39.600 --> 26:42.600] c的话大概是两倍到三倍
[26:42.600 --> 26:45.600] 嗯对这个提升还是挺明显的
[26:45.600 --> 26:51.600] 呃对python的那个python那个callback真的是代价稍微点大
[26:51.600 --> 26:53.600] 就是呃你要是玩一玩的话
[26:53.600 --> 26:57.600] 就想做一个那个proof of concept是一点问题都没有的
[26:57.600 --> 27:00.600] 但是如果真的说我想拿来用
[27:00.600 --> 27:03.600] 可能还是要跑到c上面去完成这个事情
[27:03.600 --> 27:08.600] 嗯哎对那然后就顺便聊到说你这个呃
[27:08.600 --> 27:12.600] 怎么是怎么计算他的一个函数的耗时呢
[27:12.600 --> 27:16.600] 呃这个其实就跟大家想象的就基本上一样
[27:16.600 --> 27:19.600] 我就就是在函数进来的时候打个时间戳
[27:19.600 --> 27:21.600] 函数出去的时候打个时间戳
[27:21.600 --> 27:23.600] 然后函数耗时就出来了
[27:23.600 --> 27:26.600] 呃呃有不完全准确的地方
[27:26.600 --> 27:28.600] 这个时间戳在哪打呃
[27:28.600 --> 27:31.600] 另外就是你的这个callback永远是会有一些overhead的
[27:31.600 --> 27:34.600] 这些都呃都会都会存在
[27:34.600 --> 27:36.600] 但是总体来说的话这么打啊
[27:36.600 --> 27:38.600] 呃不会出现太大的问题
[27:38.600 --> 27:40.600] 不会出现太大的问题
[27:40.600 --> 27:43.600] 嗯所以就是把两个时间减一下了
[27:43.600 --> 27:45.600] 就是就是这样
[27:45.600 --> 27:50.600] 呃更确切的说呃呃chrome trace event
[27:50.600 --> 27:52.600] 就是这个前端接受的这个数据
[27:52.600 --> 27:57.600] 你甚至不需要计算这个这个函数到底多长时间
[27:57.600 --> 28:01.600] 他实际上是可以take一个这个函数开始一个event
[28:01.600 --> 28:03.600] 这个函数结束一个event
[28:03.600 --> 28:05.600] 然后他自己会visualize上去
[28:05.600 --> 28:07.600] 当然后面我抛弃了这种方法
[28:07.600 --> 28:11.600] 因为如果呃他呃就是大家可能不太了解这个chrome trace event
[28:11.600 --> 28:14.600] 这chrome trace event你有两种形式记录一个event
[28:14.600 --> 28:16.600] 第一个是你给一个开始的event
[28:16.600 --> 28:17.600] 一个结束的event
[28:17.600 --> 28:19.600] 或者你可以给一个完整的event
[28:19.600 --> 28:22.600] 就是这个event有开始时间和一个duration
[28:22.600 --> 28:24.600] 如果你用一个完整的event相当于一个函数
[28:24.600 --> 28:26.600] 你只需要一个event
[28:26.600 --> 28:28.600] 但如果你打两个点的话需要两个event
[28:28.600 --> 28:33.600] 也就是说你需要的呃内存和需要的disk space都成了个2
[28:33.600 --> 28:35.600] 所以我在后来优化的时候呢
[28:35.600 --> 28:38.600] 就实际上最后还是自己想办法钻了时间
[28:38.600 --> 28:43.600] 那他精度是能有多少到毫秒微秒还是
[28:43.600 --> 28:48.600] 精度要看你的overhead和你这个呃你的那个timer
[28:48.600 --> 28:54.600] 就是你的那个那个那个呃那个那个那个大时间戳呃水平如何
[28:54.600 --> 29:00.600] 呃现在呃这个这个呃linux跟windows的这个最好的时间戳
[29:00.600 --> 29:04.600] 我记得是在百纳秒还是十纳秒的级别
[29:04.600 --> 29:06.600] 就是这个呃精度
[29:06.600 --> 29:14.600] 但是当然了就是我引入的overhead实际上肯定是大于这个呃十纳秒和百纳秒级别的
[29:14.600 --> 29:17.600] 可能大概是在微秒级别吧
[29:17.600 --> 29:19.600] 嗯
[29:19.600 --> 29:20.600] 哎
[29:20.600 --> 29:21.600] 我突然想到这样一个问题
[29:21.600 --> 29:25.600] 就说就说呃虽然现在是用c来实现的tracing
[29:25.600 --> 29:29.600] 但是他你刚才说也有两倍或者三倍的overhead嘛
[29:29.600 --> 29:33.600] 那那如果说这些overhead他是平均的
[29:33.600 --> 29:34.600] 那倒还好
[29:34.600 --> 29:39.600] 就比如说他的一个增量或者说是一个倍数永远是一个固定的值
[29:39.600 --> 29:40.600] 那还好
[29:40.600 --> 29:43.600] 但是如果是说那有的函数或者有的操作
[29:43.600 --> 29:44.600] 他的overhead比较大
[29:44.600 --> 29:45.600] 有的比较小
[29:45.600 --> 29:49.600] 那岂不是就会说影响最后我profile出来的一个结果
[29:49.600 --> 29:51.600] 那会有这样的一个情况吗
[29:51.600 --> 29:52.600] 呃
[29:52.600 --> 30:00.600] 首先是一定会呃这个overhead的基本上是每一个调用的overhead的时间是固定的
[30:00.600 --> 30:01.600] 基本上是这样的
[30:01.600 --> 30:05.600] 所以说那么如果你一个函数非常非常短的话
[30:05.600 --> 30:07.600] 他虽然调用的时间是固定的
[30:07.600 --> 30:09.600] 但是他占的他的比例就大
[30:09.600 --> 30:11.600] 呃但是这个问题呢cprofile也有
[30:11.600 --> 30:14.600] 就是Python最常用的这个profile这么一个library
[30:14.600 --> 30:15.600] cprofile也有
[30:15.600 --> 30:16.600] 如果你用cprofile的话
[30:16.600 --> 30:20.600] 你会发现如果你有一些调用频次非常高
[30:20.600 --> 30:22.600] 占用时间非常短的函数
[30:22.600 --> 30:23.600] 在cprofile里面
[30:23.600 --> 30:27.600] 你会发现他的比例会占的比实际要高一些
[30:27.600 --> 30:33.600] 呃这个问题是所有的deterministic profiling tool都难免会遇到的问题
[30:33.600 --> 30:36.600] 除非你去人工的去剪
[30:36.600 --> 30:38.600] 就是Python的profiling
[30:38.600 --> 30:40.600] 就是不是用c的那个profile library
[30:40.600 --> 30:43.600] 实际上他是做了一些人工的计算
[30:43.600 --> 30:45.600] 他就是说他打完时间戳之后
[30:45.600 --> 30:48.600] 他算他就是猜他猜我花了多少overhead
[30:48.600 --> 30:50.600] 再把那个overhead给剪掉
[30:50.600 --> 30:52.600] 呃就是各有利弊吧
[30:52.600 --> 30:58.600] 他这样的话可能会给你展示出来的是一个相对来说更接近实际情况的事
[30:58.600 --> 31:00.600] 但是他有时候剪着剪着会给你剪成负的
[31:00.600 --> 31:02.600] 然后他的library都会告诉你说
[31:02.600 --> 31:04.600] 有时候会出现负数
[31:04.600 --> 31:05.600] 那这就很尴尬
[31:05.600 --> 31:06.600] 所以他他也不准
[31:06.600 --> 31:11.600] 他只是可能相比于这个我们这个偏都是往一边偏的话
[31:11.600 --> 31:13.600] 他就相当有点矫枉过正
[31:13.600 --> 31:15.600] 他就有时候往左边有时候往右边大概这么个意思
[31:15.600 --> 31:16.600] 嗯
[31:17.600 --> 31:18.600] OK
[31:19.600 --> 31:21.600] 但反正就是说大致来讲
[31:21.600 --> 31:23.600] 不会有特别大的差别
[31:23.600 --> 31:24.600] 对吧
[31:24.600 --> 31:29.600] 就是因为都只是记录一个函数的入口和出口
[31:29.600 --> 31:38.600] 呃对就是每一个函数的overhead的总时长是区别呃几乎没什么区别的
[31:38.600 --> 31:42.600] 区别只是这个overhead占这个函数的比例
[31:42.600 --> 31:43.600] 如果你函数很短
[31:43.600 --> 31:45.600] 你可能overhead就占了稍微多一点
[31:45.600 --> 31:48.600] 你这个函数就可能比那个平时稍微宽一点
[31:48.600 --> 31:50.600] 如果你这个函数本来就很大
[31:50.600 --> 31:52.600] 你overhead可能就可以忽略不计
[31:52.600 --> 31:54.600] 所以说我刚才说的是这个两到三倍
[31:54.600 --> 31:55.600] 大概是worst case
[31:55.600 --> 31:57.600] 就是所有的函数都爆短
[31:57.600 --> 31:58.600] 几乎就是进来就return
[31:58.600 --> 31:59.600] 进来就return是两到三倍
[31:59.600 --> 32:03.600] 但是如果你是真正的应用到嗯这个这个呃python的
[32:03.600 --> 32:05.600] 你的真实的project里面的话
[32:05.600 --> 32:07.600] 对overhead很有可能是两倍以下
[32:07.600 --> 32:08.600] 可能一倍多一点
[32:08.600 --> 32:10.600] 如果你的函数的长度是reasonable的话
[32:10.600 --> 32:12.600] 嗯理解理解
[32:12.600 --> 32:18.600] 对呃因为我我自己没有特别多profiling的经验啊
[32:18.600 --> 32:20.600] 然后我想问adam和小白
[32:20.600 --> 32:24.600] 你们就是以往做profiling的话
[32:24.600 --> 32:27.600] 一般一般是怎么做就不限于python了
[32:27.600 --> 32:32.600] 我就是先找一些测量手段来测量啊
[32:32.600 --> 32:33.600] 这个真的很重要
[32:33.600 --> 32:38.600] 就是对因为我我工作中大部分场景可能和业务开发相关
[32:38.600 --> 32:45.600] 那做一些这种呃性能的优化或者是去测量的时候
[32:45.600 --> 32:48.600] 其实会先从响应时间入手
[32:48.600 --> 32:51.600] 因为这个会直接影响到用户嘛
[32:51.600 --> 33:01.600] 对然后又因为我往往是在一些这种所谓的微服务架构下的一些呃技术站上去工作
[33:01.600 --> 33:09.600] 那第一步可能是要先通过呃像open tracing这种技术来定位整个链条上
[33:09.600 --> 33:12.600] 它主要的瓶颈是在什么地方
[33:12.600 --> 33:15.600] 对就相当于是定位到服务
[33:15.600 --> 33:17.600] 对然后定位到服务之后呢
[33:17.600 --> 33:20.600] 然后再来看服务内的情况
[33:20.600 --> 33:28.600] 呃其实我很少会用到火焰图或者是高天老师讲到的这个
[33:28.600 --> 33:29.600] 怎么说呢
[33:29.600 --> 33:34.600] 就是大部分时候其实你都可以直接通过呃一些接口的定位
[33:34.600 --> 33:35.600] 然后看代码
[33:35.600 --> 33:37.600] 然后大概得到猜想
[33:37.600 --> 33:41.600] 对但是有用过两次火焰图吧
[33:41.600 --> 33:44.600] 确实是说就是他不是那种很明显的
[33:44.600 --> 33:46.600] 就你能看到的优化点
[33:46.600 --> 33:49.600] 然后就会使用这种工具来进行性能优化
[33:49.600 --> 33:52.600] 对嗯哦
[33:52.600 --> 33:54.600] 这这里面我可能要补充一个点
[33:54.600 --> 33:56.600] 是为什么说我刚说定位到服务之后
[33:56.600 --> 34:05.600] 我就会上上这种很专业的profiling的工具的原因是因为
[34:05.600 --> 34:10.600] 呃我面临的大部分业务场景其实都是IO密集的场景
[34:10.600 --> 34:13.600] 对然后所有的IO的这种执行的时间的消耗
[34:13.600 --> 34:20.600] 以及说他什么时间执行也会被集成进open tracing的这种呃数据里
[34:20.600 --> 34:22.600] 然后是直接可以看到的
[34:22.600 --> 34:30.600] 对哎就像就像就像open tracing会呃会区分war time和cpu time是吧
[34:30.600 --> 34:35.600] 就是呃open tracing不会做这个事情
[34:35.600 --> 34:39.600] 但是一般来说如果你的业务本身是IO密集的
[34:39.600 --> 34:46.600] 那我们都会在各种的这种呃和IO操作的一些库上去做这种open tracing的集成
[34:46.600 --> 34:51.600] 比如说数据库啊redis啊都会去和open tracing做集成
[34:51.600 --> 34:56.600] 他这个集成之后的效果是就是什么样的
[34:56.600 --> 35:00.600] 大概就本质也是记录了一个操作以及起始时间和结束时间
[35:00.600 --> 35:07.600] 最后会构成一个像高天老师的提到的那种的呃瀑布图
[35:07.600 --> 35:10.600] 所以所以说他也会记录就是说实际上
[35:10.600 --> 35:15.600] 比如说在等待一个IO操作的时间吗就这种
[35:15.600 --> 35:17.600] 对但是他其实是不准的
[35:17.600 --> 35:25.600] 就是他并不是纯IO就是open tracing这一套其实完全依赖于呃
[35:25.600 --> 35:31.600] 集成open open tracing的人决定在什么时间在什么位置去打一个点
[35:31.600 --> 35:34.600] 对但是你像微服务的话
[35:34.600 --> 35:42.600] 大家都会选择在服务调用的开始和这个服务得到结束之后的结果的位置去打一个调用点
[35:42.600 --> 35:51.600] 以及说呃在这个呃比如说我reddit操作的开始和结束的时候去打一个点这种
[35:51.600 --> 35:55.600] 对然后因为他本身有一个span的概念
[35:55.600 --> 35:59.600] 其实我可以知道说这个reddit的操作是属于这个服务的
[35:59.600 --> 36:03.600] 然后他还有trace ID可以把一整个链条给连接起来
[36:03.600 --> 36:08.600] 对所以我这边常见的模式就是说呃
[36:08.600 --> 36:14.600] 首先通过基于open tracing的一些图形化的一些开源的工具
[36:14.600 --> 36:18.600] 比如说啊jager这种的去寻找说瓶颈点
[36:18.600 --> 36:26.600] 然后因为面向用户的场景其实大部分时候呃都是IO的问题导致的
[36:26.600 --> 36:30.600] 所以基本上能直接定位那定位不了的时候
[36:30.600 --> 36:36.600] 你会发现一些情况就是可能IO占比不多
[36:36.600 --> 36:38.600] 但是他会中间会有一些空白
[36:38.600 --> 36:42.600] 对那就意味着这中间可能会有大量的cpu消耗
[36:42.600 --> 36:46.600] 然后就会使用一些火焰图工具
[36:46.600 --> 36:51.600] 然后我觉得之后也可以尝试一下高天老师的工具来做一些profiling
[36:51.600 --> 36:54.600] ok那其实with tracer的话
[36:54.600 --> 37:03.600] 他呃主要还是比较适合profile这种呃这种cpu密集的一些操作还是都可以
[37:03.600 --> 37:07.600] 呃对这个确实是呃with tracer在profiling的话
[37:07.600 --> 37:11.600] 我觉得可能是在cpu密集的程序上可能会更明确
[37:11.600 --> 37:16.600] 呃但是另外一个我一直想说的就是呃呃with tracer的定位问题
[37:16.600 --> 37:20.600] 我们大部分时候我们我们今天就是呃很多时候都在聊with tracer
[37:20.600 --> 37:24.600] 作为一个profiler的这个能力和这个这个方向对吧
[37:24.600 --> 37:26.600] 但是我自己对with tracer的定义
[37:26.600 --> 37:31.600] 他不光是一个profiler就是呃因为呃profiling的话
[37:31.600 --> 37:34.600] 其实呃火焰图本身做的还是很不错的
[37:34.600 --> 37:39.600] 我觉得with tracer更嗯更更比较呃我对with tracer的定义
[37:39.600 --> 37:42.600] 就是他是一个帮助你理解代码的工具
[37:42.600 --> 37:44.600] 那么理解完代码之后
[37:44.600 --> 37:48.600] 实际上是有呃很多事情是跟我们理解代码是有相关的
[37:48.600 --> 37:51.600] profiling当然是一个我们知道代码哪快哪慢对不对
[37:51.600 --> 37:52.600] 那么从另外的角度讲
[37:52.600 --> 37:55.600] 当我们去面临一个全新的代码
[37:55.600 --> 37:57.600] 面临一个没有读过的代码的时候
[37:57.600 --> 38:00.600] 我们想知道他到底怎么工作的
[38:00.600 --> 38:02.600] 我们想知道他的代码的结构
[38:02.600 --> 38:05.600] 我们想知道他运行的时候到底是分成哪几块
[38:05.600 --> 38:06.600] 他的调用方式是什么
[38:06.600 --> 38:08.600] 也可以用with tracer来完成
[38:08.600 --> 38:10.600] 这个事情火焰图就很难办
[38:10.600 --> 38:11.600] with tracer你跑一下
[38:11.600 --> 38:12.600] 你整个把这个程序跑一下
[38:12.600 --> 38:14.600] 你就说哦这块是干这个的
[38:14.600 --> 38:15.600] 这块是干这个的
[38:15.600 --> 38:16.600] 这块是干这个的
[38:16.600 --> 38:16.600] 对吧
[38:16.600 --> 38:19.600] 然后你就可以去呃一一一块一块的分别来看
[38:19.600 --> 38:21.600] 那么同样的debugging也是一个道理
[38:21.600 --> 38:24.600] debugging的本质也是我们的程序有一个小细节
[38:24.600 --> 38:26.600] 我跟我理解的时间是不一样的
[38:26.600 --> 38:27.600] 那也是一样的
[38:27.600 --> 38:29.600] 我把with tracer拿出来
[38:29.600 --> 38:30.600] 然后跑一遍程序
[38:30.600 --> 38:33.600] 然后看一看哪个地方和我理解的不一样
[38:33.600 --> 38:35.600] 哪个地方和我理解的有偏差
[38:35.600 --> 38:37.600] 他这个到底是怎么运行的
[38:37.600 --> 38:39.600] 或者是我用with tracer打一些变量
[38:39.600 --> 38:40.600] 在我的这个图上面
[38:40.600 --> 38:41.600] 我可以知道哎
[38:41.600 --> 38:43.600] 这个这块应该有这个变量
[38:43.600 --> 38:44.600] 或者这块不应该有这个变量
[38:44.600 --> 38:47.600] 或者这块这个cost stack看起来很诡异
[38:47.600 --> 38:49.600] 或者是这块出现了一个exception
[38:49.600 --> 38:54.600] 所以说我个人对with tracer的理解是不局限于profiling这一件事上的
[38:54.600 --> 38:55.600] 不管是debugging也好
[38:55.600 --> 38:57.600] 甚至说我们打logging也好
[38:57.600 --> 39:01.600] with tracer都可以是一个蛮好用的帮助理解代码的工具
[39:01.600 --> 39:07.600] 对我觉得可以就是把with tracer定位成一个工具箱
[39:07.600 --> 39:12.600] 就是帮助你去理解程序的这样一个工具箱
[39:12.600 --> 39:15.600] 然后你可以用来就profiling啊debugging啊
[39:15.600 --> 39:17.600] 或者就是单纯的想看一下他是怎么调用的
[39:17.600 --> 39:18.600] 都是可以的
[39:18.600 --> 39:19.600] 对吧
[39:19.600 --> 39:20.600] 对
[39:20.600 --> 39:20.600] 是的
[39:20.600 --> 39:21.600] 我就是这个想法
[39:21.600 --> 39:23.600] 我觉得这个定位很准确
[39:23.600 --> 39:23.600] 对
[39:23.600 --> 39:28.600] 我觉得其实你这个工具的野心也是挺大的
[39:28.600 --> 39:29.600] 对
[39:29.600 --> 39:33.600] 挺好的
[39:33.600 --> 39:34.600] OK
[39:34.600 --> 39:38.600] 那我们下面来聊一聊with tracer和其他一些工具的对比吧
[39:38.600 --> 39:41.600] 就我们像刚才也提到了pyflame啊
[39:41.600 --> 39:42.600] 然后这样一些工具
[39:42.600 --> 39:46.600] 然后那么还有哪些就是已经存在的
[39:46.600 --> 39:47.600] 比如说profiling啊
[39:47.600 --> 39:49.600] 或者debugging相关的工具呢
[39:49.600 --> 39:51.600] 高天你肯定也调研了不少
[39:51.600 --> 39:51.600] 对吧
[39:51.600 --> 39:52.600] 对
[39:52.600 --> 39:55.600] 确实是这个profiling这边呢
[39:55.600 --> 39:59.600] 就是python的纯profiling工具其实蛮多的
[39:59.600 --> 39:59.600] 呃
[39:59.600 --> 40:02.600] 大家最最最常用的肯定是cprofile
[40:02.600 --> 40:04.600] 因为cprofile是一个built-in的工具
[40:04.600 --> 40:05.600] 然后他也算是可以用吧
[40:05.600 --> 40:09.600] 然后还有cprofile衍生出来的一些virualization的工具
[40:09.600 --> 40:13.600] 就是把cprofile的数据给你给你变成一个一个图
[40:13.600 --> 40:16.600] 比如说我记得有graphiz吧
[40:16.600 --> 40:20.600] 然后还有这个runsnake run好像是还是snake runsnake
[40:20.600 --> 40:25.600] 就是呃有若干个呃把cprofile变成一个图的工具
[40:25.600 --> 40:32.600] 然后呃在cprofile之后呃又出现了一个就是我们知道profiling工具一般分为两种
[40:32.600 --> 40:35.600] 一种叫deterministic一种叫statistic
[40:35.600 --> 40:38.600] 就是一个是一个是确定的啊
[40:38.600 --> 40:39.600] 每一个点我都记录
[40:39.600 --> 40:41.600] 每一个函数我都记录的
[40:41.600 --> 40:45.600] 还有一种呢就是我去我去我去pull我去做那个
[40:45.600 --> 40:49.600] 我隔一段时间看一下跑在哪隔一段时间看一下跑在哪
[40:49.600 --> 40:50.600] 采样吗
[40:50.600 --> 40:53.600] 对对采样的sampling的这么一个方式
[40:53.600 --> 40:55.600] 他们两个呢就呃各有优劣
[40:55.600 --> 40:57.600] 这个deterministic更准确
[40:57.600 --> 41:01.600] 而且可以在时间很短的情况下给出一个profiling
[41:01.600 --> 41:03.600] 那么statistic呢他就是overhead更小
[41:03.600 --> 41:04.600] 因为他是sampling的
[41:04.600 --> 41:06.600] 他不需要每一个都每一个都弄
[41:06.600 --> 41:08.600] 然后在时间长的很长的情况下
[41:08.600 --> 41:12.600] 比如说这个函数运行了五分钟或者函数运行了五个礼拜
[41:12.600 --> 41:14.600] 那这种情况下他可以得到一个非常非常不错的数据
[41:14.600 --> 41:16.600] 在不太影响production的情况下
[41:16.600 --> 41:19.600] 所以说其实在呃如果是production code的话
[41:19.600 --> 41:22.600] 很多人更喜欢用statistic的那个profiling工具
[41:22.600 --> 41:27.600] 那么我我我我也是了解一些一下有点想不起名字来了
[41:27.600 --> 41:28.600] 我记得有几个很好
[41:28.600 --> 41:31.600] 有一个r开头的呃然后
[41:33.600 --> 41:36.600] pi instrument是不是也是那个什么的
[41:36.600 --> 41:38.600] 然后pi spy好像是呃
[41:38.600 --> 41:39.600] pi spy是的
[41:39.600 --> 41:41.600] 对statistic对
[41:41.600 --> 41:48.600] 所以说呃后面其实在c profile之后做那个专门做deterministic的profiling工具
[41:48.600 --> 41:50.600] 就是做底层的很少了
[41:50.600 --> 41:54.600] 基本上其他的profiler的卖点都是我比c profile快
[41:54.600 --> 41:57.600] 就基本上都是那个sampling的profiler
[41:57.600 --> 41:59.600] 然后呃像c profile也好
[41:59.600 --> 42:00.600] 包括那个pi spy也好
[42:00.600 --> 42:05.600] 包括就是大部分的很多很多那个呃这种呃profiling工具
[42:05.600 --> 42:07.600] 他们都是以函数为单位的
[42:07.600 --> 42:09.600] 呃就是这个函数占用时间多少
[42:09.600 --> 42:10.600] 这个函数占用时间多少
[42:10.600 --> 42:13.600] 当然也有一些就是以以行为单位的
[42:13.600 --> 42:15.600] 比如说最最常见就是line profiler
[42:15.600 --> 42:17.600] 这个是最常见的
[42:17.600 --> 42:19.600] 那个就是告诉你一行多长时间一行多长时间
[42:19.600 --> 42:25.600] 但是相对应的一般来说这种line profiler都是用的set trace
[42:25.600 --> 42:29.600] 而set trace这个东西的overhead是相当大的
[42:29.600 --> 42:31.600] 就是你可以想他就他们每行掉一个callback
[42:31.600 --> 42:32.600] 每行掉一个callback
[42:32.600 --> 42:34.600] 这个东西的overhead很大
[42:34.600 --> 42:38.600] 所以说他可能会给你一个比较呃基础的概念
[42:38.600 --> 42:42.600] 但是真正的如果你要每一个函数都用line profiler的话
[42:42.600 --> 42:45.600] 这个你这个程序本身会跑的非常非常慢
[42:45.600 --> 42:51.600] 那我们就说说这个同样作为deterministic的profiler
[42:51.600 --> 42:57.600] 然后呃像with tracer比c profile好在哪里呢
[42:57.600 --> 43:03.600] 呃with tracer跟c profile实际上呃展示的是一个呃不太一样的东西
[43:03.600 --> 43:07.600] c profile的数据最后是可以做成这个flame graph
[43:07.600 --> 43:11.600] 或者说c profile的这个最后展示的方式跟flame graph很像
[43:11.600 --> 43:16.600] 呃如果用我的话说我一般来说我我喜欢管他们叫一个summary
[43:16.600 --> 43:18.600] 就是它是一个总结
[43:18.600 --> 43:22.600] 呃用一个例子来说可能比如说是呃我吃饭我吃饭对吧
[43:22.600 --> 43:25.600] 然后我那个记录我这个我吃了什么饭
[43:25.600 --> 43:28.600] 然后c profile呢就像你吃了一个礼拜之后
[43:28.600 --> 43:31.600] 他告诉你你这一周摄入了多少碳纯化合物
[43:31.600 --> 43:35.600] 摄入了多少蛋白质摄入多少维生素摄入了多少这个摄入了多少那个
[43:35.600 --> 43:38.600] 然后你总体来说 哎 可能少吃点肥肉对吧
[43:38.600 --> 43:40.600] 就他是这么一个事情
[43:40.600 --> 43:42.600] 但是这个这个with tracer是什么呢
[43:42.600 --> 43:46.600] with tracer告诉你 你今天早饭吃了一个鸡蛋 喝了一碗粥
[43:46.600 --> 43:49.600] 今天午饭吃了一个巨无霸对吧 吃了一盒薯条
[43:49.600 --> 43:51.600] 今天晚饭吃了一块牛排
[43:51.600 --> 43:53.600] 那么with tracer有一个什么好处呢
[43:53.600 --> 43:57.600] 比如说你这周礼拜三的时候你晚上拉肚子了
[43:57.600 --> 44:00.600] 你就可以回去找 哎 我礼拜三晚上吃的什么
[44:00.600 --> 44:03.600] 礼拜二礼拜礼拜三中午吃的什么 礼拜三早上吃的什么
[44:03.600 --> 44:06.600] 但是c profile的话你要是告诉你礼拜三拉肚子了
[44:06.600 --> 44:10.600] 你是没有办法的 你只能说我这礼拜为什么长胖了
[44:10.600 --> 44:12.600] 你告诉你哦 你可能碳水摄入多了对吧
[44:12.600 --> 44:14.600] 或者这礼拜为什么我这么饿
[44:14.600 --> 44:15.600] 他告诉你能量摄入太少
[44:15.600 --> 44:18.600] 所以说他们两个其实是方向是一不是非常一致
[44:18.600 --> 44:22.600] 嗯嗯啊 我觉得这个比喻挺有意思的
[44:22.600 --> 44:24.600] 我觉得我一下就懂了
[44:24.600 --> 44:28.600] 然后你刚才其实提到一个很有意思的点
[44:28.600 --> 44:33.600] 就是说with tracer能够帮助你快速定位
[44:33.600 --> 44:35.600] 你的程序中某一个异常
[44:35.600 --> 44:37.600] 他的问题是出在哪里
[44:37.600 --> 44:43.600] 就是我知道这个也是你的一个在后期版本里面提到的一个卖点
[44:43.600 --> 44:45.600] 就是说比如说你有一个exception或者是一个
[44:45.600 --> 44:47.600] 就是什么异常
[44:47.600 --> 44:51.600] 然后你能够拿with tracer很快的来定位
[44:51.600 --> 44:53.600] 这个你要不要也讲一下
[44:53.600 --> 44:55.600] 对 这个是后期我加的一个feature
[44:55.600 --> 45:00.600] 当然了我们说的我们可以先聊最简单的就是真的exception
[45:00.600 --> 45:02.600] 就是某一个函数的一段代码raise了exception
[45:02.600 --> 45:04.600] 这个exception可能被catch了
[45:04.600 --> 45:06.600] 当然有可能是被故意catch了
[45:06.600 --> 45:08.600] 有可能是你自己写了一个try
[45:08.600 --> 45:10.600] 然后直接except把所有exception都catch了
[45:10.600 --> 45:11.600] 这个事情
[45:11.600 --> 45:16.600] 但是with tracer有一个能力是他可以在你raise exception之前
[45:16.600 --> 45:20.600] 直接给你打一个event在那告诉你这个位置raise了一个exception
[45:20.600 --> 45:22.600] 不管这个exception有没有被catch
[45:22.600 --> 45:26.600] 你都可以知道明确的这个时间点raise了一个exception
[45:26.600 --> 45:28.600] 它会是一个竖线长在那个
[45:28.600 --> 45:31.600] 长在你的这个UI上
[45:31.600 --> 45:33.600] 然后你就可以直接到那去
[45:33.600 --> 45:34.600] 然后你可以zoom in
[45:34.600 --> 45:36.600] 你看到是哪个函数raise这个exception
[45:36.600 --> 45:41.600] 然后它的cost tag是一个什么深度
[45:41.600 --> 45:43.600] 为什么会raise这个exception
[45:43.600 --> 45:45.600] 就能很明确的定位
[45:45.600 --> 45:46.600] OK 这个事情我出错了
[45:46.600 --> 45:48.600] 当然除了exception之外
[45:48.600 --> 45:50.600] 可能还有别的事情
[45:50.600 --> 45:52.600] 就是可能这个事情没有raise exception
[45:52.600 --> 45:54.600] 但是它也不是正确的
[45:54.600 --> 45:55.600] 对吧
[45:54.600 --> 45:56.600] 或者说我很想
[45:56.600 --> 45:58.600] 比如说我之前说的这个log variable
[45:58.600 --> 46:01.600] 就可能每一次这个variable被写入的时候
[46:01.600 --> 46:03.600] 都是一个关键的时间点
[46:03.600 --> 46:04.600] 就这个variable很重要
[46:04.600 --> 46:05.600] 每一次它被写入
[46:05.600 --> 46:07.600] 我都想知道是在什么时候发生的
[46:07.600 --> 46:10.600] 发生这件事情时候周围环境是什么样的
[46:10.600 --> 46:12.600] 其他的local variable是什么样的
[46:12.600 --> 46:14.600] 那么我也可以通过这个log variable
[46:14.600 --> 46:17.600] 然后找到每一次这个点被log的时候
[46:17.600 --> 46:19.600] 我可以zoom in去看
[46:19.600 --> 46:21.600] OK 我现在的这个cost tag是什么样的
[46:21.600 --> 46:22.600] 我之前进行了什么call
[46:22.600 --> 46:24.600] 我上面有什么call
[46:24.600 --> 46:26.600] 这些都能展示出来
[46:26.600 --> 46:29.600] 我这有一个疑问 高天老师
[46:29.600 --> 46:31.600] 因为我对这块底层不太了解
[46:31.600 --> 46:34.600] 就是刚才提到raise那个
[46:34.600 --> 46:35.600] 我比较感兴趣
[46:35.600 --> 46:36.600] 这个是怎么做到呢
[46:36.600 --> 46:40.600] 就是无论某个位置的raise
[46:40.600 --> 46:43.600] raise出来的exception有没有被捕获
[46:43.600 --> 46:44.600] 我们都可以知道
[46:44.600 --> 46:46.600] 它是哪个地方raise出来的
[46:46.600 --> 46:49.600] 是有什么
[46:49.600 --> 46:53.600] 它的这个log exception的原理
[46:53.600 --> 46:55.600] 跟log variable和log number的原理
[46:55.600 --> 46:56.600] 其实是一样的
[46:56.600 --> 46:59.600] 就是很多很多做这类似这方面的
[46:59.600 --> 47:01.600] 不管是py snooper还是很多
[47:01.600 --> 47:03.600] 他们实际上用的是set trace
[47:03.600 --> 47:05.600] 换句话说他们依然用的是一个callback
[47:05.600 --> 47:07.600] 就是用的是一个callback
[47:07.600 --> 47:09.600] 但是对于Viz tracer来说
[47:09.600 --> 47:12.600] 对于每一行都做一个callback代价太大了
[47:12.600 --> 47:14.600] 所以不管是py snooper还是什么
[47:14.600 --> 47:16.600] 他们一般都是让你先自己定位一个函数
[47:16.600 --> 47:19.600] 并且在原代码上写我要trace这个函数
[47:19.600 --> 47:20.600] 然后再trace这个函数
[47:20.600 --> 47:23.600] 但是Viz tracer想做的是不改原代码
[47:23.600 --> 47:25.600] 而每一行做callback又太
[47:25.600 --> 47:27.600] 时间又overhead又太大
[47:27.600 --> 47:29.600] 所以Viz tracer的方式是
[47:29.600 --> 47:30.600] 它在compile的时候
[47:30.600 --> 47:33.600] 它会先把它compile成ast
[47:33.600 --> 47:38.600] 然后在ast level找到variable被写入的地方
[47:38.600 --> 47:39.600] 然后去修改ast
[47:39.600 --> 47:42.600] 然后再compile成by code
[47:42.600 --> 47:47.600] 换句话说Viz tracer相当于帮你在那块打了一个print
[47:47.600 --> 47:52.600] 所以刚才我们提到race也是从ast里解析出来哪个地方有race
[47:52.600 --> 47:55.600] 然后我们去在那个地方去记录一下
[47:55.600 --> 47:57.600] 修改ok
[47:57.600 --> 48:00.600] 这个感觉很巧妙
[48:04.600 --> 48:10.600] 对其实cyberbrain也想过用类似的手段来追踪by code
[48:10.600 --> 48:15.600] 但是就是有个问题
[48:15.600 --> 48:18.600] 就是说因为追踪by code的时候
[48:18.600 --> 48:21.600] 它有一个那个字节码的offset的问题
[48:21.600 --> 48:22.600] 如果你改了
[48:22.600 --> 48:25.600] 比如说你插入了一些你自己的字节码
[48:25.600 --> 48:28.600] 然后它总会去改这个offset
[48:28.600 --> 48:31.600] 然后它可能会有一些edge case不是特别好处理
[48:31.600 --> 48:35.600] 然后就感觉就我也没有在多想
[48:35.600 --> 48:38.600] 但是就是我大概知道这个思路
[48:38.600 --> 48:41.600] 确实是一个非常好的优化手段
[48:41.600 --> 48:45.600] 这个如果你是直接在by code level去改的话
[48:45.600 --> 48:47.600] 确实会涉及到很麻烦的事情
[48:47.600 --> 48:49.600] 但如果是在ast level改的话
[48:49.600 --> 48:51.600] 它很多东西是帮你处理好的
[48:51.600 --> 48:54.600] 你相当于再重新把那个ast compile一遍就可以了
[48:54.600 --> 48:57.600] 所以你是没有我是没有写任何的by code的
[48:57.600 --> 49:01.600] 对但是如果你是只是因为你因为Viz tracer
[49:01.600 --> 49:03.600] 其实在tracing这方面做的比较简单
[49:03.600 --> 49:05.600] 它只是说你给它一个变量
[49:05.600 --> 49:08.600] 然后它能够去log或者说函数的入口出口
[49:08.600 --> 49:11.600] 就这种其实算是比较简单的
[49:11.600 --> 49:14.600] 就是cyberbrain它可能要做的事情更多一点
[49:14.600 --> 49:16.600] 就它要记录每一个操作
[49:16.600 --> 49:18.600] 所以就会更复杂
[49:18.600 --> 49:23.600] 对确实这个改ast这个事情还是说实话挺费劲的
[49:23.600 --> 49:25.600] 就是虽然Viz tracer做的确实也比较简单
[49:25.600 --> 49:28.600] 但是你就是在找然后加node
[49:28.600 --> 49:30.600] 然后加个什么node上面
[49:30.600 --> 49:32.600] 其实是挺费劲的
[49:32.600 --> 49:34.600] 如果cyberbrain做的更复杂的话
[49:34.600 --> 49:36.600] 那肯定可能会更费劲
[49:36.600 --> 49:40.600] Viz tracer当时选这个ast的一个最核心的原因
[49:40.600 --> 49:42.600] 就是我不想用那个set trace
[49:42.600 --> 49:45.600] 因为对整个函数set trace代价实在太大了
[49:45.600 --> 49:47.600] 所以就最后选了ast
[49:47.600 --> 49:50.600] 然后相当于是我在帮你写代码
[49:50.600 --> 49:51.600] 就这么个意思
[49:51.600 --> 49:57.600] 对对好那我看安东列了一个function trace
[49:57.600 --> 49:59.600] 然后说是你的前同事做的
[49:59.600 --> 50:00.600] 你来讲一下这个
[50:00.600 --> 50:01.600] 这个是我列的
[50:01.600 --> 50:04.600] 这个是这样
[50:04.600 --> 50:05.600] 这是我写的
[50:05.600 --> 50:10.600] 我在刚刚开始做Viz tracer的时候
[50:10.600 --> 50:11.600] 要先做进一步调研
[50:11.600 --> 50:13.600] 我要看这个东西有没有被做出来过
[50:13.600 --> 50:14.600] 然后我调研着调研着
[50:14.600 --> 50:15.600] 我发现了两个库
[50:15.600 --> 50:16.600] 一个叫function trace
[50:16.600 --> 50:19.600] 一个叫panopticon
[50:19.600 --> 50:22.600] 就是这两个库实际上都比我做的早
[50:22.600 --> 50:25.600] 然后他们俩做的东西跟我做的东西
[50:25.600 --> 50:27.600] 可以说几乎是一模一样的
[50:27.600 --> 50:30.600] 就是在原理上几乎是一模一样的
[50:30.600 --> 50:33.600] 都是展示的内容都是完全一样的
[50:33.600 --> 50:36.600] 然后但是当时我还是毅然决然的做了下去
[50:36.600 --> 50:40.600] 但是现在这两个库都跟Viz tracer差距比较大了
[50:40.600 --> 50:42.600] 就是function trace
[50:42.600 --> 50:45.600] 它的前端用的是mozilla的一个前端
[50:45.600 --> 50:48.600] 那个前端是本来是展示火焰图的
[50:48.600 --> 50:49.600] 所以在展示trace的时候
[50:49.600 --> 50:50.600] 效果并不是很好
[50:50.600 --> 50:51.600] 而且function trace
[50:51.600 --> 50:55.600] 他用了一个比较复杂的trace的手段
[50:55.600 --> 50:56.600] 然后很不灵活
[50:56.600 --> 51:02.600] 然后panopticon是他就是基本上就是我之前在说的
[51:02.600 --> 51:04.600] 每个人都可以做的小玩具的概念
[51:04.600 --> 51:06.600] 就是他是用python的东西
[51:06.600 --> 51:08.600] 然后做了一个set profile
[51:08.600 --> 51:09.600] 然后打几个点
[51:09.600 --> 51:11.600] 然后输出的格式跟我是一样的
[51:11.600 --> 51:13.600] 也是做的chrome输出
[51:13.600 --> 51:15.600] 但是他那个东西就是相当于一个玩具
[51:15.600 --> 51:16.600] 就是玩一玩还行
[51:16.600 --> 51:18.600] 但是真正用起来就没法用
[51:18.600 --> 51:20.600] 比较好玩的一个点
[51:20.600 --> 51:23.600] 就是function trace这个事情
[51:23.600 --> 51:27.600] 是我的两个之前在greenhouse一起工作的同事做的
[51:27.600 --> 51:30.600] 就是是他们两个人做了function trace
[51:30.600 --> 51:32.600] 大概比我做vstracer早半年多吧
[51:32.600 --> 51:34.600] 他们两个做的function trace
[51:34.600 --> 51:35.600] 那么这是一个很巧的事情
[51:35.600 --> 51:38.600] 因为整个市面上呃类似的这个项目
[51:38.600 --> 51:40.600] 我就只找除了vstracer之外
[51:40.600 --> 51:41.600] 我就只找到这两个
[51:41.600 --> 51:43.600] 其中有一个人就是之前我两个同事做的
[51:43.600 --> 51:47.600] 我觉得有一个原因是因为我们公司自己内部
[51:47.600 --> 51:49.600] 有一个这么个工具
[51:49.600 --> 51:51.600] 这个工具是就商业化的工具是卖钱的
[51:51.600 --> 51:53.600] 然后那工具非常非常非常非常强大
[51:53.600 --> 51:56.600] 就是配合上我们公司的很多呃debug什么东西
[51:56.600 --> 51:57.600] 他很强大
[51:57.600 --> 52:01.600] 然后但是他的核心理念就这也是他其中很重要的一个理念
[52:01.600 --> 52:03.600] 就是这个函数的entry exit
[52:03.600 --> 52:07.600] 所以我猜测他们可能也是用公司那个用了很久
[52:07.600 --> 52:10.600] 然后就说ok我做一个python的做一个差不多的
[52:10.600 --> 52:12.600] 所以我感觉应该是这样的
[52:12.600 --> 52:15.600] 所以就是恰好就做了同样的东西
[52:15.600 --> 52:19.600] 嗯是是有可能你们那个是profile c++的吗
[52:19.600 --> 52:21.600] 我们那个是对c跟c++
[52:21.600 --> 52:24.600] 那个也是那个就比profile要强太多了
[52:24.600 --> 52:27.600] 就是那个那个工具真的是就是强大到有点可怕
[52:27.600 --> 52:34.600] 就是呃因为我们公司是从os然后做compiler做debugger的
[52:34.600 --> 52:37.600] 所以我们是全套工具都是自己的
[52:37.600 --> 52:42.600] 然后所以在那个各种的优化和feature上面可以做的特别的极端
[52:42.600 --> 52:47.600] 比如说我们现在有我不知道你们熟不熟悉什么叫这个呃这个backward debugging
[52:47.600 --> 52:52.600] 就是GDB曾经出过一个不太能用的这么一个prototype
[52:52.600 --> 52:54.600] 就可以往回跑的程序
[52:54.600 --> 52:56.600] 就是你在一个点之后你可以往回跑看之前发生什么
[52:56.600 --> 52:59.600] 然后再往后跑再往回跑再往后跑来回来去这么跑
[52:59.600 --> 53:01.600] 呃我们公司的debugger是可以做到这件事
[53:01.600 --> 53:03.600] 当然这件事已经是十年前的事了
[53:03.600 --> 53:09.600] 但是呃那个呃我们公司的那个那个那个图就是相当于点开之后
[53:09.600 --> 53:13.600] 你可以随时双击某一个timestamp双击那个时候
[53:13.600 --> 53:16.600] 然后他就会直接把你带回到那个状态下
[53:16.600 --> 53:18.600] 就你就直接开debugger了
[53:18.600 --> 53:22.600] 就是直接debugger就到那个状态下告诉你那个状态要什么
[53:22.600 --> 53:24.600] 然后你就可以从那个点开始往前run
[53:24.600 --> 53:26.600] 可以single step可以run什么的
[53:26.600 --> 53:29.600] 然后就是整个联动起来那个东西非常非常强
[53:29.600 --> 53:32.600] 呃我感觉那个和就是cyberbrain的理念挺像的
[53:32.600 --> 53:33.600] 对
[53:33.600 --> 53:35.600] 有有点像吧
[53:35.600 --> 53:42.600] 但我我知道python领域也有一些就是这种做那叫什么backward debugging的这种工具
[53:42.600 --> 53:47.600] 好像呃有有见到过一些但都比较不成熟吧
[53:47.600 --> 53:51.600] 基本上对这个就是细节就特别特别多
[53:51.600 --> 53:53.600] 如果你真的是一个人坐着玩的话
[53:53.600 --> 53:55.600] 很难就做到特别全面
[53:55.600 --> 53:56.600] 嗯
[53:56.600 --> 54:00.600] 那你们公司这个商业产品叫什么呢
[54:00.600 --> 54:07.600] 呃我现在我我我现在确定他已经过了NDA的期了
[54:07.600 --> 54:10.600] 但是我不确定他在市面上的呃名字
[54:10.600 --> 54:12.600] 因为这个这个东西比较比较近
[54:12.600 --> 54:15.600] 我不确定他现在卖的时候的确切的名字叫什么
[54:15.600 --> 54:17.600] 我们在内部经常买的
[54:17.600 --> 54:19.600] 对是是是卖钱的
[54:19.600 --> 54:21.600] 哦叫什么history
[54:21.600 --> 54:24.600] 呃我们我们一般我们在内部管他叫history
[54:24.600 --> 54:29.600] 但是后来他应该叫呃debug snapshot好像叫正式的名字
[54:29.600 --> 54:31.600] ok ok
[54:31.600 --> 54:32.600] 嗯
[54:33.600 --> 54:34.600] 啊
[54:34.600 --> 54:35.600] 哦
[54:35.600 --> 54:36.600] 你离职了吗
[54:36.600 --> 54:38.600] 还是你刚说没有啊
[54:38.600 --> 54:40.600] 哦那你说过NDA是指
[54:40.600 --> 54:44.600] 不是就是那个呃呃在这个工具刚刚出来的时候
[54:44.600 --> 54:45.600] 因为我们公司要申请专利
[54:45.600 --> 54:47.600] 所以我们是不可以聊这个东西的
[54:47.600 --> 54:48.600] ok ok 理解
[54:49.600 --> 54:50.600] 好
[54:50.600 --> 54:56.600] 呃那就刚才提到了就是那个公司内部有一个类似工具
[54:56.600 --> 54:59.600] 然后呃这个是提一个挺好玩的事情
[54:59.600 --> 55:04.600] 那呃就还有一个挺好玩的事就是呃
[55:04.600 --> 55:08.600] 然后高铁你之前把with tracer改名了
[55:08.600 --> 55:09.600] 对吧
[55:09.600 --> 55:11.600] 不对应该是改名为with tracer了
[55:11.600 --> 55:13.600] 对嗯呃这就像我刚才说了
[55:13.600 --> 55:15.600] 刚才你问我那个工具叫什么
[55:15.600 --> 55:18.600] 他的现在official的那个名应该是debug snapshot
[55:18.600 --> 55:20.600] 就是snap就是他的他的意思就是说
[55:20.600 --> 55:23.600] 我在这个位置你可以随时回到当当时的情况去
[55:23.600 --> 55:25.600] 所以后来我在做这个工具的时候
[55:25.600 --> 55:26.600] 我就想ok我叫什么名字呢
[55:26.600 --> 55:28.600] 然后我就说我那我叫code snap吧
[55:28.600 --> 55:29.600] 就是code是代码吧
[55:29.600 --> 55:31.600] 然后snap就是去snapshot的意思
[55:31.600 --> 55:32.600] 就是说ok
[55:32.600 --> 55:34.600] 我给你那个相当于拍了一张照
[55:34.600 --> 55:36.600] with tracer本身相当于是一个录影吗
[55:36.600 --> 55:38.600] 相当于是一个拍电影的感觉
[55:38.600 --> 55:39.600] 录完之后
[55:39.600 --> 55:40.600] 然后你想看哪
[55:40.600 --> 55:41.600] 然后都有各式的记录
[55:41.600 --> 55:43.600] 我说好那叫code snap
[55:43.600 --> 55:47.600] 然后code snap我大概呃这个做了两三个三四个版本
[55:47.600 --> 55:50.600] 然后那个能做到就大概现在的那个
[55:50.600 --> 55:52.600] 我之前说的那个拍到那个小toy的那个水准
[55:52.600 --> 55:53.600] 然后做到那之后呢
[55:53.600 --> 55:54.600] 然后我就开始说ok
[55:54.600 --> 55:56.600] 我可能需要呃宣传一下啊
[55:56.600 --> 56:00.600] 或者说我要看一看那个怎么怎么让更多人用它
[56:00.600 --> 56:02.600] 然后就开始googlecode snap
[56:02.600 --> 56:03.600] 然后一google呢
[56:03.600 --> 56:05.600] 发现哎有这么个东西
[56:05.600 --> 56:09.600] 然后有就是一google出来的是一个vs code的一个这个这个这个工具
[56:09.600 --> 56:11.600] 然后他就叫code snap
[56:11.600 --> 56:13.600] 然后关键是这个vs code的工具呢
[56:13.600 --> 56:14.600] 还不是就是巨冷门
[56:14.600 --> 56:15.600] 完全没有人用那种
[56:15.600 --> 56:17.600] 我记得当时有一两万下载量吧
[56:17.600 --> 56:19.600] 大概就是有些人用
[56:19.600 --> 56:21.600] 然后关键他这个功能呢
[56:21.600 --> 56:23.600] 就是他真的就是code snap
[56:23.600 --> 56:26.600] 他是给他的那个呃代码拍张照
[56:26.600 --> 56:28.600] 就是将来截图代码截图工具
[56:28.600 --> 56:32.600] 然后我想哎他用这个名可比我用这个名要合理多了
[56:32.600 --> 56:35.600] 就是人是正儿八经的给那个代码照相的
[56:35.600 --> 56:36.600] 我说不行
[56:36.600 --> 56:37.600] 那我得换个名
[56:37.600 --> 56:38.600] 然后我说我换一个名
[56:38.600 --> 56:39.600] 一定不能跟人重名了
[56:39.600 --> 56:41.600] 因为我这个工具刚开始做嘛
[56:41.600 --> 56:42.600] 跟人重名了
[56:42.600 --> 56:44.600] 你就会觉得哎非常非常不爽
[56:44.600 --> 56:45.600] 然后想了好多好多名
[56:45.600 --> 56:46.600] 好多好多名
[56:46.600 --> 56:49.600] 然后发现这个好听的名字都被人之前起差不多了
[56:49.600 --> 56:51.600] 然后要不然就是有人就是做了一些东西
[56:51.600 --> 56:53.600] 要不然就是有一人霸占着名字
[56:53.600 --> 56:54.600] 然后什么都没有做
[56:54.600 --> 56:56.600] 就相当于什么那个拍屁
[56:56.600 --> 56:57.600] 然后就只有一个名字挂在那
[56:57.600 --> 56:58.600] 然后版本0.0.1
[56:58.600 --> 56:59.600] 然后里面什么都没有
[56:59.600 --> 57:02.600] 这种可特别可恶这种
[57:02.600 --> 57:04.600] 对就是这就很难受
[57:04.600 --> 57:05.600] 然后后来想了半天
[57:05.600 --> 57:06.600] 想了半天
[57:06.600 --> 57:08.600] 然后想哎这个这Viz Tracer这个名字
[57:08.600 --> 57:10.600] 总体来说它是一个比较general的东西
[57:10.600 --> 57:11.600] 因为我当然可以
[57:11.600 --> 57:13.600] 比如说我自己叫天Tracer对吧
[57:13.600 --> 57:14.600] 我就把我自己名字写上
[57:14.600 --> 57:17.600] 但是感觉好像稍微差点意思
[57:17.600 --> 57:18.600] 但这个总体上名字
[57:18.600 --> 57:19.600] 你一看这个名字
[57:19.600 --> 57:20.600] 你大概能猜到个两三分
[57:20.600 --> 57:22.600] 这个东西是干嘛的
[57:22.600 --> 57:23.600] 然后这个名字
[57:23.600 --> 57:24.600] 我当时起的时候
[57:24.600 --> 57:26.600] 没有任何其他的项目叫这个东西
[57:26.600 --> 57:28.600] 然后就还是比较独特的
[57:28.600 --> 57:30.600] 所以看到它基本上就是我的项目
[57:30.600 --> 57:31.600] 我说OK那叫Viz Tracer吧
[57:31.600 --> 57:32.600] 然后从那个时候开始
[57:32.600 --> 57:34.600] 一直到现在它都叫Viz Tracer
[57:34.600 --> 57:35.600] 未来应该不会改名了
[57:35.600 --> 57:38.600] 嗯嗯对就改名
[57:38.600 --> 57:39.600] 这个事情真的挺有意思
[57:39.600 --> 57:41.600] 尤其是你作为一个开源项目
[57:41.600 --> 57:42.600] 我不知道你有没有听
[57:42.600 --> 57:43.600] 我们和力挡聊的那期
[57:43.600 --> 57:46.600] 他的那个项目不是叫Hedgehog Lab吗
[57:46.600 --> 57:48.600] 就是刺猬实验室
[57:48.600 --> 57:50.600] 然后但是那个Hedgehog Lab
[57:50.600 --> 57:52.600] 是一个外包公司的名字吧
[57:52.600 --> 57:55.600] 然后我还知道
[57:55.600 --> 57:56.600] Hedgehog Lab
[57:56.600 --> 57:58.600] 第一个结果是这个公司
[57:58.600 --> 58:00.600] 不是他这个工具就很尴尬
[58:00.600 --> 58:02.600] 对对我真的觉得这件事
[58:02.600 --> 58:04.600] 其实在因为我们刚开始
[58:04.600 --> 58:05.600] 像我们这种就程序员脑子的人
[58:05.600 --> 58:06.600] 刚开始做的时候
[58:06.600 --> 58:08.600] 总想说OK我把这个项目做出来
[58:08.600 --> 58:09.600] 我把这项目做到能用
[58:09.600 --> 58:10.600] 然后就怎么怎么着
[58:10.600 --> 58:12.600] 然后但是起名这个事吧
[58:12.600 --> 58:14.600] 就是你刚开始就总在我随便起个名
[58:14.600 --> 58:15.600] 但是随便起个名
[58:15.600 --> 58:17.600] 后来改名其实有点费劲
[58:17.600 --> 58:19.600] 所以我觉得还是挺重要的
[58:19.600 --> 58:21.600] 还是挺重要的
[58:21.600 --> 58:23.600] 我其实和你是恰恰相反
[58:23.600 --> 58:26.600] 是先我的名字都是反复深思熟虑
[58:26.600 --> 58:28.600] 先弄好然后再开始做项目
[58:28.600 --> 58:30.600] 就是这样的
[58:32.600 --> 58:34.600] 那还有一个有意思小故事
[58:34.600 --> 58:37.600] 就是我看到你写你用VisTracer
[58:37.600 --> 58:39.600] 把一个实际的程序
[58:39.600 --> 58:42.600] 在一小时内性能提升了900%对吧
[58:42.600 --> 58:45.600] 对这个事也是当时我在想办法
[58:45.600 --> 58:46.600] 宣传VisTracer的时候
[58:46.600 --> 58:47.600] 我说我怎么宣传呢
[58:47.600 --> 58:49.600] 我最好的办法就是我拿一个例子来
[58:49.600 --> 58:50.600] 我拿一个程序来
[58:50.600 --> 58:51.600] 我用VisTracer跑一下
[58:51.600 --> 58:52.600] 然后把它的性能提升上去
[58:52.600 --> 58:54.600] 这不就是一个很好的宣传吗
[58:54.600 --> 58:56.600] 所以我记得我当时是在
[58:56.600 --> 58:57.600] 不是stackoverflow
[58:57.600 --> 58:58.600] 是另外一个平台
[58:58.600 --> 58:59.600] 然后有一个人问
[58:59.600 --> 59:01.600] 就是我记得叫code review
[59:01.600 --> 59:03.600] 就是stackoverflow下面的一个平台
[59:03.600 --> 59:06.600] 然后有一个code review的板块
[59:06.600 --> 59:07.600] 然后有一个人发了一个
[59:07.600 --> 59:08.600] 他的数读程序
[59:08.600 --> 59:09.600] 他发了一个数读程序说
[59:09.600 --> 59:12.600] 有没有人可以把我数读程序变得更好
[59:12.600 --> 59:14.600] 我说这是个好机会对不对
[59:14.600 --> 59:16.600] 然后我就把数读程序下下来
[59:16.600 --> 59:17.600] 然后我用VisTracer跑了一下
[59:17.600 --> 59:19.600] 然后我记得我还发现了一个bug
[59:19.600 --> 59:20.600] 虽然我不记得什么bug了
[59:20.600 --> 59:21.600] 但是我发现了一个bug
[59:21.600 --> 59:23.600] 然后把那个bug先修复了
[59:23.600 --> 59:24.600] 然后我VisTracer跑了一下
[59:24.600 --> 59:26.600] 然后在当时我的感觉是
[59:26.600 --> 59:27.600] VisTracer确实是管用的
[59:27.600 --> 59:29.600] 就是当时也是增加了一些我的信念
[59:29.600 --> 59:30.600] 因为跑完之后
[59:30.600 --> 59:32.600] 你非常非常明确
[59:32.600 --> 59:34.600] 到底什么地方在花时间
[59:34.600 --> 59:35.600] 就是他很直观
[59:35.600 --> 59:37.600] 然后你进那个花时间的地方
[59:37.600 --> 59:40.600] 还有一个很重要的点
[59:40.600 --> 59:43.600] 就是我们很多时候做profiling
[59:43.600 --> 59:45.600] 做这个代码的optimization
[59:45.600 --> 59:48.600] 是这个optimize我们自己的代码
[59:48.600 --> 59:50.600] 是我们非常非常熟悉的代码
[59:50.600 --> 59:51.600] 这是一个概念
[59:51.600 --> 59:53.600] 但是当我们面临一个陌生代码
[59:53.600 --> 59:55.600] 我们要把它变得更好的时候
[59:55.600 --> 59:56.600] 这是另外一个概念
[59:56.600 --> 59:59.600] VisTracer可以让你非常非常迅速的
[59:59.600 --> 01:00:01.600] 大概理解这个陌生的代码
[01:00:01.600 --> 01:00:02.600] 是怎么工作的
[01:00:02.600 --> 01:00:03.600] 同时这个陌生的代码
[01:00:03.600 --> 01:00:05.600] 它哪一部分是你需要着重看的
[01:00:05.600 --> 01:00:07.600] 所以我在做这个
[01:00:07.600 --> 01:00:09.600] 他那个数读的优化的时候
[01:00:09.600 --> 01:00:11.600] 他的大部分的代码我看都没看
[01:00:11.600 --> 01:00:13.600] 就我根本不在乎他们是在干嘛
[01:00:13.600 --> 01:00:15.600] 我只需要找到那个
[01:00:15.600 --> 01:00:16.600] 我认为重要的部分
[01:00:16.600 --> 01:00:17.600] 然后去想OK
[01:00:17.600 --> 01:00:18.600] 这个部分我可以怎么优化
[01:00:18.600 --> 01:00:21.600] 然后可以去扎进去去想
[01:00:21.600 --> 01:00:23.600] OK这个for loop怎么怎么着
[01:00:23.600 --> 01:00:25.600] 当然他犯了一些比较愚蠢的错误
[01:00:25.600 --> 01:00:26.600] 所以我才能提升这么多
[01:00:26.600 --> 01:00:29.600] 就是他可能也是
[01:00:29.600 --> 01:00:30.600] 第一个是可能没有特别认真写
[01:00:30.600 --> 01:00:31.600] 第二个可能是新手
[01:00:31.600 --> 01:00:32.600] 写一个数读试一试
[01:00:32.600 --> 01:00:33.600] 所以他很多
[01:00:33.600 --> 01:00:35.600] 其实比如他有一些for loop
[01:00:35.600 --> 01:00:36.600] 本来可以做n变
[01:00:36.600 --> 01:00:37.600] 他做了n方变
[01:00:37.600 --> 01:00:38.600] 就是有一些这种错误
[01:00:38.600 --> 01:00:41.600] 但是你是能VisTracer可以让你
[01:00:41.600 --> 01:00:42.600] 尽快的定位到
[01:00:42.600 --> 01:00:45.600] 你改这些错误能带来影响的位置
[01:00:45.600 --> 01:00:47.600] 然后你再修改这些错误
[01:00:47.600 --> 01:00:48.600] 因为在很多地方
[01:00:48.600 --> 01:00:50.600] 你可能都会犯这种n到n方的错误
[01:00:50.600 --> 01:00:51.600] 但是那个函数
[01:00:51.600 --> 01:00:52.600] 可能压根就不影响
[01:00:52.600 --> 01:00:53.600] 不影响大局
[01:00:53.600 --> 01:00:56.600] 那个函数可能本身占的时间只有0.1%
[01:00:56.600 --> 01:00:59.600] 你把n方变成1还是0.1%
[01:00:59.600 --> 01:01:01.600] 而有一些函数可能占80%
[01:01:01.600 --> 01:01:02.600] 你把n方变n的时候
[01:01:02.600 --> 01:01:04.600] 他就会提升非常非常多
[01:01:04.600 --> 01:01:06.600] 所以我基本上就是用VisTracer
[01:01:06.600 --> 01:01:08.600] 做了一些profiling
[01:01:08.600 --> 01:01:10.600] 然后找到了一些bottleneck
[01:01:10.600 --> 01:01:11.600] 然后改了一些
[01:01:11.600 --> 01:01:12.600] 其实蛮简单的事情
[01:01:12.600 --> 01:01:13.600] 基本上都是把n方变n
[01:01:13.600 --> 01:01:15.600] 或者n变1这种东西
[01:01:15.600 --> 01:01:17.600] 然后一个小时大概提升了900%的速度
[01:01:17.600 --> 01:01:20.600] 我突然有个想法
[01:01:20.600 --> 01:01:23.600] 你能不能把这个和那个lead code结合起来
[01:01:23.600 --> 01:01:25.600] 就是我一段程序啪一点
[01:01:25.600 --> 01:01:27.600] 然后VisTracer一个图就出来
[01:01:27.600 --> 01:01:28.600] 到底哪里慢
[01:01:28.600 --> 01:01:29.600] 然后对吧
[01:01:29.600 --> 01:01:31.600] 直接优化
[01:01:31.600 --> 01:01:32.600] 很好的思路
[01:01:32.600 --> 01:01:35.600] 而lead code全是CPU操作
[01:01:35.600 --> 01:01:36.600] 对啊
[01:01:36.600 --> 01:01:37.600] 确实是
[01:01:37.600 --> 01:01:39.600] 你这个思路还蛮有趣的
[01:01:39.600 --> 01:01:41.600] 对这思路蛮有趣的
[01:01:41.600 --> 01:01:43.600] 可以跟lead code结合起来
[01:01:43.600 --> 01:01:45.600] 一个极大的败点
[01:01:45.600 --> 01:01:49.600] 而且你都是在chrome里的话
[01:01:49.600 --> 01:01:50.600] 我感觉也
[01:01:50.600 --> 01:01:53.600] 说不定有办法也是直接在
[01:01:53.600 --> 01:01:55.600] 就可以在浏览器里做
[01:01:55.600 --> 01:01:56.600] 或者怎么样
[01:01:56.600 --> 01:01:58.600] 还是需要一个Python运行环境
[01:01:58.600 --> 01:02:01.600] 就是你肯定用JavaScript估计很难
[01:02:01.600 --> 01:02:03.600] 你需要一个Python的运行环境
[01:02:03.600 --> 01:02:04.600] 然后再展示
[01:02:04.600 --> 01:02:08.600] 除非说lead code的backend愿意用VisTracer
[01:02:08.600 --> 01:02:11.600] 就是他跑完你的代码之后
[01:02:11.600 --> 01:02:12.600] 然后VisTracer跑一下
[01:02:12.600 --> 01:02:13.600] 然后给你开开
[01:02:15.600 --> 01:02:18.600] 有一些那种就是在线的代码运行环境
[01:02:18.600 --> 01:02:20.600] 就是像最有名的
[01:02:20.600 --> 01:02:23.600] 那个就是replit
[01:02:23.600 --> 01:02:26.600] 那个东西也不能随便加包吧
[01:02:27.600 --> 01:02:29.600] 他现在好像是可以的
[01:02:29.600 --> 01:02:31.600] 然后并且我最近有在用一个叫做
[01:02:31.600 --> 01:02:34.600] 那个gitpod
[01:02:34.600 --> 01:02:37.600] 就是git然后pod
[01:02:37.600 --> 01:02:40.600] 那个是一个就是完全的在线ide
[01:02:40.600 --> 01:02:41.600] 那个东西非常好用
[01:02:41.600 --> 01:02:44.600] 所以之后你也可以调研一下
[01:02:44.600 --> 01:02:47.600] 就是我用那个做了一个cyberbrain的online demo
[01:02:47.600 --> 01:02:50.600] 就是用户不需要在本地装任何东西
[01:02:50.600 --> 01:02:51.600] 直接在浏览器里就可以
[01:02:51.600 --> 01:02:52.600] 就能运行cyberbrain
[01:02:52.600 --> 01:02:53.600] 然后看到效果
[01:02:53.600 --> 01:02:55.600] 我觉得那个还挺方便的
[01:02:55.600 --> 01:02:57.600] 这思路还蛮有趣的
[01:02:57.600 --> 01:03:00.600] 其实lead code的那个确实挺好玩的
[01:03:00.600 --> 01:03:01.600] 对
[01:03:01.600 --> 01:03:02.600] OK
[01:03:02.600 --> 01:03:03.600] 那我们下面来问一下
[01:03:03.600 --> 01:03:07.600] 你在做VisTracer中遇到的最大的挑战有哪些
[01:03:07.600 --> 01:03:09.600] 第一个
[01:03:09.600 --> 01:03:11.600] 第一个就是因为我当时做VisTracer的时候
[01:03:11.600 --> 01:03:14.600] 我就想不把它做成一个toy
[01:03:14.600 --> 01:03:15.600] 就不把它做成一个玩具
[01:03:15.600 --> 01:03:18.600] 所以说性能优化一直是比较重要的一部分
[01:03:18.600 --> 01:03:21.600] 性能优化第一个最最重要的东西
[01:03:21.600 --> 01:03:24.600] 我觉得就是用C把core的部分重写了
[01:03:24.600 --> 01:03:26.600] 很多事情在pattern上其实挺简单的
[01:03:26.600 --> 01:03:28.600] 用C的话就稍微复杂一点
[01:03:28.600 --> 01:03:29.600] 不光是callback
[01:03:29.600 --> 01:03:35.600] 就是我里面凡是在callback里面需要进行的运算
[01:03:35.600 --> 01:03:36.600] 全是C写的
[01:03:36.600 --> 01:03:37.600] 所以C写的还蛮多的
[01:03:37.600 --> 01:03:40.600] 然后那个时候把performance提升了大概有一二十倍
[01:03:40.600 --> 01:03:41.600] 第二个呢
[01:03:41.600 --> 01:03:44.600] 就是比如说filter
[01:03:44.600 --> 01:03:45.600] 就是可以
[01:03:45.600 --> 01:03:51.600] 因为如果你真的用VisTracer跑了一个相对来说比较大的程序的话
[01:03:51.600 --> 01:03:54.600] 你会知道产生的那个log是非常非常大的
[01:03:54.600 --> 01:03:59.600] 就是因为VisTracer是每一个function的entry都是一个节点
[01:03:59.600 --> 01:04:01.600] 都要单独的记录
[01:04:01.600 --> 01:04:03.600] 所以产生的那个log是非常大的
[01:04:03.600 --> 01:04:04.600] 那么在
[01:04:04.600 --> 01:04:06.600] 在你真正使用的过程中
[01:04:06.600 --> 01:04:08.600] 怎么减小减小这个log
[01:04:08.600 --> 01:04:11.600] 怎么减小log的disk space
[01:04:11.600 --> 01:04:13.600] 因为如果你log两个t的话
[01:04:13.600 --> 01:04:14.600] 这个东西还是很难用
[01:04:14.600 --> 01:04:19.600] 怎么减小这个log的disk space也是很重要的优化的部分
[01:04:19.600 --> 01:04:21.600] 就是对于一个production level的东西来说的话
[01:04:21.600 --> 01:04:23.600] 那么filter是其中一个
[01:04:23.600 --> 01:04:26.600] 就是说我可以不感兴趣的东西不要
[01:04:26.600 --> 01:04:27.600] 这样的话你不就少了吗
[01:04:27.600 --> 01:04:29.600] 这个东西也对速度是有帮助的
[01:04:29.600 --> 01:04:31.600] 你可以把一些不感兴趣的function全都filter掉
[01:04:31.600 --> 01:04:34.600] 那么我之前说到的那个把2变1
[01:04:34.600 --> 01:04:35.600] 其实那也是个挺明确的优化
[01:04:35.600 --> 01:04:36.600] 那个是一个乘2的优化
[01:04:36.600 --> 01:04:38.600] 就是本来你是log开始结束
[01:04:38.600 --> 01:04:40.600] 现在你只需要log一整个
[01:04:40.600 --> 01:04:43.600] 然后duration跟那个start time就可以了
[01:04:43.600 --> 01:04:44.600] 因为那个
[01:04:44.600 --> 01:04:47.600] 如果你看一下那个chrome trace event的话
[01:04:47.600 --> 01:04:49.600] 你会发现那里面很大的一部分name
[01:04:49.600 --> 01:04:50.600] 要占挺大的一个比例
[01:04:50.600 --> 01:04:53.600] 所以你name只写一次和写两次就差挺多的
[01:04:53.600 --> 01:04:55.600] 然后还有一个呢
[01:04:55.600 --> 01:04:57.600] 就是我在做着做着的时候
[01:04:57.600 --> 01:05:00.600] 我大概做到0.2还是0.3的时候
[01:05:00.600 --> 01:05:01.600] 我突然发现一个事情
[01:05:01.600 --> 01:05:04.600] 就是说当我真正跑一个需要运行
[01:05:04.600 --> 01:05:05.600] 好多好多秒
[01:05:05.600 --> 01:05:07.600] 比如说20秒30秒一分钟
[01:05:07.600 --> 01:05:10.600] 然后有大量的函数运行的程序的时候
[01:05:10.600 --> 01:05:12.600] 我会直接把内存爆掉
[01:05:12.600 --> 01:05:14.600] 就是因为记录的log实在太多了
[01:05:14.600 --> 01:05:15.600] 反正内存爆掉
[01:05:15.600 --> 01:05:16.600] 就算不爆内存
[01:05:16.600 --> 01:05:19.600] 我产生的那个log可能是gb级别的
[01:05:19.600 --> 01:05:22.600] gb级别的log用那个trace viewer打开的时候
[01:05:22.600 --> 01:05:24.600] 经常会把浏览器搞爆
[01:05:24.600 --> 01:05:26.600] 就是数据量实在太大了
[01:05:26.600 --> 01:05:27.600] 然后后来呢
[01:05:27.600 --> 01:05:29.600] 我就说ok我一定要把这件事从动
[01:05:29.600 --> 01:05:31.600] 因为没有任何一个人会想
[01:05:31.600 --> 01:05:32.600] 我跑了一个30分钟的程序
[01:05:32.600 --> 01:05:34.600] 然后或者说跑了哪怕30秒的程序
[01:05:34.600 --> 01:05:36.600] 跑完之后这个东西
[01:05:36.600 --> 01:05:38.600] 他log产生不出来
[01:05:38.600 --> 01:05:39.600] 他写的巨慢
[01:05:39.600 --> 01:05:41.600] 或者是好不容易产生出来就打不开
[01:05:41.600 --> 01:05:42.600] 然后我说ok
[01:05:42.600 --> 01:05:46.600] 那我决定我就是把当时的linklist buffer
[01:05:46.600 --> 01:05:48.600] 直接就变成了一个circular buffer
[01:05:48.600 --> 01:05:52.600] 变成了一个后面出现的东西
[01:05:52.600 --> 01:05:55.600] 可以把前面给取代掉
[01:05:55.600 --> 01:05:56.600] 这样的话
[01:05:56.600 --> 01:05:58.600] 我这个程序可以运行任意长时间
[01:05:58.600 --> 01:06:00.600] 我可以保证你memory不爆
[01:06:00.600 --> 01:06:01.600] 就你运行两天
[01:06:01.600 --> 01:06:03.600] 你也不会把自己的memory弄爆
[01:06:03.600 --> 01:06:05.600] 然后你两天结束之后一关
[01:06:05.600 --> 01:06:08.600] 你可以看到最新发生的事情
[01:06:08.600 --> 01:06:10.600] 你可以看到最latest的事情
[01:06:10.600 --> 01:06:13.600] 这个经常是相对来说比较关心的
[01:06:13.600 --> 01:06:15.600] 比如说我这个程序
[01:06:15.600 --> 01:06:19.600] 我就是规定他一旦hit了某一个情况
[01:06:19.600 --> 01:06:22.600] 比如说我认为这个function不应该被call
[01:06:22.600 --> 01:06:24.600] 可能只有1%的几率
[01:06:24.600 --> 01:06:27.600] 我这个错会让这个方式被call
[01:06:27.600 --> 01:06:28.600] 然后我这个方式被call的时候
[01:06:28.600 --> 01:06:31.600] 我可以直接在那save log
[01:06:31.600 --> 01:06:33.600] 我可以直接在那把log save下来
[01:06:33.600 --> 01:06:35.600] 然后我拿到的we tracer的信息
[01:06:35.600 --> 01:06:37.600] 就是最新最新的信息
[01:06:37.600 --> 01:06:38.600] 一般情况下来说
[01:06:38.600 --> 01:06:41.600] 离这个时间节点越近的信息
[01:06:41.600 --> 01:06:44.600] 越有利于帮助我debug
[01:06:44.600 --> 01:06:47.600] 越有利于让我知道最近发生了什么事
[01:06:47.600 --> 01:06:48.600] 所以我做了一个circular buffer
[01:06:48.600 --> 01:06:50.600] 就是储存最新的信息
[01:06:50.600 --> 01:06:53.600] 这个事情比想象的还稍微难那么一点点
[01:06:53.600 --> 01:06:56.600] 因为最新是有很多概念
[01:06:56.600 --> 01:06:58.600] 它不是最新发生的
[01:06:58.600 --> 01:07:00.600] 而是最新结束的
[01:07:00.600 --> 01:07:03.600] 就是是要最近结束的那个事情
[01:07:03.600 --> 01:07:04.600] 才是一个完整的event
[01:07:04.600 --> 01:07:05.600] 那块稍微有一点点复杂
[01:07:05.600 --> 01:07:10.600] 但是anyway就是现在你看到的we tracer
[01:07:10.600 --> 01:07:11.600] 如果你运行的不是一个完整的程序
[01:07:11.600 --> 01:07:14.600] 你运行一个30秒程序60秒程序
[01:07:14.600 --> 01:07:17.600] 有可能million级别的function call的话
[01:07:17.600 --> 01:07:19.600] 你拿到的是最后那一小段
[01:07:19.600 --> 01:07:22.600] 这个是性能上的一个优化
[01:07:22.600 --> 01:07:25.600] 然后除了性能优化跟这个filesize的
[01:07:25.600 --> 01:07:28.600] 就是这个文件大小的优化之外
[01:07:28.600 --> 01:07:32.600] 其实还有一些是就做项目就不是技术上的事
[01:07:32.600 --> 01:07:35.600] 而是我觉得作为一个open source project
[01:07:35.600 --> 01:07:37.600] 你可能会面临的一些挑战
[01:07:37.600 --> 01:07:39.600] 第一个就是我对we tracer理解
[01:07:39.600 --> 01:07:44.600] 是我希望we tracer可以在所有人
[01:07:44.600 --> 01:07:46.600] 就是不管你是不是一个python expert
[01:07:46.600 --> 01:07:49.600] 都可以用we tracer能收获一些东西
[01:07:49.600 --> 01:07:53.600] 那他尽量要特别特别简单就能用
[01:07:53.600 --> 01:07:56.600] 可以让你不改任何的源代码就能用
[01:07:56.600 --> 01:07:59.600] 那么这个事情上我其实是下了一些功夫的
[01:07:59.600 --> 01:08:02.600] 我希望we tracer就是你从最最简单开始
[01:08:02.600 --> 01:08:04.600] 从pp install然后直接we tracer跑
[01:08:04.600 --> 01:08:05.600] 就能跑出来一个结果
[01:08:05.600 --> 01:08:06.600] 你看这结果不错
[01:08:06.600 --> 01:08:08.600] 那我看看还有什么其他的新的feature
[01:08:08.600 --> 01:08:12.600] 然后你可以就是叫design的时候
[01:08:12.600 --> 01:08:14.600] 我们叫incremental design
[01:08:14.600 --> 01:08:17.600] 但是这个experience你也是incremental experience
[01:08:17.600 --> 01:08:19.600] 你一开始有一个非常快就能拿到的experience
[01:08:19.600 --> 01:08:21.600] 你感觉到这个experience不错
[01:08:21.600 --> 01:08:24.600] 你可以逐渐逐渐的增加你的这个
[01:08:24.600 --> 01:08:26.600] 感觉到舒适的experience
[01:08:26.600 --> 01:08:27.600] 这个feature有用
[01:08:27.600 --> 01:08:30.600] 然后我瞬间我可能用五秒钟看一下documentation
[01:08:30.600 --> 01:08:32.600] 我就能把这个feature加进来看看好不好
[01:08:32.600 --> 01:08:33.600] 第二个feature用十秒钟
[01:08:33.600 --> 01:08:35.600] 第三个feature用半分钟
[01:08:35.600 --> 01:08:38.600] 就是我可以用这种很快很快能理解的这个速度
[01:08:38.600 --> 01:08:40.600] 可以让他使用新的feature
[01:08:40.600 --> 01:08:42.600] 这是其中的在项目上的一个挑战
[01:08:42.600 --> 01:08:47.600] 然后最后一个我觉得真正开始做一个
[01:08:47.600 --> 01:08:50.600] 想拿得出手的项目的一个挑战
[01:08:50.600 --> 01:08:52.600] 就是跟懒惰做斗争
[01:08:52.600 --> 01:08:56.600] 就是写测试和写documentation
[01:08:56.600 --> 01:08:59.600] 这个事情我是花了也是花了蛮长时间
[01:08:59.600 --> 01:09:01.600] 就是正常的程序员都不爱写测试
[01:09:01.600 --> 01:09:03.600] 就是我喜欢开发feature不爱写测试
[01:09:03.600 --> 01:09:05.600] 然后我是在某一个版本的时候
[01:09:05.600 --> 01:09:06.600] 我说不行
[01:09:06.600 --> 01:09:07.600] 我一定要把每一行代码都测试到
[01:09:07.600 --> 01:09:09.600] 然后我就花了很大的精力去
[01:09:09.600 --> 01:09:11.600] 我就把我去疯狂的写test case
[01:09:11.600 --> 01:09:13.600] 然后我去搭那个test framework
[01:09:13.600 --> 01:09:15.600] 因为有的不是那么好测试到
[01:09:15.600 --> 01:09:17.600] 我就写了好多好多测试
[01:09:17.600 --> 01:09:18.600] 写了好多好多测试
[01:09:18.600 --> 01:09:20.600] 然后最后我现在的viz tracer的
[01:09:20.600 --> 01:09:23.600] code coverage率是99.5%以上
[01:09:23.600 --> 01:09:26.600] 就是几乎每一行代码都是cover的
[01:09:26.600 --> 01:09:28.600] 这个是我觉得挺大的一个部分
[01:09:28.600 --> 01:09:31.600] 这个也逼着我每一次开发一个新feature的时候
[01:09:31.600 --> 01:09:32.600] 我的所有的test都要跟上
[01:09:32.600 --> 01:09:36.600] 我就不希望有任何一行没有cover的代码
[01:09:36.600 --> 01:09:38.600] 就算一个督促
[01:09:38.600 --> 01:09:39.600] 然后documentation也是一样
[01:09:39.600 --> 01:09:41.600] documentation我刚开始的时候
[01:09:41.600 --> 01:09:42.600] 只有一个readme
[01:09:42.600 --> 01:09:44.600] 然后后来readme越来越长越来越长
[01:09:44.600 --> 01:09:45.600] 我说不行
[01:09:45.600 --> 01:09:46.600] 我得写一个正儿八经的documentation
[01:09:46.600 --> 01:09:47.600] 然后我就开始写docs
[01:09:47.600 --> 01:09:50.600] 然后把每一个feature都尽量的写的明白一点
[01:09:50.600 --> 01:09:51.600] 然后专门做documentation
[01:09:51.600 --> 01:09:52.600] 这也是一个鞭策
[01:09:52.600 --> 01:09:54.600] 如果你docs本来是缺着的
[01:09:54.600 --> 01:09:56.600] 你本来只有50%documentation
[01:09:56.600 --> 01:09:57.600] 你再写一个新feature
[01:09:57.600 --> 01:09:58.600] 你会觉得说
[01:09:58.600 --> 01:10:01.600] 这个新的feature不documentation就不写就不写吧
[01:10:01.600 --> 01:10:03.600] 然后就一直差着一直差着
[01:10:03.600 --> 01:10:04.600] 所以我当时也是下定决心
[01:10:04.600 --> 01:10:06.600] 把所有的documentation都写好
[01:10:06.600 --> 01:10:08.600] 然后每一次加个新feature的时候
[01:10:08.600 --> 01:10:09.600] test全都跟上
[01:10:09.600 --> 01:10:10.600] documentation也要跟上
[01:10:10.600 --> 01:10:12.600] 算是对自己的一种鞭策吧
[01:10:12.600 --> 01:10:14.600] 就是这我觉得也是蛮大的一个挑战
[01:10:14.600 --> 01:10:15.600] 对对对
[01:10:15.600 --> 01:10:17.600] 我觉得作为一个就是
[01:10:17.600 --> 01:10:20.600] 非玩具而是实际可用的项目
[01:10:20.600 --> 01:10:22.600] 这些都是必须的
[01:10:24.600 --> 01:10:27.600] 然后你刚才说那个circular buffer
[01:10:27.600 --> 01:10:32.600] 其实我也就是在做cyber brain的时候
[01:10:32.600 --> 01:10:33.600] 我也是想有类似优化
[01:10:33.600 --> 01:10:35.600] 但是目前还没有做到那个
[01:10:35.600 --> 01:10:38.600] 还没有考虑到这些事情
[01:10:38.600 --> 01:10:41.600] 就是因为现在也是把所有东西都存在内存里
[01:10:41.600 --> 01:10:44.600] 我觉得可能也会有内存爆掉的情况
[01:10:44.600 --> 01:10:48.600] 但是我当时想法就是说
[01:10:48.600 --> 01:10:51.600] 也是就相当于把一些老的东西
[01:10:51.600 --> 01:10:53.600] 直接dump到磁盘上去
[01:10:53.600 --> 01:10:57.600] 然后这样可能是一个能够缓解一些
[01:10:57.600 --> 01:10:58.600] 但是circular的话
[01:10:58.600 --> 01:11:01.600] 就我觉得因为像cyber brain
[01:11:01.600 --> 01:11:05.600] 它不是它是想记录所有信息的
[01:11:05.600 --> 01:11:07.600] 所以就应该不会做circular
[01:11:07.600 --> 01:11:08.600] 对
[01:11:10.600 --> 01:11:12.600] 其实我现在连profile都没profile过
[01:11:12.600 --> 01:11:13.600] 不知道占了多少内存
[01:11:13.600 --> 01:11:15.600] 但是我觉得应该挺大的
[01:11:15.600 --> 01:11:22.600] 就是如果你真的想做一整个时间跑的很长的大程序的话
[01:11:22.600 --> 01:11:26.600] 你始终要就你永远有可能面临一个问题
[01:11:26.600 --> 01:11:28.600] 就是你的内存和磁盘都不够用了
[01:11:28.600 --> 01:11:31.600] 就这个程序如果你跑一个月
[01:11:31.600 --> 01:11:33.600] 你一直挂着跑
[01:11:33.600 --> 01:11:37.600] 就它始终会有把你硬盘干爆的一天
[01:11:37.600 --> 01:11:39.600] 这种只能慢慢解决了
[01:11:39.600 --> 01:11:42.600] OK
[01:11:42.600 --> 01:11:44.600] 然后就我们说了
[01:11:44.600 --> 01:11:46.600] 刚才主要聊了一些技术上的方面
[01:11:46.600 --> 01:11:50.600] 就是我们知道做一个开源项目
[01:11:50.600 --> 01:11:52.600] 光有技术是不够的
[01:11:52.600 --> 01:11:53.600] 你还得宣传
[01:11:53.600 --> 01:11:56.600] 你还得去就是构建一个社区
[01:11:56.600 --> 01:12:00.600] 然后因为你的一个项目一开始肯定是没有人知道的
[01:12:00.600 --> 01:12:01.600] 你要有人知道才有人用
[01:12:01.600 --> 01:12:02.600] 才能给你反馈
[01:12:02.600 --> 01:12:04.600] 然后才能就是持续的改进
[01:12:04.600 --> 01:12:08.600] 那就是这方面高天你有做什么工作吗
[01:12:08.600 --> 01:12:12.600] 宣传确实也是我觉得很大很大的一个挑战
[01:12:12.600 --> 01:12:13.600] 就说实话
[01:12:13.600 --> 01:12:14.600] 我觉得我项目做的还可以
[01:12:14.600 --> 01:12:16.600] 宣传这个事情真的是令人头疼
[01:12:16.600 --> 01:12:19.600] 就是你怎么让人知道你做了这么个东西
[01:12:19.600 --> 01:12:20.600] 怎么让人试用这个东西
[01:12:20.600 --> 01:12:22.600] 这个事情真的是一个挺麻烦的事
[01:12:22.600 --> 01:12:23.600] 我尝试过很多事
[01:12:23.600 --> 01:12:24.600] 我尝试过很多方式
[01:12:24.600 --> 01:12:26.600] 最开始的时候肯定是知乎对吧
[01:12:26.600 --> 01:12:28.600] 因为知乎有一定的关注数
[01:12:28.600 --> 01:12:32.600] 然后知乎也确实为我带来了第一批的那些用户
[01:12:32.600 --> 01:12:33.600] 不管他们用没用
[01:12:33.600 --> 01:12:35.600] 还是就是点了个新人就走了
[01:12:35.600 --> 01:12:38.600] 但是确实是让我有动力接着把它做
[01:12:38.600 --> 01:12:41.600] 如果一直是没有人管的话
[01:12:41.600 --> 01:12:42.600] 我可能做不到现在
[01:12:42.600 --> 01:12:45.600] 所以说我知乎是最最开始的
[01:12:45.600 --> 01:12:48.600] 然后后面慢慢我觉得可能要在其他地方宣传
[01:12:48.600 --> 01:12:50.600] reddit我试了好几次
[01:12:50.600 --> 01:12:52.600] reddit的好处就是你可以随便发
[01:12:52.600 --> 01:12:54.600] 就是他也不管你
[01:12:54.600 --> 01:12:55.600] 你随便发
[01:12:55.600 --> 01:12:59.600] 然后上面的人总体来说还是有一定的回应的
[01:12:59.600 --> 01:13:01.600] 效果过得去
[01:13:01.600 --> 01:13:06.600] 然后目前来说给我带来单日这个star数
[01:13:06.600 --> 01:13:07.600] 我们就以最简单
[01:13:07.600 --> 01:13:09.600] 就是最最最普通的star数来算的话
[01:13:09.600 --> 01:13:11.600] 单日star数最多的有两个
[01:13:11.600 --> 01:13:12.600] 一个是hacker news
[01:13:12.600 --> 01:13:15.600] 一个是这个V2EX
[01:13:15.600 --> 01:13:19.600] 就是这两个地儿是我就是宣传了一次
[01:13:19.600 --> 01:13:21.600] 然后单日就能带来可能几十个star
[01:13:21.600 --> 01:13:23.600] 就是比较效果很好的地方
[01:13:23.600 --> 01:13:25.600] 我觉得这两个是比较好的地方
[01:13:25.600 --> 01:13:27.600] 然后还做了一些其他东西
[01:13:27.600 --> 01:13:29.600] 就朋友圈什么的就不说了对吧
[01:13:29.600 --> 01:13:30.600] 就可以聊一聊
[01:13:30.600 --> 01:13:32.600] 然后我自己做了一个推特account
[01:13:32.600 --> 01:13:33.600] 对吧
[01:13:33.600 --> 01:13:35.600] 当然现在还是刚刚起步阶段
[01:13:35.600 --> 01:13:36.600] 我是第一个关注者
[01:13:36.600 --> 01:13:39.600] 对对对你也是现在唯一一个关注者
[01:13:39.600 --> 01:13:42.600] 那个推特account
[01:13:42.600 --> 01:13:44.600] 我其实某种程度上也想是记录一下
[01:13:44.600 --> 01:13:46.600] 记录一下自己的这个情况
[01:13:46.600 --> 01:13:47.600] 包括知乎也是
[01:13:47.600 --> 01:13:49.600] 知乎我每一个版本会发一个记录性的文章
[01:13:49.600 --> 01:13:50.600] 第一个是宣传
[01:13:50.600 --> 01:13:51.600] 第二个也是说
[01:13:51.600 --> 01:13:53.600] ok我这个版本做了些什么东西
[01:13:53.600 --> 01:13:54.600] 有点像change log
[01:13:54.600 --> 01:13:56.600] 然后还有就是我做了一个视频
[01:13:56.600 --> 01:13:58.600] 那个时候就是想试一下其他的宣传方式
[01:13:58.600 --> 01:14:00.600] 然后花了大概一天的时间
[01:14:00.600 --> 01:14:01.600] 我做了一个视频
[01:14:01.600 --> 01:14:02.600] 发到b站跟知乎了
[01:14:02.600 --> 01:14:04.600] 其实也有一定的水花
[01:14:04.600 --> 01:14:05.600] 没有想象的大
[01:14:05.600 --> 01:14:06.600] 但是就好玩
[01:14:06.600 --> 01:14:08.600] 因为我之前其实也做一些视频
[01:14:08.600 --> 01:14:09.600] 然后做了个视频
[01:14:09.600 --> 01:14:11.600] 我觉得还蛮有意思的
[01:14:11.600 --> 01:14:12.600] 然后就就就
[01:14:12.600 --> 01:14:14.600] 然后就不算很成功
[01:14:14.600 --> 01:14:15.600] 说实话
[01:14:15.600 --> 01:14:16.600] 那个不算那么成功
[01:14:16.600 --> 01:14:17.600] 然后另外其他的
[01:14:17.600 --> 01:14:18.600] 我比如说我在medium上
[01:14:18.600 --> 01:14:20.600] 我发过一些文章
[01:14:20.600 --> 01:14:22.600] 有关vtracer的
[01:14:22.600 --> 01:14:24.600] medium其实有一篇文章还被采用了
[01:14:24.600 --> 01:14:27.600] 但是那篇文章是介绍的所有debugging tool
[01:14:27.600 --> 01:14:34.600] 就是它是一个带着带着带着那个带着私货的这么一篇分享文章
[01:14:34.600 --> 01:14:37.600] 就是我先是分享其他的debugging tool
[01:14:37.600 --> 01:14:40.600] 然后最后花了一定的版面去介绍vtracer
[01:14:40.600 --> 01:14:42.600] 这样的话可能其他人更有机会看到它
[01:14:42.600 --> 01:14:44.600] 然后更有机会了解vtracer
[01:14:44.600 --> 01:14:46.600] 那个相对来说点击率还稍微高一点
[01:14:46.600 --> 01:14:50.600] 然后还有一个就是我最近在open source.org
[01:14:50.600 --> 01:14:52.600] 这还是一个算还蛮大的开源网站吧
[01:14:52.600 --> 01:14:54.600] 是red hat现在在管
[01:14:54.600 --> 01:14:56.600] open source.org我投了一个稿
[01:14:56.600 --> 01:14:59.600] 然后最近已经在中审阶段了
[01:14:59.600 --> 01:15:00.600] 就是基本上已经过了
[01:15:00.600 --> 01:15:01.600] 他们在最后的编辑阶段
[01:15:01.600 --> 01:15:06.600] 所以可能在我怀疑这个稿出现可能会比这期节目出现要早一些
[01:15:06.600 --> 01:15:11.600] 所以那个当然这时候已经能看到open source.org的那个稿件了
[01:15:11.600 --> 01:15:12.600] 这个我还真不知道
[01:15:12.600 --> 01:15:13.600] 学习了一下
[01:15:13.600 --> 01:15:16.600] 然后我感觉你还漏了一个最重要的一个
[01:15:16.600 --> 01:15:18.600] 就是上补车者说进行宣传
[01:15:18.600 --> 01:15:19.600] 对不对
[01:15:19.600 --> 01:15:20.600] 对对对补车者说
[01:15:20.600 --> 01:15:21.600] 我觉得是一个特别的好的平台
[01:15:21.600 --> 01:15:22.600] 我看了一下
[01:15:22.600 --> 01:15:24.600] 我感觉补车者说的关注人还很多
[01:15:24.600 --> 01:15:27.600] 很重要的一点是补车者说的关注群体
[01:15:27.600 --> 01:15:29.600] 是大都是用python的
[01:15:29.600 --> 01:15:31.600] 所以在很多其他
[01:15:31.600 --> 01:15:33.600] 比如说你不管是在open source也好
[01:15:33.600 --> 01:15:35.600] 或者是在hacker news也好
[01:15:35.600 --> 01:15:37.600] 你面临的群体可能是程序员
[01:15:37.600 --> 01:15:39.600] 甚至可能是更大的一个群体
[01:15:39.600 --> 01:15:44.600] 但是如果你能面向一个纯python的群体去说你的python项目的话
[01:15:44.600 --> 01:15:45.600] 他们可能会更感兴趣
[01:15:45.600 --> 01:15:47.600] 嗯对
[01:15:47.600 --> 01:15:51.600] 其实我们的听众也不光只有写python了
[01:15:51.600 --> 01:15:53.600] 就是各行各业程序员都有
[01:15:53.600 --> 01:15:55.600] 这个我还是要澄清一下
[01:15:55.600 --> 01:15:56.600] 对
[01:15:56.600 --> 01:15:57.600] 但就补蛇者说嘛
[01:15:57.600 --> 01:16:01.600] 肯定就是有蛮大一部分人是至少是写python
[01:16:01.600 --> 01:16:02.600] 他不一定主力写python
[01:16:02.600 --> 01:16:04.600] 但可能至少用过python
[01:16:04.600 --> 01:16:06.600] 对是的
[01:16:06.600 --> 01:16:08.600] 我们经常在那个听众群里说
[01:16:08.600 --> 01:16:11.600] 就是股东一些人去做一个补谢者说嘛
[01:16:11.600 --> 01:16:13.600] 就是那个关于rust
[01:16:13.600 --> 01:16:15.600] 然后没人搞
[01:16:15.600 --> 01:16:18.600] 嗯ok
[01:16:18.600 --> 01:16:22.600] 然后我们也聊了一下VisTracer的现状
[01:16:22.600 --> 01:16:24.600] 那关于未来你有什么打算吗
[01:16:24.600 --> 01:16:25.600] 嗯
[01:16:25.600 --> 01:16:30.600] 我觉得第一个是希望能有更多的人用
[01:16:30.600 --> 01:16:34.600] 因为就是我现在我基本还是算闭门造车嘛
[01:16:34.600 --> 01:16:35.600] 我虽然用python
[01:16:35.600 --> 01:16:38.600] 但是我用的python也是可能是局限于某一个比较小的领域
[01:16:38.600 --> 01:16:39.600] 如果更多人用的话
[01:16:39.600 --> 01:16:41.600] 他们可能会有自己的feature request
[01:16:41.600 --> 01:16:43.600] 可能会有自己遇到的issue
[01:16:43.600 --> 01:16:47.600] 我希望大家在试用的时候能给我更多的反馈
[01:16:47.600 --> 01:16:49.600] 我这样就能知道未来开发的方向
[01:16:49.600 --> 01:16:51.600] 因为我现在就是自己一个人闷头往里加feature
[01:16:51.600 --> 01:16:53.600] 我想ok这个feature可能用得到
[01:16:53.600 --> 01:16:54.600] 那个feature可能用得到
[01:16:54.600 --> 01:16:56.600] 但实际上可能有一些我没有想到
[01:16:56.600 --> 01:16:57.600] 大家真正需要的东西
[01:16:57.600 --> 01:16:58.600] 我没有做进去
[01:16:58.600 --> 01:17:00.600] 这个是我最希望看到的
[01:17:00.600 --> 01:17:02.600] 就是有更多的人使用VisTracer
[01:17:02.600 --> 01:17:03.600] 然后近期的话
[01:17:03.600 --> 01:17:07.600] 我正在做大量的multiprocess的支持
[01:17:07.600 --> 01:17:09.600] 就是VisTracer相比于其他的
[01:17:09.600 --> 01:17:10.600] 不管是profiler也好
[01:17:10.600 --> 01:17:11.600] debugger也好
[01:17:11.600 --> 01:17:12.600] 它的最大的优势是
[01:17:12.600 --> 01:17:14.600] 它有二维的这个展示面
[01:17:14.600 --> 01:17:15.600] 有二维display面
[01:17:15.600 --> 01:17:19.600] 所以说我觉得当出现了multiprocess
[01:17:19.600 --> 01:17:21.600] 或者是multithread debugging
[01:17:21.600 --> 01:17:23.600] 你需要理解多线程
[01:17:23.600 --> 01:17:26.600] 或者是多进程的这种concurrency的代码的时候
[01:17:26.600 --> 01:17:29.600] VisTracer就会比其他的工具强非常多
[01:17:29.600 --> 01:17:31.600] 因为其他的工具是线性的
[01:17:31.600 --> 01:17:34.600] 你没有办法同时知道这个时间点下
[01:17:34.600 --> 01:17:36.600] 这个process下面的这个thread
[01:17:36.600 --> 01:17:39.600] 跟这个process下面这个thread在做什么事情
[01:17:39.600 --> 01:17:42.600] 当你去比如说debug一些deadlock
[01:17:42.600 --> 01:17:44.600] 或者当你debug一些
[01:17:44.600 --> 01:17:48.600] 跟order跟thread之间order顺序有关的问题的时候
[01:17:48.600 --> 01:17:52.600] VisTracer会给你一个非常明确的
[01:17:52.600 --> 01:17:55.600] 这么一个很自然的状态
[01:17:55.600 --> 01:17:57.600] 你会知道这块我这个thread运行这个
[01:17:57.600 --> 01:17:58.600] 这个thread运行这个
[01:17:58.600 --> 01:18:00.600] 所以这块出现了一个racing issue
[01:18:00.600 --> 01:18:02.600] 我觉得这个可能是VisTracer
[01:18:02.600 --> 01:18:05.600] 接下来可能会发光发热的一个领域吧
[01:18:05.600 --> 01:18:08.600] 我觉得这个应该算是你的一个killer feature了
[01:18:08.600 --> 01:18:09.600] 就是有点这种感觉
[01:18:09.600 --> 01:18:10.600] 对对对对
[01:18:10.600 --> 01:18:14.600] 所以我现在之前的那个multithreading支持的一直很好
[01:18:14.600 --> 01:18:16.600] multithreading一直很不错
[01:18:16.600 --> 01:18:19.600] multiprocess之前支持的比较个色就比较不舒服
[01:18:19.600 --> 01:18:21.600] 然后最近我正在修改
[01:18:21.600 --> 01:18:23.600] 现在这个subprocess已经支持的还不错了
[01:18:23.600 --> 01:18:25.600] 就是你在里边跑subprocess
[01:18:25.600 --> 01:18:27.600] 你也不需要任何特殊的东西
[01:18:27.600 --> 01:18:29.600] 你就跑然后加一个-log subprocess
[01:18:29.600 --> 01:18:31.600] 你就可以把process都log出来
[01:18:31.600 --> 01:18:35.600] 然后multiprocessing跟那个os.fork是我今天做了一些的
[01:18:35.600 --> 01:18:37.600] 现在也能用
[01:18:37.600 --> 01:18:40.600] 当你用pool的时候会有一些小问题
[01:18:40.600 --> 01:18:42.600] 所以我觉得更重要的还是
[01:18:42.600 --> 01:18:44.600] 就如果大家能尝试一下用这个
[01:18:44.600 --> 01:18:46.600] 感受一下是不是好用
[01:18:46.600 --> 01:18:48.600] 然后哪不好用或者哪有问题能回馈给我
[01:18:48.600 --> 01:18:50.600] 我觉得这才是我最喜欢看到的吧
[01:18:50.600 --> 01:18:53.600] 对就是
[01:18:53.600 --> 01:18:57.600] 我甚至感觉你可以
[01:18:57.600 --> 01:19:02.600] 做一些比如说自动的死锁检测啊这种
[01:19:02.600 --> 01:19:05.600] 就是我不知道能不能在那个UI上实现
[01:19:05.600 --> 01:19:08.600] 所以既然你都能把它visualize出来了
[01:19:08.600 --> 01:19:09.600] 对吧
[01:19:09.600 --> 01:19:11.600] visualize是一回事
[01:19:11.600 --> 01:19:13.600] 因为死锁的种类很多
[01:19:13.600 --> 01:19:16.600] 死锁是一个比较大的概念
[01:19:16.600 --> 01:19:18.600] 那么再从代码上找的话
[01:19:18.600 --> 01:19:20.600] 是可能还是有一定难度
[01:19:20.600 --> 01:19:21.600] 但未来没准呢
[01:19:21.600 --> 01:19:23.600] 对吧都有可能
[01:19:23.600 --> 01:19:26.600] 对那我们来问一下
[01:19:26.600 --> 01:19:28.600] 王老师和小白你们有没有什么feature request
[01:19:28.600 --> 01:19:30.600] 或者觉得就是
[01:19:30.600 --> 01:19:32.600] 就是VisTracer还可以改进的地方
[01:19:32.600 --> 01:19:35.600] 我刚其实听下来
[01:19:35.600 --> 01:19:40.600] 我感觉VisTracer已经满足了我这个
[01:19:40.600 --> 01:19:43.600] 对这种Tracer的理解
[01:19:43.600 --> 01:19:45.600] 但是我会觉得就是
[01:19:45.600 --> 01:19:47.600] 它目前只是使用了这个瀑布图嘛
[01:19:47.600 --> 01:19:48.600] 对吧
[01:19:48.600 --> 01:19:51.600] 其实刚才那个高天老师也讲说
[01:19:51.600 --> 01:19:54.600] 方便我们可以去更快的去理解一些程序啊之类的
[01:19:54.600 --> 01:19:57.600] 那会不会考虑之后支持一些
[01:19:57.600 --> 01:20:01.600] 比如说call graph这种说调用的图
[01:20:01.600 --> 01:20:04.600] 对以及说这种战士的这种图
[01:20:04.600 --> 01:20:07.600] 就是因为我理解
[01:20:07.600 --> 01:20:10.600] VisTracer其实本质不是采样的
[01:20:10.600 --> 01:20:12.600] 它记录了全量的信息
[01:20:12.600 --> 01:20:15.600] 但是我们依然可以生成一个Samurai
[01:20:15.600 --> 01:20:17.600] 这样的话我其实
[01:20:17.600 --> 01:20:20.600] 我就不需要用这个工具用那个工具
[01:20:20.600 --> 01:20:22.600] 就一战式的解决了我所有的问题
[01:20:22.600 --> 01:20:30.600] 对这是一个很好的方向
[01:20:30.600 --> 01:20:34.600] 实际上VisTracer现在是支持生成flame graph的
[01:20:34.600 --> 01:20:37.600] 就是你可以用VisTracer直接生成flame graph
[01:20:37.600 --> 01:20:38.600] VisTracer支持这个的
[01:20:38.600 --> 01:20:40.600] 但是call graph目前还没有支持
[01:20:40.600 --> 01:20:43.600] 可能是因为前端的一些情况
[01:20:43.600 --> 01:20:45.600] 我可能会调研一下
[01:20:45.600 --> 01:20:47.600] 但是flame graph是可以直接跑出来的
[01:20:47.600 --> 01:20:51.600] 很强大
[01:20:51.600 --> 01:20:52.600] 小白呢
[01:20:52.600 --> 01:21:00.600] 我其实没太有使用这种Python这种性能分析的一些经验
[01:21:00.600 --> 01:21:04.600] 然后所以我也说不上什么建议吧
[01:21:04.600 --> 01:21:10.600] 但只是感觉我建议的话应该是针对前端方面的
[01:21:10.600 --> 01:21:13.600] 后端方面的我觉得现在做的这些已经挺不错的了
[01:21:13.600 --> 01:21:18.600] 对如果说我要用的话应该已经能满足我所有的需求了
[01:21:18.600 --> 01:21:20.600] 然后可能在优化的话
[01:21:20.600 --> 01:21:24.600] 我比较建议的是就是针对前端这一块
[01:21:24.600 --> 01:21:26.600] 然后方便大家操作一点
[01:21:26.600 --> 01:21:29.600] 就比如说刚才的那个缩放
[01:21:29.600 --> 01:21:31.600] 然后他好像不能使用滚轮缩放吧
[01:21:31.600 --> 01:21:34.600] 他只能用那个鼠标点住之后往上下去拖
[01:21:34.600 --> 01:21:37.600] 然后再就是用那个键盘去缩放
[01:21:37.600 --> 01:21:41.600] 对因为滚轮缩放是在你有多个process的时候
[01:21:41.600 --> 01:21:43.600] 他是滚那个的
[01:21:43.600 --> 01:21:44.600] 滚那个
[01:21:44.600 --> 01:21:45.600] 明白
[01:21:45.600 --> 01:21:47.600] 滚上下process
[01:21:47.600 --> 01:21:49.600] 所以说就是这些操作方面可能
[01:21:49.600 --> 01:21:53.600] 不过这个好像也是跟这个前端这个Google的这个框架有关
[01:21:53.600 --> 01:21:57.600] 也不是不是我们说优化就能优化的
[01:21:57.600 --> 01:22:02.600] 我其实尝试过在上面做小的implementation
[01:22:02.600 --> 01:22:06.600] 但是他那个代码量实在是太大了
[01:22:06.600 --> 01:22:08.600] 而且这是相对来说比较古老代码
[01:22:08.600 --> 01:22:11.600] 就是我最后用的是他的一个standalone version
[01:22:11.600 --> 01:22:15.600] standalone version是他就是他将对javascript全都是在HTML里面
[01:22:15.600 --> 01:22:18.600] 而且都是就是被那个简化过的
[01:22:18.600 --> 01:22:19.600] 被minify过的
[01:22:19.600 --> 01:22:22.600] 就是对吧
[01:22:22.600 --> 01:22:23.600] 看着非常费劲
[01:22:23.600 --> 01:22:26.600] 我曾经想加个小feature然后都很大
[01:22:26.600 --> 01:22:29.600] 我未来确实有在前端上可能做一些优化的打算
[01:22:29.600 --> 01:22:32.600] 但是就是最近的几次尝试都失败了
[01:22:32.600 --> 01:22:35.600] 连入口都找不着
[01:22:35.600 --> 01:22:38.600] 我就觉得这个现在可能就是用一个已经有的前端
[01:22:38.600 --> 01:22:40.600] 一开始肯定是能节省很多工作量
[01:22:40.600 --> 01:22:43.600] 但是长期来看说不定他会成为一个
[01:22:43.600 --> 01:22:46.600] 就是说你的一个阻碍或者
[01:22:46.600 --> 01:22:49.600] 就是一个就让你没有办法做一些事情
[01:22:49.600 --> 01:22:52.600] 因为这个我原来我在做cyberbrain第一版的时候
[01:22:52.600 --> 01:22:53.600] 我是有体会的
[01:22:53.600 --> 01:22:56.600] 我当时用直接是用的那个graphviz
[01:22:56.600 --> 01:22:58.600] 就输出了一个PDF
[01:22:58.600 --> 01:23:01.600] 然后我发现很多事情比如说一些
[01:23:01.600 --> 01:23:03.600] 需要跟用户交互的部分
[01:23:03.600 --> 01:23:05.600] 我完全没有办法用graphviz来实现
[01:23:05.600 --> 01:23:09.600] 后来我第二版就是一开始就想是自己实现前端
[01:23:09.600 --> 01:23:11.600] 然后实现完全的这样一种控制
[01:23:11.600 --> 01:23:14.600] 我觉得这个角色目前还是正确的
[01:23:14.600 --> 01:23:19.600] 对反正可能就是会有这样一种tradeoff吧
[01:23:19.600 --> 01:23:22.600] 我觉得这个V3前端如果能自己实现
[01:23:22.600 --> 01:23:23.600] 当然是非常好的
[01:23:23.600 --> 01:23:25.600] 我觉得很多事情都有利
[01:23:25.600 --> 01:23:28.600] 现在的话有一个问题就是这个
[01:23:28.600 --> 01:23:33.600] 我也说了这个google的这个trace viewer的前端代码量非常大
[01:23:33.600 --> 01:23:36.600] 就是我之前提到有一个很难的点
[01:23:36.600 --> 01:23:39.600] 就是性能上当你有很多很多很多entry的时候
[01:23:39.600 --> 01:23:42.600] 你怎么做这个事情难度其实还是挺大的
[01:23:42.600 --> 01:23:44.600] 作为一个个人项目来说
[01:23:44.600 --> 01:23:46.600] 如果未来就是有前端的大神们
[01:23:46.600 --> 01:23:47.600] 对不对
[01:23:47.600 --> 01:23:50.600] 愿意说给V3做一个量身定做的前端
[01:23:50.600 --> 01:23:52.600] 或者愿意说去魔改一下这个trace viewer
[01:23:52.600 --> 01:23:53.600] 那当然是好事
[01:23:53.600 --> 01:23:54.600] 对不对当然好事
[01:23:54.600 --> 01:23:57.600] 现在来说我觉得我自己要想就哪怕复刻出来
[01:23:57.600 --> 01:23:59.600] 现在google这个trace viewer的能力
[01:23:59.600 --> 01:24:01.600] 我就感觉我一两年做不出来
[01:24:01.600 --> 01:24:04.600] 是对就理解
[01:24:04.600 --> 01:24:07.600] 然后然后如果要说我的话
[01:24:07.600 --> 01:24:10.600] 我就是其实之前跟高天聊的时候也提到
[01:24:10.600 --> 01:24:13.600] 我可能唯一的feedback就是说
[01:24:13.600 --> 01:24:18.600] 就是我觉得V3的功能太多了
[01:24:18.600 --> 01:24:21.600] 然后就如果是我的话
[01:24:21.600 --> 01:24:24.600] 我可能会就是怎么样去
[01:24:24.600 --> 01:24:27.600] 也不说合并吧
[01:24:27.600 --> 01:24:29.600] 就是怎么样去整合一些这种功能
[01:24:29.600 --> 01:24:33.600] 让用户能更好去知道有这些feature
[01:24:33.600 --> 01:24:35.600] 就比如说我可能会去想怎么样把
[01:24:35.600 --> 01:24:38.600] 这些flag去做到那个UI里面
[01:24:38.600 --> 01:24:40.600] 就是类似这种东西
[01:24:40.600 --> 01:24:43.600] 但我觉得可能也是涉及到一些实现上的困难吧
[01:24:43.600 --> 01:24:45.600] 不一定可以做
[01:24:45.600 --> 01:24:49.600] 反正就毕竟你是个命令行工具的话
[01:24:49.600 --> 01:24:51.600] 其实也只能用flag
[01:24:51.600 --> 01:24:53.600] 对他是个命令行工具吧
[01:24:53.600 --> 01:24:56.600] 然后所以说还是就是
[01:24:56.600 --> 01:24:59.600] 当大家都开始用这个工具的时候
[01:24:59.600 --> 01:25:01.600] 大家会开始研究各种flag
[01:25:01.600 --> 01:25:05.600] 所以我还是很希望就是能有人开始用这个工具
[01:25:05.600 --> 01:25:08.600] 从最最最基础什么flag都没有开始
[01:25:08.600 --> 01:25:10.600] 然后一点想我可能需要这个feature
[01:25:10.600 --> 01:25:11.600] 我可能需要这个feature
[01:25:11.600 --> 01:25:13.600] 然后回过去找看看你能不能完成这件事
[01:25:13.600 --> 01:25:16.600] 我觉得这也是我自己的一个想法吧
[01:25:16.600 --> 01:25:20.600] 嗯那你现在有得到一些这种就是真实用户的反馈吗
[01:25:20.600 --> 01:25:22.600] 有一些大部分是bug的
[01:25:22.600 --> 01:25:24.600] 就是feature request比较少
[01:25:24.600 --> 01:25:27.600] 大部分是就是这块就是跑跑崩了
[01:25:27.600 --> 01:25:30.600] 或者是这块保室feature request其实真有
[01:25:30.600 --> 01:25:31.600] 我在早期阶段
[01:25:31.600 --> 01:25:34.600] 我有过一个支持windows的feature request
[01:25:34.600 --> 01:25:36.600] 我早期阶段是只有linux什么的
[01:25:36.600 --> 01:25:38.600] 后来说OK那我就支持个windows
[01:25:38.600 --> 01:25:39.600] 我记得还有一个什么事
[01:25:39.600 --> 01:25:40.600] 我有点不太记得了
[01:25:40.600 --> 01:25:41.600] 但是是有一些
[01:25:41.600 --> 01:25:43.600] 但是我觉得还不够吧
[01:25:43.600 --> 01:25:45.600] 就是都是比较浅层的
[01:25:45.600 --> 01:25:48.600] 还是希望有需求的小伙伴可以试用一下
[01:25:48.600 --> 01:25:50.600] 试用一下我觉得挺好用的
[01:25:50.600 --> 01:25:52.600] 嗯我觉得这期节目发出去之后
[01:25:52.600 --> 01:25:56.600] 你会收到很多feature request和就是issue的
[01:25:56.600 --> 01:25:57.600] 嗯就但愿如此
[01:25:57.600 --> 01:26:00.600] 我觉得普稍者说的这个影响力应该还是蛮大的
[01:26:00.600 --> 01:26:04.600] 我希望能多收到一些这个feature request跟那个bug report
[01:26:04.600 --> 01:26:06.600] 嗯应该会的
[01:26:06.600 --> 01:26:10.600] OK那然后最后我们就进入传统的推荐环节吧
[01:26:10.600 --> 01:26:14.600] 然后我不知道你有没有准备啊
[01:26:14.600 --> 01:26:18.600] 但是如果你听过我们以前节目就会让嘉宾推荐一些东西
[01:26:18.600 --> 01:26:21.600] 就是什么其实什么都可以了
[01:26:21.600 --> 01:26:23.600] 就包括你比如说你最近在读的书啊
[01:26:23.600 --> 01:26:28.600] 或者说你就是写了篇文章或者甚至买了一个东西都OK
[01:26:28.600 --> 01:26:31.600] 你想想有没有什么这种
[01:26:31.600 --> 01:26:33.600] 但是我觉得你知乎那么多东西
[01:26:33.600 --> 01:26:35.600] 其实可能也推荐不过来
[01:26:35.600 --> 01:26:41.600] 我知乎东西就是那个那个欢迎大家去看看我的知乎好了
[01:26:41.600 --> 01:26:47.600] 就是那个如果你从来之前没有那个不知道我是谁的话
[01:26:47.600 --> 01:26:49.600] 大家可以去那个扫一下我的知乎账号
[01:26:49.600 --> 01:26:52.600] 应该会就被贴上来
[01:26:52.600 --> 01:26:56.600] 然后大家可以看一下那个Vis Tracer的这个开发进程
[01:26:56.600 --> 01:26:57.600] 我都写上了
[01:26:57.600 --> 01:27:00.600] 可以当一个当一个那个那个那个什么
[01:27:00.600 --> 01:27:04.600] 当一个这个这个这个小文章看也是蛮有趣的
[01:27:04.600 --> 01:27:07.600] 就是我知道就我还在知乎混的时候
[01:27:07.600 --> 01:27:11.600] 我知道很多人是很多知乎用户是把你当做男神的
[01:27:11.600 --> 01:27:14.600] 就是我看到评论里很多这种评论
[01:27:14.600 --> 01:27:16.600] 也没有很多吧个别吧
[01:27:16.600 --> 01:27:19.600] 主要是因为没有见过我长什么样
[01:27:19.600 --> 01:27:21.600] 就挺多的还是挺多的
[01:27:21.600 --> 01:27:24.600] 对然后你知乎是17万粉对吧
[01:27:24.600 --> 01:27:26.600] 现在应该是17万吧
[01:27:26.600 --> 01:27:30.600] 17万OK这真的是名副其实的大V啊
[01:27:30.600 --> 01:27:36.600] 就是就我甚至觉得如果说你比如说你一开始是决定走做视频的路线的话
[01:27:36.600 --> 01:27:40.600] 说不定能就是成为一个短视频领域的网红也是有可能
[01:27:40.600 --> 01:27:42.600] 每个人能力不一样吗
[01:27:42.600 --> 01:27:44.600] 我可能做视频做的很烂
[01:27:44.600 --> 01:27:46.600] 我可能就写写字还凑合
[01:27:46.600 --> 01:27:50.600] OK就我觉得你也是非常能说的啊
[01:27:50.600 --> 01:27:53.600] 但anyway就是你有没有什么要推荐的
[01:27:53.600 --> 01:27:55.600] 啊
[01:27:55.600 --> 01:28:06.600] 我最近因为说实话我最近绝大部分的那个时间都就是跟程序有关的时间都搭在这个VTracer上了
[01:28:06.600 --> 01:28:10.600] 所以你也要跟程序有关啊跟别的也行啊
[01:28:10.600 --> 01:28:14.600] 也行啊我们之前还有推荐动画的
[01:28:14.600 --> 01:28:18.600] 推荐
[01:28:18.600 --> 01:28:22.600] 那你要不再想想我们先问问小白
[01:28:22.600 --> 01:28:30.600] 好那我想一下OK那我就直接开始开始宣传一下Python China
[01:28:30.600 --> 01:28:37.600] 来来来来好对对对好我们这个期待已久的Python China 2020正式启动了
[01:28:37.600 --> 01:28:42.600] 然后时间是定在11月份的28号和29号
[01:28:42.600 --> 01:28:47.600] 然后我们这次呢主要是通过不设置说像啊
[01:28:47.600 --> 01:28:49.600] 有三方面的一个邀请
[01:28:49.600 --> 01:28:53.600] 一个是如果你是一个使用Python比较久
[01:28:53.600 --> 01:28:55.600] 然后有自己的一定心得的话
[01:28:55.600 --> 01:28:59.600] 你可以申请成为我们的一个Python China的一个讲师
[01:28:59.600 --> 01:29:01.600] 然后如果说你是像我一样
[01:29:01.600 --> 01:29:04.600] 然后喜欢使用Python
[01:29:04.600 --> 01:29:08.600] 但是就是自己自己总结方面比较欠缺
[01:29:08.600 --> 01:29:11.600] 但是想要为这一次大会做一些贡献的话
[01:29:11.600 --> 01:29:13.600] 你可以申请成为我们的志愿者
[01:29:13.600 --> 01:29:16.600] 然后如果你是公司的大佬
[01:29:16.600 --> 01:29:18.600] 然后对公司有一定的把控权
[01:29:18.600 --> 01:29:19.600] 想要赞助我们的话
[01:29:19.600 --> 01:29:22.600] 你可以申请成为我们的赞助商
[01:29:22.600 --> 01:29:30.600] 对我们我后面会把这个一些详细的内容通过这个show notes的形式来贴出来
[01:29:30.600 --> 01:29:34.600] 对然后大家可以之后看我们这一期的一个show notes
[01:29:34.600 --> 01:29:36.600] 好那我来再重复一下
[01:29:36.600 --> 01:29:40.600] 时间是11月份的28号和29号对吧
[01:29:40.600 --> 01:29:41.600] 对对对
[01:29:41.600 --> 01:29:45.600] 然后是一个线上会议的这种形式是两天
[01:29:45.600 --> 01:29:47.600] 对今年这个形式会很特别
[01:29:47.600 --> 01:29:52.600] 它是线上线下都会有线下的话
[01:29:52.600 --> 01:29:53.600] 目前还没有明确桥顶
[01:29:53.600 --> 01:29:59.600] 但是大概率是在北京和上海会有会有这两个线下点
[01:29:59.600 --> 01:30:03.600] 然后具体形式的话还是看我们后期的一个官方通知
[01:30:03.600 --> 01:30:06.600] 线上的话就比较多了点就比较多了
[01:30:06.600 --> 01:30:09.600] 对然后大概率是通过直播的形式
[01:30:09.600 --> 01:30:12.600] 大家一起看看视频聊聊天
[01:30:12.600 --> 01:30:15.600] 是吧在这个魔幻的一年里
[01:30:15.600 --> 01:30:19.600] 我们相约PyCon China 2020
[01:30:19.600 --> 01:30:22.600] 对也是感谢你们的辛勤工作
[01:30:22.600 --> 01:30:24.600] 就我一直是想问你们
[01:30:24.600 --> 01:30:27.600] 就是线上的话他你说有多个点是怎么回事
[01:30:27.600 --> 01:30:30.600] 难道不是说全国只有一场吗
[01:30:30.600 --> 01:30:32.600] 是就是如果对于观众来说的话
[01:30:32.600 --> 01:30:34.600] 他确实是只看一个直播
[01:30:34.600 --> 01:30:37.600] 但是其实我们的讲师是在全国各地的
[01:30:37.600 --> 01:30:40.600] 对包括海外是吧
[01:30:40.600 --> 01:30:41.600] 我也想去讲一下
[01:30:41.600 --> 01:30:43.600] 对对对是包括海外的
[01:30:43.600 --> 01:30:45.600] 对你如果有兴趣的话
[01:30:45.600 --> 01:30:48.600] 可以来提交我们这个讲师申请
[01:30:48.600 --> 01:30:52.600] 我打算去讲一下怎么做播客
[01:30:52.600 --> 01:30:54.600] 提交演讲
[01:30:54.600 --> 01:30:57.600] 可以但是有一点就是我一定要更正一下
[01:30:57.600 --> 01:31:00.600] 刚才小白说如果你是一个就是Python的资深用户的话
[01:31:00.600 --> 01:31:02.600] 你可以去提交演讲
[01:31:02.600 --> 01:31:05.600] 但是这个其实完全不需要是这样的
[01:31:05.600 --> 01:31:07.600] 如果其实你是一个初学者
[01:31:07.600 --> 01:31:10.600] 然后你就说我就是有很多很多不懂
[01:31:10.600 --> 01:31:13.600] 然后我就想比如说把我遇到的一些问题
[01:31:13.600 --> 01:31:14.600] 做成一个演讲
[01:31:14.600 --> 01:31:15.600] 这个也是完全ok的
[01:31:15.600 --> 01:31:19.600] 其实就是像国外的Python有很多这种面向初学者的演讲
[01:31:19.600 --> 01:31:23.600] 然后真的不需要你是什么大佬啊
[01:31:23.600 --> 01:31:24.600] 或者怎么样
[01:31:24.600 --> 01:31:28.600] 你只要去讲就是本身对你自己也是一种提高
[01:31:28.600 --> 01:31:35.600] 然后很多人是说他们是先想去了解某一个事情
[01:31:35.600 --> 01:31:36.600] 想去做某个演讲
[01:31:36.600 --> 01:31:39.600] 然后他们再去真正了解这件事的
[01:31:39.600 --> 01:31:41.600] 这个其实是很常见的一个过程
[01:31:41.600 --> 01:31:44.600] 所以就是说不要觉得自己水平不够啊
[01:31:44.600 --> 01:31:45.600] 就不想去提交演讲
[01:31:45.600 --> 01:31:49.600] 如果你想去讲那就不要犹豫
[01:31:49.600 --> 01:31:51.600] 对非常对
[01:31:51.600 --> 01:31:54.600] 所以说我今年可能也会提交一个演讲的申请
[01:31:54.600 --> 01:31:55.600] 好
[01:31:55.600 --> 01:32:00.600] 那我们这个今年Python就是有审核吗
[01:32:00.600 --> 01:32:03.600] 就是说是不是也是有一个审核的过程
[01:32:03.600 --> 01:32:05.600] 对对对
[01:32:05.600 --> 01:32:07.600] 就是你提交上来之后的话
[01:32:07.600 --> 01:32:11.600] 会跟我们这边的志愿者会直接有对接的
[01:32:11.600 --> 01:32:16.600] 然后我们后期无论是你能不能正式的演讲
[01:32:16.600 --> 01:32:18.600] 我们都会通过这种可能微信啊
[01:32:18.600 --> 01:32:21.600] 或者是邮件的方式来通知你们
[01:32:21.600 --> 01:32:27.600] 那他这个提交演讲的截止日期是什么时候
[01:32:27.600 --> 01:32:31.600] 具体的截止日期是11月7号
[01:32:31.600 --> 01:32:33.600] 但是也说不定了
[01:32:33.600 --> 01:32:35.600] 你其实11月7号之后再提交的话
[01:32:35.600 --> 01:32:37.600] 我们也不是不可以通过
[01:32:37.600 --> 01:32:41.600] 对其实只要你在开始之前能提交上来
[01:32:41.600 --> 01:32:42.600] 我们都是会看的
[01:32:42.600 --> 01:32:47.600] 你哪怕今年没有上你可以延期到明年是吧
[01:32:47.600 --> 01:32:49.600] 不是我问这个是因为
[01:32:49.600 --> 01:32:52.600] 就突然感觉你给我剪辑的压力好大
[01:32:52.600 --> 01:32:56.600] 我必须让11月7日之前
[01:32:56.600 --> 01:32:58.600] 不会不会
[01:32:58.600 --> 01:33:01.600] 你只要有这个想法的话
[01:33:01.600 --> 01:33:05.600] 就是哪怕过了11月7号也是可以的
[01:33:05.600 --> 01:33:08.600] 最好我还是尽量之前检查
[01:33:08.600 --> 01:33:09.600] 不然放出来之后
[01:33:09.600 --> 01:33:12.600] 然后发现时间已经过了就有点尴尬
[01:33:12.600 --> 01:33:16.600] 反正也是大家积极参与今年的PyCon China
[01:33:16.600 --> 01:33:19.600] 一个因为线上的机会实际上是非常好的
[01:33:19.600 --> 01:33:22.600] 就以前你可能说我不想去花路费
[01:33:22.600 --> 01:33:25.600] 然后或者不想买门票去参与
[01:33:25.600 --> 01:33:26.600] 然后但是今年的话
[01:33:26.600 --> 01:33:30.600] 你线上完全你在世界上任何地方都可以去参与的
[01:33:30.600 --> 01:33:32.600] 所以我觉得是一个很好的机会
[01:33:32.600 --> 01:33:33.600] 是的
[01:33:33.600 --> 01:33:37.600] 那Adam有没有什么要推荐
[01:33:37.600 --> 01:33:42.600] 我给大家推荐一篇文章吧
[01:33:42.600 --> 01:33:46.600] 对然后叫其实严格来说不能算文章
[01:33:46.600 --> 01:33:48.600] 叫是一篇论文
[01:33:48.600 --> 01:33:50.600] 名字是My Philosophy on Alerting
[01:33:50.600 --> 01:33:59.600] 是一篇关于讲你如何去设计一些报警和监控的原则的一篇论文
[01:33:59.600 --> 01:34:00.600] 对
[01:34:00.600 --> 01:34:04.600] 然后是一个Google的SRE写的这篇论文
[01:34:04.600 --> 01:34:07.600] 然后我朋友最近刚好把它翻译成中文了
[01:34:07.600 --> 01:34:12.600] 然后我是在这个契机下了解到的这篇论文
[01:34:12.600 --> 01:34:13.600] 然后很短
[01:34:13.600 --> 01:34:15.600] 然后都是一些总结性的经验和思路
[01:34:15.600 --> 01:34:16.600] 我觉得很不错
[01:34:16.600 --> 01:34:17.600] 对
[01:34:17.600 --> 01:34:19.600] 我觉得可以推荐给大家
[01:34:19.600 --> 01:34:20.600] 就不只和Python有关了
[01:34:20.600 --> 01:34:24.600] 就如果你在维护一个线上服务
[01:34:24.600 --> 01:34:25.600] 它需要报警和监控
[01:34:25.600 --> 01:34:27.600] 那你要怎么去考虑和设计
[01:34:27.600 --> 01:34:32.600] 其实都是一篇能对你很有帮助的一篇论文
[01:34:32.600 --> 01:34:35.600] 我知道是姚刚强翻译的
[01:34:35.600 --> 01:34:36.600] 对
[01:34:36.600 --> 01:34:39.600] 对那个翻译的朋友叫姚刚强
[01:34:39.600 --> 01:34:43.600] 我们之后也可以邀请他来做一期播客
[01:34:43.600 --> 01:34:44.600] 迟早我们会邀请他来的
[01:34:44.600 --> 01:34:47.600] 其实我在Google就是做这方面
[01:34:47.600 --> 01:34:50.600] 但是我觉得可能我还没有看
[01:34:50.600 --> 01:34:51.600] 我之后会看一看
[01:34:51.600 --> 01:34:53.600] 然后希望我也能学到些东西
[01:34:53.600 --> 01:34:57.600] 那最后高天你应该想好了
[01:34:57.600 --> 01:35:00.600] 我就推荐这么个东西
[01:35:00.600 --> 01:35:05.600] 因为我自己有一个这么一个小网站
[01:35:05.600 --> 01:35:07.600] 叫ecsresume.com
[01:35:07.600 --> 01:35:08.600] 这个东西
[01:35:08.600 --> 01:35:10.600] 它的网站的核心
[01:35:10.600 --> 01:35:14.600] 就是帮你点评和修改简历的
[01:35:14.600 --> 01:35:18.600] 我觉得可能我知道在不是说听众
[01:35:18.600 --> 01:35:20.600] 有可能很多人已经工作了
[01:35:20.600 --> 01:35:21.600] 对吧
[01:35:21.600 --> 01:35:22.600] 但也有可能有一些学生
[01:35:22.600 --> 01:35:24.600] 然后这个是我自己的一个网站
[01:35:24.600 --> 01:35:27.600] 然后点评是免费的
[01:35:27.600 --> 01:35:28.600] 然后你要修改的话
[01:35:28.600 --> 01:35:29.600] 是要付费的
[01:35:29.600 --> 01:35:30.600] 所以说如果你有英文简历
[01:35:30.600 --> 01:35:33.600] 然后尤其是我专门做ECS这个方向
[01:35:33.600 --> 01:35:37.600] 因为我自己本人是已经进行了六年到七年的招聘了
[01:35:37.600 --> 01:35:41.600] 我现在是我们公司去若干个学校招聘的lead
[01:35:41.600 --> 01:35:44.600] 所以说不是乱改的
[01:35:44.600 --> 01:35:46.600] 就是就有知道什么是resume
[01:35:46.600 --> 01:35:49.600] 所以说大家如果是英文的
[01:35:49.600 --> 01:35:51.600] 英文的就是如果有英文简历
[01:35:51.600 --> 01:35:52.600] 然后想点评一下
[01:35:52.600 --> 01:35:54.600] 想看看你自己写的怎么样
[01:35:54.600 --> 01:35:55.600] 然后你可以发给我
[01:35:55.600 --> 01:35:57.600] 然后我会点评的话是免费
[01:35:57.600 --> 01:35:58.600] 我会告诉你大概有什么地方好
[01:35:58.600 --> 01:35:59.600] 有什么地方不好
[01:35:59.600 --> 01:36:00.600] 有什么地方值得改进
[01:36:00.600 --> 01:36:03.600] 你的简历大概在同类种水平如何
[01:36:03.600 --> 01:36:06.600] 不管你是在职在找工作
[01:36:06.600 --> 01:36:09.600] 还是要毕业了
[01:36:09.600 --> 01:36:12.600] 想找工作找实习都可以到这个网站上
[01:36:12.600 --> 01:36:14.600] 然后发给我
[01:36:14.600 --> 01:36:16.600] 那中文不行吗
[01:36:16.600 --> 01:36:18.600] 因为是这样
[01:36:18.600 --> 01:36:20.600] 就是有很多人问我中文可不可以
[01:36:20.600 --> 01:36:21.600] 别的专业可不可以
[01:36:21.600 --> 01:36:23.600] 或者是怎么可不可以
[01:36:23.600 --> 01:36:24.600] 我不是说我不改
[01:36:24.600 --> 01:36:27.600] 是因为这个东西不是我的专长
[01:36:27.600 --> 01:36:29.600] 因为我出去招聘的时候
[01:36:29.600 --> 01:36:30.600] 我们公司去筛简历
[01:36:30.600 --> 01:36:32.600] 我去筛简历的时候全都是英文的
[01:36:32.600 --> 01:36:36.600] 所以我只对英文的ECS这个领域的resume
[01:36:36.600 --> 01:36:38.600] 我是有发言权的
[01:36:38.600 --> 01:36:39.600] 我知道什么是好的简历
[01:36:39.600 --> 01:36:41.600] 我知道怎么写好的简历
[01:36:41.600 --> 01:36:43.600] 别的东西你说你愣让我看
[01:36:43.600 --> 01:36:44.600] 我当然也能说对吧
[01:36:44.600 --> 01:36:46.600] 我胡说八道是可以的
[01:36:46.600 --> 01:36:48.600] 但是对你可能没有帮助
[01:36:48.600 --> 01:36:50.600] 因为我从来没有看过中文简历
[01:36:50.600 --> 01:36:52.600] 我自己没有写过中文简历
[01:36:52.600 --> 01:36:53.600] 我也没有收到过中文简历
[01:36:53.600 --> 01:36:54.600] 你给我一个中文简历
[01:36:54.600 --> 01:36:55.600] 你让我点评
[01:36:55.600 --> 01:36:57.600] 我可能点评的是错误的
[01:36:57.600 --> 01:36:59.600] OK行
[01:36:59.600 --> 01:37:02.600] 然后虽然我觉得是相同
[01:37:02.600 --> 01:37:04.600] 但是既然你说你只看英文
[01:37:04.600 --> 01:37:05.600] 那就这样也OK
[01:37:05.600 --> 01:37:08.600] 然后你的收费是怎么样一个情况
[01:37:08.600 --> 01:37:09.600] 是这样
[01:37:09.600 --> 01:37:10.600] 如果点评的话
[01:37:10.600 --> 01:37:11.600] 你发给我
[01:37:11.600 --> 01:37:12.600] 我给你点评这件事是免费的
[01:37:12.600 --> 01:37:14.600] 只有你决定说OK
[01:37:14.600 --> 01:37:15.600] 我觉得你点评特别好
[01:37:15.600 --> 01:37:16.600] 然后我这个简历
[01:37:16.600 --> 01:37:17.600] 我也是确实想改
[01:37:17.600 --> 01:37:20.600] 那么你就可以跟我email联系
[01:37:20.600 --> 01:37:21.600] 说我们要进入复位阶段
[01:37:21.600 --> 01:37:25.600] 复位阶段现在是160刀一份简历
[01:37:25.600 --> 01:37:27.600] 修改是反复多稿的
[01:37:27.600 --> 01:37:28.600] 就是改到好为止
[01:37:28.600 --> 01:37:30.600] 不是说我给你一稿就结束了
[01:37:30.600 --> 01:37:31.600] 修改的话
[01:37:31.600 --> 01:37:33.600] 是我会提出详细的修改意见
[01:37:33.600 --> 01:37:35.600] 然后是你来写
[01:37:35.600 --> 01:37:39.600] 因为我知道很多的简历修改的机构
[01:37:39.600 --> 01:37:40.600] 是说你把你的简历发给我
[01:37:40.600 --> 01:37:42.600] 然后我给你发过去一份好的
[01:37:42.600 --> 01:37:43.600] 我的理念来看
[01:37:43.600 --> 01:37:45.600] 这件事情是不可能的
[01:37:45.600 --> 01:37:47.600] 因为我根本不知道你做什么了
[01:37:47.600 --> 01:37:49.600] 你给我发过来一份不好的简历
[01:37:49.600 --> 01:37:50.600] 你的上面是没有足够的信息量
[01:37:50.600 --> 01:37:51.600] 完成一份好简历的
[01:37:51.600 --> 01:37:52.600] 所以我只能告诉你
[01:37:52.600 --> 01:37:53.600] 这块哪写的不好
[01:37:53.600 --> 01:37:54.600] 哪应该加强
[01:37:54.600 --> 01:37:55.600] 应该加强什么东西
[01:37:55.600 --> 01:37:57.600] 然后你要再写再发给我
[01:37:57.600 --> 01:37:58.600] 我再点评
[01:37:58.600 --> 01:38:01.600] 一般来说会在3到5稿之内完稿
[01:38:01.600 --> 01:38:02.600] 大概是这么一个情况
[01:38:02.600 --> 01:38:04.600] 对
[01:38:04.600 --> 01:38:05.600] 我觉得这个收费
[01:38:05.600 --> 01:38:07.600] 其实在业界来看是挺良心的
[01:38:07.600 --> 01:38:08.600] 因为你是多稿
[01:38:08.600 --> 01:38:09.600] 然后对对对
[01:38:09.600 --> 01:38:11.600] 我收费不算贵了
[01:38:11.600 --> 01:38:13.600] 就是还可以
[01:38:13.600 --> 01:38:16.600] 如果大家有这个需求的话
[01:38:16.600 --> 01:38:17.600] 可以考虑一下
[01:38:17.600 --> 01:38:18.600] OK
[01:38:18.600 --> 01:38:22.600] 我们今天的节目差不多也就是这样
[01:38:22.600 --> 01:38:25.600] 最后我们就和观众打个招呼
[01:38:25.600 --> 01:38:26.600] 然后就结束吧
[01:38:26.600 --> 01:38:28.600] 那就各位听众
[01:38:28.600 --> 01:38:29.600] 我们下期再见
[01:38:29.600 --> 01:38:58.600] 拜拜
[01:38:59.600 --> 01:39:00.600] 嗯
