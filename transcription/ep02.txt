[00:00.000 --> 00:10.000] 【本期视频的字幕由红十字会和Sakura的合作伙伴提供】
[00:10.000 --> 00:14.000] 好,大家好,欢迎来到捕蛇者说第二期
[00:14.000 --> 00:20.000] 然后说实话这一期的内容我们叫什么名字我们都没有想好
[00:20.000 --> 00:24.000] 然后所以说我们就干脆把它叫做碎碎念吧
[00:24.000 --> 00:26.000] 然后开发中的碎碎念
[00:26.000 --> 00:30.000] 然后我的话就是你们的娱乐主播Manju Saka
[00:30.000 --> 00:35.000] 然后今天的三位嘉宾依旧还是我们熟悉的四人
[00:35.000 --> 00:38.000] 好了,三位嘉宾来介绍一下吧
[00:39.000 --> 00:40.000] 还要介绍啊
[00:41.000 --> 00:43.000] 肯定要介绍啊,对吧
[00:43.000 --> 00:47.000] 我们这个东西,对,然后我们来介绍一下吧
[00:47.000 --> 00:49.000] OK,好,我还是Like9M
[00:49.000 --> 00:53.000] 然后这期我不主持了,换Manju Saka来主持
[00:53.000 --> 00:56.000] 然后我就轻松很多
[00:57.000 --> 00:59.000] 来,文老师
[00:59.000 --> 01:01.000] Hi,大家好,我是Adam
[01:01.000 --> 01:06.000] 很高兴和大家分享一些关于Python的知识经验和见解
[01:06.000 --> 01:08.000] 我们这一期的DJ
[01:08.000 --> 01:11.000] 对,我们的DJ选手
[01:11.000 --> 01:16.000] 然后我们还有一位同学他一直在旁边欢声笑语打出了机器
[01:16.000 --> 01:17.000] 来,介绍一下
[01:17.000 --> 01:19.000] 我是赖心涛
[01:19.000 --> 01:23.000] 我的真名叫赖心涛
[01:24.000 --> 01:26.000] 可以,说到真名这个问题啊
[01:26.000 --> 01:28.000] 我们今天都既然叫开发中的水水链
[01:28.000 --> 01:30.000] 然后我正好来问一下
[01:30.000 --> 01:33.000] 话说Like9M你的这个ID是怎么来的呀
[01:33.000 --> 01:42.000] 这ID就是十多年前我在那个新浪的一个回答问题的论坛叫I-Ask
[01:42.000 --> 01:44.000] 我不知道你们用过吗
[01:44.000 --> 01:45.000] 用过
[01:45.000 --> 01:47.000] 就是当时是用那个论坛
[01:47.000 --> 01:49.000] 然后随便起的
[01:49.000 --> 01:51.000] 然后就一直用到现在
[01:51.000 --> 01:54.000] 可以,我怎么感觉你跟那个力杰老师
[01:54.000 --> 01:58.000] 那个他的ID那个一串随机字不串有点相像
[01:58.000 --> 01:59.000] 可以可以可以
[01:59.000 --> 02:01.000] 话说Adam的话
[02:01.000 --> 02:03.000] Adam的话就是你的英文名吗
[02:03.000 --> 02:06.000] 对啊,就是我上学的时候
[02:06.000 --> 02:11.000] 老师给我清点的一个英文名就一直持续用下来了
[02:11.000 --> 02:13.000] 可以可以,Adam,好可以
[02:13.000 --> 02:14.000] 好,那我们
[02:14.000 --> 02:17.000] Adam问我呀
[02:17.000 --> 02:19.000] 你都不说了吗
[02:19.000 --> 02:20.000] 你都不说了吗
[02:20.000 --> 02:22.000] 我赖信涛我叫真名
[02:22.000 --> 02:23.000] 那我们来采访一下吧
[02:23.000 --> 02:24.000] 赖信涛同学
[02:24.000 --> 02:27.000] 你的名字有什么特殊的含义没有
[02:27.000 --> 02:30.000] 我跟你讲就是这个名字为什么好呢
[02:30.000 --> 02:33.000] 因为它你的拼音拼出来一共九个字母
[02:33.000 --> 02:35.000] 九个字母全都占中上格
[02:35.000 --> 02:37.000] 所以如果你申请一个域名的话
[02:37.000 --> 02:38.000] 它就是赖信涛.com
[02:38.000 --> 02:40.000] 所有的都是中上格
[02:40.000 --> 02:42.000] 看起来非常整齐
[02:42.000 --> 02:44.000] 什么叫中上格
[02:44.000 --> 02:46.000] 就是没有这一种东西
[02:46.000 --> 02:49.000] 没有Y,懂吗
[02:49.000 --> 02:51.000] 它底下全都是平的
[02:51.000 --> 02:53.000] 三格线那个对吧
[02:53.000 --> 02:55.000] 三格线,四格线那个
[02:55.000 --> 02:58.000] 然后都是放在全面那个
[02:58.000 --> 03:01.000] 这么讲究的
[03:01.000 --> 03:02.000] 不过你的ID也是
[03:02.000 --> 03:04.000] 所以你的ID很酷
[03:04.000 --> 03:07.000] 这个名字就是为域名而生的是吗
[03:07.000 --> 03:10.000] 你看我的Mangisaka就不行
[03:10.000 --> 03:12.000] 中间有个介是下格
[03:16.000 --> 03:17.000] 好吧好吧
[03:17.000 --> 03:18.000] 好我们聊完了
[03:18.000 --> 03:19.000] 我们碎碎念
[03:19.000 --> 03:20.000] 好碎碎念的第一部分
[03:20.000 --> 03:24.000] 我们就准备开始正式的第一部分了
[03:24.000 --> 03:25.000] 然后我们今天想的是这样
[03:25.000 --> 03:27.000] 我们今天都说了叫开发中的碎碎念
[03:27.000 --> 03:28.000] 对吧
[03:28.000 --> 03:30.000] 开发中碎碎念肯定就是
[03:30.000 --> 03:31.000] 要么就是踩过的坑
[03:31.000 --> 03:33.000] 要么就是说是被人坑过
[03:33.000 --> 03:35.000] 然后要么就是自己坑了人
[03:35.000 --> 03:37.000] 然后我们今天就主要是来聊聊各种
[03:37.000 --> 03:39.000] 我们自己的踩坑经历
[03:39.000 --> 03:41.000] 然后的话我们就我们最开始先聊一聊
[03:41.000 --> 03:43.000] 大家可能都很关心
[03:43.000 --> 03:45.000] 你们四个娱乐主播对吧
[03:45.000 --> 03:46.000] 你们四个娱乐主播
[03:46.000 --> 03:47.000] 虽然说是娱乐主播
[03:47.000 --> 03:48.000] 但是作为开发里面
[03:48.000 --> 03:50.000] 你们平时踩过
[03:50.000 --> 03:52.000] 有什么踩过的坑没有
[03:52.000 --> 03:55.000] 有什么觉得这个东西很好玩的坑没有
[03:55.000 --> 03:57.000] 所以说我们就第一部分的话
[03:57.000 --> 03:59.000] 就是说是让大家来聊一聊
[03:59.000 --> 04:02.000] 我们自己踩过最有意思的坑是什么
[04:02.000 --> 04:04.000] 然后怎么发现
[04:04.000 --> 04:05.000] 然后的话
[04:05.000 --> 04:07.000] 那我就作为今天的主播
[04:07.000 --> 04:09.000] 我就来清点一下
[04:09.000 --> 04:12.000] 刚才是谁说他的赖心涛是两格来着
[04:12.000 --> 04:14.000] 是赖心涛同学对吧
[04:14.000 --> 04:16.000] 来我们就请赖心涛同学来先聊一聊
[04:16.000 --> 04:18.000] 我们今天就清点一下
[04:18.000 --> 04:20.000] 你是第一位发言的选手
[04:20.000 --> 04:21.000] OK
[04:21.000 --> 04:25.000] 我先说一个最近遇到的吧
[04:25.000 --> 04:28.000] 也不是最有意思的
[04:28.000 --> 04:29.000] 我要再想一想
[04:29.000 --> 04:31.000] 我可以先说一个最近遇到的
[04:31.000 --> 04:34.000] 就是我最近在搞一个用GitHub登录
[04:34.000 --> 04:37.000] 然后用Jungle写的
[04:37.000 --> 04:39.000] 有一个东西叫social call
[04:39.000 --> 04:42.000] 它就是集成了一些各个第三方登录
[04:42.000 --> 04:43.000] 比如说Google登录
[04:43.000 --> 04:44.000] Twitter登录之类的
[04:44.000 --> 04:47.000] 然后做这个GitHub登录的时候
[04:47.000 --> 04:48.000] 就做完了没有问题
[04:48.000 --> 04:50.000] 过几天发现全都挂了
[04:50.000 --> 04:51.000] 登录不上了
[04:51.000 --> 04:55.000] 然后GitHub返回的是403
[04:55.000 --> 05:00.000] 然后那个语言代码看了也没有什么问题
[05:00.000 --> 05:01.000] 也没有相关的issue
[05:01.000 --> 05:03.000] 就非常痛苦
[05:03.000 --> 05:08.000] 然后我给GitHub发了一封邮件
[05:08.000 --> 05:10.000] 过了几天他们回复我
[05:10.000 --> 05:13.000] 是他们把python-request
[05:13.000 --> 05:17.000] 就是request-could默认那个user agent
[05:17.000 --> 05:23.000] 给错误的封杀掉了
[05:23.000 --> 05:24.000] 其实我有个问题
[05:24.000 --> 05:28.000] 你刚才说是你一开始没有发现它出问题
[05:28.000 --> 05:29.000] 然后过了一段时间才出问题
[05:29.000 --> 05:33.000] 这个不是很奇怪吗
[05:33.000 --> 05:34.000] 是的
[05:34.000 --> 05:37.000] 他们邮件里说的是
[05:37.000 --> 05:42.000] 就那个GitHub的同学说的是by mistake
[05:42.000 --> 05:45.000] 但其实我在GitHub的文档里面
[05:45.000 --> 05:46.000] 发现了一个
[05:46.000 --> 05:49.000] 就是说你要写一下自己的UA
[05:49.000 --> 05:51.000] 然后我怀疑是这个问题
[05:51.000 --> 05:52.000] 就是他回复邮件之前
[05:52.000 --> 05:56.000] 我就自己把这个UA改了一下
[05:56.000 --> 05:57.000] 发现就可以了
[05:57.000 --> 05:59.000] 然后我发现这个UA
[05:59.000 --> 06:00.000] 是有一个很大的问题
[06:00.000 --> 06:02.000] 就是说他不想封API
[06:02.000 --> 06:05.000] 他只想封那些commit之类的
[06:05.000 --> 06:06.000] 他们想封掉
[06:06.000 --> 06:08.000] 因为里面有email
[06:08.000 --> 06:11.000] 但是API可能也被误杀了
[06:11.000 --> 06:13.000] 其实我有个问题
[06:13.000 --> 06:14.000] 就是你刚才说是
[06:14.000 --> 06:16.000] 你一开始没有发现它出问题
[06:16.000 --> 06:18.000] 然后过了一段时间才出问题
[06:18.000 --> 06:20.000] 这个是不是很奇怪吗
[06:20.000 --> 06:21.000] 是的
[06:21.000 --> 06:23.000] 因为他可能是故意封了
[06:23.000 --> 06:24.000] 然后的话
[06:24.000 --> 06:26.000] 但是你们投诉的人太多了
[06:26.000 --> 06:27.000] 是的
[06:27.000 --> 06:29.000] 因为刚开始他们没有封
[06:29.000 --> 06:30.000] 就是那一段时间
[06:30.000 --> 06:33.000] 就正常用了大约一个星期
[06:33.000 --> 06:36.000] 然后后来一个星期之后
[06:36.000 --> 06:37.000] 就突然的出问题
[06:37.000 --> 06:38.000] 就很奇怪
[06:38.000 --> 06:39.000] 所以我一开始就怀疑
[06:39.000 --> 06:41.000] 可能是对方的原因
[06:41.000 --> 06:43.000] 因为很多场的反作弊
[06:43.000 --> 06:45.000] 可能会基于频率和行为
[06:45.000 --> 06:46.000] 就不是看你是这个头
[06:46.000 --> 06:48.000] 就直接干掉你
[06:48.000 --> 06:49.000] 对
[06:49.000 --> 06:51.000] 那老爱你是怎么
[06:51.000 --> 06:52.000] 就是说当时你就是只是觉得
[06:52.000 --> 06:53.000] 我看到403了
[06:53.000 --> 06:56.000] 好像不太对对吧
[06:56.000 --> 06:57.000] 这个首先是看一下原代码
[06:57.000 --> 07:00.000] 然后看一下那个Github的
[07:00.000 --> 07:02.000] OAuth的文档
[07:02.000 --> 07:04.000] 我感觉原代码跟Oauth的文档
[07:04.000 --> 07:05.000] 都对得上
[07:05.000 --> 07:07.000] 就是那个
[07:07.000 --> 07:08.000] 但是那个文档里面
[07:08.000 --> 07:09.000] 有明确的说
[07:09.000 --> 07:12.000] 你的请求要带一个UA
[07:12.000 --> 07:13.000] 然后我看一下代码
[07:13.000 --> 07:14.000] 使用的默认的UA
[07:14.000 --> 07:16.000] 就是说他没指定UA
[07:16.000 --> 07:17.000] 然后那个request的库
[07:17.000 --> 07:18.000] 如果你不指定的话
[07:18.000 --> 07:20.000] request的库会给你
[07:20.000 --> 07:21.000] 自己带一个码
[07:21.000 --> 07:23.000] 我就觉得这个可能是
[07:23.000 --> 07:24.000] 这个的问题
[07:24.000 --> 07:26.000] 然后改了一下就好了
[07:26.000 --> 07:27.000] 可以
[07:27.000 --> 07:29.000] 我觉得这种东西的话
[07:29.000 --> 07:30.000] 有些时候还是挺隐蔽的
[07:30.000 --> 07:31.000] 对吧
[07:31.000 --> 07:32.000] 特别是他一些文档
[07:32.000 --> 07:33.000] 微记录的东西
[07:33.000 --> 07:35.000] 对尤其是那种默认参数的
[07:35.000 --> 07:36.000] 就是他
[07:36.000 --> 07:38.000] 就是你如果不设的话
[07:38.000 --> 07:39.000] 他会设一个默认的这种
[07:39.000 --> 07:40.000] 可以可以
[07:40.000 --> 07:41.000] 就是好吧
[07:41.000 --> 07:42.000] 我觉得我之前
[07:42.000 --> 07:44.000] 我前段时间之前也
[07:44.000 --> 07:45.000] 也遇到一个坑
[07:45.000 --> 07:46.000] 也是关于Header的
[07:46.000 --> 07:47.000] 不过不是UA
[07:47.000 --> 07:48.000] 等一下讲吧
[07:48.000 --> 07:49.000] 那我
[07:49.000 --> 07:51.000] 老大你的坑就是这个吗
[07:51.000 --> 07:53.000] 还有其他的坑可以分享吗
[07:54.000 --> 07:55.000] 先这个吧
[07:55.000 --> 07:56.000] 你们先说吧
[07:56.000 --> 07:57.000] 如果你们说的过程中
[07:57.000 --> 07:58.000] 我想起来别的
[07:58.000 --> 08:00.000] 我再查一下
[08:00.000 --> 08:01.000] OK好
[08:01.000 --> 08:04.000] 那我们的Nike9M和Adam选手的话
[08:04.000 --> 08:05.000] 你们俩谁来
[08:05.000 --> 08:06.000] 或者是你们俩猜拳
[08:06.000 --> 08:07.000] 决定一下谁来
[08:07.000 --> 08:08.000] 我先说吧
[08:08.000 --> 08:09.000] 因为我最近博客
[08:09.000 --> 08:10.000] 正好写过一篇文章
[08:10.000 --> 08:12.000] 就是讲遇到一些坑
[08:12.000 --> 08:13.000] 对
[08:13.000 --> 08:14.000] 因为就是
[08:14.000 --> 08:16.000] 我感觉我遇到坑
[08:16.000 --> 08:19.000] 本质原因还是因为
[08:19.000 --> 08:21.000] 单元测试的问题吧
[08:21.000 --> 08:22.000] 就是说
[08:23.000 --> 08:25.000] 就是说单元测试的输入
[08:25.000 --> 08:27.000] 如果你没有正确的去
[08:27.000 --> 08:29.000] mark对的话
[08:29.000 --> 08:31.000] 其实你测到的东西并不是它
[08:31.000 --> 08:34.000] 就程序里真正真正的表现
[08:34.000 --> 08:36.000] 就是说即使你的测试通过了
[08:36.000 --> 08:37.000] 然后也没有什么用
[08:37.000 --> 08:39.000] 然后然后我当时就
[08:39.000 --> 08:41.000] 没有实际去
[08:41.000 --> 08:42.000] 就有些东西
[08:42.000 --> 08:43.000] 有些实际的输入
[08:43.000 --> 08:44.000] 我没有去看
[08:44.000 --> 08:46.000] 然后我就
[08:46.000 --> 08:48.000] 我就从别人的那个
[08:48.000 --> 08:49.000] Unity Test里面
[08:49.000 --> 08:51.000] 把它的那个input拿过来
[08:52.000 --> 08:53.000] 然后测试通过了
[08:53.000 --> 08:55.000] 然后通过之后程序挂了
[08:57.000 --> 08:58.000] 对就他那个
[08:58.000 --> 08:59.000] 就是发现实际
[08:59.000 --> 09:00.000] 他传的那个
[09:00.000 --> 09:01.000] 传的那个字符串
[09:01.000 --> 09:02.000] 会带一个后缀
[09:02.000 --> 09:04.000] 但是他那个测试的时候
[09:04.000 --> 09:05.000] 没有写那个后缀
[09:05.000 --> 09:06.000] 然后没有写的话
[09:06.000 --> 09:08.000] 然后就会出问题
[09:08.000 --> 09:09.000] 所以就是说
[09:09.000 --> 09:10.000] 嗯
[09:10.000 --> 09:11.000] 这给我一个很大的教训吧
[09:11.000 --> 09:13.000] 就是说不能
[09:13.000 --> 09:15.000] 不能盲目相信Unity Test
[09:15.000 --> 09:17.000] 就虽然以前也有这个概念
[09:17.000 --> 09:20.000] 但是就发现真的是
[09:20.000 --> 09:22.000] 有太多的东西测不到
[09:22.000 --> 09:25.000] 尤其是这种多个component之间
[09:25.000 --> 09:27.000] 组合成一个大的系统的时候
[09:27.000 --> 09:29.000] 你每一部分测试的时候
[09:29.000 --> 09:31.000] 如果要把其他的东西mark掉
[09:31.000 --> 09:33.000] 就一定要特别小心的去
[09:33.000 --> 09:35.000] 去做这些mark
[09:35.000 --> 09:37.000] 就就至少保证你测的输入
[09:37.000 --> 09:39.000] 一定要是符合真实情况的才行
[09:39.000 --> 09:40.000] 对
[09:40.000 --> 09:41.000] 嗯
[09:41.000 --> 09:42.000] 我觉得对
[09:42.000 --> 09:43.000] 我觉得单元测试这个东西的确
[09:43.000 --> 09:45.000] 其实它可以教出一种
[09:45.000 --> 09:47.000] 我觉得它是一个很复杂的一个东西
[09:47.000 --> 09:49.000] 我觉得我们可以哪天做一期节目
[09:49.000 --> 09:52.000] 叫做单元测试的best practice
[09:52.000 --> 09:55.000] 这个东西做十期节目都讲不完的
[09:55.000 --> 09:57.000] 而且针对Python的这个mark
[09:57.000 --> 09:59.000] 其实有的时候我觉得用起来
[09:59.000 --> 10:01.000] 有一种艺术的感觉
[10:01.000 --> 10:04.000] 就是你如果只写单元测试
[10:04.000 --> 10:06.000] 其实有可能很多地方你测不到
[10:06.000 --> 10:07.000] 对Python来说
[10:07.000 --> 10:10.000] 很多地方要用集成测试来补充
[10:10.000 --> 10:11.000] 对
[10:11.000 --> 10:12.000] 对我觉得
[10:12.000 --> 10:14.000] 我觉得对于任何语言都是都是这样子
[10:14.000 --> 10:16.000] 但就是说Python的单元测试
[10:16.000 --> 10:18.000] 其实是我觉得应该是所有语言里最方便的
[10:18.000 --> 10:19.000] 但就会
[10:19.000 --> 10:20.000] 它可能就会给你一种错觉
[10:20.000 --> 10:24.000] 就是你写了很多很就mark的非常好
[10:24.000 --> 10:25.000] 然后你以为都测到了
[10:25.000 --> 10:26.000] 其实没有测到
[10:26.000 --> 10:29.000] 对而且还有一个问题就是动态语言嘛
[10:29.000 --> 10:32.000] 对所以说其实它不像精彩语言这种
[10:32.000 --> 10:34.000] 可以说有一些编译前的检查
[10:34.000 --> 10:37.000] 这种传参的参数类型啊这种
[10:37.000 --> 10:38.000] 对就是很多
[10:38.000 --> 10:40.000] 如果你只靠单元测试是测不到的
[10:40.000 --> 10:45.000] 这个问题这个对于Google倒不是什么特别大问题
[10:45.000 --> 10:48.000] 因为都有一些linter和静态分析的工具
[10:48.000 --> 10:49.000] 对
[10:49.000 --> 10:55.000] 我觉得的话反正我觉得的话就其实对于线上的东西而言的话
[10:55.000 --> 10:59.000] 基本就是基本我感觉就是说是要应该按照单测
[10:59.000 --> 11:00.000] 然后会集成
[11:00.000 --> 11:01.000] 然后灰度
[11:01.000 --> 11:04.000] 然后然后再上线这样一个东西
[11:04.000 --> 11:07.000] 我感觉少了其中一个环节的话都指不定有什么坑
[11:07.000 --> 11:09.000] 嗯是
[11:09.000 --> 11:14.000] 对反正我感觉按照我学到一句话就是所谓的程序正义
[11:14.000 --> 11:16.000] 无存侥幸就是说你别以为你单测过了
[11:16.000 --> 11:18.000] 你就可以直接全量上线了
[11:18.000 --> 11:20.000] 对还有一个就是
[11:20.000 --> 11:23.000] 当然这个可能跟我们后面聊的比较关系紧密
[11:23.000 --> 11:27.000] 就我觉得你加一个什么功能就一定不能假设它会work
[11:27.000 --> 11:30.000] 一定要就是先加了一个新功能就多打一些log
[11:30.000 --> 11:32.000] 万一挂了就会比较好
[11:32.000 --> 11:35.000] 对对对我觉得是我自己也踩过一些坑
[11:35.000 --> 11:37.000] 我觉得这个东西很重要
[11:37.000 --> 11:39.000] 我觉得就是用我们总监的一句话来说
[11:39.000 --> 11:42.000] 你千万不要对你的代码太过有信心
[11:42.000 --> 11:43.000] 是的
[11:43.000 --> 11:48.000] 对然后呢那就那你这边还有什么东西吗
[11:48.000 --> 11:49.000] 让让让他们讲吧
[11:49.000 --> 11:51.000] 对我我看一下
[11:51.000 --> 11:53.000] 嗯行好那adam呢
[11:53.000 --> 11:58.000] OK我来分享一个我印象深刻的坑吧
[11:58.000 --> 12:01.000] 嗯对就是我我先讲一下现象
[12:01.000 --> 12:04.000] 就是有一天我收到一个用户反馈
[12:04.000 --> 12:09.000] 这个用户说他在我们的网站上点登录
[12:09.000 --> 12:12.000] 能登录进去也能看
[12:12.000 --> 12:15.000] 但是他一刷新或者是做其他的请求
[12:15.000 --> 12:19.000] 我们的网站就会提示他说未登录需要登录
[12:19.000 --> 12:22.000] 你们网站是直呼吗
[12:22.000 --> 12:25.000] 嗯可以吧对
[12:25.000 --> 12:28.000] 这是什么磨了两口的回答
[12:28.000 --> 12:31.000] 对OK然后我就是是哪网站不知道
[12:31.000 --> 12:35.000] 重要的现象就是他可以登录可以登录成功
[12:35.000 --> 12:37.000] 然后也能看到登录成功的第一页
[12:37.000 --> 12:42.000] 但是他只要一刷新或者提交任何请求都会提示他未登录
[12:42.000 --> 12:46.000] 然后他刷新之后就真的是未登录了
[12:46.000 --> 12:49.000] 对这是我我看到的用户现象
[12:49.000 --> 12:52.000] 然后这个现象对我来说就是一个大坑
[12:52.000 --> 12:55.000] 我可以分享一下我当时的debug的过程
[12:55.000 --> 12:56.000] 我我又回去看了一下
[12:56.000 --> 13:01.000] 大概是16年的时候15年的时候遇到这个问题
[13:01.000 --> 13:04.000] 就是首先我尝试自己复现
[13:04.000 --> 13:05.000] 我拿自己的用户去登录
[13:05.000 --> 13:07.000] 我发现没有这个问题
[13:07.000 --> 13:13.000] 然后和用户沟通之后尝试用用户本人的账户去操作
[13:13.000 --> 13:16.000] 发现也没有这个问题对
[13:16.000 --> 13:22.000] 然后去看登录日志看请求日志发现登录是200是真的成功的
[13:22.000 --> 13:24.000] 而且看他的现象也是没有问题的
[13:24.000 --> 13:28.000] 那我就我就把自己搞成一个解释器
[13:28.000 --> 13:31.000] 我自己去得代码组行去看
[13:31.000 --> 13:33.000] 我也没有找到问题
[13:33.000 --> 13:40.000] 为什么不能在logout的就是就logout没有这种逻辑吗
[13:40.000 --> 13:47.000] 但是怎么这个其实如果我当时比如说我在logout上去打log的话
[13:47.000 --> 13:49.000] 其实也也不会打出任何log
[13:49.000 --> 13:51.000] 我待会会讲到
[13:51.000 --> 13:56.000] 然后然后其实中间一步
[13:56.000 --> 14:00.000] 刚才我说的我和用户我尝试用用户的账户去复现
[14:00.000 --> 14:01.000] 我发现也没有问题的时候
[14:01.000 --> 14:07.000] 其实这个时候基本上就可以把问题定位在用户的设备上
[14:07.000 --> 14:10.000] 对对这是我和那个用户唯一的区别吧
[14:10.000 --> 14:12.000] 对我或者说网络运营商有区别
[14:12.000 --> 14:15.000] 但是感觉这个区别应该不大
[14:15.000 --> 14:16.000] 对
[14:16.000 --> 14:23.000] 然后我就为这个用户加了一个特别详细的这个log来记录他的请求
[14:23.000 --> 14:26.000] 来来看到底有什么不一样
[14:26.000 --> 14:28.000] 对我看了半天
[14:28.000 --> 14:33.000] 我没看出来有啥不一样的HTTP请求还能有什么不一样呢
[14:33.000 --> 14:37.000] 对然后我我印象中我当时又想了一下午
[14:37.000 --> 14:40.000] 就是完全没有头绪这种事情
[14:40.000 --> 14:42.000] 然后但是但是回到回过去
[14:42.000 --> 14:44.000] 我觉得可能还是请求的问题
[14:44.000 --> 14:46.000] 我就一点点的看那个请求报文
[14:46.000 --> 14:48.000] 我发现一个问题
[14:48.000 --> 14:51.000] 我发现在这个用户的QQ里
[14:51.000 --> 14:57.000] 他有一个Unicode乱码的字符
[14:57.000 --> 15:03.000] 你可以认为他在QQ里带了一个汉字
[15:03.000 --> 15:07.000] 对然后那你们那你们返回的QQ对不对
[15:07.000 --> 15:09.000] 我们返回到QQ是正常的
[15:09.000 --> 15:13.000] 对他提交了QQ始终有一个汉字
[15:13.000 --> 15:19.000] 然后然后然后我就去了解了一些QQ的具体实现
[15:19.000 --> 15:21.000] 这个其实就比较有意思了
[15:21.000 --> 15:23.000] 就是我去看了QQ的RFC
[15:23.000 --> 15:29.000] 其实QQ他允许的合法字符只包含ASK字符
[15:29.000 --> 15:32.000] 然后这ASK字符中还要去掉控制符
[15:32.000 --> 15:36.000] 双引号逗号这些可能本身就是在QQ格式里有含义的
[15:36.000 --> 15:39.000] 这不一些字符
[15:39.000 --> 15:43.000] 对然后Python的实现也是严格按照实现的
[15:43.000 --> 15:46.000] 就是他会设置一个合法字符的白名单
[15:46.000 --> 15:51.000] 然后只要是非法的他就抛错
[15:51.000 --> 15:54.000] 对然后然后关键的问题就出在Tonado上
[15:54.000 --> 15:58.000] Tonado他是把这个QQ的那一串Stream
[15:58.000 --> 16:01.000] 就是A等于1分号B等于2这种Stream
[16:01.000 --> 16:03.000] 他一把都传进去了
[16:03.000 --> 16:05.000] 对然后传进去之后
[16:05.000 --> 16:07.000] Python的标准库会给他报错
[16:07.000 --> 16:09.000] 就是说包含非法字符
[16:09.000 --> 16:13.000] 然后Tonado就CatchException
[16:13.000 --> 16:15.000] 然后什么都没做
[16:15.000 --> 16:20.000] 然后这个导致用户登录请求的时候
[16:20.000 --> 16:22.000] 他提交的是用户名密码
[16:22.000 --> 16:26.000] 对然后我们去教验发现OK他是登录的
[16:26.000 --> 16:28.000] 那我们就认为这个请求是登录状态
[16:28.000 --> 16:30.000] 然后给到他登录状态的那个页面
[16:30.000 --> 16:32.000] 登录后的第一页
[16:32.000 --> 16:35.000] 对然后他在发后续的请求的时候
[16:35.000 --> 16:37.000] 都因为这个非法的字符
[16:37.000 --> 16:40.000] 我们就拿不到这个QQ
[16:40.000 --> 16:42.000] 对然后就认为他是未登录的
[16:42.000 --> 16:44.000] 然后他又要重新登录
[16:44.000 --> 16:46.000] 对然后他就重新登录
[16:46.000 --> 16:48.000] 重新登录然后能开第一页
[16:48.000 --> 16:50.000] 然后一刷新又要重新登录
[16:50.000 --> 16:52.000] 但是我这个地方有个问题
[16:52.000 --> 16:56.000] 你是说你们下发的QQ是正常的对吧
[16:56.000 --> 17:01.000] 对其实不是下发的QQ
[17:01.000 --> 17:04.000] 下发的QQ是正常的
[17:04.000 --> 17:06.000] 下发的页面也是正常的
[17:06.000 --> 17:09.000] 对那他那个就说是额外的非法的QQ
[17:09.000 --> 17:12.000] 是从哪来的难道是浏览器的特殊行为
[17:12.000 --> 17:16.000] 你说的对这个用户装了一个浏览器插件
[17:16.000 --> 17:19.000] 然后那个浏览器插件应该还不是什么
[17:19.000 --> 17:21.000] 我就猜到是这样
[17:21.000 --> 17:24.000] 还不是什么特别怎么说
[17:24.000 --> 17:25.000] 特别正常的插件
[17:25.000 --> 17:28.000] 那个插件就是给用户的请求里
[17:28.000 --> 17:31.000] 私自插入了这个QQ做用户追踪
[17:31.000 --> 17:36.000] 哇塞你这个坑有点有点隐蔽啊
[17:36.000 --> 17:40.000] 对啊然后我当时查了一天我超级崩溃
[17:40.000 --> 17:43.000] 然后后来总算是搞出来了
[17:43.000 --> 17:45.000] 来我来采访一下Adam选手
[17:45.000 --> 17:50.000] 然后你当时查出来查出来这个问题后的第一反应是什么
[17:50.000 --> 17:55.000] 我大概就是问候了那个浏览器插件作者无数遍吧
[17:55.000 --> 17:57.000] 问候全家无数遍的感觉
[17:57.000 --> 18:00.000] 就是就是这种这种情况就很无奈嘛
[18:00.000 --> 18:05.000] 你别你做的是一个面向用户的这种系统
[18:05.000 --> 18:10.000] 其实它的输入你是有预期说和你的预期是不符的
[18:10.000 --> 18:17.000] 但是你谁能想到这个预期是在HTTP的这种QQ的具体格式上是不合法的呢
[18:17.000 --> 18:21.000] 对我觉得这个地方的确挺坑的
[18:21.000 --> 18:27.000] 说起来你怎么你怎么发现那个字符是有哪个浏览器插件弄起来
[18:27.000 --> 18:28.000] 我没有发现
[18:28.000 --> 18:30.000] 我是跟用户说了让他挨个进用
[18:30.000 --> 18:33.000] 然后来看是哪一个
[18:33.000 --> 18:39.000] 啊哎这种这种应该尽早用隐身模式来看一下
[18:39.000 --> 18:41.000] 因为隐身模式是最纯净的
[18:41.000 --> 18:44.000] 对我觉得这个也是一个经验嘛
[18:44.000 --> 18:47.000] 就是如果有用户说了这个你这无法复现
[18:47.000 --> 18:51.000] 可以尝试让他用隐身模式来试一下
[18:51.000 --> 18:54.000] 对但是其实有的用户隐身模式也会配一些插件
[18:54.000 --> 18:55.000] 比如说我就试掉了
[18:55.000 --> 18:57.000] 比如说我也是这样的
[18:57.000 --> 18:59.000] 隐身模式怎么配插件
[18:59.000 --> 19:04.000] 你在那个chrome extension里面去设置那个extension的话
[19:04.000 --> 19:07.000] 是可以在隐身模式下使用就可以了
[19:07.000 --> 19:09.000] 啊对的
[19:09.000 --> 19:16.000] 然后我当时的做法就是其实给Tonado加了一层中间键
[19:16.000 --> 19:18.000] 然后先自己来load
[19:18.000 --> 19:20.000] 然后过滤掉非法字符
[19:20.000 --> 19:22.000] 然后再把这个传给标准户
[19:22.000 --> 19:25.000] 对然后我觉得这也算是遗憾吧
[19:25.000 --> 19:26.000] 因为我们当时在用4.0
[19:26.000 --> 19:29.000] 后来5.0的时候Tonado修复了这个问题
[19:29.000 --> 19:31.000] 可惜不是我提的PR
[19:31.000 --> 19:33.000] 我当时应该去提一个的
[19:33.000 --> 19:34.000] 我觉得可以
[19:34.000 --> 19:36.000] 然后Fork Fork
[19:36.000 --> 19:38.000] 然后PR PR
[19:38.000 --> 19:41.000] 对这就是我踩的一个大坑
[19:41.000 --> 19:44.000] 我觉得有点心疼Andam的选手
[19:44.000 --> 19:45.000] 然后我最近踩的几个
[19:45.000 --> 19:47.000] 我之前踩过还有最近踩的坑
[19:47.000 --> 19:49.000] 其中有一个是
[19:49.000 --> 19:50.000] 我分享两个坑吧
[19:50.000 --> 19:52.000] 然后的话
[19:52.000 --> 19:53.000] 第一个是
[19:53.000 --> 19:57.000] 那个我不是现在开始转行Go选手了吗
[19:57.000 --> 19:58.000] 然后的话
[19:58.000 --> 19:59.000] 然后我一直
[19:59.000 --> 20:02.000] 然后就我之前有写过一个Go的
[20:02.000 --> 20:04.000] 就是说是基层的反向代理
[20:04.000 --> 20:05.000] 然后的话对
[20:05.000 --> 20:07.000] 然后你们知道反向代理的话
[20:07.000 --> 20:10.000] 其实就是把一个http的request load进来
[20:10.000 --> 20:12.000] 然后转发到另外一个地方去对吧
[20:12.000 --> 20:13.000] 然后这是个大背景
[20:13.000 --> 20:17.000] 然后我们在GoLang里面用loadhttp这一层的话
[20:17.000 --> 20:19.000] 就是用GoLang的标准户
[20:19.000 --> 20:20.000] nethttp
[20:20.000 --> 20:23.000] 然后在那个突然发现一个很有意思的东西
[20:23.000 --> 20:26.000] 就是说是我一个一堆请求进来之后
[20:26.000 --> 20:30.000] 有相当一部分请求就直接返回4xxxx
[20:30.000 --> 20:33.000] 然后对400还是403
[20:33.000 --> 20:34.000] 然后我一下忘了
[20:34.000 --> 20:36.000] 对然后我当时就很奇怪
[20:36.000 --> 20:37.000] 然后就是说是
[20:37.000 --> 20:39.000] 然后发现这个东西
[20:39.000 --> 20:41.000] 而这一类的请求
[20:41.000 --> 20:43.000] 都是从某一个客户端进来的
[20:43.000 --> 20:46.000] 然后某一类型的客户端进来的
[20:46.000 --> 20:47.000] 然后然后我们就在想
[20:47.000 --> 20:49.000] 我就在想是这个问题
[20:49.000 --> 20:51.000] 然后你们猜一下这个问题是什么
[20:51.000 --> 20:52.000] 猜对有假
[20:54.000 --> 20:56.000] 这怎么猜的到
[20:58.000 --> 21:00.000] 然后实际上是这样
[21:00.000 --> 21:02.000] 然后就是我刚才已经有前情提要了
[21:02.000 --> 21:04.000] 这个地方是关于header的
[21:04.000 --> 21:06.000] 因为是在那个RFC里面
[21:06.000 --> 21:09.000] 那个就是说是在RFC7230里面
[21:09.000 --> 21:10.000] 那个规定了
[21:10.000 --> 21:15.000] 就是说是你在一个合法的http request header里面
[21:15.000 --> 21:17.000] 有一个字是必须有的是host
[21:17.000 --> 21:20.000] 是表示你的来源主机对吧
[21:21.000 --> 21:22.000] 然后来
[21:22.000 --> 21:25.000] 啊host不是请求的
[21:25.000 --> 21:27.000] 对对请求的来源主机嘛
[21:27.000 --> 21:28.000] 对吧
[21:28.000 --> 21:29.000] 对就是你发起一个request的时候
[21:29.000 --> 21:31.000] 你的host是必须的对吧
[21:31.000 --> 21:34.000] 对然后的话在golang里面
[21:34.000 --> 21:37.000] 他是认为就是说这个地方是必须的一个选项
[21:37.000 --> 21:40.000] 如果你没有host的这个http的话
[21:40.000 --> 21:45.000] 他直接在他的标准库里面就直接给你forb的
[21:45.000 --> 21:49.000] 然后的话根本得不到你后台的处理逻辑
[21:49.000 --> 21:50.000] 然后的话
[21:50.000 --> 21:54.000] 但是实际上是有很多第三方的库
[21:54.000 --> 21:56.000] 就比如说java的native
[21:56.000 --> 22:00.000] 或者说是其他的一些库
[22:00.000 --> 22:04.000] 他们发起的请求里面是默认不带host
[22:05.000 --> 22:09.000] 他们只是一个不带host
[22:09.000 --> 22:15.000] 不带host不是http 1.0才可以这样
[22:15.000 --> 22:17.000] 1.1不是必须带的
[22:17.000 --> 22:18.000] 是1.1必须带的
[22:18.000 --> 22:20.000] 然后但是因为他们库不知道是从
[22:20.000 --> 22:23.000] 处于什么角度考虑是默认不带host
[22:23.000 --> 22:27.000] 换句话说就是不完整的一个request
[22:27.000 --> 22:29.000] 一个http的请求
[22:29.000 --> 22:31.000] 而对于golang这样的库内
[22:31.000 --> 22:35.000] 他可能认为大家处理的都是一个标准的http请求
[22:35.000 --> 22:37.000] 就说是符合RFC7230的
[22:37.000 --> 22:39.000] 然后7230的对
[22:39.000 --> 22:41.000] 然后的话但是实际上并不是
[22:41.000 --> 22:44.000] 所以说最后我们的做法是只能去
[22:44.000 --> 22:47.000] 在构建镜像的时候把它给patch掉
[22:47.000 --> 22:50.000] 把这一部分代码给它patch掉
[22:50.000 --> 22:53.000] 因为golang这个地方就涉及到一个很坑的点了
[22:53.000 --> 22:58.000] 它的natehttp这个包是跟它内部强而我和的
[22:58.000 --> 23:03.000] 你想把它fork出来重新写一部分都是不可以的
[23:03.000 --> 23:10.000] 我刚刚没有听明白是你们的客户端是自己的客户端
[23:10.000 --> 23:14.000] 可能就是说你不同语言可能用其他各种各样的客户端
[23:14.000 --> 23:18.000] 就是说是用某一个比如说java的http的client
[23:18.000 --> 23:22.000] apache的http client或者说是nate
[23:22.000 --> 23:25.000] 用nate java的pysh request这种东西
[23:25.000 --> 23:27.000] 某一些这种code
[23:27.000 --> 23:31.000] 所以有一个客户端是不带host的
[23:31.000 --> 23:33.000] 据我后面复查的话
[23:33.000 --> 23:35.000] 然后是比如说像java的nate这种东西
[23:35.000 --> 23:37.000] 它是不带host的
[23:37.000 --> 23:40.000] 然后的话就很恶心
[23:42.000 --> 23:47.000] 我总感觉这种坑应该是有很多人都遇到过才对
[23:47.000 --> 23:53.000] nate社区难道没有遇到过这种bug的反馈吗
[23:53.000 --> 23:58.000] 但是目前就目前而言的话可能它是允许你自己加的
[23:58.000 --> 24:01.000] 我猜的话可能nate社区
[24:01.000 --> 24:03.000] 我没有去往nate那边去查
[24:03.000 --> 24:07.000] 我猜的话nate社区可能说是我给你提供一个选项
[24:07.000 --> 24:10.000] 或者说是你需要的时候你显示开启
[24:12.000 --> 24:15.000] 如果在前面挡一个adjins
[24:15.000 --> 24:18.000] 然后adjins收到这种请求往后端转发的时候
[24:18.000 --> 24:20.000] 再设立一个host的变量
[24:20.000 --> 24:22.000] 这个是可以的
[24:22.000 --> 24:26.000] 但是因为我们就说是我自己写可能就是一个7层的反派
[24:26.000 --> 24:28.000] 就直接对外暴露就直接是暴露了
[24:28.000 --> 24:30.000] 没有过Nginx
[24:31.000 --> 24:33.000] 好像也只有golang会这样是吧
[24:33.000 --> 24:35.000] 其他的语言我不太清楚
[24:35.000 --> 24:40.000] 但是golang的话他就说是他默认你所有的http都是符合RFC的
[24:40.000 --> 24:45.000] 不是我的意思是也只有golang不会在前面加一层server这样子
[24:45.000 --> 24:47.000] 其实如果是内部用的话
[24:47.000 --> 24:49.000] 有whiskey也可以直接暴露
[24:49.000 --> 24:52.000] golang其实要后面你最后的服务的话
[24:52.000 --> 24:54.000] 其实也是要加server的
[24:54.000 --> 24:56.000] 就是说做负载均衡
[24:56.000 --> 24:58.000] 对就看需求
[25:00.000 --> 25:01.000] 然后我第二个坑的话
[25:01.000 --> 25:03.000] 之前不知道你们采购没有
[25:03.000 --> 25:06.000] 一个就是说是python内存泄漏的坑
[25:06.000 --> 25:08.000] 然后的话之前一个情况就是说
[25:08.000 --> 25:10.000] 是我之前在老东家的时候
[25:10.000 --> 25:13.000] 然后就简而言之的话
[25:13.000 --> 25:16.000] 就是说是你突然会某一天发现某一个服务
[25:16.000 --> 25:20.000] 它的内存就一直水位一直往上高
[25:20.000 --> 25:23.000] 就内存就比如说最开始看到40%
[25:23.000 --> 25:25.000] 你过了一天去看到60%
[25:25.000 --> 25:27.000] 然后你再过一天去看到100%
[25:27.000 --> 25:29.000] 这种挺常见的
[25:29.000 --> 25:31.000] 对这种挺常见的
[25:31.000 --> 25:32.000] 因为当时我
[25:32.000 --> 25:35.000] 就是它慢慢的涨不是突然涨上去
[25:35.000 --> 25:37.000] 对然后的话后面因为我
[25:37.000 --> 25:39.000] 当时我太喜庆的具体的进程里面去看
[25:39.000 --> 25:42.000] 我看他的内存分配
[25:42.000 --> 25:44.000] 就是用python自带的那个trace mail lock
[25:44.000 --> 25:46.000] 还有就是他的gc cool
[25:46.000 --> 25:48.000] 去看他的gc状态
[25:48.000 --> 25:50.000] 还有看他内存分配是正常的
[25:50.000 --> 25:53.000] 这是正常的
[25:53.000 --> 25:55.000] 但是这个地方你们猜问题是出在哪里
[25:55.000 --> 25:58.000] 你们猜这内存泄露是最后定位是在哪个地方
[25:58.000 --> 26:02.000] 是不是维护了一个list
[26:02.000 --> 26:04.000] 然后一直往里面放元素
[26:04.000 --> 26:06.000] 你怎么判断它是正常的
[26:06.000 --> 26:09.000] 这个正常的原因的话
[26:09.000 --> 26:10.000] 就是说是他该回收的
[26:10.000 --> 26:13.000] 我是三层去判断它正常的
[26:13.000 --> 26:15.000] 第一个是review代码
[26:15.000 --> 26:18.000] 我们确定我们是没有什么全局内型的东西的
[26:18.000 --> 26:22.000] 第二个东西的话是他gc的话是该回收是回收的
[26:22.000 --> 26:26.000] 对然后我们用他gc是快造的对吧
[26:26.000 --> 26:30.000] 对然后的话第三个用他trace mail lock去看他的
[26:30.000 --> 26:32.000] 就是说是具体对象的分配
[26:32.000 --> 26:34.000] 那个内存分配也是在符合预期的
[26:34.000 --> 26:39.000] 他应该总有一块是
[26:39.000 --> 26:44.000] 就你比如说你可以每天去就是弄一次
[26:44.000 --> 26:46.000] 然后弄一个把它dump下来的
[26:46.000 --> 26:49.000] 然后看一下对比一下
[26:49.000 --> 26:53.000] 这个的话后面没有去细查
[26:53.000 --> 26:55.000] 然后就没有做到这一步
[26:55.000 --> 26:58.000] 但是我们前面三个步骤是做了对吧
[26:58.000 --> 27:03.000] 然后你们猜内存泄漏点是在哪个地方
[27:03.000 --> 27:07.000] 听起来就像有一个变量在不断的变大
[27:07.000 --> 27:11.000] 不是然后是实际上是在deliver c上
[27:11.000 --> 27:13.000] 然后deliver c的mail lock上面
[27:13.000 --> 27:16.000] 因为他是这个其实是一个pattern
[27:16.000 --> 27:18.000] 一个就是说是或者是用deliver c
[27:18.000 --> 27:21.000] 一个很臭名昭著的问题了
[27:21.000 --> 27:22.000] 就是说你们后面
[27:22.000 --> 27:25.000] 你等一下我可以把一些参考资料发出来
[27:25.000 --> 27:26.000] 就是deliver c的话
[27:26.000 --> 27:28.000] mail lock在一些特定的情况下
[27:28.000 --> 27:31.000] 他你去申请你最开始是用mail lock
[27:31.000 --> 27:34.000] 去申请快递的内存对吧
[27:34.000 --> 27:36.000] 然后的话最后你不要这块内存的
[27:36.000 --> 27:38.000] 你是用free去把它还给操作系统对吧
[27:38.000 --> 27:41.000] 然后deliver c的话是在特定的情况下
[27:41.000 --> 27:43.000] free的这部分的内存
[27:43.000 --> 27:45.000] 他是没有办法去还给操作系统
[27:45.000 --> 27:48.000] 那你们最后怎么解决的
[27:48.000 --> 27:50.000] 这种情况的话
[27:50.000 --> 27:53.000] 我们是换用了就是说是机架出的
[27:53.000 --> 27:54.000] 另外一个TCM
[27:54.000 --> 27:57.000] 就是换mail lock的库去解决这个问题
[27:57.000 --> 27:59.000] 那我在想这种情况下
[27:59.000 --> 28:03.000] 他那个你看到会有一部分内存是在哪里
[28:03.000 --> 28:05.000] 会显示成什么样子
[28:05.000 --> 28:06.000] 目前看起来的话
[28:06.000 --> 28:08.000] 就是一直是持有的状态
[28:08.000 --> 28:11.000] 但是你看但是你去从trace mail lock来看
[28:11.000 --> 28:14.000] 你去看到python是没有持有的
[28:14.000 --> 28:15.000] 就是他已经是free了
[28:15.000 --> 28:18.000] 但是他free之后没有还给操作系统
[28:18.000 --> 28:20.000] 哦
[28:20.000 --> 28:22.000] 这好tricky
[28:22.000 --> 28:24.000] 对我觉得当时这个地方就很好玩
[28:24.000 --> 28:26.000] 然后因为python在那个后面
[28:26.000 --> 28:29.000] 我去请教的时候是张翔老师
[28:29.000 --> 28:30.000] 张翔老师在他们的话
[28:30.000 --> 28:32.000] 他们华为那边也遇到过这个问题
[28:32.000 --> 28:36.000] 然后的话在python2.7.15的时候
[28:36.000 --> 28:39.000] 是有过一个补丁区的部分解决这个问题
[28:39.000 --> 28:40.000] 但是没有彻底解决
[28:43.000 --> 28:46.000] 对我觉得我觉得这种坑的话特别隐私
[28:46.000 --> 28:50.000] 有些时候之前我记得在那个华网邮件组里面的话
[28:50.000 --> 28:52.000] 都是有一个邮件去讨论过
[28:52.000 --> 28:54.000] 然后就说是python的几大内存泄漏的坑
[28:54.000 --> 28:57.000] 说起来你之前说在某些条件
[28:57.000 --> 29:00.000] 他才会不会还给操作系统
[29:00.000 --> 29:01.000] 那个条件是啥
[29:01.000 --> 29:03.000] 这个条件说起来有一点复杂
[29:03.000 --> 29:06.000] 我干脆这个条件这个地方的话
[29:06.000 --> 29:08.000] 就说是涉及到一个对齐的问题
[29:08.000 --> 29:09.000] 我记得
[29:09.000 --> 29:12.000] 然后我等一下把这个操作系统的资料
[29:12.000 --> 29:14.000] 直接发那个分享出来
[29:14.000 --> 29:16.000] 行行行OK我们之后都整理出来
[29:16.000 --> 29:17.000] 对整理出来
[29:17.000 --> 29:19.000] 因为这个地方要是要想聊的话
[29:19.000 --> 29:20.000] 估计聊几期都聊不完
[29:20.000 --> 29:23.000] 这个东西从底层一直聊到现在
[29:23.000 --> 29:27.000] 你这个比较技术含量的一个bug
[29:27.000 --> 29:29.000] 没有我觉得是挺好玩的一个bug
[29:29.000 --> 29:32.000] 因为其实你去有些时候你会觉得很操蛋
[29:32.000 --> 29:35.000] 就是说你觉得我自己看我怎么
[29:35.000 --> 29:36.000] 我代码没问题
[29:36.000 --> 29:38.000] 我线上服务就没问题
[29:38.000 --> 29:40.000] 然后有很多时候我觉得这个地方就提醒了
[29:40.000 --> 29:42.000] 给我的一个价值的东西
[29:42.000 --> 29:45.000] 就是说是很多时候如果你反复double check了
[29:45.000 --> 29:46.000] 或者说triple check了
[29:46.000 --> 29:49.000] 你自己的锅不在这个地方的时候
[29:49.000 --> 29:52.000] 你可以去往更深一层思考
[29:52.000 --> 29:54.000] 你看一下是不是其他依赖的坑
[29:54.000 --> 29:56.000] 很多时候我们做代码的
[29:56.000 --> 29:58.000] 很多时候可能是更习惯的去怪罪自己
[29:58.000 --> 30:00.000] 我操你代码有问题了
[30:00.000 --> 30:02.000] 肯定是我的锅
[30:02.000 --> 30:03.000] 别急我马上给你解决
[30:03.000 --> 30:06.000] 我觉得这个地方其实是对我挺大的一个教育的
[30:06.000 --> 30:09.000] 然后我们坑的话
[30:09.000 --> 30:10.000] 其实就差不多
[30:10.000 --> 30:11.000] 我觉得我们坑的话
[30:11.000 --> 30:14.000] 其实差不多也聊到快半个小时半个钟了
[30:14.000 --> 30:16.000] 然后的话我们其实可以来聊一聊其他的
[30:16.000 --> 30:17.000] 所以说
[30:17.000 --> 30:21.000] 等一下我再补充一个
[30:21.000 --> 30:23.000] 就是这个我还没仔细看
[30:23.000 --> 30:26.000] 就是最近那个flask依赖的
[30:26.000 --> 30:30.000] 那个workzog
[30:30.000 --> 30:32.000] 单词是德语不太会读
[30:32.000 --> 30:35.000] 然后有一个PR挺有意思的
[30:35.000 --> 30:36.000] 我的朋友发给我了
[30:36.000 --> 30:37.000] 我还没去看
[30:37.000 --> 30:40.000] 就是他fix一个内存泄漏的bug
[30:40.000 --> 30:44.000] Poll request的ID是1521
[30:44.000 --> 30:46.000] 我一会贴一下链接
[30:46.000 --> 30:49.000] 这个我还没看
[30:49.000 --> 30:50.000] 我本来打算周末看
[30:50.000 --> 30:51.000] 这个很有意思
[30:51.000 --> 30:54.000] 就是他在上面贴了一个链接
[30:54.000 --> 30:56.000] 说他怎么发现这个bug的
[30:56.000 --> 31:01.000] 然后那个链接是一个三个小时的YouTube视频
[31:01.000 --> 31:03.000] 所以我觉得这个值得看一下
[31:03.000 --> 31:04.000] 可以
[31:04.000 --> 31:06.000] 你贴一下
[31:06.000 --> 31:08.000] 我之后去看一看
[31:08.000 --> 31:10.000] 这哥们挺有意思的
[31:10.000 --> 31:11.000] 把自己debug的过程
[31:11.000 --> 31:13.000] 给修复的过程录了下来
[31:13.000 --> 31:14.000] 三个小时
[31:14.000 --> 31:15.000] 三个半小时
[31:15.000 --> 31:16.000] 可以
[31:16.000 --> 31:20.000] 我们等下会觉得很有价值去看对吧
[31:20.000 --> 31:22.000] 但我看这个PR被close了
[31:22.000 --> 31:24.000] 因为他提了另一个PR
[31:24.000 --> 31:26.000] 好像就是在修复这个问题
[31:26.000 --> 31:27.000] OK
[31:27.000 --> 31:29.000] 那我们等一下可以去看一下
[31:29.000 --> 31:30.000] 好
[31:30.000 --> 31:32.000] 那我们来开始聊一聊吧
[31:32.000 --> 31:34.000] 然后我们下面的话题的话
[31:34.000 --> 31:37.000] 可能大家也是非常感兴趣
[31:37.000 --> 31:38.000] 然后你们猜
[31:38.000 --> 31:39.000] 我等下观众朋友们
[31:39.000 --> 31:40.000] 你们可以
[31:40.000 --> 31:41.000] 听众朋友们
[31:41.000 --> 31:43.000] 你们可以先关闭一下
[31:43.000 --> 31:44.000] 你们的播客
[31:44.000 --> 31:45.000] 然后来猜一下
[31:45.000 --> 31:47.000] 我们接下来会聊什么话题
[31:47.000 --> 31:49.000] 然后实际上是
[31:49.000 --> 31:50.000] 我们差不多
[31:50.000 --> 31:51.000] 我来采访
[31:51.000 --> 31:52.000] 我先来采访一下
[31:52.000 --> 31:55.000] 盛涛你写Python多久了
[31:55.000 --> 31:58.000] Python三年了
[31:58.000 --> 31:59.000] 三年可以
[31:59.000 --> 32:01.000] 然后Nike9M呢
[32:01.000 --> 32:04.000] 我应该是从13年开始写了
[32:04.000 --> 32:05.000] 到现在六年了
[32:05.000 --> 32:07.000] 但我写
[32:07.000 --> 32:10.000] 但我肯定在生产环境写的都没有你们多
[32:10.000 --> 32:12.000] 都是写自己项目
[32:12.000 --> 32:14.000] 你这都快七年之痒了
[32:14.000 --> 32:16.000] 然后Adam呢
[32:16.000 --> 32:19.000] 我和Nike9M应该是同一年开始
[32:19.000 --> 32:21.000] 在一起吧
[32:21.000 --> 32:22.000] 然后对
[32:22.000 --> 32:25.000] 然后我也是差不多快写三年了
[32:25.000 --> 32:27.000] 然后我们差不多写了几年了
[32:27.000 --> 32:29.000] 然后我们觉得可能就是说
[32:29.000 --> 32:31.000] 我们自己对于Python
[32:31.000 --> 32:33.000] 还有Python一些主流的框架
[32:33.000 --> 32:35.000] 可能都有一些想吐槽
[32:35.000 --> 32:36.000] 或者说是一些建议
[32:36.000 --> 32:37.000] 或者是其他的
[32:37.000 --> 32:38.000] 所以说呢
[32:38.000 --> 32:40.000] 这个东西我们觉得分享出来
[32:40.000 --> 32:41.000] 可能也是非常有意义的
[32:41.000 --> 32:43.000] 于是我们这期节目里面
[32:43.000 --> 32:44.000] 也会聊一聊
[32:44.000 --> 32:46.000] 我们自己对于Python这门语言
[32:46.000 --> 32:47.000] 或者说是对于Python
[32:47.000 --> 32:49.000] 一些生态里面的一些东西
[32:49.000 --> 32:51.000] 我们自己的一些小小的看法
[32:51.000 --> 32:53.000] 当然这个仅代表个人意见
[32:53.000 --> 32:55.000] 然后不代表其他
[32:55.000 --> 32:56.000] 好
[32:56.000 --> 32:57.000] 那我们今天
[32:57.000 --> 32:59.000] 我们这个环节的第一位选手是谁呢
[33:01.000 --> 33:02.000] 你要点名吗
[33:02.000 --> 33:03.000] 还是怎么样
[33:04.000 --> 33:05.000] 你们来吧
[33:05.000 --> 33:06.000] 那我就点名吧
[33:06.000 --> 33:09.000] 那我们就让我们刚才说的六年的同学
[33:09.000 --> 33:12.000] 六年马上要七年之痒的Nike9M
[33:12.000 --> 33:13.000] 你先来吧
[33:14.000 --> 33:15.000] 行
[33:15.000 --> 33:16.000] 我可以聊一下
[33:16.000 --> 33:17.000] 就是
[33:18.000 --> 33:19.000] 就我觉得
[33:19.000 --> 33:20.000] 就怎么说
[33:20.000 --> 33:22.000] 有很多方面都可以吐槽吧
[33:22.000 --> 33:23.000] 但是在吐槽之前
[33:23.000 --> 33:24.000] 我还是想先说一下
[33:24.000 --> 33:26.000] 我还是很喜欢Python的
[33:26.000 --> 33:27.000] 就不要听众朋友们
[33:27.000 --> 33:28.000] 不要以为我们就是
[33:29.000 --> 33:31.000] 讲了很多Python不好的地方
[33:31.000 --> 33:32.000] 然后就觉得
[33:32.000 --> 33:34.000] 说你们都这么讨厌Python
[33:34.000 --> 33:35.000] 为什么还在写是吧
[33:35.000 --> 33:37.000] 还在写是因为我们觉得这门语言
[33:37.000 --> 33:39.000] 还是写起来比较舒服的
[33:39.000 --> 33:40.000] 对
[33:40.000 --> 33:42.000] 我记得上期节目里面
[33:42.000 --> 33:43.000] 评论里面
[33:43.000 --> 33:45.000] 直播那个文章的评论里面
[33:45.000 --> 33:46.000] 就有人说
[33:46.000 --> 33:48.000] 你们有四个人推荐语言
[33:48.000 --> 33:50.000] 有两个人不推荐Python
[33:52.000 --> 33:53.000] 对
[33:53.000 --> 33:55.000] 然后我们是一场Python节目
[33:55.000 --> 33:56.000] 他其实是开玩笑的
[33:56.000 --> 33:57.000] 对对对
[33:57.000 --> 33:59.000] 我们就是说有朋友在开玩笑
[33:59.000 --> 34:00.000] 9M你继续
[34:00.000 --> 34:01.000] 对
[34:00.000 --> 34:01.000] 我觉得
[34:02.000 --> 34:03.000] 就是
[34:03.000 --> 34:05.000] 先从一个小的方面说吧
[34:05.000 --> 34:06.000] 就我觉得Python有一些
[34:06.000 --> 34:09.000] 对于对于Scope的处理不是很好
[34:09.000 --> 34:11.000] Scope中文应该叫什么
[34:11.000 --> 34:13.000] 作用域
[34:13.000 --> 34:14.000] 作用域对
[34:14.000 --> 34:16.000] 就是就有两个问题
[34:16.000 --> 34:18.000] 第一个就是很著名的
[34:18.000 --> 34:21.000] 那个叫Unbound local error
[34:21.000 --> 34:22.000] 对
[34:22.000 --> 34:24.000] 在局部作用域里面复制一下
[34:24.000 --> 34:26.000] 然后你想用外面那个
[34:26.000 --> 34:27.000] 它已经变成局部的
[34:27.000 --> 34:28.000] 对对我可以解释一下
[34:28.000 --> 34:29.000] 大概是什么意思呢
[34:29.000 --> 34:30.000] 就是说你比如说
[34:30.000 --> 34:32.000] 你define了一个一个函数
[34:32.000 --> 34:35.000] 然后你在你在这个函数的外面
[34:35.000 --> 34:36.000] 比如说全局有一个
[34:36.000 --> 34:37.000] 比如说A等于1
[34:37.000 --> 34:40.000] 然后你在这个函数的第一行
[34:40.000 --> 34:42.000] 写print A
[34:42.000 --> 34:44.000] 然后你的第二行写A等于2
[34:44.000 --> 34:46.000] 然后你运行这个函数的时候
[34:46.000 --> 34:47.000] 它就会出问题
[34:47.000 --> 34:49.000] 就是说出问题
[34:49.000 --> 34:51.000] 是出问题在print A的那一行
[34:51.000 --> 34:52.000] 为什么呢
[34:52.000 --> 34:54.000] 因为Python它认为就是
[34:54.000 --> 34:56.000] 你在这个局部作用域
[34:56.000 --> 34:57.000] 就是这个函数的
[34:57.000 --> 34:59.000] 这个local的Scope里面
[34:59.000 --> 35:02.000] 它你写了A等于2
[35:02.000 --> 35:04.000] 然后它就发现了A等于2
[35:04.000 --> 35:07.000] 它就认为这个A是在这个局部
[35:07.000 --> 35:11.000] 在这个局部作用域里去去定义的
[35:11.000 --> 35:14.000] 然后它就会发现说
[35:14.000 --> 35:15.000] A等于2在第二行
[35:15.000 --> 35:18.000] 然后你在第一行print A就不对了
[35:18.000 --> 35:20.000] 然后因为它这样之后
[35:20.000 --> 35:22.000] 它就看不到外层的那个A等于1
[35:22.000 --> 35:24.000] 所以就会出这个问题
[35:24.000 --> 35:25.000] 我觉得应该就是
[35:25.000 --> 35:27.000] 很多初学Python的人
[35:27.000 --> 35:30.000] 都会遇到这个超级坑的问题
[35:30.000 --> 35:32.000] 对因为这个的话
[35:32.000 --> 35:33.000] 最直接的就是说
[35:33.000 --> 35:35.000] 它那个语法解析之后
[35:35.000 --> 35:37.000] 生成的字节码就不一样
[35:37.000 --> 35:39.000] 就是说是Python的话
[35:39.000 --> 35:41.000] 它不是最后始终是
[35:41.000 --> 35:43.000] 以字节码方式运行的对吧
[35:43.000 --> 35:45.000] 然后的话你如果说只是print
[35:45.000 --> 35:46.000] 你只是一个print A
[35:46.000 --> 35:48.000] 没有那个A等于2的话
[35:48.000 --> 35:50.000] 然后你它字节码解析出来
[35:50.000 --> 35:51.000] 是load global
[35:51.000 --> 35:52.000] load global的一个
[35:52.000 --> 35:54.000] 就是说是一个变量
[35:54.000 --> 35:56.000] 如果说是你直接
[35:56.000 --> 35:58.000] 是后面有A等于2的话
[35:58.000 --> 35:59.000] 然后它这个地方的print A的话
[35:59.000 --> 36:00.000] 它就是load local的
[36:00.000 --> 36:03.000] 所以它字节码就不一样
[36:03.000 --> 36:04.000] 是的
[36:04.000 --> 36:06.000] 其实这是一个设计的选择
[36:06.000 --> 36:08.000] 这个问题我之前也看过
[36:08.000 --> 36:12.000] 就是说如果
[36:12.000 --> 36:14.000] 其实Ruby也有这样的问题
[36:14.000 --> 36:15.000] 但是Ruby是假如说
[36:15.000 --> 36:17.000] 你在一个函数内定义
[36:17.000 --> 36:19.000] 一个跟外面一样的作用域的话
[36:19.000 --> 36:21.000] 那你这个新的变量
[36:21.000 --> 36:23.000] 只在你的函数内有
[36:23.000 --> 36:24.000] 你就跟外面是一个
[36:24.000 --> 36:26.000] 完全不一样的
[36:26.000 --> 36:28.000] 就是它们两个正好用了
[36:28.000 --> 36:30.000] 两种可以选的方案
[36:30.000 --> 36:33.000] 那个Fluent Python里面
[36:33.000 --> 36:35.000] 就是说如果你用这种方法的话
[36:35.000 --> 36:37.000] 你可能就是说
[36:37.000 --> 36:39.000] 你本来想去改外面的变量
[36:39.000 --> 36:41.000] 但是因为Python跟Ruby
[36:41.000 --> 36:42.000] 都是复制即声明
[36:42.000 --> 36:45.000] 就是说你复制一下
[36:45.000 --> 36:47.000] 然后你就有一个新的变量了
[36:47.000 --> 36:48.000] Ruby这种方式
[36:48.000 --> 36:49.000] 可能就比较难debug
[36:49.000 --> 36:50.000] 因为你看起来像
[36:50.000 --> 36:51.000] 你在改一个外部的
[36:51.000 --> 36:53.000] 但是实际你改了内部的
[36:53.000 --> 36:55.000] Python现在不是加了
[36:55.000 --> 36:57.000] non-local跟global
[36:57.000 --> 36:58.000] 就是说你要改外面的
[36:58.000 --> 37:00.000] 你就要显示声明
[37:00.000 --> 37:01.000] 所以就是
[37:01.000 --> 37:04.000] explicit is better than in
[37:04.000 --> 37:07.000] 就那句话
[37:07.000 --> 37:08.000] 对我理解Python
[37:08.000 --> 37:10.000] 它就是在生成自解码的时候
[37:10.000 --> 37:11.000] 它应该是一个frame
[37:11.000 --> 37:14.000] 一个frame去处理的
[37:14.000 --> 37:15.000] 然后也就是说
[37:15.000 --> 37:16.000] 它把这个函数里面
[37:16.000 --> 37:18.000] 这个frame给处理完了之后
[37:18.000 --> 37:20.000] 它就对吧
[37:20.000 --> 37:21.000] 它认为这个是
[37:21.000 --> 37:22.000] 是local的变量
[37:22.000 --> 37:24.000] 它就没有看外面
[37:24.000 --> 37:25.000] 所以就导致这个问题
[37:25.000 --> 37:27.000] 当然我也没有具体去看过
[37:27.000 --> 37:29.000] 就是它的实现
[37:29.000 --> 37:30.000] 它应该就是这个
[37:30.000 --> 37:31.000] 因为你其实
[37:31.000 --> 37:33.000] 在做那个解析的话
[37:33.000 --> 37:34.000] 它其实就发现
[37:34.000 --> 37:35.000] 如果你在内部的话
[37:35.000 --> 37:36.000] 它是一个
[37:36.000 --> 37:38.000] 就是说你内部没有算上文的话
[37:38.000 --> 37:40.000] 就是说你直接一个a
[37:40.000 --> 37:41.000] 那么它就会觉得你直接是
[37:41.000 --> 37:43.000] 我这个肯定是要去global一个东西
[37:43.000 --> 37:45.000] 因为你assignment和那个
[37:45.000 --> 37:47.000] 直接去把它取出来
[37:47.000 --> 37:49.000] 这个操作还是不太一样
[37:49.000 --> 37:50.000] 反正这个坑
[37:50.000 --> 37:52.000] 应该真的是很多人都踩过
[37:52.000 --> 37:53.000] 并且它的
[37:53.000 --> 37:57.000] 就它的提示也非常的不明确吧
[37:57.000 --> 37:59.000] 就谁知道unbound local
[37:59.000 --> 38:00.000] 又是啥
[38:00.000 --> 38:02.000] 对就是它出错的利益
[38:02.000 --> 38:04.000] 好像就不是你要的那一行
[38:04.000 --> 38:05.000] 对吧
[38:05.000 --> 38:07.000] 就是错误出在另一个地方
[38:07.000 --> 38:09.000] 对我对
[38:09.000 --> 38:10.000] 不过我觉得它这个
[38:10.000 --> 38:12.000] 都还是保持了一致性的
[38:12.000 --> 38:14.000] 因为比如说你a等于2
[38:14.000 --> 38:15.000] 这样的东西的话
[38:15.000 --> 38:17.000] 它认为你说你直接那个
[38:17.000 --> 38:18.000] 我觉得这个东西
[38:18.000 --> 38:21.000] 倒还是也可以说它是正确的
[38:21.000 --> 38:22.000] 因为如果对
[38:22.000 --> 38:25.000] 按照它既有的策略来说的话
[38:25.000 --> 38:28.000] 不是关键是它这个是
[38:28.000 --> 38:30.000] 看你有没有前面那个print
[38:30.000 --> 38:31.000] 如果你没有前面那个print
[38:31.000 --> 38:33.000] 其实行为还是挺不一致的
[38:33.000 --> 38:35.000] 是这样吧
[38:35.000 --> 38:36.000] 我觉得还是一致的吧
[38:36.000 --> 38:37.000] 我觉得是一致
[38:37.000 --> 38:39.000] 因为你a等于2的话
[38:39.000 --> 38:41.000] 你使它始终是把这个a的话
[38:41.000 --> 38:43.000] 当做一个就是说是一个
[38:43.000 --> 38:44.000] local的一个东西
[38:44.000 --> 38:45.000] 当做一个local的一个variable
[38:45.000 --> 38:48.000] 然后的话你a等于2进行一个assignment
[38:48.000 --> 38:49.000] 然后的操作
[38:49.000 --> 38:51.000] 然后的话如果说是你那个
[38:51.000 --> 38:53.000] 在前面a等于2前面
[38:53.000 --> 38:54.000] 加一个print a的话
[38:54.000 --> 38:55.000] 它都会认为你这个a
[38:55.000 --> 38:57.000] 是一个local的一个东西
[38:57.000 --> 38:59.000] 然后的话只是说你在前面
[38:59.000 --> 39:00.000] 你print a的时候
[39:00.000 --> 39:02.000] 它的确是没有声音
[39:02.000 --> 39:03.000] 没有
[39:03.000 --> 39:04.000] 我觉得
[39:05.000 --> 39:07.000] 我觉得就是你不能
[39:07.000 --> 39:09.000] 因为你比如说你把那个a等于2去掉
[39:09.000 --> 39:11.000] 这个函数肯定是没有问题的
[39:11.000 --> 39:13.000] 就是你不能说你加了一行
[39:13.000 --> 39:14.000] 它就behavior就变了
[39:14.000 --> 39:16.000] 这个是我觉得还是有问题的
[39:16.000 --> 39:17.000] ok吧
[39:17.000 --> 39:19.000] 这个可能我们彼此观点不太一致吧
[39:19.000 --> 39:21.000] 但是我觉得的话可能说
[39:21.000 --> 39:23.000] 它策略来说可能不太合适的
[39:23.000 --> 39:26.000] 但是我觉得就它现有的策略来讲的话
[39:26.000 --> 39:29.000] 这两个表现都还是是一致的
[39:29.000 --> 39:30.000] ok行
[39:30.000 --> 39:31.000] 这个我们可以之后再讨论
[39:31.000 --> 39:34.000] 然后我觉得第二个有关scope的问题
[39:34.000 --> 39:37.000] 就是当然这个不是一个
[39:37.000 --> 39:38.000] 就问题没那么大吧
[39:38.000 --> 39:41.000] 就是说你比如说你去用
[39:41.000 --> 39:42.000] 做列表解析的时候
[39:42.000 --> 39:46.000] 它的那个那个for的那个东西会泄露出来
[39:46.000 --> 39:49.000] 这个在python3里面好像已经改了
[39:49.000 --> 39:50.000] 改了吗
[39:50.000 --> 39:51.000] 是已经改了
[39:51.000 --> 39:53.000] 对是有那个一些行为上的改变
[39:53.000 --> 39:55.000] 不过我不太确定你说的那个
[39:55.000 --> 39:56.000] 不是你说改了是指
[39:56.000 --> 39:59.000] 它就那个东西那个变量就不存在了吗
[39:59.000 --> 40:01.000] 还是怎么样
[40:01.000 --> 40:03.000] 哦不是它是它是那个
[40:03.000 --> 40:05.000] 它是那个是在b包的时候
[40:05.000 --> 40:07.000] 那个中域的那个区分好像有区别
[40:07.000 --> 40:10.000] 但是泄露好像还是会有
[40:10.000 --> 40:11.000] 还是会吗
[40:11.000 --> 40:15.000] 我记得我记得还是会有的吧
[40:15.000 --> 40:16.000] 它泄露还是会有
[40:16.000 --> 40:19.000] 它那个泄露应该还是
[40:19.000 --> 40:21.000] 对就是这个对于其
[40:21.000 --> 40:24.000] 就其他语言转过转到python的同学
[40:24.000 --> 40:28.000] 可能就会比较比较困惑了
[40:28.000 --> 40:30.000] 对因为一般语言里对吧
[40:30.000 --> 40:31.000] 你这个for完了那个东西
[40:31.000 --> 40:34.000] 那个i或者x就不存在了
[40:34.000 --> 40:34.000] 是吧
[40:34.000 --> 40:36.000] 但python里还是有那个东西的
[40:36.000 --> 40:39.000] 对因为python里面只有四种作用语
[40:39.000 --> 40:40.000] 它没有quark的作用语
[40:40.000 --> 40:42.000] 是对
[40:42.000 --> 40:47.000] 但是python3里面好像真的不会泄露出来
[40:47.000 --> 40:48.000] 你试了吗
[40:48.000 --> 40:50.000] 嗯
[40:50.000 --> 40:52.000] 我我刚刚试了一下
[40:52.000 --> 40:56.000] 我写了个a for ae range 10
[40:56.000 --> 40:57.000] 然后这个列表解析
[40:57.000 --> 40:59.000] 然后打完之后第二行
[40:59.000 --> 41:02.000] 那个a是不能再用了
[41:02.000 --> 41:04.000] 你是在repl里测试的吗
[41:04.000 --> 41:06.000] 对repl
[41:06.000 --> 41:09.000] repl的行为不太一致
[41:09.000 --> 41:11.000] ok这个回去再看一下
[41:11.000 --> 41:13.000] 我记得就是因为之前那个
[41:13.000 --> 41:15.000] 我看过那个for循环
[41:15.000 --> 41:16.000] 就是你不写列表解析的话
[41:16.000 --> 41:17.000] for循环完了
[41:17.000 --> 41:21.000] 那个中间的边上你还是可以用的
[41:21.000 --> 41:23.000] 但是3里面好像改了
[41:23.000 --> 41:24.000] 列表解析我不知道
[41:24.000 --> 41:26.000] 但是for循环肯定还是会泄露的
[41:26.000 --> 41:27.000] 对吧
[41:27.000 --> 41:28.000] 不是for循环不会泄露
[41:28.000 --> 41:31.000] 也不会了吗
[41:31.000 --> 41:32.000] 不是我的意思就是
[41:32.000 --> 41:34.000] 比如说你没有列表解析
[41:34.000 --> 41:37.000] 就是for x in比如说一个list
[41:37.000 --> 41:38.000] 对对对对对
[41:38.000 --> 41:39.000] 这个python2是会泄露的
[41:39.000 --> 41:41.000] 但是python3是不会泄露的
[41:41.000 --> 41:43.000] ok我可能好吧
[41:43.000 --> 41:44.000] 我可能记混了
[41:44.000 --> 41:46.000] 但是总之这可能
[41:46.000 --> 41:48.000] 这曾经肯定是一个问题
[41:48.000 --> 41:49.000] 这段需要剪掉
[41:49.000 --> 41:50.000] 对对对
[41:50.000 --> 41:52.000] 没事没事没事
[41:52.000 --> 41:53.000] 等等
[41:53.000 --> 41:54.000] 我也不确定
[41:54.000 --> 41:55.000] 我刚刚试了一下
[41:55.000 --> 41:56.000] 那个for循环里面
[41:56.000 --> 41:57.000] 那个边上是会泄露的
[41:57.000 --> 41:58.000] 列表解析不会泄露
[41:58.000 --> 42:00.000] 是吧就是会啊
[42:00.000 --> 42:01.000] 对应该是列表解析不会泄露
[42:01.000 --> 42:03.000] 我也记混了
[42:03.000 --> 42:05.000] 但是python2的列表解析
[42:05.000 --> 42:06.000] 是会泄露的
[42:06.000 --> 42:07.000] 好了好了
[42:07.000 --> 42:08.000] 总之这是个问题
[42:08.000 --> 42:09.000] 所以我们都搞混了
[42:09.000 --> 42:11.000] 我们没有一个人记得清
[42:11.000 --> 42:12.000] 第一个这段剪掉
[42:12.000 --> 42:14.000] 不能把这段泄露出去
[42:16.000 --> 42:17.000] 对然后我还补充一点
[42:17.000 --> 42:18.000] 就是说关于之前
[42:18.000 --> 42:21.000] 那个local作用域的问题
[42:21.000 --> 42:23.000] 其实现在
[42:23.000 --> 42:25.000] 就是有一些linter
[42:25.000 --> 42:27.000] 是能够能够检测出来的
[42:27.000 --> 42:30.000] 就是我之前试了一下
[42:30.000 --> 42:32.000] 就是google的那个叫
[42:32.000 --> 42:33.000] google里面用的
[42:33.000 --> 42:34.000] 那个python的linter
[42:34.000 --> 42:35.000] 如果你写了这种
[42:35.000 --> 42:36.000] 它就会提示你说
[42:36.000 --> 42:38.000] 你这个这个变量
[42:38.000 --> 42:41.000] 然后它就在local和外面都有
[42:41.000 --> 42:43.000] 然后会就会是一个警告
[42:43.000 --> 42:46.000] 对所以就还有些帮助吧
[42:46.000 --> 42:47.000] 这么好的东西
[42:47.000 --> 42:48.000] 为什么不开源
[42:48.000 --> 42:52.000] 我不知道外面有没有能检测的
[42:52.000 --> 42:53.000] 因为没用过
[42:53.000 --> 42:55.000] 它linter是可以检测出来的
[42:55.000 --> 42:56.000] 可以的是吗
[42:56.000 --> 42:57.000] 对
[42:57.000 --> 42:58.000] ok
[42:58.000 --> 43:00.000] 好那轮到你们了
[43:00.000 --> 43:02.000] 来谁来谁来谁来快来
[43:04.000 --> 43:06.000] 来那就安德姆吧
[43:09.000 --> 43:10.000] 我倒是没有什么
[43:10.000 --> 43:12.000] 特别想吐槽的酷啊
[43:12.000 --> 43:15.000] 但是我还是想让大家来注意
[43:15.000 --> 43:16.000] 这么一类酷
[43:16.000 --> 43:17.000] 对我经常会用
[43:17.000 --> 43:19.000] 然后他们的大数据也很高
[43:19.000 --> 43:23.000] 你说他用起来好不好用
[43:23.000 --> 43:24.000] 有没有问题
[43:24.000 --> 43:26.000] 其实也没有什么太大的问题
[43:26.000 --> 43:28.000] 但是一旦说你想对这个酷
[43:28.000 --> 43:30.000] 对一些高阶使用的时候
[43:30.000 --> 43:31.000] 你就会比较难
[43:31.000 --> 43:34.000] 然后这个酷通常有这么几类特征吧
[43:34.000 --> 43:36.000] 对一类特征就是这个
[43:36.000 --> 43:38.000] 比如说他某一个client
[43:38.000 --> 43:40.000] 或者某一个library
[43:40.000 --> 43:42.000] 他可以接收超多参数
[43:42.000 --> 43:46.000] 但是呢他声明接收参数的形式
[43:46.000 --> 43:50.000] 都是他的接口是声明一个
[43:50.000 --> 43:53.000] 这种naming kvirth
[43:53.000 --> 43:56.000] 就是星星kwirts让你自己往里传
[43:56.000 --> 43:59.000] 对这种酷其实不良的设计
[43:59.000 --> 44:01.000] 你用起来就特别的复杂
[44:01.000 --> 44:07.000] 然后其实我想黑的是卡普卡派森
[44:07.000 --> 44:08.000] 对这个酷真的是
[44:08.000 --> 44:10.000] 我我推荐大家去看一下
[44:10.000 --> 44:13.000] 你会发现你一开始简单的用的时候
[44:13.000 --> 44:15.000] 你会觉得哎很简单呀
[44:15.000 --> 44:17.000] 就是host port传一把就好
[44:17.000 --> 44:19.000] 但是你想做一些高级的参数设置
[44:19.000 --> 44:23.000] 你会发现一开始你会找不到在哪设置
[44:23.000 --> 44:24.000] 然后你就去看原代码
[44:24.000 --> 44:26.000] 看原代码你会发现这个
[44:26.000 --> 44:28.000] 因为他的这个配置
[44:28.000 --> 44:32.000] 最后会他自己打包成一个config的这么一个dict
[44:32.000 --> 44:35.000] 然后在他自己内部到处传
[44:35.000 --> 44:38.000] 对后来就特别特别说白了
[44:38.000 --> 44:41.000] 就是文档文档没写好
[44:41.000 --> 44:43.000] 是吧不这不是文档的问题
[44:43.000 --> 44:46.000] 这其实我觉得还是接口设计的问题
[44:46.000 --> 44:47.000] 这如果是你对
[44:47.000 --> 44:49.000] 然后文档没写好是另外一个例子
[44:49.000 --> 44:50.000] 我可以接着举一下
[44:50.000 --> 44:53.000] 就是我觉得如果你不是很清楚的
[44:53.000 --> 44:56.000] 知道你想怎么处理度的话
[44:56.000 --> 44:58.000] 你就去用beautiful soup
[44:58.000 --> 45:01.000] 不要用lxml
[45:01.000 --> 45:02.000] 这样啊
[45:02.000 --> 45:04.000] 那个pattern3你刚刚说那个参数
[45:04.000 --> 45:06.000] pattern3我看了一个what's new
[45:06.000 --> 45:10.000] 他说就是函数的参数打破了255的限制
[45:10.000 --> 45:12.000] 就是说你可以传更多的参数
[45:12.000 --> 45:16.000] 我觉得这个东西
[45:16.000 --> 45:18.000] 本质上不管跟语言特性都没有什么东西
[45:18.000 --> 45:19.000] 你其实而言的话
[45:19.000 --> 45:22.000] 你是一个设计上的问题
[45:22.000 --> 45:23.000] 就比如说你golang
[45:23.000 --> 45:26.000] 你golang的函数也是可以传不定量参数的
[45:26.000 --> 45:28.000] 然后他直接给传一个大的array进去
[45:28.000 --> 45:30.000] 你也只能干看着
[45:30.000 --> 45:32.000] 但是golang的设计可能一般不会那么做
[45:32.000 --> 45:33.000] golang的话
[45:33.000 --> 45:36.000] 他一般会传一个config的对象
[45:36.000 --> 45:38.000] 然后你自己来定义
[45:38.000 --> 45:40.000] 这倒也是不太一样
[45:40.000 --> 45:42.000] 但是也有那些不太良设计
[45:42.000 --> 45:43.000] 不太好设计的
[45:43.000 --> 45:47.000] 然后就直接是那个可变常参数
[45:47.000 --> 45:48.000] 对
[45:48.000 --> 45:51.000] 然后我接着想吐槽的就是
[45:51.000 --> 45:54.000] 可能各位就是用lxml比较少
[45:54.000 --> 45:55.000] 因为我这边
[45:55.000 --> 45:56.000] 我用的比较多
[45:56.000 --> 45:58.000] 我之前工作是写part1
[45:58.000 --> 46:00.000] 所以一直在用这个
[46:00.000 --> 46:03.000] 我会觉得其实没有特殊的需求
[46:03.000 --> 46:05.000] 或者你不太清楚你要不要用lxml
[46:05.000 --> 46:07.000] 所以你优先选用beautiful soup
[46:07.000 --> 46:08.000] 对
[46:08.000 --> 46:10.000] 然后你觉得性能不够
[46:10.000 --> 46:13.000] 那你就把解析器给他配成lxml
[46:13.000 --> 46:14.000] 对
[46:14.000 --> 46:17.000] 但是lxml本身的那个文档真的是
[46:17.000 --> 46:18.000] 我可以贴一下
[46:18.000 --> 46:20.000] 大家有兴趣可以看一下
[46:20.000 --> 46:23.000] 反正是我基本上看不懂他的文档
[46:23.000 --> 46:24.000] 我都是去看他的代码
[46:24.000 --> 46:26.000] 外加自己测试来看某一个方法
[46:26.000 --> 46:27.000] 到底在干嘛
[46:27.000 --> 46:28.000] 对确实是
[46:28.000 --> 46:31.000] 但是千万不要用郑泽
[46:31.000 --> 46:32.000] 千万不要用郑泽
[46:32.000 --> 46:34.000] 这个他代码都知道
[46:34.000 --> 46:37.000] 郑泽另外一个问题就是
[46:37.000 --> 46:38.000] 很容易被拒绝攻击
[46:38.000 --> 46:40.000] 拒绝攻击
[46:40.000 --> 46:41.000] 对
[46:41.000 --> 46:42.000] 对啊
[46:42.000 --> 46:46.000] 就是因为你的郑泽
[46:46.000 --> 46:47.000] 如果比如说
[46:47.000 --> 46:50.000] 如果用到那个叫什么来着
[46:50.000 --> 46:53.000] 叫backing forward
[46:53.000 --> 46:55.000] 对那种特性的话
[46:55.000 --> 46:57.000] 然后如果被外部人知道的话
[46:57.000 --> 46:59.000] 他其实是可以用这个来构造一个
[46:59.000 --> 47:01.000] 很复杂的输入来
[47:01.000 --> 47:04.000] 让你去匹配郑泽匹配的超级慢
[47:04.000 --> 47:05.000] 是
[47:05.000 --> 47:07.000] 就是那个反向
[47:07.000 --> 47:08.000] 反向那个反向临快断言
[47:08.000 --> 47:09.000] 是吧
[47:09.000 --> 47:10.000] 反向断言
[47:10.000 --> 47:11.000] 对
[47:10.000 --> 47:13.000] 然后一旦涉及到这个的话
[47:13.000 --> 47:17.000] 那我可能不是出于拿到你权限的目的
[47:17.000 --> 47:19.000] 我是可以直接拒绝攻击你的
[47:19.000 --> 47:20.000] 就让你的服务变得很慢
[47:20.000 --> 47:22.000] 或卡死
[47:22.000 --> 47:23.000] 嗯
[47:23.000 --> 47:24.000] 啊
[47:24.000 --> 47:25.000] 来来来还有吗
[47:25.000 --> 47:26.000] 还有吗
[47:26.000 --> 47:27.000] 说到这个
[47:27.000 --> 47:28.000] 说到文档
[47:28.000 --> 47:30.000] 我不知道你们用过那个
[47:30.000 --> 47:31.000] 你们应该用过talks吧
[47:31.000 --> 47:32.000] 啊
[47:32.000 --> 47:33.000] 你用过用过
[47:33.000 --> 47:34.000] 很方便
[47:34.000 --> 47:36.000] 我用过我用的比较少
[47:36.000 --> 47:39.000] 他的那个他的那个
[47:39.000 --> 47:40.000] 他不是有个config file吗
[47:40.000 --> 47:42.000] 然后里面要你设置一些environment
[47:42.000 --> 47:44.000] 然后我就从来没
[47:44.000 --> 47:46.000] 就没有真正彻底搞懂那些environment
[47:46.000 --> 47:47.000] 到底要怎么设置
[47:47.000 --> 47:49.000] 对每次用我都去看文档
[47:49.000 --> 47:52.000] 然后我就是就是看不太懂
[47:52.000 --> 47:54.000] 他到底想表达什么
[47:54.000 --> 47:55.000] 我不知道是我英文不好
[47:55.000 --> 47:56.000] 还是我理解能力不好
[47:56.000 --> 47:57.000] 那个文档我基本上都不看
[47:57.000 --> 47:58.000] 我我用的时候
[47:58.000 --> 48:01.000] 我一般从一个我信得过的项目里面
[48:01.000 --> 48:02.000] 抄一个出来
[48:02.000 --> 48:03.000] 哦
[48:03.000 --> 48:05.000] 我也是
[48:05.000 --> 48:07.000] 我这个感觉跟我写setup py
[48:07.000 --> 48:08.000] 那个也是
[48:08.000 --> 48:10.000] 我一般都抄request的那个setup
[48:10.000 --> 48:13.000] setup.py我觉得没有什么
[48:13.000 --> 48:14.000] 对setup.py还可以
[48:14.000 --> 48:15.000] 对
[48:15.000 --> 48:17.000] 你们用过buildout吗
[48:17.000 --> 48:18.000] 没有
[48:18.000 --> 48:19.000] 一个构建工具
[48:19.000 --> 48:21.000] 那个简直是
[48:21.000 --> 48:23.000] 我基本上都是抄别人的
[48:23.000 --> 48:24.000] 可以
[48:24.000 --> 48:27.000] 我setup.py也是基本上是抄别人的
[48:27.000 --> 48:28.000] 我觉得他
[48:28.000 --> 48:29.000] setup.py
[48:29.000 --> 48:32.000] 我觉得他主要是你在写extension的时候
[48:32.000 --> 48:34.000] 那个setup.py的话就有点恶心
[48:34.000 --> 48:36.000] 还好吧
[48:36.000 --> 48:37.000] 对
[48:37.000 --> 48:41.000] 我们那个system什么的都配在setup.py里
[48:41.000 --> 48:42.000] 很多时候
[48:42.000 --> 48:45.000] 我自己有些时候写的话是不太会用那个system
[48:45.000 --> 48:48.000] 我是直接c加那个python的那个capi去做
[48:48.000 --> 48:52.000] 然后那个的话实际的变异加一套setup.py就很恶心
[48:52.000 --> 48:54.000] OK
[48:54.000 --> 48:56.000] 对来来来其他的酷呢
[48:56.000 --> 48:58.000] 还有吗
[48:58.000 --> 49:00.000] 其他没什么想吐槽的了
[49:00.000 --> 49:01.000] 好
[49:01.000 --> 49:04.000] 然后我顺便吐槽一些生产上的
[49:04.000 --> 49:06.000] 不要用的吧
[49:06.000 --> 49:10.000] 我觉得和那个刚才Lac9m提到的作用域问题也很像
[49:10.000 --> 49:11.000] 但是
[49:11.000 --> 49:13.000] 就是直接生产不推荐的
[49:13.000 --> 49:14.000] 就是
[49:14.000 --> 49:17.000] 不要用太多的动态特性
[49:17.000 --> 49:19.000] 不要用太多的字型
[49:19.000 --> 49:22.000] getattr setattr
[49:22.000 --> 49:25.000] 这种尽量少用吧
[49:25.000 --> 49:28.000] 我觉得原内
[49:28.000 --> 49:29.000] 原内
[49:29.000 --> 49:31.000] 原内原编程加上动态特性什么的
[49:31.000 --> 49:33.000] 我觉得都尽量少用吧
[49:33.000 --> 49:34.000] 对
[49:34.000 --> 49:38.000] 你们说的动态特性是指哪些
[49:38.000 --> 49:40.000] 就主要指原编程的那一类
[49:40.000 --> 49:41.000] 其实
[49:41.000 --> 49:43.000] 原编程的那些
[49:43.000 --> 49:45.000] 对除非你在做一个基础库
[49:45.000 --> 49:46.000] 然后你知道你在干嘛
[49:46.000 --> 49:48.000] 对不然你就不要用这个
[49:48.000 --> 49:49.000] 这个很重要
[49:49.000 --> 49:52.000] 你干什么都要知道你在干什么
[49:52.000 --> 49:53.000] 对
[49:53.000 --> 49:55.000] 我觉得原编程那些东西的话
[49:55.000 --> 49:56.000] 我觉得现在有些时候
[49:56.000 --> 49:58.000] 有些时候有一个很不太好的
[49:58.000 --> 50:00.000] 我其实之前有看到过
[50:00.000 --> 50:01.000] 然后我之前带过人的话
[50:01.000 --> 50:02.000] 其实也有那种
[50:02.000 --> 50:03.000] 就是面试过人的话
[50:03.000 --> 50:05.000] 就很多人就是信任
[50:05.000 --> 50:09.000] 就是就有些时候就开始问进阶看到什么书对吧
[50:09.000 --> 50:11.000] 然后也看到什么流畅的python
[50:11.000 --> 50:12.000] python cookbook之类的
[50:12.000 --> 50:15.000] 然后就开始无脑在生产环境
[50:15.000 --> 50:19.000] 把各种原编程什么一大套的东西全部上上来
[50:19.000 --> 50:21.000] 哇擦那个代码简直销魂
[50:23.000 --> 50:25.000] 至少说明他很好学
[50:25.000 --> 50:28.000] 对我觉得比什么都不学的要好
[50:28.000 --> 50:29.000] 对我觉得Adam那个说的对
[50:29.000 --> 50:31.000] 我觉得在生产环境上面
[50:31.000 --> 50:33.000] 那些原编程动态的东西
[50:33.000 --> 50:34.000] 我觉得尽量少用
[50:34.000 --> 50:35.000] 或者说是某些程度上
[50:35.000 --> 50:36.000] 我觉得是要禁用的
[50:36.000 --> 50:38.000] 除非是有特殊圣僻
[50:40.000 --> 50:43.000] 对反正Google里是会有
[50:43.000 --> 50:44.000] 会禁用一些语法的
[50:44.000 --> 50:47.000] 就是各种语言都会都会有这种style guide
[50:47.000 --> 50:49.000] 然后对我也觉得Google里很有意思
[50:49.000 --> 50:50.000] 我跟你说一个很有意思
[50:50.000 --> 50:52.000] 就是那个列表解析
[50:52.000 --> 50:54.000] Google里是不让写两层
[50:54.000 --> 50:56.000] 我也是我之前在老东家规定了
[50:56.000 --> 50:58.000] 列表解析和那么大都不能写
[50:58.000 --> 51:02.000] 但是我感觉两层就太那个三层可以不写
[51:02.000 --> 51:04.000] 两层不是很常见吗
[51:06.000 --> 51:07.000] 他觉得你写两层
[51:07.000 --> 51:08.000] 你就写循环比较清楚
[51:08.000 --> 51:10.000] 我也觉得我觉得像列表解析
[51:10.000 --> 51:12.000] 还有像那么大的这些东西的话
[51:12.000 --> 51:15.000] 一般情况下除非是非常简单的东西
[51:15.000 --> 51:17.000] 要不然的话你还是老老实实写循环
[51:17.000 --> 51:19.000] 或者说写其他的显示的函数定义
[51:21.000 --> 51:24.000] 反正就有一些很有意思的规定
[51:25.000 --> 51:26.000] 你可以加那个吗
[51:26.000 --> 51:29.000] 你们谷歌可以加no QA之类的东西
[51:29.000 --> 51:30.000] 跳过去吗
[51:31.000 --> 51:32.000] 应该可以吧
[51:36.000 --> 51:38.000] 可以强行提交
[51:38.000 --> 51:40.000] 但是但是很不推荐这么做就是了
[51:40.000 --> 51:43.000] 强行提交是想背锅吧
[51:43.000 --> 51:44.000] 因为有些情况下
[51:44.000 --> 51:48.000] 有些有些有些就是一些检查
[51:48.000 --> 51:49.000] 他就是过不了
[51:49.000 --> 51:51.000] 然后你也知道那个东西没有什么
[51:51.000 --> 51:53.000] 就不会特别影响
[51:53.000 --> 51:55.000] 就直接刚刚force之类的
[51:56.000 --> 51:57.000] 你们允许刚刚force吗
[51:59.000 --> 52:02.000] 其实就是就你要知道你在干什么
[52:02.000 --> 52:04.000] 然后你要用明白了
[52:05.000 --> 52:06.000] 我觉得反正是
[52:06.000 --> 52:08.000] 我觉得Python有些时候在工程上面
[52:08.000 --> 52:11.000] 的确有一些东西要很慎重的使用
[52:11.000 --> 52:13.000] 有些时候写代码也得非常小心翼翼
[52:15.000 --> 52:16.000] 对
[52:16.000 --> 52:18.000] 那然后我看一下
[52:18.000 --> 52:20.000] 那我们的新涛同学
[52:20.000 --> 52:21.000] 你来分享一下
[52:24.000 --> 52:25.000] 我感觉还好吧
[52:25.000 --> 52:28.000] 我感觉遇到的坑都挺有意思的
[52:28.000 --> 52:30.000] 但是我现在想不起来
[52:30.000 --> 52:32.000] 当时对Python的什么那个了
[52:33.000 --> 52:35.000] 现在有一点就是
[52:35.000 --> 52:38.000] 你们有没有觉得Python的函数的
[52:38.000 --> 52:40.000] 参数有点种类太多了
[52:40.000 --> 52:42.000] 跟其他语言不太一样
[52:44.000 --> 52:46.000] 比如说我们现在有
[52:46.000 --> 52:48.000] 有position args
[52:48.000 --> 52:49.000] 不就两个
[52:50.000 --> 52:53.000] 然后你可以在中间加一个星
[52:53.000 --> 52:55.000] 就是前面有一个前后面有一个
[52:55.000 --> 52:57.000] 你现在还能加一个斜杠
[52:57.000 --> 53:00.000] 前面有些后面有些把他隔开
[53:02.000 --> 53:04.000] 我倒是觉得还OK
[53:04.000 --> 53:05.000] 我觉得还OK
[53:05.000 --> 53:06.000] 因为说实话
[53:06.000 --> 53:07.000] 一般情况下
[53:07.000 --> 53:09.000] 我对于函数的推荐就是说是
[53:09.000 --> 53:12.000] 能使用那个keyword argument
[53:12.000 --> 53:14.000] 就优先使用keyword argument
[53:14.000 --> 53:15.000] 对我也是这样
[53:15.000 --> 53:16.000] 比较对
[53:16.000 --> 53:19.000] 现在有那个什么叫keyword only argument
[53:19.000 --> 53:21.000] 就是你只能用keyword
[53:21.000 --> 53:23.000] 3.5之后添加了
[53:23.000 --> 53:24.000] 3.4 3.5之后添加了
[53:24.000 --> 53:25.000] keyword only
[53:25.000 --> 53:28.000] 我以为你说最新那个position only
[53:29.000 --> 53:30.000] 我觉得那个的话
[53:30.000 --> 53:32.000] 我觉得对于函数来讲的话
[53:32.000 --> 53:34.000] 我觉得我所推荐的一个
[53:34.000 --> 53:35.000] 所谓的best practice的话
[53:35.000 --> 53:37.000] 就是说你在写函数参数的时候
[53:37.000 --> 53:38.000] 能使用keyword only
[53:38.000 --> 53:39.000] 就使用keyword only
[53:40.000 --> 53:42.000] 可读性极大的提升
[53:42.000 --> 53:44.000] 对可读性极大提升
[53:44.000 --> 53:45.000] 其实这个东西的话
[53:45.000 --> 53:46.000] 你也敲不了多少
[53:46.000 --> 53:48.000] 其实很多时候IDE都能帮你解决
[53:49.000 --> 53:50.000] 但是其实用的时候
[53:50.000 --> 53:52.000] 你有的时候也会有一点点尴尬
[53:52.000 --> 53:54.000] 就比如说如果外部使用方
[53:54.000 --> 53:55.000] 他真的命名很好
[53:55.000 --> 53:57.000] 你会发现他会传一个a等于a
[53:57.000 --> 53:59.000] b等于b c等于c进来
[53:59.000 --> 54:02.000] 其实我觉得是可以
[54:02.000 --> 54:03.000] 我觉得可以
[54:03.000 --> 54:05.000] 其实有些时候我还推荐一种
[54:05.000 --> 54:07.000] 我自己更习惯的一种做法是
[54:07.000 --> 54:10.000] 我是直接把它写成一个dict
[54:10.000 --> 54:12.000] 然后用那个解包的语法
[54:12.000 --> 54:16.000] 对就是直接写成一个
[54:16.000 --> 54:18.000] 对写成一个argument
[54:18.000 --> 54:19.000] argument的一个dict
[54:19.000 --> 54:21.000] 然后把它就dict传进去
[54:21.000 --> 54:23.000] 我觉得这种封装一下
[54:23.000 --> 54:26.000] 我觉得是看起可读性比较好的一种做法
[54:26.000 --> 54:30.000] 然后说到参数
[54:30.000 --> 54:32.000] 有一个那个就是默认参数
[54:32.000 --> 54:33.000] 不能是可变类型
[54:33.000 --> 54:36.000] 比如说a等于就括号一括号
[54:36.000 --> 54:37.000] 那个很经典的
[54:37.000 --> 54:41.000] 之前不是说是坑过哪一家公司的吗
[54:41.000 --> 54:47.000] 就直接上市公司被那个坑得很惨对吧
[54:47.000 --> 54:49.000] 就损失很严重
[54:49.000 --> 54:51.000] 对好像是那样
[54:51.000 --> 54:54.000] 我可能没太听过是怎么回事
[54:54.000 --> 54:56.000] 就是有一个公司是用python的
[54:56.000 --> 54:59.000] 然后他们在那个函数里面
[54:59.000 --> 55:01.000] 那个默认参数用了一个可变类型的
[55:01.000 --> 55:03.000] 就是这个中括号
[55:03.000 --> 55:06.000] 对就是默认一个list
[55:06.000 --> 55:08.000] 一个list或者其他的
[55:08.000 --> 55:10.000] 然后他们就不断在可变类型的
[55:10.000 --> 55:13.000] 就是默认参数上面做操作
[55:13.000 --> 55:15.000] 这个我觉得是完全是他自己的问题
[55:15.000 --> 55:18.000] 这种code在google是提交不进去的
[55:18.000 --> 55:20.000] 也是会被linked的
[55:20.000 --> 55:22.000] 然后这家公司几乎毁了
[55:22.000 --> 55:28.000] 这就是难道是传说中的一个语言毁了一个公司
[55:28.000 --> 55:32.000] 但是这种新手真的很容易遇到
[55:32.000 --> 55:34.000] 我遇到过很多次
[55:34.000 --> 55:37.000] 就是我自己写的还有我看别人的
[55:37.000 --> 55:39.000] 对我觉得这个东西其实是一个
[55:39.000 --> 55:42.000] 所以说我觉得有些时候
[55:42.000 --> 55:44.000] 可能我们对于新手而言的话
[55:44.000 --> 55:45.000] 可能最开始就可以说
[55:45.000 --> 55:47.000] 我对于一些python书而言的话
[55:47.000 --> 55:49.000] 我觉得他可能建议就是说是
[55:49.000 --> 55:51.000] 在最开始就给他们介绍一些line的工具
[55:51.000 --> 55:53.000] 像pyline这样的工具
[55:53.000 --> 55:54.000] 对对对
[55:54.000 --> 55:55.000] 然后这个就能
[55:55.000 --> 55:58.000] 但是我觉得这一点可以believe python
[55:58.000 --> 56:01.000] 我觉得的确可以吧
[56:01.000 --> 56:03.000] 但是这个东西看怎么用吧
[56:03.000 --> 56:05.000] 它的确是一个设计不合理的点
[56:05.000 --> 56:07.000] 我想起还有一个坑
[56:07.000 --> 56:08.000] 你说
[56:08.000 --> 56:10.000] 就py2.7的时候
[56:10.000 --> 56:12.000] 你们试过字符串和数字比较吗
[56:12.000 --> 56:14.000] 没有
[56:14.000 --> 56:18.000] 字符串和数字比较应该会有什么
[56:18.000 --> 56:21.000] 体验把a大于1 b小于1这种
[56:21.000 --> 56:24.000] 他是会
[56:24.000 --> 56:26.000] 他是一个
[56:26.000 --> 56:29.000] 他是cpython的一个实现不良导致的
[56:29.000 --> 56:32.000] 我忘记了是什么了
[56:32.000 --> 56:34.000] 反正就是如果
[56:34.000 --> 56:36.000] 大意就是如果说这两个类型
[56:36.000 --> 56:37.000] 有一个是数字
[56:37.000 --> 56:38.000] 另外一个是其他类型
[56:38.000 --> 56:42.000] 他然后他又没有定义那个letter的话
[56:42.000 --> 56:43.000] Lt那个属性的话
[56:43.000 --> 56:47.000] 他应该是按照你type的首字母来排行
[56:47.000 --> 56:52.000] 你这个对象的type的首字母来做比较
[56:52.000 --> 56:56.000] 这个也太扯了
[56:56.000 --> 56:58.000] 我试了一下三里已经不能比
[56:58.000 --> 56:59.000] 三里是不能比的
[56:59.000 --> 57:02.000] 2的cpython的实现会造成这个问题
[57:02.000 --> 57:04.000] 天啊可以好吧
[57:04.000 --> 57:06.000] 我这个坑我还真没遇到过
[57:06.000 --> 57:08.000] OK
[57:08.000 --> 57:12.000] 然后我的话我想吐槽的其实是
[57:12.000 --> 57:13.000] 我想吐槽的其实挺多的
[57:13.000 --> 57:15.000] 我挑几个代表性的吧
[57:15.000 --> 57:17.000] 然后第一个像celery
[57:17.000 --> 57:20.000] celery的celery的
[57:20.000 --> 57:22.000] 首先celery一个被
[57:22.000 --> 57:24.000] 我们上一期节目就里面吐槽过很多
[57:24.000 --> 57:26.000] celery像他的那个参数太多对吧
[57:26.000 --> 57:29.000] 然后像他的那个就说是
[57:29.000 --> 57:32.000] 3-4的一个broken change对吧
[57:32.000 --> 57:34.000] 然后还有的话
[57:34.000 --> 57:36.000] 其实前几天正好帮人查了一个错
[57:36.000 --> 57:38.000] 然后也是我之前遇到过的
[57:38.000 --> 57:40.000] 然后就说是
[57:40.000 --> 57:43.000] Python login里面
[57:43.000 --> 57:44.000] celery是这样
[57:44.000 --> 57:46.000] 我们一般都知道Python
[57:46.000 --> 57:48.000] 我们一般用Python的打日志的话
[57:48.000 --> 57:51.000] 就是直接基于它官方的login的库进行操作
[57:51.000 --> 57:52.000] 对不对
[57:52.000 --> 57:53.000] 对
[57:53.000 --> 57:54.000] 对
[57:54.000 --> 57:57.000] 然后可能就说你在里面加一些不同的那个handle
[57:57.000 --> 57:58.000] 就是说是加一些formatter
[57:58.000 --> 58:00.000] 再加一些logger之类的对吧
[58:00.000 --> 58:03.000] 然后但是celery是有这样一个坑点
[58:03.000 --> 58:06.000] 它默认的设计是默认会hijack
[58:06.000 --> 58:09.000] login里面的所有的handle和logger
[58:09.000 --> 58:11.000] 这个我知道
[58:11.000 --> 58:13.000] 它是会hijack里面的
[58:13.000 --> 58:17.000] 所以说它有个参数叫做zotloggerhijack
[58:17.000 --> 58:19.000] 你要把它设置为force
[58:19.000 --> 58:22.000] 你才能用去用你自己定义的logger
[58:22.000 --> 58:23.000] handle和formatter
[58:23.000 --> 58:26.000] 它是相当于把那个login包了一层
[58:26.000 --> 58:27.000] 对
[58:27.000 --> 58:29.000] 它是一个它就说是叫hijack了
[58:29.000 --> 58:31.000] 就是说是去劫持了
[58:33.000 --> 58:35.000] 它这样是为了
[58:35.000 --> 58:36.000] 我怎么样
[58:36.000 --> 58:38.000] 我不太知道这个
[58:38.000 --> 58:40.000] 我不太知道这个东西
[58:40.000 --> 58:42.000] 但是我至少从我的角度来讲
[58:42.000 --> 58:46.000] 因为你从一个合理设计的角度来讲
[58:46.000 --> 58:48.000] 你作为一个第三方的罗库
[58:48.000 --> 58:51.000] 你是不应该去对官方的就是说是
[58:51.000 --> 58:53.000] 进行一个patch的操作
[58:53.000 --> 58:56.000] 而且你是假定用户会按照你的习惯去行使
[58:56.000 --> 58:58.000] 我没看具体实现
[58:58.000 --> 59:01.000] 但是我觉得就是他如果真的要做
[59:01.000 --> 59:03.000] 他用pattern的那个动态机制
[59:03.000 --> 59:05.000] 也可以做到就是扩展extend的
[59:05.000 --> 59:07.000] 也不需要自己hijack
[59:07.000 --> 59:09.000] 替换成全部都是自己的
[59:09.000 --> 59:11.000] 但是他就是替换成
[59:11.000 --> 59:16.000] 他是应该想就是在自己的那个log里面
[59:16.000 --> 59:17.000] 加一些task的信息
[59:17.000 --> 59:19.000] 比如说你无论打什么log
[59:19.000 --> 59:23.000] 他就会自动把那个task名字时间啊什么的带上
[59:23.000 --> 59:24.000] 对
[59:24.000 --> 59:26.000] 然后这个地方造成的一个坑点
[59:26.000 --> 59:27.000] 就是说是你自己
[59:27.000 --> 59:29.000] 比如说你自己定义了一些logger的话
[59:29.000 --> 59:32.000] 然后你想定义一些headerformatter之类的东西的话
[59:32.000 --> 59:36.000] 如果你不去把它参数显示的声明为force的话
[59:36.000 --> 59:38.000] 那么你的这个logger是不生效的
[59:38.000 --> 59:41.000] 这有点过分了
[59:41.000 --> 59:43.000] 对
[59:43.000 --> 59:46.000] 你应该按照他的文档里面
[59:46.000 --> 59:48.000] 就是你不能用pattern的logging模块来试
[59:48.000 --> 59:52.000] 你应该用他文档里面的salarylog来试
[59:52.000 --> 59:53.000] 但是关键是这样
[59:53.000 --> 59:56.000] 你这个东西你不应该说是
[59:56.000 --> 59:59.000] 你不应该把用户的选择给剥夺了
[59:59.000 --> 01:00:01.000] 就是说你在默认的
[01:00:01.000 --> 01:00:04.000] 你的默认的行为是不应该把用户的选择给剥夺了
[01:00:04.000 --> 01:00:06.000] 而现在说来说
[01:00:06.000 --> 01:00:08.000] 你可以通过configure的参数
[01:00:08.000 --> 01:00:11.000] 但是你想你configure一页几十上百个参数
[01:00:11.000 --> 01:00:12.000] 朋友
[01:00:12.000 --> 01:00:14.000] 然后你怎么样去让用户去定义到
[01:00:14.000 --> 01:00:16.000] 我login是你highjack了
[01:00:16.000 --> 01:00:17.000] 对吧
[01:00:17.000 --> 01:00:18.000] 然后你的这个东西
[01:00:18.000 --> 01:00:19.000] 你没有显示的说明
[01:00:19.000 --> 01:00:21.000] 你对于一个库而言
[01:00:21.000 --> 01:00:24.000] 我觉得说是你不能去剥夺用户默认的行为
[01:00:24.000 --> 01:00:26.000] 去剥夺用户的操作选择权
[01:00:26.000 --> 01:00:29.000] 而salarym他默认就是做了这一点
[01:00:29.000 --> 01:00:31.000] 但是他是一层抽象
[01:00:31.000 --> 01:00:33.000] 所有的抽象都是不完整的
[01:00:33.000 --> 01:00:35.000] 但是也许有另外一个可能
[01:00:35.000 --> 01:00:37.000] 就是其实
[01:00:39.000 --> 01:00:41.000] 比如说市面上95%的人
[01:00:41.000 --> 01:00:43.000] 他不会自己去配logger
[01:00:43.000 --> 01:00:46.000] 这个地方的话
[01:00:46.000 --> 01:00:48.000] 我觉得怎么说吧
[01:00:48.000 --> 01:00:49.000] 我觉得这个地方的话
[01:00:49.000 --> 01:00:50.000] 你不敢说是你
[01:00:50.000 --> 01:00:53.000] 我觉得这个地方其实是有更优雅的一个东西
[01:00:53.000 --> 01:00:58.000] 就是说是你在tutorial里面去告诉用户
[01:00:58.000 --> 01:00:59.000] 你去有这样的选择权
[01:00:59.000 --> 01:01:01.000] 但是salary
[01:01:01.000 --> 01:01:03.000] 他默认剥夺了
[01:01:03.000 --> 01:01:05.000] 他是想屏蔽你
[01:01:05.000 --> 01:01:07.000] 对于这个的知情权
[01:01:07.000 --> 01:01:09.000] 他只在configure的文档里面
[01:01:09.000 --> 01:01:10.000] 是说有这样一个参数
[01:01:10.000 --> 01:01:13.000] 但是具体怎么样去查到这个参数
[01:01:13.000 --> 01:01:14.000] 很对不起
[01:01:14.000 --> 01:01:15.000] 你只能去爆炸网上
[01:01:15.000 --> 01:01:16.000] stackoverflow上
[01:01:16.000 --> 01:01:17.000] 去搜索对应的观念词
[01:01:17.000 --> 01:01:19.000] 才有可能获得这样的信息
[01:01:19.000 --> 01:01:21.000] 我觉得这样是一个很不妥的行为
[01:01:23.000 --> 01:01:27.000] 这个是我最近和另外一个朋友在聊的一个话题
[01:01:27.000 --> 01:01:29.000] 就是很多库
[01:01:29.000 --> 01:01:31.000] 他会选择比如说
[01:01:31.000 --> 01:01:33.000] 他会覆盖95%的场景
[01:01:35.000 --> 01:01:40.000] 但是他就会牺牲一些扩展性或者是高级特性
[01:01:40.000 --> 01:01:43.000] 或者是对这种更高级的人不是很友好
[01:01:44.000 --> 01:01:49.000] 所以说封装就是带来了一层限制吗
[01:01:49.000 --> 01:01:51.000] 带来方便的同时也带来限制
[01:01:51.000 --> 01:01:54.000] 其实我觉得是能够理解这种封装的
[01:01:54.000 --> 01:01:58.000] 但是我觉得封装始终是有个前提
[01:01:58.000 --> 01:02:01.000] 你需要对用户有足够的知情权
[01:02:01.000 --> 01:02:04.000] 就是说你需要有足够的渠道
[01:02:04.000 --> 01:02:07.000] 去给用户说明你这个知情权
[01:02:07.000 --> 01:02:10.000] 而目前Sara我看到她关于这些东西的话
[01:02:10.000 --> 01:02:12.000] 是没有这样一个选择权的
[01:02:12.000 --> 01:02:15.000] 就是感觉她不应该自己设一个默认值
[01:02:15.000 --> 01:02:16.000] 应该让用户来选对吧
[01:02:16.000 --> 01:02:18.000] 我选你的或不选你的
[01:02:18.000 --> 01:02:21.000] 对就是说是比如说你可以参数里面
[01:02:21.000 --> 01:02:22.000] 你在Twitter里面
[01:02:22.000 --> 01:02:24.000] 你可以很明确的告诉用户
[01:02:24.000 --> 01:02:25.000] 你通过哪个参数
[01:02:25.000 --> 01:02:27.000] 你可以去选择使用默认的Logger
[01:02:27.000 --> 01:02:30.000] 还是使用她帮助Sara封装的Logger
[01:02:30.000 --> 01:02:33.000] 这样我觉得比她现在的行为优雅很多
[01:02:33.000 --> 01:02:38.000] Sara的教程现在已经感觉有点不太完整了
[01:02:38.000 --> 01:02:40.000] 她的文档也不是特别多
[01:02:40.000 --> 01:02:42.000] 对我觉得也是
[01:02:42.000 --> 01:02:45.000] 我觉得这种东西可能就是她一开始
[01:02:45.000 --> 01:02:47.000] 在写第一版的时候
[01:02:47.000 --> 01:02:49.000] 她为了简单她就这么搞了
[01:02:49.000 --> 01:02:51.000] 但是她后面已经很难
[01:02:51.000 --> 01:02:54.000] 就很多东西都依赖于这种很难汇报出来
[01:02:54.000 --> 01:02:56.000] 对就是一些技术债我觉得算是
[01:02:56.000 --> 01:02:57.000] 让她重新设计
[01:02:57.000 --> 01:02:59.000] 我觉得她没有理由会这样设计
[01:02:59.000 --> 01:03:01.000] 对我觉得也倒也是
[01:03:01.000 --> 01:03:05.000] 然后第二个的话就是我吐槽的话
[01:03:05.000 --> 01:03:07.000] 就是变于Python和AsyncIO那一套东西
[01:03:07.000 --> 01:03:09.000] 然后点名
[01:03:09.000 --> 01:03:10.000] 对点名
[01:03:10.000 --> 01:03:12.000] 我记得我之前给你们吐槽过很多遍
[01:03:12.000 --> 01:03:16.000] 然后但是可能听众朋友们还不太知道
[01:03:16.000 --> 01:03:18.000] 然后我之前17年的时候
[01:03:18.000 --> 01:03:20.000] 我们当时在老东家
[01:03:20.000 --> 01:03:23.000] 我们是在线上是AsyncIO普及的很多
[01:03:23.000 --> 01:03:24.000] 对吧
[01:03:24.000 --> 01:03:26.000] AsyncIO普及的很多的话
[01:03:26.000 --> 01:03:29.000] 然后我们突然就发现某一天某一些时候
[01:03:29.000 --> 01:03:31.000] 一个机器上面的
[01:03:31.000 --> 01:03:33.000] 机器上面的然后连接
[01:03:33.000 --> 01:03:35.000] CloseVit就爆了
[01:03:35.000 --> 01:03:36.000] 然后就最高的时候
[01:03:36.000 --> 01:03:39.000] 峰值一台机器干了15K
[01:03:39.000 --> 01:03:41.000] 然后15K
[01:03:41.000 --> 01:03:43.000] 还有可能还有更多的一个CloseVit
[01:03:43.000 --> 01:03:45.000] 就是说不正常的连接
[01:03:45.000 --> 01:03:47.000] 很明显连接泄露了
[01:03:47.000 --> 01:03:49.000] 最后我们定位到是什么呢
[01:03:49.000 --> 01:03:51.000] 是AsyncIO官方的一个
[01:03:51.000 --> 01:03:54.000] 对于HTTPS就说是SL的连接
[01:03:54.000 --> 01:03:57.000] 存在那个处理的时候存在一个缺陷
[01:03:57.000 --> 01:04:01.000] 导致了就说是他在针对一些HTTPS连接的时候
[01:04:01.000 --> 01:04:03.000] 他没法正确的关闭连接
[01:04:03.000 --> 01:04:07.000] 然后这个库是在17年的时候
[01:04:07.000 --> 01:04:09.000] 是有两个BPO
[01:04:09.000 --> 01:04:11.000] 两个就是Bugs of Python.org
[01:04:11.000 --> 01:04:13.000] 我们就是Python里面的BPO
[01:04:13.000 --> 01:04:15.000] 就是他的那个Bug编号
[01:04:15.000 --> 01:04:20.000] 有两个BPO的话去提到了这个问题
[01:04:20.000 --> 01:04:22.000] 到了18年19年的时候
[01:04:22.000 --> 01:04:24.000] 官方对于就问题还没有修复
[01:04:24.000 --> 01:04:27.000] 然后别人去Ping官方对于你们AsyncIO
[01:04:27.000 --> 01:04:30.000] 这个SL泄露怎么办啊
[01:04:30.000 --> 01:04:33.000] 然后Python的一个Coach出来说了
[01:04:33.000 --> 01:04:37.000] 我们会争取在Python3.8解决这个问题
[01:04:37.000 --> 01:04:39.000] 当然了AsyncIO现在没有解决
[01:04:39.000 --> 01:04:41.000] 你们可以去用第三方的Async
[01:04:41.000 --> 01:04:44.000] 基于AsyncEvite的事件泄露的一个循环
[01:04:44.000 --> 01:04:46.000] 然后他推荐了Terror
[01:04:46.000 --> 01:04:50.000] 我觉得这是我很想吐槽的点
[01:04:50.000 --> 01:04:58.000] Terror是那个Python支付Resume
[01:04:58.000 --> 01:05:00.000] 之前AsyncIO的前身
[01:05:00.000 --> 01:05:04.000] 不是是另外一个第三方核心
[01:05:04.000 --> 01:05:08.000] 还有比如说常见的像UVLoop之类的
[01:05:08.000 --> 01:05:10.000] AsyncIO的替代
[01:05:10.000 --> 01:05:18.000] 如果要用Async这套的话都是用UVloop
[01:05:18.000 --> 01:05:22.000] 是用UVloop但是默认的官方的loop的话
[01:05:22.000 --> 01:05:24.000] 我觉得有这样的问题一直不修
[01:05:24.000 --> 01:05:26.000] 对我知道我知道
[01:05:26.000 --> 01:05:27.000] 我只是问一下
[01:05:27.000 --> 01:05:29.000] 我觉得其实是个挺不合理的现象
[01:05:29.000 --> 01:05:33.000] 说到这个
[01:05:33.000 --> 01:05:36.000] 我其实对于Python很大的一个怨念
[01:05:36.000 --> 01:05:40.000] 就是他把一大部分人力都投到开发Async这套
[01:05:40.000 --> 01:05:46.000] 实际上并不会有多大impact的东西上面去
[01:05:46.000 --> 01:05:50.000] 其实我觉得Async的意义还是挺大的
[01:05:50.000 --> 01:05:52.000] 但是就目前而言的话
[01:05:52.000 --> 01:05:54.000] 但是实际上作用有多少
[01:05:54.000 --> 01:05:56.000] 其实真的挺难说的
[01:05:56.000 --> 01:05:59.000] 你想他如果能把performance提升一点
[01:05:59.000 --> 01:06:01.000] 那肯定会比你弄个Async
[01:06:01.000 --> 01:06:05.000] 更能留住或者吸引人
[01:06:05.000 --> 01:06:09.000] 对其实我觉得他能把包括调试监控
[01:06:09.000 --> 01:06:12.000] 然后再加上其他的一套工程化的东西
[01:06:12.000 --> 01:06:14.000] 给提升起来
[01:06:14.000 --> 01:06:17.000] 我觉得其实他能获得的收益是远高于
[01:06:17.000 --> 01:06:19.000] 全力去搞Async这套
[01:06:19.000 --> 01:06:23.000] 我不太确认
[01:06:23.000 --> 01:06:25.000] 因为我觉得Python再怎么提升性能
[01:06:25.000 --> 01:06:28.000] 其实性能也就这样了
[01:06:28.000 --> 01:06:32.000] 我也觉得其实的确
[01:06:32.000 --> 01:06:36.000] 他底层抽象的说了这个我就要再吐槽一遍了
[01:06:36.000 --> 01:06:39.000] 就是说是我之前我前段时间我在跟一个BPO
[01:06:39.000 --> 01:06:41.000] 然后的话跟一个BPO的时候
[01:06:41.000 --> 01:06:42.000] 我遇到一个问题就是说
[01:06:42.000 --> 01:06:44.000] 就是这个BPO内容是这样的
[01:06:44.000 --> 01:06:48.000] 就是说你们知道首先是Docker的话
[01:06:48.000 --> 01:06:50.000] 是可以对CPU进行限制的对不对
[01:06:50.000 --> 01:06:55.000] 然后Docker是对CPU进行限制
[01:06:55.000 --> 01:06:58.000] 然后你在按照你说你的语言
[01:06:58.000 --> 01:07:00.000] 在获取CPU限制的时候
[01:07:00.000 --> 01:07:02.000] 你应该是获取到Docker
[01:07:02.000 --> 01:07:04.000] 就是说你去启动Docker的时候
[01:07:04.000 --> 01:07:05.000] 启动容器的时候
[01:07:05.000 --> 01:07:07.000] 它的CPU限制对不对
[01:07:07.000 --> 01:07:09.000] 但是像PythonGo上去演的话
[01:07:09.000 --> 01:07:13.000] 就还是会获取到数据上面的核数
[01:07:13.000 --> 01:07:17.000] 就比如说你PythonOS.getCPUCounts
[01:07:17.000 --> 01:07:18.000] 这样的对吧
[01:07:18.000 --> 01:07:19.000] 好
[01:07:19.000 --> 01:07:20.000] 然后就是背景
[01:07:20.000 --> 01:07:23.000] 然后的话我看到JavaOpenJDK上面
[01:07:23.000 --> 01:07:26.000] 是实现了针对容器的优化
[01:07:26.000 --> 01:07:28.000] 我想去把它移植过去
[01:07:28.000 --> 01:07:30.000] 但是我放弃了这个BPO了
[01:07:30.000 --> 01:07:31.000] 你知道为什么吗
[01:07:31.000 --> 01:07:34.000] 因为它内部的偶合太严重
[01:07:34.000 --> 01:07:37.000] 它内部的那个Python的那个OS的实现
[01:07:37.000 --> 01:07:38.000] 偶合太严重
[01:07:38.000 --> 01:07:40.000] 我觉得相对来说是很严重了
[01:07:40.000 --> 01:07:42.000] 就是说至少从代码结构上来说
[01:07:42.000 --> 01:07:46.000] 它的确是对于不同的操作系统做封装
[01:07:46.000 --> 01:07:50.000] 但是它的封装很多时候就只是用那种
[01:07:50.000 --> 01:07:51.000] 就是说是红定义
[01:07:51.000 --> 01:07:55.000] 就是if diff if diff if not diff
[01:07:55.000 --> 01:07:57.000] 然后这样的类似于红定义的
[01:07:57.000 --> 01:08:01.000] 就是说是跟C语言ABI这种
[01:08:01.000 --> 01:08:03.000] 类似的就是这种很简单的
[01:08:03.000 --> 01:08:07.000] 原始的一种封装去针对于不同操作系统
[01:08:07.000 --> 01:08:08.000] 做补丁
[01:08:08.000 --> 01:08:09.000] 但是实际上而言
[01:08:09.000 --> 01:08:11.000] 这种东西其实是应该不同的
[01:08:11.000 --> 01:08:13.000] 出来成为一套独立的代码
[01:08:13.000 --> 01:08:15.000] 像JDK它就是这么做的
[01:08:15.000 --> 01:08:18.000] 它是底层是有专门叫做OS module
[01:08:18.000 --> 01:08:20.000] 它是把Linux Proxy
[01:08:20.000 --> 01:08:22.000] 然后Windows这些东西单独是有
[01:08:22.000 --> 01:08:24.000] 各自有一套代码实现的
[01:08:24.000 --> 01:08:26.000] 然后通过其他方式把它引进去
[01:08:26.000 --> 01:08:29.000] 而Python的话就是直接一套
[01:08:29.000 --> 01:08:31.000] 哇擦你们去看了那个东西
[01:08:31.000 --> 01:08:33.000] 你们就知道非常顺手
[01:08:33.000 --> 01:08:35.000] 但是这种我总感觉应该
[01:08:35.000 --> 01:08:37.000] 就我没有看过实际代码
[01:08:37.000 --> 01:08:39.000] 但我直观感觉你难道不能
[01:08:39.000 --> 01:08:40.000] 就如果要修的话
[01:08:40.000 --> 01:08:44.000] 难道不能再wrap一层东西吗
[01:08:44.000 --> 01:08:45.000] 是这样的
[01:08:45.000 --> 01:08:47.000] 是你可以再wrap一层东西
[01:08:47.000 --> 01:08:49.000] 但是那个东西的话相当于说
[01:08:49.000 --> 01:08:51.000] 又是一个broken change了
[01:08:51.000 --> 01:08:52.000] 对于Python来讲
[01:08:52.000 --> 01:08:55.000] 为什么是broken change呢
[01:08:55.000 --> 01:08:59.000] 因为如果它只改变你的程序
[01:08:59.000 --> 01:09:02.000] 在docker里跑的时候的行为
[01:09:02.000 --> 01:09:04.000] 是因为是这样
[01:09:04.000 --> 01:09:06.000] 你在docker里跑的时候
[01:09:06.000 --> 01:09:08.000] 其实你又会去关联到其他
[01:09:08.000 --> 01:09:10.000] 去获取到其他模块的信息
[01:09:10.000 --> 01:09:12.000] 就是说你需要去改其他模块的信息
[01:09:12.000 --> 01:09:14.000] 因为是这样
[01:09:14.000 --> 01:09:17.000] 你单纯的去获取docker的信息
[01:09:17.000 --> 01:09:19.000] 你看着它是一个函数
[01:09:19.000 --> 01:09:20.000] 但是实际上它的代码量
[01:09:20.000 --> 01:09:22.000] 可能就是说是几百行这样一个东西
[01:09:22.000 --> 01:09:23.000] 几百行这样的东西
[01:09:23.000 --> 01:09:25.000] 你要再把它插进去
[01:09:25.000 --> 01:09:27.000] 然后怎么插插到哪个地方
[01:09:27.000 --> 01:09:28.000] 这个地方的话
[01:09:28.000 --> 01:09:30.000] 不管是对它的代码结构
[01:09:30.000 --> 01:09:31.000] 还是对它现在的
[01:09:31.000 --> 01:09:33.000] 已经有的可读性的一个破坏来讲
[01:09:33.000 --> 01:09:35.000] 其实都是一个broken change
[01:09:37.000 --> 01:09:39.000] 我可能没有看过代码
[01:09:39.000 --> 01:09:40.000] 所以我不太了解
[01:09:40.000 --> 01:09:41.000] 我问个问题
[01:09:41.000 --> 01:09:44.000] 这个是它之所以现在这个现象
[01:09:44.000 --> 01:09:47.000] 是因为docker把这个system call
[01:09:47.000 --> 01:09:49.000] 转发到了宿主机对吧
[01:09:49.000 --> 01:09:50.000] 是这样
[01:09:50.000 --> 01:09:51.000] 因为你那个
[01:09:51.000 --> 01:09:53.000] 其实因为它默认你get CPU的话
[01:09:53.000 --> 01:09:54.000] 它是那个
[01:09:54.000 --> 01:09:55.000] 就是说是
[01:09:55.000 --> 01:09:57.000] 你sig group的话
[01:09:57.000 --> 01:09:58.000] 你sig group
[01:09:58.000 --> 01:10:00.000] 它是有另外一套的信息
[01:10:00.000 --> 01:10:01.000] 去记录你获取
[01:10:01.000 --> 01:10:03.000] 因为你当然其实
[01:10:03.000 --> 01:10:05.000] 本质上是基于sig group来做的
[01:10:05.000 --> 01:10:07.000] 然后你本质上基于sig group来做
[01:10:07.000 --> 01:10:10.000] 你针对于sig group下面的一些进程的话
[01:10:10.000 --> 01:10:11.000] 你要去获取信息
[01:10:11.000 --> 01:10:13.000] 你是有另外一套机制的
[01:10:13.000 --> 01:10:14.000] 而不是跟现在我直接说
[01:10:14.000 --> 01:10:17.000] 比如说我去SYS那个PROC下面
[01:10:17.000 --> 01:10:20.000] PROC直接下面去info去cat一下
[01:10:20.000 --> 01:10:21.000] 你就可以获得到对应的信息
[01:10:21.000 --> 01:10:22.000] 这是不太可能的
[01:10:23.000 --> 01:10:24.000] ok
[01:10:24.000 --> 01:10:27.000] 对因为因为其实因为像那个
[01:10:27.000 --> 01:10:30.000] 呃像最后实现出来一版的话
[01:10:30.000 --> 01:10:32.000] 差不多是有五六百行代码
[01:10:32.000 --> 01:10:33.000] 然后这个东西的话
[01:10:33.000 --> 01:10:35.000] 因为它是涉及到前前后后的
[01:10:35.000 --> 01:10:37.000] 可能你要涉及到中间的一部分
[01:10:37.000 --> 01:10:40.000] 对于OS这部分的读对于其他的东西
[01:10:40.000 --> 01:10:43.000] 你这个时候单纯你从代码结构上来讲
[01:10:43.000 --> 01:10:45.000] 你直接把它插在一个大文件里面
[01:10:45.000 --> 01:10:47.000] 我觉得可能不是太合适的
[01:10:47.000 --> 01:10:48.000] 那么你可能说
[01:10:48.000 --> 01:10:50.000] 按照不同的系统的封装
[01:10:50.000 --> 01:10:51.000] 不同的把它抽象出来
[01:10:51.000 --> 01:10:53.000] 因为像这个的话是专注于
[01:10:53.000 --> 01:10:55.000] 针对于Ninux下面的东西
[01:10:55.000 --> 01:10:56.000] 你把它抽象封装
[01:10:56.000 --> 01:10:58.000] 能复用的复用
[01:10:58.000 --> 01:10:59.000] 这样出来是一个很好的
[01:10:59.000 --> 01:11:00.000] 但是你现在就是说
[01:11:00.000 --> 01:11:02.000] 直接在一个大的一个文件上面来去改
[01:11:02.000 --> 01:11:05.000] 我觉得可能就是说是非常恶心的事情
[01:11:06.000 --> 01:11:07.000] 我觉得这种
[01:11:08.000 --> 01:11:10.000] 就是只能说你弄一个第三方
[01:11:10.000 --> 01:11:12.000] 就是弄一个第三方库来解决
[01:11:12.000 --> 01:11:16.000] 呃对我我目前想的也是也是这样的
[01:11:16.000 --> 01:11:17.000] 所以说我觉得的话
[01:11:17.000 --> 01:11:19.000] 可能对于它的历史的代码
[01:11:19.000 --> 01:11:20.000] 还有一些很多东西来讲的话
[01:11:20.000 --> 01:11:24.000] 它的设计来讲可能相对于其他语言的设计来讲
[01:11:24.000 --> 01:11:26.000] 可能并不是一个非常优雅
[01:11:26.000 --> 01:11:27.000] 或者是非常合适的
[01:11:28.000 --> 01:11:31.000] from Docker OS import
[01:11:31.000 --> 01:11:34.000] 可以可以
[01:11:34.000 --> 01:11:36.000] 可以搞一个这样的第三方库吗
[01:11:36.000 --> 01:11:38.000] 呃对可以搞一个
[01:11:38.000 --> 01:11:39.000] 其实Python有第三
[01:11:39.000 --> 01:11:41.000] 有一些类似于这样的第三方库
[01:11:41.000 --> 01:11:45.000] 但是的话呃很多时候也是因为各种原因吧
[01:11:45.000 --> 01:11:47.000] 然后都没有太流行起来
[01:11:48.000 --> 01:11:50.000] 行我觉得我们其实可以进入下一个环节了
[01:11:50.000 --> 01:11:51.000] 已经聊了一个多小时了
[01:11:51.000 --> 01:11:54.000] 对对对我觉得我觉得也是我们可以来聊一聊
[01:11:54.000 --> 01:11:57.000] 然后的话其实这个第三个环节的话
[01:11:57.000 --> 01:11:59.000] 也是今天非常重要的一个环节啊
[01:11:59.000 --> 01:12:03.000] 就是说大家我们刚才前面不是聊到一些坑对吧
[01:12:03.000 --> 01:12:06.000] 然后我们聊到自己对于一些各种各样语言
[01:12:06.000 --> 01:12:07.000] 第三方库的东西
[01:12:07.000 --> 01:12:10.000] 其实很多人可能还关心一个东西的话
[01:12:10.000 --> 01:12:13.000] 就是说呃我大家在生产环境上面
[01:12:13.000 --> 01:12:16.000] 在工作中怎么样去做一些伊朗问题上的排查
[01:12:16.000 --> 01:12:18.000] 你平时会有什么样的小技巧
[01:12:18.000 --> 01:12:21.000] 或者说你会使用什么样的小工具之类的
[01:12:24.000 --> 01:12:25.000] 我先说吧
[01:12:25.000 --> 01:12:26.000] 你说吧
[01:12:26.000 --> 01:12:27.000] 那我先说吧
[01:12:28.000 --> 01:12:31.000] 呃那个有个库嘛叫py-spy
[01:12:31.000 --> 01:12:35.000] 我觉得这个库已经拯救了我无数次了
[01:12:35.000 --> 01:12:38.000] 叫什么是那个可以远程连上去的那个吗
[01:12:39.000 --> 01:12:41.000] 呃不是不是远程吧
[01:12:41.000 --> 01:12:42.000] 是本机py-spy
[01:12:42.000 --> 01:12:43.000] py-spy
[01:12:44.000 --> 01:12:45.000] py-spy
[01:12:46.000 --> 01:12:47.000] spy吗
[01:12:47.000 --> 01:12:49.000] py-spy
[01:12:49.000 --> 01:12:51.000] 这个库你们没有用过
[01:12:51.000 --> 01:12:53.000] 我知道我看到了我找到了
[01:12:53.000 --> 01:12:54.000] 我没用过
[01:12:54.000 --> 01:12:56.000] 非常非常好用
[01:12:56.000 --> 01:12:58.000] 就是这个库就是你挑一个命令
[01:12:58.000 --> 01:12:59.000] py-spy
[01:12:59.000 --> 01:13:00.000] pid
[01:13:00.000 --> 01:13:02.000] 然后输上你python的pid
[01:13:02.000 --> 01:13:07.000] 它能把当前你这个python进程里面现成正在运行什么
[01:13:07.000 --> 01:13:09.000] 给你用一个套布展示出来
[01:13:09.000 --> 01:13:11.000] 就是运行时间最长的
[01:13:11.000 --> 01:13:14.000] 哦居然还是用rust写的呀
[01:13:15.000 --> 01:13:19.000] 对它就是能展示到每一行代码
[01:13:19.000 --> 01:13:21.000] 比如说你的代码现在卡住了
[01:13:21.000 --> 01:13:22.000] 有个死锁
[01:13:22.000 --> 01:13:24.000] 然后你用py-spy敲一下
[01:13:24.000 --> 01:13:28.000] 它立马能显示出来你的程序现在卡在哪一行
[01:13:28.000 --> 01:13:30.000] 哦这个很好
[01:13:30.000 --> 01:13:31.000] 这个很棒
[01:13:31.000 --> 01:13:33.000] 对然后你解决死锁的话
[01:13:33.000 --> 01:13:34.000] 这个基本上很快的
[01:13:34.000 --> 01:13:35.000] 然后第二个是性能问题
[01:13:35.000 --> 01:13:37.000] 假如说你的代码就运行很慢
[01:13:37.000 --> 01:13:38.000] 但是你觉得它没问题啊
[01:13:38.000 --> 01:13:40.000] 你觉得代码都写的很好
[01:13:40.000 --> 01:13:43.000] 然后你跑起来用py-spy看一下
[01:13:43.000 --> 01:13:45.000] 你就知道哪一个函数占用的时间最长
[01:13:45.000 --> 01:13:48.000] 我们之前有一个地方用到那个matplot
[01:13:48.000 --> 01:13:50.000] 它画图的时间特别长
[01:13:50.000 --> 01:13:51.000] 但是我们不知道
[01:13:51.000 --> 01:13:54.000] 然后用这个看发现那个画图占的时间特别长
[01:13:54.000 --> 01:13:56.000] 我们就可以专门优化这一部分
[01:13:57.000 --> 01:13:59.000] 哦对这个非常好
[01:13:59.000 --> 01:14:00.000] 这个非常棒
[01:14:00.000 --> 01:14:04.000] 它特别好的一个地方就是它不用重启你的进程
[01:14:04.000 --> 01:14:05.000] 你知道吗
[01:14:05.000 --> 01:14:06.000] 就是在生产环境
[01:14:06.000 --> 01:14:07.000] 你的程序正在跑
[01:14:07.000 --> 01:14:09.000] 你直接它有个wire嘛
[01:14:09.000 --> 01:14:10.000] wire下载下来装上去
[01:14:10.000 --> 01:14:12.000] 然后但是它要用sudo
[01:14:12.000 --> 01:14:14.000] 然后你看一下就可以了
[01:14:14.000 --> 01:14:17.000] 基本上就环境来说没有什么限制
[01:14:17.000 --> 01:14:18.000] 就用起来特别快
[01:14:19.000 --> 01:14:22.000] 而且它还支持一个火焰图
[01:14:22.000 --> 01:14:25.000] 就是你可以把它download出来一个火焰图
[01:14:25.000 --> 01:14:27.000] 然后你看那个程序的调用占什么
[01:14:27.000 --> 01:14:29.000] 哪一个程序运行的时间最长
[01:14:29.000 --> 01:14:32.000] 这首词我看这个原理
[01:14:32.000 --> 01:14:33.000] 我没看原理啊
[01:14:33.000 --> 01:14:36.000] 我看它的模式和我上期说的那个py-flame有点像
[01:14:36.000 --> 01:14:38.000] 就是你可以attach到那个进程
[01:14:38.000 --> 01:14:40.000] 所以它也是走的p-trace吗
[01:14:40.000 --> 01:14:41.000] 还是
[01:14:41.000 --> 01:14:43.000] 具体借口
[01:14:43.000 --> 01:14:44.000] 这个我要承认我没有看
[01:14:44.000 --> 01:14:45.000] 我没有看它的原理
[01:14:45.000 --> 01:14:47.000] 我只是用了一下
[01:14:47.000 --> 01:14:50.000] 它应该是download内存采样
[01:14:51.000 --> 01:14:52.000] 我看到了
[01:14:52.000 --> 01:14:53.000] 对
[01:14:53.000 --> 01:14:55.000] 它是通过这个processing read way
[01:14:56.000 --> 01:14:57.000] 对
[01:14:57.000 --> 01:14:59.000] 如果你对原理有兴趣的话
[01:14:59.000 --> 01:15:01.000] 你可以看一下那个Rbspot
[01:15:02.000 --> 01:15:03.000] 这个是那个
[01:15:03.000 --> 01:15:05.000] 你们认识那个julian events吗
[01:15:05.000 --> 01:15:06.000] 知道
[01:15:06.000 --> 01:15:08.000] 对
[01:15:08.000 --> 01:15:09.000] 他一开始写的那个RubySpot
[01:15:09.000 --> 01:15:14.000] 他的博客里面有几篇开发RubySpot的分享
[01:15:14.000 --> 01:15:16.000] 然后看一下那个应该就明白原理
[01:15:16.000 --> 01:15:20.000] 然后python这个是抄的他们这个东西
[01:15:23.000 --> 01:15:24.000] 对
[01:15:24.000 --> 01:15:26.000] 我觉得这个query很有帮助
[01:15:26.000 --> 01:15:27.000] 对
[01:15:27.000 --> 01:15:29.000] 这个已经救过我无数次了
[01:15:29.000 --> 01:15:31.000] 学习了
[01:15:32.000 --> 01:15:33.000] 用起来也很方便
[01:15:33.000 --> 01:15:36.000] 他用一个top展示出来
[01:15:36.000 --> 01:15:37.000] 对
[01:15:37.000 --> 01:15:38.000] 我觉得很棒
[01:15:38.000 --> 01:15:39.000] 我觉得这个query
[01:15:39.000 --> 01:15:41.000] 我觉得信涛推荐这个query非常棒
[01:15:41.000 --> 01:15:42.000] 对吧
[01:15:42.000 --> 01:15:43.000] 是的
[01:15:43.000 --> 01:15:44.000] 我之前
[01:15:44.000 --> 01:15:45.000] 我发现我之前还start了
[01:15:45.000 --> 01:15:47.000] 但是我一直还没机会用
[01:15:47.000 --> 01:15:48.000] 我还没start
[01:15:48.000 --> 01:15:49.000] 我之前还不知道这个query
[01:15:49.000 --> 01:15:50.000] 但是看起来很棒
[01:15:50.000 --> 01:15:52.000] 不过突然说起来有点搞笑
[01:15:52.000 --> 01:15:54.000] python一个非常好用的调试工具
[01:15:54.000 --> 01:15:56.000] 是用那个rust写的
[01:15:58.000 --> 01:15:59.000] 这个是个黑杀吧
[01:15:59.000 --> 01:16:00.000] 这个
[01:16:00.000 --> 01:16:01.000] 还好
[01:16:01.000 --> 01:16:02.000] 突然之间想黑一下
[01:16:02.000 --> 01:16:08.000] 但是说到这个就是系统中
[01:16:08.000 --> 01:16:09.000] 如果做一些限制
[01:16:09.000 --> 01:16:11.000] 比如说他不让你在生态环境安装一些东西
[01:16:11.000 --> 01:16:13.000] 或者说他禁用了一些系统调用
[01:16:13.000 --> 01:16:14.000] 那这个工具
[01:16:14.000 --> 01:16:16.000] 我碰到过
[01:16:16.000 --> 01:16:17.000] 我没法安装上
[01:16:17.000 --> 01:16:18.000] 没法用的情况
[01:16:18.000 --> 01:16:20.000] 这个就很蛋疼
[01:16:20.000 --> 01:16:22.000] 不过这个可能和用为
[01:16:22.000 --> 01:16:24.000] 就是说是和团队沟通一下
[01:16:24.000 --> 01:16:25.000] 其实也应该还好吧
[01:16:27.000 --> 01:16:28.000] 其实
[01:16:28.000 --> 01:16:29.000] 对
[01:16:29.000 --> 01:16:30.000] 我其实又想起
[01:16:30.000 --> 01:16:32.000] 就是张老师每次说的
[01:16:32.000 --> 01:16:36.000] 说就是你要是能有一个内置的事
[01:16:36.000 --> 01:16:38.000] 就内置的调试工具也这么好
[01:16:38.000 --> 01:16:39.000] 就好了
[01:16:39.000 --> 01:16:40.000] 对
[01:16:40.000 --> 01:16:42.000] 之前张老师说
[01:16:42.000 --> 01:16:45.000] 他其实先是有意向去做一个这方面的pp
[01:16:45.000 --> 01:16:46.000] 他在做吗
[01:16:46.000 --> 01:16:47.000] 他有意向
[01:16:47.000 --> 01:16:49.000] 但是我具体没有去问他的一个进度
[01:16:49.000 --> 01:16:51.000] 或者说是一个schedule是怎么样的
[01:16:51.000 --> 01:16:54.000] 但是之前他是有意向去做这样一个东西
[01:16:54.000 --> 01:16:56.000] 而且就是相比于JVM来说的话
[01:16:56.000 --> 01:16:57.000] python这块
[01:16:57.000 --> 01:17:00.000] 差太多了
[01:17:00.000 --> 01:17:01.000] 对
[01:17:03.000 --> 01:17:04.000] OK
[01:17:04.000 --> 01:17:05.000] 对
[01:17:05.000 --> 01:17:06.000] 然后的话
[01:17:06.000 --> 01:17:07.000] 你看
[01:17:07.000 --> 01:17:08.000] 那你工具推荐了
[01:17:08.000 --> 01:17:12.000] 那你有什么技巧或者是方法论之类的东西吗
[01:17:13.000 --> 01:17:14.000] 技巧
[01:17:14.000 --> 01:17:15.000] 技巧
[01:17:15.000 --> 01:17:16.000] 技巧就是
[01:17:16.000 --> 01:17:17.000] 如果你遇到一个问题的话
[01:17:17.000 --> 01:17:23.000] 你就想办法搞一个最小的能复现的例子出来
[01:17:23.000 --> 01:17:25.000] 其实这个上一期好像也说过
[01:17:25.000 --> 01:17:27.000] 比如说你遇到一些网络的问题的话
[01:17:27.000 --> 01:17:31.000] 你就不要再去看你代码了
[01:17:31.000 --> 01:17:32.000] 如果你实在看不出来
[01:17:32.000 --> 01:17:33.000] 你就把你代码
[01:17:33.000 --> 01:17:35.000] 你想用一个什么样的curl来
[01:17:35.000 --> 01:17:37.000] 你用那个curl打出来
[01:17:37.000 --> 01:17:39.000] 你把整个过程都透明出来
[01:17:39.000 --> 01:17:41.000] 你可能就很快就发现问题了
[01:17:43.000 --> 01:17:44.000] OK
[01:17:44.000 --> 01:17:45.000] 对
[01:17:45.000 --> 01:17:46.000] 我觉得可以
[01:17:46.000 --> 01:17:47.000] 就最小能复现版本
[01:17:47.000 --> 01:17:48.000] 对吧
[01:17:48.000 --> 01:17:49.000] 对
[01:17:49.000 --> 01:17:50.000] 基本上你如果去问别人
[01:17:50.000 --> 01:17:51.000] 或者你给别人讲的话
[01:17:51.000 --> 01:17:54.000] 你有一个最小能复现的一个代码片段出来的话
[01:17:54.000 --> 01:17:56.000] 你们沟通成本可能很低
[01:17:56.000 --> 01:18:00.000] 而且如果你把这个最小能复现的代码片段搞出来
[01:18:00.000 --> 01:18:03.000] 很多情况下你都可以解决自己的问题了
[01:18:03.000 --> 01:18:04.000] 我觉得
[01:18:06.000 --> 01:18:07.000] 但是怎么
[01:18:07.000 --> 01:18:08.000] 但是怎么
[01:18:08.000 --> 01:18:11.000] 其实怎么搞出来这个最小的能复现的IA
[01:18:11.000 --> 01:18:13.000] 其实也是挺麻烦的
[01:18:13.000 --> 01:18:14.000] 因为不是说
[01:18:14.000 --> 01:18:15.000] 最难的
[01:18:15.000 --> 01:18:16.000] 对
[01:18:15.000 --> 01:18:18.000] 不是说你只要能复现这个bug
[01:18:18.000 --> 01:18:20.000] 你已经解决了50%了
[01:18:20.000 --> 01:18:22.000] 我觉得其实是70%
[01:18:22.000 --> 01:18:25.000] 对
[01:18:25.000 --> 01:18:26.000] 对
[01:18:26.000 --> 01:18:27.000] OK
[01:18:27.000 --> 01:18:28.000] 来来来
[01:18:28.000 --> 01:18:30.000] 我来说一下吧
[01:18:30.000 --> 01:18:31.000] 我觉得其实
[01:18:31.000 --> 01:18:34.000] 就因为我维护的那种系统是
[01:18:34.000 --> 01:18:39.000] 就是一套一直在跑的
[01:18:39.000 --> 01:18:43.000] 然后一直在处理数据的一套系统
[01:18:43.000 --> 01:18:45.000] 就是它的内部状态非常多
[01:18:45.000 --> 01:18:49.000] 所以想去真正复现一些问题
[01:18:49.000 --> 01:18:51.000] 基本是不太可能
[01:18:51.000 --> 01:18:55.000] 所以最终结论还是多打log
[01:18:55.000 --> 01:18:56.000] 是
[01:18:56.000 --> 01:19:00.000] 我刚也提到了
[01:19:00.000 --> 01:19:01.000] 你加了一个新功能
[01:19:01.000 --> 01:19:04.000] 反正新功能不要假定它能work
[01:19:04.000 --> 01:19:06.000] 然后该打的log都打上
[01:19:06.000 --> 01:19:07.000] 然后可以
[01:19:07.000 --> 01:19:09.000] 因为log可以有
[01:19:09.000 --> 01:19:12.000] 不管是level
[01:19:12.000 --> 01:19:15.000] 还是有一些debug的log
[01:19:15.000 --> 01:19:18.000] 你都是可以通过flag去控制它开关的
[01:19:18.000 --> 01:19:20.000] 所以你就加上
[01:19:20.000 --> 01:19:21.000] 你现在生产环境
[01:19:21.000 --> 01:19:22.000] 先测试
[01:19:22.000 --> 01:19:24.000] 然后生产环境可以关掉
[01:19:24.000 --> 01:19:26.000] 所以就加上
[01:19:26.000 --> 01:19:29.000] 然后因为你真的是出问题之后
[01:19:29.000 --> 01:19:32.000] 想去复现很难
[01:19:32.000 --> 01:19:34.000] 如果出问题有log的话
[01:19:34.000 --> 01:19:36.000] 就那时候就会发现
[01:19:36.000 --> 01:19:38.000] 你之前加了一些log的时间
[01:19:38.000 --> 01:19:40.000] 都是值得的
[01:19:40.000 --> 01:19:41.000] 是
[01:19:41.000 --> 01:19:47.000] 我觉得日日真的是会帮很大很大的忙
[01:19:47.000 --> 01:19:48.000] 有没有那种东西
[01:19:48.000 --> 01:19:49.000] 就是假如说你的进程
[01:19:49.000 --> 01:19:51.000] 就像这个pathman一样
[01:19:51.000 --> 01:19:52.000] 如果你进程出问题了
[01:19:52.000 --> 01:19:53.000] 然后这个时候
[01:19:53.000 --> 01:19:56.000] 你再把他所有的变量给
[01:19:56.000 --> 01:19:58.000] Sentry
[01:19:58.000 --> 01:20:00.000] 对对对Sentry
[01:20:00.000 --> 01:20:03.000] 但是Sentry也有限
[01:20:03.000 --> 01:20:07.000] 它只是把你出错的一行上下的变量打出来
[01:20:07.000 --> 01:20:12.000] 我印象中Sentry应该会把你的low cost和global都打掉吧
[01:20:12.000 --> 01:20:14.000] 对对对
[01:20:14.000 --> 01:20:16.000] 但是我觉得Sentry有个特别不好的地方
[01:20:16.000 --> 01:20:21.000] 就是它的性能太差
[01:20:21.000 --> 01:20:23.000] 你会用Sentry打日志吗
[01:20:23.000 --> 01:20:25.000] 我一般用Sentry来做
[01:20:25.000 --> 01:20:28.000] 就是我没有补货的一场的补货
[01:20:28.000 --> 01:20:32.000] 对Sentry就是它会不是有个log exception吗
[01:20:32.000 --> 01:20:34.000] 就是你的exception
[01:20:34.000 --> 01:20:35.000] 如果出来的话
[01:20:35.000 --> 01:20:36.000] 它会往上冒
[01:20:36.000 --> 01:20:37.000] 但是它会节制一下
[01:20:37.000 --> 01:20:39.000] 把这个exception
[01:20:39.000 --> 01:20:41.000] 那个stock的local作用
[01:20:41.000 --> 01:20:43.000] 那个变量给打出来
[01:20:43.000 --> 01:20:44.000] 然后打完之后
[01:20:44.000 --> 01:20:46.000] 它再继续往上抛
[01:20:46.000 --> 01:20:48.000] 对我是不太建议用Sentry来打log的
[01:20:48.000 --> 01:20:52.000] 因为那个东西确实是性能不太好
[01:20:52.000 --> 01:20:55.000] 而且我觉得有点不适合Sentry的场景
[01:20:55.000 --> 01:20:56.000] 因为它打log
[01:20:56.000 --> 01:20:59.000] 其实你想的话也可以强行打上战信息
[01:20:59.000 --> 01:21:01.000] 对但是一般打log的话
[01:21:01.000 --> 01:21:03.000] 往往就会打很多log
[01:21:03.000 --> 01:21:04.000] 对对
[01:21:04.000 --> 01:21:05.000] 其实打log的话
[01:21:05.000 --> 01:21:09.000] 各公司基本上都有自己的一套定制的方案吧
[01:21:09.000 --> 01:21:13.000] 说起来这个Sentry其实帮了我也非常非常多的忙
[01:21:13.000 --> 01:21:14.000] 就是它
[01:21:14.000 --> 01:21:17.000] 你如果用那个web框架的话
[01:21:17.000 --> 01:21:18.000] Sentry如果补扣到了一场
[01:21:18.000 --> 01:21:22.000] 它会把这个请求涉及到的那些查DB的那些语句
[01:21:22.000 --> 01:21:23.000] 给你打出来
[01:21:23.000 --> 01:21:24.000] 特别有用
[01:21:24.000 --> 01:21:25.000] 然后它会帮你打
[01:21:25.000 --> 01:21:27.000] 会适配一些框架常见的
[01:21:27.000 --> 01:21:28.000] 对对对
[01:21:28.000 --> 01:21:31.000] 然后它会帮你打一些浏览器信息
[01:21:31.000 --> 01:21:33.000] UAR影响了多少用户
[01:21:33.000 --> 01:21:35.000] 调用战信息
[01:21:35.000 --> 01:21:37.000] 什么的非常有用
[01:21:37.000 --> 01:21:40.000] 我是建议生产环境的项目
[01:21:40.000 --> 01:21:43.000] 就是如果你没有接Sentry或Sentry类似的组件的话
[01:21:43.000 --> 01:21:45.000] 你都应该接一下
[01:21:45.000 --> 01:21:46.000] 对你不需要额外配置
[01:21:46.000 --> 01:21:47.000] 你就接一下就好
[01:21:47.000 --> 01:21:51.000] 你们可以试一下那个Sentry.io可以免费用
[01:21:51.000 --> 01:21:52.000] 对我们Sentry
[01:21:52.000 --> 01:21:53.000] 其实我们也在用
[01:21:53.000 --> 01:21:55.000] 但是的话可能就是说Sentry性能并不好
[01:21:55.000 --> 01:21:57.000] 我们可能更多选择
[01:21:57.000 --> 01:21:59.000] 也就是会自研一些东西
[01:22:00.000 --> 01:22:02.000] 它相当于是一个hook是吧
[01:22:02.000 --> 01:22:04.000] 对Sentry的那个client
[01:22:04.000 --> 01:22:06.000] 它主要就是用了那个exception hook
[01:22:06.000 --> 01:22:07.000] 对
[01:22:07.000 --> 01:22:08.000] 我用过
[01:22:08.000 --> 01:22:10.000] 你只要接入之后它就会
[01:22:10.000 --> 01:22:12.000] 你自己没有catch exception的话
[01:22:12.000 --> 01:22:14.000] 它就会来帮你catch
[01:22:14.000 --> 01:22:19.000] 对然后它把这个exception和战信息一起发到自己的server端
[01:22:19.000 --> 01:22:21.000] 那个原理我大概知道
[01:22:21.000 --> 01:22:22.000] 但是有
[01:22:22.000 --> 01:22:25.000] 但是我们其实之前那部维护了一个嘛
[01:22:25.000 --> 01:22:27.000] 但是大家用的人太多了
[01:22:27.000 --> 01:22:31.000] 就很多项目疯狂的向Sentry发消息
[01:22:31.000 --> 01:22:32.000] 会有这个问题
[01:22:32.000 --> 01:22:35.000] 就是多了之后Sentry本身的性能就会很差
[01:22:35.000 --> 01:22:39.000] 然后那个项目他们可能已经不维护了或者什么
[01:22:39.000 --> 01:22:41.000] 但是他们不管他们也不下线
[01:22:41.000 --> 01:22:44.000] 就导致很多就疯狂的往Sentry上面发
[01:22:44.000 --> 01:22:46.000] 这个需要剪掉吗
[01:22:46.000 --> 01:22:49.000] 好像泄露了什么行业机密
[01:22:49.000 --> 01:22:52.000] 这个又不是什么机密
[01:22:52.000 --> 01:22:53.000] 还好吧
[01:22:53.000 --> 01:22:54.000] 内部的内部
[01:22:54.000 --> 01:22:56.000] Sentry还有一个问题吧
[01:22:56.000 --> 01:22:58.000] 就是其实你想接的话
[01:22:58.000 --> 01:23:00.000] 我建议是要定期维护的
[01:23:00.000 --> 01:23:02.000] 不然你那里面堆的异常会越来越多
[01:23:02.000 --> 01:23:05.000] 特别是你做这种大型系统
[01:23:05.000 --> 01:23:08.000] Connection Error Timeout可能是无法避免的
[01:23:08.000 --> 01:23:09.000] 对
[01:23:09.000 --> 01:23:11.000] 然后这些会越积越多
[01:23:11.000 --> 01:23:14.000] 然后你都看到最后你可能看不下去了
[01:23:14.000 --> 01:23:16.000] 所以还是要定期维护的
[01:23:16.000 --> 01:23:17.000] 对
[01:23:17.000 --> 01:23:18.000] 行好好
[01:23:18.000 --> 01:23:21.000] 我们先不要把环节变成Sentry吐舌大会
[01:23:21.000 --> 01:23:24.000] 然后我们刚才都可以改天来做一些
[01:23:24.000 --> 01:23:28.000] 就常见的这些各种系统的一些基础组件的吐槽
[01:23:28.000 --> 01:23:29.000] 然后来
[01:23:29.000 --> 01:23:32.000] Mac9M你继续
[01:23:32.000 --> 01:23:33.000] 你说到Log
[01:23:33.000 --> 01:23:36.000] 对你说到Log
[01:23:36.000 --> 01:23:38.000] 我好像就
[01:23:38.000 --> 01:23:39.000] 我暂时先说这些吧
[01:23:39.000 --> 01:23:40.000] 你们你们可以再
[01:23:40.000 --> 01:23:42.000] 我补充一个吧
[01:23:42.000 --> 01:23:43.000] 就是PDB
[01:23:43.000 --> 01:23:45.000] 对就各种Debugger
[01:23:45.000 --> 01:23:46.000] 反正你找一个吧
[01:23:46.000 --> 01:23:47.000] 对
[01:23:47.000 --> 01:23:50.000] 就是这个我的一般就是什么场景会用呢
[01:23:50.000 --> 01:23:54.000] 就是我的Log没有足够信息
[01:23:54.000 --> 01:23:56.000] 然后我去追的时候
[01:23:56.000 --> 01:23:58.000] 我基本上可以已经定位到
[01:23:58.000 --> 01:23:59.000] 不是我的问题
[01:23:59.000 --> 01:24:03.000] 是我依赖的某些某些库的问题
[01:24:03.000 --> 01:24:06.000] 对这个时候其实
[01:24:06.000 --> 01:24:10.000] 再去比如说打Log或者是
[01:24:10.000 --> 01:24:11.000] 加些Print
[01:24:11.000 --> 01:24:12.000] 其实不是不可以
[01:24:12.000 --> 01:24:15.000] 但是你就相当于是你要改你依赖的代码
[01:24:15.000 --> 01:24:16.000] Falk一份也好
[01:24:16.000 --> 01:24:17.000] 或者说自己先把它搞出来
[01:24:17.000 --> 01:24:19.000] 然后再去修改
[01:24:19.000 --> 01:24:23.000] 或者直接改那个Site Packages里面的代码
[01:24:23.000 --> 01:24:24.000] 对对
[01:24:24.000 --> 01:24:26.000] 所以说很多情况下
[01:24:26.000 --> 01:24:27.000] 我会选择就是我能复现
[01:24:27.000 --> 01:24:29.000] 那我就直接追进去就好
[01:24:29.000 --> 01:24:32.000] 看一下到底有什么问题
[01:24:32.000 --> 01:24:33.000] 对你大概知道问题在哪的话
[01:24:33.000 --> 01:24:35.000] 用PDB应该是最方便
[01:24:35.000 --> 01:24:38.000] 那个云峰的博客上面有一篇
[01:24:38.000 --> 01:24:42.000] 他就讨论了是用PDB还是用Log
[01:24:42.000 --> 01:24:44.000] 那篇博客的观点好像就是
[01:24:44.000 --> 01:24:45.000] 如果你用Log的话
[01:24:45.000 --> 01:24:46.000] 你的思维是连贯的
[01:24:46.000 --> 01:24:48.000] 你可以看一下就是每一步都在干什么
[01:24:48.000 --> 01:24:51.000] 但是用PDB你可能中途要抄一些命令
[01:24:51.000 --> 01:24:53.000] 你可能要打断自己的思维
[01:24:53.000 --> 01:24:56.000] 所以他是他比较倾向于用Log
[01:24:56.000 --> 01:24:59.000] 但是关键是你对于第三方案的很多东西的话
[01:24:59.000 --> 01:25:02.000] 你要去感知它内部的状态的话
[01:25:02.000 --> 01:25:05.000] 你很多时候你要单纯的Log来说是不太够的
[01:25:05.000 --> 01:25:08.000] 因为你毕竟要显示的侵入性的事物
[01:25:08.000 --> 01:25:10.000] 我觉得这是不太OK的
[01:25:10.000 --> 01:25:15.000] 所以意思是要就是发现第三方库有问题是吗
[01:25:15.000 --> 01:25:17.000] 对就是经常会发现
[01:25:17.000 --> 01:25:19.000] 你觉得你的代码是没有问题的
[01:25:19.000 --> 01:25:21.000] 你会怀疑第三方库
[01:25:21.000 --> 01:25:23.000] 那你就在你自己的代码的入口这
[01:25:23.000 --> 01:25:25.000] 就依赖的那个地方的入口
[01:25:25.000 --> 01:25:27.000] 然后用PDB一路追进去
[01:25:27.000 --> 01:25:29.000] 来确认是不是真的有问题就好
[01:25:29.000 --> 01:25:32.000] 但是我这么搞过几次
[01:25:32.000 --> 01:25:34.000] 我基本上跳进去我就晕了
[01:25:34.000 --> 01:25:38.000] 你要配合着对方的源码来跳
[01:25:38.000 --> 01:25:40.000] 对确实是还好
[01:25:40.000 --> 01:25:45.000] 那为什么你不能在你调用他的函数
[01:25:45.000 --> 01:25:48.000] 或者他提供的接口那里去加个Log
[01:25:48.000 --> 01:25:50.000] 然后来判断他的输出
[01:25:50.000 --> 01:25:52.000] 是可以但是会遇到这么一个情况
[01:25:52.000 --> 01:25:54.000] 就是第三方比如说这个入口
[01:25:54.000 --> 01:25:56.000] 他内部会各种跳
[01:25:56.000 --> 01:25:59.000] 对然后其实你一开始比较难确认
[01:25:59.000 --> 01:26:01.000] 说我应该在哪加具体的Log
[01:26:01.000 --> 01:26:04.000] 就比如说对我调用了这个库的A接口
[01:26:04.000 --> 01:26:06.000] 但是这个A接口本身又掉了
[01:26:06.000 --> 01:26:10.000] 他内部的CDEF这种不断的链式掉下去
[01:26:10.000 --> 01:26:13.000] 对OK所以OK
[01:26:13.000 --> 01:26:15.000] 所以你是已经确认
[01:26:15.000 --> 01:26:17.000] 他是在内部发生的问题
[01:26:17.000 --> 01:26:20.000] 就是或者说想要确认是不是库的问题
[01:26:20.000 --> 01:26:24.000] 你就要追下去看一下
[01:26:24.000 --> 01:26:27.000] 然后的话像我这边的话
[01:26:27.000 --> 01:26:32.000] 我推荐的一个东西叫做PRZset
[01:26:32.000 --> 01:26:34.000] 就是那个这个库的话
[01:26:34.000 --> 01:26:37.000] 可能你们线上很多应该是Andorment
[01:26:37.000 --> 01:26:39.000] 或者说Syntax还有JM都应该是用过
[01:26:39.000 --> 01:26:42.000] 发群里就是说是这个库的话
[01:26:42.000 --> 01:26:43.000] 这个地方有个好处
[01:26:43.000 --> 01:26:46.000] 就是说是你可以Attach进一个
[01:26:46.000 --> 01:26:49.000] 就是说是Attach进一个进程
[01:26:49.000 --> 01:26:51.000] 就是一个Python的进程
[01:26:51.000 --> 01:26:53.000] 然后的话你可以去就直接的
[01:26:53.000 --> 01:26:55.000] 他是会给你提供一个Repel
[01:26:55.000 --> 01:26:58.000] 在一个对应的进程里面提供一个Repel
[01:26:58.000 --> 01:27:00.000] 然后你可以去看那个
[01:27:00.000 --> 01:27:04.000] 对然后你可以去看对应进程里面的状态
[01:27:04.000 --> 01:27:07.000] 像我之前调试像内存泄漏
[01:27:07.000 --> 01:27:09.000] 还有调试其他的一些问题的话
[01:27:09.000 --> 01:27:13.000] 像PRZset的话就是一个非常好用的东西
[01:27:13.000 --> 01:27:15.000] 这个就是我刚刚说的
[01:27:15.000 --> 01:27:19.000] 我想要的就是LikeJM提到的那个东西
[01:27:19.000 --> 01:27:21.000] 就是可以Attach进一个进程
[01:27:21.000 --> 01:27:22.000] 当他发生了问题的时候
[01:27:22.000 --> 01:27:24.000] 我再看他哪些编辑
[01:27:24.000 --> 01:27:25.000] 对这个地方就是可以的
[01:27:25.000 --> 01:27:28.000] 你就是Attach进一个具体的进程
[01:27:28.000 --> 01:27:29.000] 你该执行的事情
[01:27:29.000 --> 01:27:32.000] 然后你的Repel是在后面是不影响
[01:27:33.000 --> 01:27:36.000] 对然后应该也可以
[01:27:36.000 --> 01:27:39.000] 就是看我要我的目标进程的
[01:27:39.000 --> 01:27:40.000] 当时的GC的情况吧
[01:27:40.000 --> 01:27:41.000] 对可以是没有
[01:27:41.000 --> 01:27:45.000] 就是你是已经是Attach进了一个
[01:27:45.000 --> 01:27:47.000] 就是你正在运行的进程
[01:27:47.000 --> 01:27:49.000] 然后他会给提供一个Repel或者一个Gree
[01:27:49.000 --> 01:27:51.000] 然后你自己该干什么干什么
[01:27:52.000 --> 01:27:54.000] 但是这个是两个进程吗
[01:27:54.000 --> 01:27:56.000] 就是我的终端的进程跟目标进程是
[01:27:56.000 --> 01:27:58.000] 具体的原因我没有看到实现的话
[01:27:58.000 --> 01:28:01.000] 但是我看到好像是应该是用了PDB的一个端口
[01:28:01.000 --> 01:28:05.000] 然后的话PDB然后追那个GDB
[01:28:05.000 --> 01:28:07.000] GDB追他的就是说是额外的信息
[01:28:07.000 --> 01:28:08.000] 然后的话就是说是
[01:28:08.000 --> 01:28:12.000] 他有他里面有个组件叫做PyresetCell
[01:28:12.000 --> 01:28:15.000] 然后话就是说是你Attach进一个进程之后
[01:28:15.000 --> 01:28:17.000] 他会给提供一个Repel
[01:28:17.000 --> 01:28:20.000] 这个时候你就直接可以用GC或者是TraceMailLock
[01:28:20.000 --> 01:28:23.000] 或者是其他的库来追踪里面的具体的状态
[01:28:24.000 --> 01:28:26.000] 这个Repel是什么
[01:28:26.000 --> 01:28:28.000] 就是Iepel
[01:28:28.000 --> 01:28:29.000] 我知道我知道我知道
[01:28:29.000 --> 01:28:30.000] 对Repel
[01:28:30.000 --> 01:28:32.000] 对然后的话这个地方
[01:28:32.000 --> 01:28:35.000] 我觉得这个在线上调试一些疑难问题的
[01:28:35.000 --> 01:28:36.000] 还是挺挺有用的
[01:28:36.000 --> 01:28:38.000] 这个有没有什么限制
[01:28:38.000 --> 01:28:41.000] 比如线上可不可以借用什么系统交易
[01:28:41.000 --> 01:28:43.000] 让你不能Attach进去
[01:28:43.000 --> 01:28:45.000] 是需要是有限制的
[01:28:45.000 --> 01:28:51.000] 然后你需要在线上SU2去改一个System Code的设置
[01:28:51.000 --> 01:28:55.000] 因为毕竟你GDB的东西
[01:28:55.000 --> 01:28:59.000] 你要Attach进一个进程还是一个高危操作
[01:28:59.000 --> 01:29:01.000] 但是这个高危操作带来的收益
[01:29:01.000 --> 01:29:03.000] 有些时候还是挺大的
[01:29:03.000 --> 01:29:08.000] 我发现确实有很多这种第三方调试工具
[01:29:08.000 --> 01:29:10.000] 对但是Python官方就没有了
[01:29:12.000 --> 01:29:14.000] 对感觉他们只要对吧
[01:29:14.000 --> 01:29:17.000] 选一个然后来击成一下
[01:29:17.000 --> 01:29:19.000] 对然后的话
[01:29:19.000 --> 01:29:21.000] 对于调试技巧和方法论的话
[01:29:21.000 --> 01:29:24.000] 你们有什么有什么推荐的没有
[01:29:24.000 --> 01:29:26.000] 我觉得一个
[01:29:26.000 --> 01:29:28.000] 我觉得有点搞笑
[01:29:28.000 --> 01:29:30.000] 但是但是就我想说
[01:29:30.000 --> 01:29:34.000] 就是很多时候一个bug调不出来
[01:29:34.000 --> 01:29:36.000] 然后就休息一下
[01:29:36.000 --> 01:29:38.000] 然后再读一遍代码
[01:29:38.000 --> 01:29:40.000] 出去抽
[01:29:40.000 --> 01:29:42.000] 都睡觉真的很有用
[01:29:42.000 --> 01:29:44.000] 出去抽支烟再来对吧
[01:29:44.000 --> 01:29:46.000] 好好看一遍代码
[01:29:46.000 --> 01:29:49.000] 我觉得这个是个很好的建议
[01:29:49.000 --> 01:29:50.000] 还有吗
[01:29:50.000 --> 01:29:53.000] 我觉得90%的代码应该都是很傻的
[01:29:53.000 --> 01:29:57.000] 然后只有10%是那种真的需要就花很大力气去调
[01:29:57.000 --> 01:29:58.000] 我觉得是
[01:29:58.000 --> 01:30:00.000] 小黄鸭调试法
[01:30:00.000 --> 01:30:02.000] 小黄鸭调试法还行
[01:30:03.000 --> 01:30:05.000] 你们知道小黄鸭调试法吗
[01:30:06.000 --> 01:30:07.000] 知道啊
[01:30:07.000 --> 01:30:08.000] 可以我就讲一下吧
[01:30:08.000 --> 01:30:09.000] 讲一下吧
[01:30:09.000 --> 01:30:11.000] 我觉得小黄鸭调试法还行
[01:30:12.000 --> 01:30:13.000] 我说你们讲一下吧
[01:30:13.000 --> 01:30:15.000] 万一听众有来来来
[01:30:15.000 --> 01:30:17.000] 谁来讲一下小黄鸭调试法吧
[01:30:17.000 --> 01:30:22.000] 其实其实那个就是说你拿一个那个小黄鸭
[01:30:22.000 --> 01:30:27.000] 就是有些人洗澡的时候会用的这种小鸭子吗
[01:30:27.000 --> 01:30:29.000] 然后你把它放到你的面前
[01:30:29.000 --> 01:30:32.000] 跟他说一下你这段代码的逻辑是怎么样
[01:30:32.000 --> 01:30:34.000] 然后你就把它当成一个听众
[01:30:34.000 --> 01:30:36.000] 然后你讲一遍
[01:30:36.000 --> 01:30:38.000] 然后有时候就发现你自己的问题在哪里
[01:30:38.000 --> 01:30:39.000] 对
[01:30:39.000 --> 01:30:41.000] 我觉得是是很有意义
[01:30:41.000 --> 01:30:45.000] 对我也我也我也觉得就是说是是一个很棒的方法
[01:30:46.000 --> 01:30:47.000] 来
[01:30:47.000 --> 01:30:48.000] 然后的话
[01:30:48.000 --> 01:30:53.000] 还有其他人要来聊聊聊关于调试的一些技巧和方法论之类的东西
[01:30:53.000 --> 01:30:55.000] 我觉得有一个方法论吧
[01:30:55.000 --> 01:30:56.000] 对有点类似于小黄鸭
[01:30:56.000 --> 01:30:59.000] 就是我不知道大家有没有遇到那种情况
[01:30:59.000 --> 01:31:00.000] 就是
[01:31:01.000 --> 01:31:04.000] 发现这个地方为什么总总是会出错
[01:31:04.000 --> 01:31:06.000] 然后怎么想都想不明白
[01:31:06.000 --> 01:31:08.000] 就觉得应该没有问题
[01:31:08.000 --> 01:31:10.000] 对就我靠为什么是这个地方出错了
[01:31:10.000 --> 01:31:12.000] 对这个地方不应该有问题啊
[01:31:13.000 --> 01:31:14.000] 对然后
[01:31:14.000 --> 01:31:17.000] 但是这个事情其实会很影响你本身的情绪
[01:31:17.000 --> 01:31:19.000] 就是你觉得这个地方完全没有问题
[01:31:19.000 --> 01:31:21.000] 而且怎么看都不会有问题
[01:31:21.000 --> 01:31:23.000] 但是就是在这个地方有问题
[01:31:23.000 --> 01:31:25.000] 又搞了很久搞不出来
[01:31:25.000 --> 01:31:27.000] 对会很影响情绪
[01:31:27.000 --> 01:31:30.000] 但是其实我会觉得这个是一个
[01:31:30.000 --> 01:31:31.000] 好的现象啊
[01:31:31.000 --> 01:31:32.000] 就是相比于什么呢
[01:31:32.000 --> 01:31:34.000] 相比于你根本复现不出来
[01:31:35.000 --> 01:31:36.000] 呵呵
[01:31:36.000 --> 01:31:37.000] 啊对就遇到那种
[01:31:37.000 --> 01:31:39.000] 那是因为你有更糟糕的经历
[01:31:39.000 --> 01:31:40.000] 对对因为因为
[01:31:40.000 --> 01:31:42.000] 过一段时间就在线上出现一次
[01:31:42.000 --> 01:31:43.000] 过一段时间就出现一次
[01:31:43.000 --> 01:31:45.000] 你根本不知道他为什么会出现
[01:31:45.000 --> 01:31:47.000] 对就是这个地方总出错
[01:31:47.000 --> 01:31:50.000] 而且其实会接着爆发第二个
[01:31:51.000 --> 01:31:53.000] 就是如果不从焦躁方面考虑的话
[01:31:53.000 --> 01:31:55.000] 就是第二个有意义的思路
[01:31:55.000 --> 01:31:58.000] 就是其实这个地方就是不符合逻辑的
[01:31:58.000 --> 01:32:01.000] 你就去找这个地方所有相关的
[01:32:01.000 --> 01:32:03.000] 向上再去重新找
[01:32:03.000 --> 01:32:05.000] 一定会找到不符合逻辑的地方
[01:32:06.000 --> 01:32:07.000] 是的是的我很同意
[01:32:07.000 --> 01:32:08.000] 对
[01:32:08.000 --> 01:32:09.000] 嗯
[01:32:09.000 --> 01:32:12.000] 但很多时候就是你需要有一种
[01:32:12.000 --> 01:32:15.000] 平静的情绪去真的静下心
[01:32:15.000 --> 01:32:17.000] 看每一行你写的代码
[01:32:17.000 --> 01:32:19.000] 对就才能发现问题
[01:32:20.000 --> 01:32:21.000] 嗯
[01:32:21.000 --> 01:32:24.000] 对我觉得其实也是
[01:32:24.000 --> 01:32:26.000] 其实我觉得方法上一个东西的话
[01:32:26.000 --> 01:32:28.000] 其实我觉得就是说是
[01:32:28.000 --> 01:32:31.000] 我其实思想其实是一样的
[01:32:31.000 --> 01:32:33.000] 我觉得其实有一个东西就
[01:32:33.000 --> 01:32:35.000] 不要急躁
[01:32:35.000 --> 01:32:37.000] 然后的话就是说是慢慢来
[01:32:37.000 --> 01:32:38.000] 因为你急躁的话
[01:32:38.000 --> 01:32:40.000] 其实很多时候你会出现一个东西
[01:32:40.000 --> 01:32:43.000] 一个问题就是我要说的另外一个东西
[01:32:43.000 --> 01:32:45.000] 就是说是你一定要搞明确
[01:32:45.000 --> 01:32:47.000] 因为你在线上系统里面
[01:32:47.000 --> 01:32:49.000] 可能是它是有多个环节的对吧
[01:32:49.000 --> 01:32:50.000] 然后多个环节的话
[01:32:50.000 --> 01:32:51.000] 可能是有不同的表征
[01:32:51.000 --> 01:32:54.000] 每个环节可能一个链式的问题的话
[01:32:54.000 --> 01:32:56.000] 每一个环节可能都是有不同的表征对吧
[01:32:56.000 --> 01:32:58.000] 然后的话你一急躁
[01:32:58.000 --> 01:32:59.000] 你可能把
[01:32:59.000 --> 01:33:02.000] 把一个果当做一个因
[01:33:02.000 --> 01:33:04.000] 把一个因当做一个果因果高
[01:33:04.000 --> 01:33:06.000] 关系搞混了
[01:33:06.000 --> 01:33:09.000] 然后的话这就会完全的就是说是
[01:33:09.000 --> 01:33:11.000] 让你后续的排查的思路给
[01:33:11.000 --> 01:33:13.000] 就是说是呃迷惑了
[01:33:13.000 --> 01:33:15.000] 所以说我觉得的话就是说
[01:33:15.000 --> 01:33:19.000] 静下心来搞清楚你前面的一个因果关系
[01:33:19.000 --> 01:33:21.000] 就是说是什么是因什么是果
[01:33:21.000 --> 01:33:24.000] 哪一个线上是因哪个线上是果
[01:33:24.000 --> 01:33:27.000] 然后最后的话你可以形成一个因果关系链
[01:33:27.000 --> 01:33:29.000] 就是从前到后一套串起来
[01:33:29.000 --> 01:33:32.000] 你大概就知道有些东西该怎么样去解决或其他的
[01:33:32.000 --> 01:33:34.000] 对然后的话还有东西的话
[01:33:34.000 --> 01:33:36.000] 就是说你在查问题的时候
[01:33:36.000 --> 01:33:39.000] 你一定要找到足够的case
[01:33:39.000 --> 01:33:40.000] road case来
[01:33:40.000 --> 01:33:43.000] 就是足够的证据来证明你的推测
[01:33:43.000 --> 01:33:44.000] 而不是一个凭空推测
[01:33:46.000 --> 01:33:47.000] 嗯对吧
[01:33:47.000 --> 01:33:49.000] 这一点的话我相信大家应该都是有共识的
[01:33:49.000 --> 01:33:51.000] 就是说你再去你推测一个原因的时候
[01:33:51.000 --> 01:33:54.000] 你一定要找到足够的证据来证明
[01:33:54.000 --> 01:33:56.000] 然后最后的话其实我觉得像你排查
[01:33:56.000 --> 01:33:58.000] 对于一个团队而言的话
[01:33:58.000 --> 01:34:00.000] 你排查了很多东西
[01:34:00.000 --> 01:34:02.000] 你是可以用一个事故报告
[01:34:02.000 --> 01:34:04.000] 或者说是一个用一个排查记录
[01:34:04.000 --> 01:34:06.000] 把形成一个文档画了一个东西
[01:34:06.000 --> 01:34:07.000] 知识库的东西记录下来
[01:34:07.000 --> 01:34:10.000] 我不知道你们这边有没有这些东西
[01:34:10.000 --> 01:34:12.000] 这个应该我没有的
[01:34:12.000 --> 01:34:13.000] KDAHV是吗
[01:34:13.000 --> 01:34:16.000] 你们有看过那个
[01:34:16.000 --> 01:34:20.000] 过年的时候应该不是今年
[01:34:20.000 --> 01:34:22.000] 18年的时候GearLab当机那次
[01:34:22.000 --> 01:34:24.000] 他们的故障报告吗
[01:34:24.000 --> 01:34:26.000] 我没有看过
[01:34:26.000 --> 01:34:28.000] 我看过那个
[01:34:28.000 --> 01:34:30.000] 他们其实写的就已经比较规范了
[01:34:30.000 --> 01:34:33.000] 就是从一个就不单只是bug了
[01:34:33.000 --> 01:34:35.000] 就是从故障开始
[01:34:35.000 --> 01:34:38.000] 他们都在做什么时间线是什么
[01:34:38.000 --> 01:34:40.000] 然后最后怎么解决了
[01:34:40.000 --> 01:34:43.000] 然后最后的故障的核心原因是什么
[01:34:43.000 --> 01:34:46.000] 以及我们未来采取什么样的措施来避免
[01:34:46.000 --> 01:34:49.000] 这就是其实我们各个公司都应该有的
[01:34:49.000 --> 01:34:50.000] 那个事故复盘吧
[01:34:52.000 --> 01:34:54.000] 对其实我觉得这种东西的话
[01:34:54.000 --> 01:34:56.000] 如果是像听众朋友们
[01:34:56.000 --> 01:34:58.000] 如果自己有条件或者有意愿的话
[01:34:58.000 --> 01:35:02.000] 你平时在线上或者说是工作中查的
[01:35:02.000 --> 01:35:04.000] 这些问题其实可以形成一个文档化
[01:35:04.000 --> 01:35:06.000] 一个文档化的一个记录
[01:35:06.000 --> 01:35:07.000] 这样的话不管说是对于团队
[01:35:07.000 --> 01:35:09.000] 还是对于你个人发展
[01:35:09.000 --> 01:35:10.000] 都是非常有帮助
[01:35:12.000 --> 01:35:15.000] 我觉得可能未必需要复盘那么重的东西
[01:35:15.000 --> 01:35:17.000] 但至少你得去用某种方式记录
[01:35:17.000 --> 01:35:19.000] 对其实就是文档化的一个东西吧
[01:35:19.000 --> 01:35:21.000] 就是说是很多时候你可能说你写
[01:35:21.000 --> 01:35:22.000] 你只是一个很简单的东西
[01:35:22.000 --> 01:35:24.000] 其实你都可以把它写在一个
[01:35:24.000 --> 01:35:25.000] 作为一个文档化的一个东西
[01:35:25.000 --> 01:35:27.000] 这样对于然后
[01:35:27.000 --> 01:35:29.000] 然后难得有难得的写法
[01:35:29.000 --> 01:35:31.000] 简单的问题有简单的写法吧
[01:35:31.000 --> 01:35:33.000] 然后因问题而异吧对吧
[01:35:36.000 --> 01:35:37.000] OK那我们这个环节
[01:35:37.000 --> 01:35:38.000] 大家还有什么想说的吗
[01:35:38.000 --> 01:35:39.000] 如果没有的话
[01:35:39.000 --> 01:35:41.000] 那我们这个环节就先到此结束了
[01:35:41.000 --> 01:35:43.000] 我们已经聊了两个小时了
[01:35:43.000 --> 01:35:44.000] 没有没有其实还好
[01:35:44.000 --> 01:35:46.000] 一个一个多小时还是两个小时
[01:35:46.000 --> 01:35:47.000] 不到我们十点半开始吧
[01:35:49.000 --> 01:35:52.000] 我的录音是一小时四十三分钟了
[01:35:52.000 --> 01:35:54.000] 我的差不多也是
[01:35:54.000 --> 01:35:55.000] 好那我们你知道吗
[01:35:55.000 --> 01:35:56.000] 我跟别人保证说
[01:35:56.000 --> 01:35:58.000] 我们下期不超过一个半小时
[01:35:59.000 --> 01:36:00.000] 好那我们
[01:36:01.000 --> 01:36:03.000] 对那我们现在就开始
[01:36:03.000 --> 01:36:05.000] 对然后那我们现在来进入
[01:36:05.000 --> 01:36:06.000] 我们今天的最后一个环节
[01:36:06.000 --> 01:36:09.000] 也是我们以后我们每一期节目
[01:36:09.000 --> 01:36:11.000] 也就是上上上期我们说了
[01:36:11.000 --> 01:36:13.000] 我们每一期节目都会保留的一个环节吧
[01:36:13.000 --> 01:36:16.000] 那么就是有请我们的四
[01:36:16.000 --> 01:36:18.000] 算我啊算我四位嘉宾
[01:36:19.000 --> 01:36:21.000] 推荐一个库
[01:36:21.000 --> 01:36:22.000] 然后因为我本来我们想
[01:36:22.000 --> 01:36:24.000] 今天是推荐两个库
[01:36:24.000 --> 01:36:25.000] 一个你推荐的库
[01:36:25.000 --> 01:36:26.000] 一个和不推荐的库
[01:36:26.000 --> 01:36:27.000] 但是前面大家都已经黑
[01:36:27.000 --> 01:36:29.000] 把该黑的库都黑的差不多了
[01:36:29.000 --> 01:36:32.000] 那我们就今天还是只推荐一个
[01:36:32.000 --> 01:36:34.000] 你最好觉得最好用的库
[01:36:34.000 --> 01:36:36.000] 来吧推荐
[01:36:36.000 --> 01:36:39.000] 我先来吧就我推荐一下
[01:36:39.000 --> 01:36:42.000] 那个就是mark掉时间的
[01:36:42.000 --> 01:36:45.000] 那个python的库叫freezegang
[01:36:47.000 --> 01:36:49.000] freezegang应该就是
[01:36:49.000 --> 01:36:50.000] 你需要mark时间
[01:36:50.000 --> 01:36:51.000] 因为因为python
[01:36:51.000 --> 01:36:53.000] 如果你去直接mark
[01:36:53.000 --> 01:36:57.000] 那个那个他的time
[01:36:57.000 --> 01:36:58.000] 那个库的话
[01:36:58.000 --> 01:37:00.000] 好像会有点问题
[01:37:00.000 --> 01:37:01.000] 对吧我忘记
[01:37:01.000 --> 01:37:03.000] 我忘记具体是什么问题了
[01:37:03.000 --> 01:37:05.000] 就是但是如果你用freezegang的话
[01:37:05.000 --> 01:37:06.000] 就非常的简单
[01:37:06.000 --> 01:37:09.000] 你如果是代码里设计到时间的话
[01:37:09.000 --> 01:37:11.000] 我觉得这个库是你写
[01:37:11.000 --> 01:37:14.000] Unitest的时候必须必须要用
[01:37:14.000 --> 01:37:15.000] 对
[01:37:15.000 --> 01:37:17.000] 然后freez到任何一个时间
[01:37:17.000 --> 01:37:18.000] 特别方便
[01:37:18.000 --> 01:37:20.000] 对对对就就特别好用
[01:37:20.000 --> 01:37:22.000] 对然后
[01:37:22.000 --> 01:37:24.000] 我觉得我觉得那个库的推荐
[01:37:24.000 --> 01:37:25.000] 我们就不用展开讲
[01:37:25.000 --> 01:37:26.000] 对吧
[01:37:26.000 --> 01:37:27.000] 就可以
[01:37:27.000 --> 01:37:28.000] 然后那个文
[01:37:28.000 --> 01:37:29.000] 就是其他东西的话
[01:37:29.000 --> 01:37:32.000] 我推荐一个stackoverflow的问题吧
[01:37:32.000 --> 01:37:35.000] 就是叫那个hidden features of python
[01:37:35.000 --> 01:37:37.000] 就是这个问题
[01:37:37.000 --> 01:37:39.000] 他有那个1420多个vote
[01:37:39.000 --> 01:37:44.000] 然后他其实是一个类似于类似于wiki的那种形式
[01:37:44.000 --> 01:37:48.000] 他就是会把很多的这种hidden features列出来
[01:37:48.000 --> 01:37:51.000] 然后就是一些可能你平时没有注意到
[01:37:51.000 --> 01:37:56.000] 但是但是又又会碰到一些问题
[01:37:56.000 --> 01:37:57.000] 对
[01:37:57.000 --> 01:37:58.000] 嗯
[01:37:58.000 --> 01:38:00.000] 反正这个链接到时候都会贴出来
[01:38:00.000 --> 01:38:02.000] OK
[01:38:02.000 --> 01:38:03.000] OK下一位
[01:38:03.000 --> 01:38:05.000] 来我们的Adam和新涛
[01:38:05.000 --> 01:38:07.000] 你们俩是先打一架呢
[01:38:07.000 --> 01:38:08.000] 还是直接谁来
[01:38:08.000 --> 01:38:10.000] 我说了新涛来吧
[01:38:10.000 --> 01:38:13.000] 我推荐一个我自己写的库吧
[01:38:13.000 --> 01:38:14.000] 就是
[01:38:14.000 --> 01:38:15.000] 哈哈哈
[01:38:15.000 --> 01:38:17.000] nice我们终于有这种库了
[01:38:17.000 --> 01:38:18.000] 我终于有这种库了
[01:38:18.000 --> 01:38:21.000] 他的名字叫pintop
[01:38:21.000 --> 01:38:22.000] 这个分两部分
[01:38:22.000 --> 01:38:24.000] 一个是pin一个是top
[01:38:24.000 --> 01:38:27.000] top是因为他展示的形式是一个toplike
[01:38:27.000 --> 01:38:31.000] 就是他会把就按照top那种形式给展示出来
[01:38:31.000 --> 01:38:35.000] 他是一个同时pin多个server的工具
[01:38:35.000 --> 01:38:36.000] OK
[01:38:36.000 --> 01:38:38.000] 我一开始写这个库的用处呢
[01:38:38.000 --> 01:38:40.000] 就是我有十几个服务器
[01:38:40.000 --> 01:38:42.000] 我要测试一个速度最快的
[01:38:42.000 --> 01:38:45.000] 但是我发现没有一个特别好的工具
[01:38:45.000 --> 01:38:47.000] 能比较直观的看到就是我发pin包
[01:38:47.000 --> 01:38:50.000] 看哪一个服务器的回复速度最快
[01:38:50.000 --> 01:38:51.000] 啊
[01:38:51.000 --> 01:38:52.000] 他的稳定性怎么样
[01:38:52.000 --> 01:38:55.000] 就是是不是回复速度波动很大
[01:38:55.000 --> 01:38:57.000] 然后我就自己写了一个
[01:38:57.000 --> 01:39:01.000] 用终端的top界面来展示出来一个状态的这么一个东西
[01:39:01.000 --> 01:39:03.000] 大家可以看一下叫pintop
[01:39:03.000 --> 01:39:05.000] 我在看这个库确实确实不错
[01:39:05.000 --> 01:39:06.000] 我觉得对
[01:39:06.000 --> 01:39:07.000] OK好
[01:39:07.000 --> 01:39:08.000] 我们终于来
[01:39:08.000 --> 01:39:10.000] 来我们先给那个新淘鼓个掌吧
[01:39:10.000 --> 01:39:12.000] 我们终于有个自己的库可以推荐
[01:39:12.000 --> 01:39:13.000] 哦
[01:39:13.000 --> 01:39:14.000] 哈哈哈
[01:39:14.000 --> 01:39:15.000] 好好
[01:39:15.000 --> 01:39:16.000] 来来来
[01:39:16.000 --> 01:39:17.000] Adam老师
[01:39:17.000 --> 01:39:21.000] 我这边推了一个算是一个repo吧
[01:39:21.000 --> 01:39:23.000] 我觉得不算是一个库了
[01:39:23.000 --> 01:39:24.000] 就是
[01:39:24.000 --> 01:39:26.000] 很多人都应该知道就awesome python
[01:39:26.000 --> 01:39:27.000] 对
[01:39:27.000 --> 01:39:30.000] 我现在说我会发现很多这种
[01:39:30.000 --> 01:39:31.000] 比如说
[01:39:31.000 --> 01:39:33.000] 使用python1到3年的同学
[01:39:33.000 --> 01:39:36.000] 可能还是有很多人不太清楚这个库
[01:39:36.000 --> 01:39:37.000] 对
[01:39:37.000 --> 01:39:38.000] 所以在做一些技术显示的时候
[01:39:38.000 --> 01:39:40.000] 对他们来说就很困难
[01:39:40.000 --> 01:39:41.000] 就是首先不知道去哪找库
[01:39:41.000 --> 01:39:44.000] 然后不知道对哪些库比较好
[01:39:44.000 --> 01:39:45.000] 对
[01:39:45.000 --> 01:39:46.000] 然后
[01:39:46.000 --> 01:39:47.000] 对
[01:39:47.000 --> 01:39:49.000] 对你可以解释一下awesome python市场
[01:39:49.000 --> 01:39:51.000] 我觉得有可能有听众可能不是很清楚
[01:39:51.000 --> 01:39:54.000] awesome python就是一个github上的repo
[01:39:54.000 --> 01:39:55.000] 对
[01:39:55.000 --> 01:39:56.000] 就是一个仓库
[01:39:56.000 --> 01:39:58.000] 然后这个仓库其实没有什么代码
[01:39:58.000 --> 01:40:00.000] 它主要的就是做一个收录
[01:40:00.000 --> 01:40:03.000] 收录了python上一些很不错的框架
[01:40:03.000 --> 01:40:05.000] 库软件工具
[01:40:05.000 --> 01:40:06.000] 或者是可能
[01:40:06.000 --> 01:40:07.000] 它不是
[01:40:07.000 --> 01:40:08.000] 库
[01:40:08.000 --> 01:40:10.000] 但是它是用python写的一些cli
[01:40:10.000 --> 01:40:11.000] 对
[01:40:11.000 --> 01:40:12.000] 嗯
[01:40:12.000 --> 01:40:13.000] 是的
[01:40:13.000 --> 01:40:16.000] 然后具体推荐库的话
[01:40:16.000 --> 01:40:19.000] 我这期可能想推荐一个库叫click
[01:40:19.000 --> 01:40:21.000] click
[01:40:21.000 --> 01:40:22.000] 对
[01:40:22.000 --> 01:40:26.000] 就是有的时候我会写一些就是自己工作中
[01:40:26.000 --> 01:40:29.000] 或者是针对自己的工作旅游定义的一些小工具
[01:40:29.000 --> 01:40:30.000] 对
[01:40:30.000 --> 01:40:34.000] 然后这个时候可能就会用click会方便一些
[01:40:34.000 --> 01:40:35.000] 就是他写cli
[01:40:35.000 --> 01:40:38.000] 只要包一个装饰器就可以了
[01:40:38.000 --> 01:40:39.000] ok
[01:40:39.000 --> 01:40:41.000] 这种东西我见过类似的
[01:40:41.000 --> 01:40:42.000] 对
[01:40:42.000 --> 01:40:43.000] 然后
[01:40:43.000 --> 01:40:44.000] click真的很好用
[01:40:44.000 --> 01:40:46.000] pingtop也是用的那个click
[01:40:46.000 --> 01:40:47.000] 哦
[01:40:47.000 --> 01:40:57.000] 然后文章的话也是一个在github上的repo
[01:40:57.000 --> 01:40:58.000] 对
[01:40:58.000 --> 01:41:02.000] 配合这些主题有一个repo叫wtfpython
[01:41:02.000 --> 01:41:03.000] 啊
[01:41:03.000 --> 01:41:05.000] what the fuck
[01:41:05.000 --> 01:41:06.000] 对
[01:41:06.000 --> 01:41:11.000] 就是这个这个推荐的原因主要是你会发现有很多这种python的这种不能说是隐藏特性
[01:41:11.000 --> 01:41:14.000] 而是其实你在生产环境基本上不会使用
[01:41:14.000 --> 01:41:19.000] 但是确实很有趣的一些让你很惊讶的一些现象
[01:41:19.000 --> 01:41:20.000] 对
[01:41:19.000 --> 01:41:22.000] 然后也会配合着解释一些原理
[01:41:22.000 --> 01:41:25.000] 说起来我今天看了一个我不知道你们知不知道
[01:41:25.000 --> 01:41:31.000] 就python你可以写a逗号b逗号c等于一个字符串
[01:41:31.000 --> 01:41:35.000] 然后只要那个字符串是比如说字符串也是abc
[01:41:35.000 --> 01:41:39.000] 然后他就会就是给abc三个分别复制成abc
[01:41:39.000 --> 01:41:42.000] 我还有这种这种
[01:41:42.000 --> 01:41:45.000] 就很扯淡
[01:41:45.000 --> 01:41:55.000] 我觉得python有些时候很多的像9m你之前我记得我们之前聊过一个东西
[01:41:55.000 --> 01:41:58.000] 就是说python很多东西是太隐世了对吧
[01:41:58.000 --> 01:41:59.000] 是
[01:41:59.000 --> 01:42:01.000] 对隐世的东西
[01:42:01.000 --> 01:42:02.000] 太复杂了
[01:42:02.000 --> 01:42:04.000] 然后的话那Adam你的推荐结束了吗
[01:42:04.000 --> 01:42:06.000] 推荐结束了
[01:42:06.000 --> 01:42:08.000] 然后的话我今天
[01:42:08.000 --> 01:42:12.000] 然后我的话我今天就推荐的话givent吧
[01:42:12.000 --> 01:42:13.000] givent
[01:42:13.000 --> 01:42:17.000] 我givent和配套的greenit吧
[01:42:17.000 --> 01:42:20.000] 因为givent可能很多听众朋友知道
[01:42:20.000 --> 01:42:21.000] 或者说也不知道
[01:42:21.000 --> 01:42:26.000] 但是大家但是肯定都听到一个名词叫做cruiting协程
[01:42:26.000 --> 01:42:27.000] 对吧
[01:42:26.000 --> 01:42:31.000] 但是就目前而言而言就而讲就而言来讲
[01:42:31.000 --> 01:42:34.000] 基于greenit所演示的两套方案
[01:42:34.000 --> 01:42:35.000] 一套是eventnet
[01:42:35.000 --> 01:42:37.000] 一套是givent
[01:42:37.000 --> 01:42:40.000] 然后这两套方案是目前python
[01:42:40.000 --> 01:42:42.000] 真正意义上可用
[01:42:42.000 --> 01:42:46.000] 而且被大规模使用的一套协议
[01:42:46.000 --> 01:42:47.000] 一整套协商方案
[01:42:47.000 --> 01:42:50.000] 不管是givent还是eventnet都算是师出同源吧
[01:42:50.000 --> 01:42:53.000] 虽然他们各自的具体很多
[01:42:53.000 --> 01:42:54.000] 还有很多细节不同
[01:42:54.000 --> 01:42:57.000] 但是他们都是基于greenit来做
[01:42:57.000 --> 01:42:58.000] 然后的话
[01:42:58.000 --> 01:43:02.000] 我相信像大家经常写web服务的肯定像
[01:43:02.000 --> 01:43:04.000] 比如说温老师9m
[01:43:04.000 --> 01:43:06.000] 还有新淘可能都都知道
[01:43:06.000 --> 01:43:09.000] givent实际上虽然他有很多坑
[01:43:09.000 --> 01:43:12.000] 但是也是他现在算是现在是最好的
[01:43:12.000 --> 01:43:13.000] 也是唯一的选择
[01:43:16.000 --> 01:43:18.000] 我做个小退步
[01:43:18.000 --> 01:43:20.000] 就是如果你想用这一问题
[01:43:20.000 --> 01:43:22.000] 你一定要一进去就先patch
[01:43:22.000 --> 01:43:24.000] 在你自己的所有代码之前先patch
[01:43:24.000 --> 01:43:25.000] 不然你会
[01:43:25.000 --> 01:43:26.000] 相信我这样做
[01:43:26.000 --> 01:43:28.000] 其实也看情况而论吧
[01:43:28.000 --> 01:43:31.000] 相信我前段时间才吃了一个这样的屎
[01:43:31.000 --> 01:43:32.000] 然后我觉得这个东西
[01:43:32.000 --> 01:43:34.000] 一进去patch就可能有些事
[01:43:34.000 --> 01:43:36.000] 还是要具体情况具体而论
[01:43:39.000 --> 01:43:40.000] 好好
[01:43:41.000 --> 01:43:43.000] 我能不能补充一个推荐
[01:43:43.000 --> 01:43:47.000] 就是刚刚说调试的时候
[01:43:47.000 --> 01:43:50.000] 我想起来最近特别火的一个库
[01:43:50.000 --> 01:43:51.000] 叫pysnoper
[01:43:51.000 --> 01:43:53.000] 打印执行过程的那个是吧
[01:43:57.000 --> 01:44:00.000] 对他的description叫
[01:44:00.000 --> 01:44:04.000] never use print for debugging again
[01:44:04.000 --> 01:44:08.000] 就是说你用一个装置器装置你的函数
[01:44:08.000 --> 01:44:13.000] 然后他会把这个函数里面的变量的创建跟变化
[01:44:13.000 --> 01:44:16.000] 这个相当于是我想做的那个的一部分
[01:44:17.000 --> 01:44:18.000] 对对对
[01:44:18.000 --> 01:44:20.000] 我看到这个我就想起来
[01:44:20.000 --> 01:44:21.000] 他说的那个
[01:44:21.000 --> 01:44:22.000] 达不到我那种
[01:44:22.000 --> 01:44:24.000] 因为一个函数
[01:44:24.000 --> 01:44:26.000] 其实对吧
[01:44:26.000 --> 01:44:27.000] 稍微简单一点
[01:44:27.000 --> 01:44:30.000] 当然算是也对
[01:44:30.000 --> 01:44:32.000] 这个概念我是很喜欢的
[01:44:32.000 --> 01:44:33.000] 对
[01:44:33.000 --> 01:44:34.000] 然后的话
[01:44:34.000 --> 01:44:36.000] 然后像不算基本的坑的确很多
[01:44:36.000 --> 01:44:39.000] 比如说他跟multiple session这些有冲突
[01:44:39.000 --> 01:44:40.000] 但是的话目前而言
[01:44:40.000 --> 01:44:41.000] 他对于我们来讲
[01:44:41.000 --> 01:44:42.000] 算是唯一也是最好的选择
[01:44:42.000 --> 01:44:45.000] 然后的话文章的话
[01:44:45.000 --> 01:44:46.000] 我推荐
[01:44:46.000 --> 01:44:47.000] 然后next gen
[01:44:47.000 --> 01:44:49.000] 你最不想听到的那个名字
[01:44:49.000 --> 01:44:50.000] David Brazley
[01:44:51.000 --> 01:44:52.000] 对
[01:44:52.000 --> 01:44:53.000] 你知不知道
[01:44:53.000 --> 01:44:55.000] 我下周要去PyCon
[01:44:55.000 --> 01:44:57.000] 然后报名了他的那个tutorial
[01:44:57.000 --> 01:44:58.000] 可以
[01:44:59.000 --> 01:45:01.000] 他的tutorial是讲函数是变化
[01:45:01.000 --> 01:45:03.000] 然后我那个是我报名了
[01:45:03.000 --> 01:45:04.000] 助理活着
[01:45:04.000 --> 01:45:06.000] 然后David Brazley的话
[01:45:06.000 --> 01:45:08.000] 在那个PyCon 2009
[01:45:08.000 --> 01:45:09.000] 他做了一个很经典的演讲
[01:45:09.000 --> 01:45:11.000] 是关于写程方面的
[01:45:11.000 --> 01:45:16.000] 叫做career course on cruting and concurrency
[01:45:16.000 --> 01:45:17.000] 然后就是说是
[01:45:17.000 --> 01:45:19.000] 他在这个上面非常硬核的
[01:45:19.000 --> 01:45:20.000] 在这里
[01:45:20.000 --> 01:45:22.000] 他当时应该还是2009年的时候
[01:45:22.000 --> 01:45:24.000] 应该是Python3刚刚出来
[01:45:24.000 --> 01:45:26.000] 但是Python2应该是2.5
[01:45:26.000 --> 01:45:28.000] 2.6时期的时候
[01:45:28.000 --> 01:45:30.000] 也就是说没有Yield frog
[01:45:30.000 --> 01:45:31.000] 没有sync wait的情况下
[01:45:31.000 --> 01:45:34.000] 他在这里如何现场用Yield
[01:45:34.000 --> 01:45:36.000] 去实现一个写程
[01:45:36.000 --> 01:45:37.000] 也就是说是
[01:45:37.000 --> 01:45:39.000] 其实这一部分是事件驱动的
[01:45:39.000 --> 01:45:40.000] 包括一个事件驱动
[01:45:40.000 --> 01:45:42.000] 一个事件驱动循环
[01:45:42.000 --> 01:45:44.000] 然后这一部分某种意义上来讲
[01:45:44.000 --> 01:45:46.000] 可以说是一个Tornado的核心部分
[01:45:46.000 --> 01:45:47.000] 然后所以说是他非常硬核的
[01:45:47.000 --> 01:45:49.000] 带着你去实现一整套东西
[01:45:49.000 --> 01:45:50.000] 所以这个
[01:45:50.000 --> 01:45:51.000] 上次Adam是不是推荐过
[01:45:51.000 --> 01:45:53.000] 这个好像我上次推荐过
[01:45:53.000 --> 01:45:55.000] 是推荐过这个吗
[01:45:55.000 --> 01:45:56.000] 对
[01:45:56.000 --> 01:45:58.000] 正好是Pycon 2015
[01:45:58.000 --> 01:45:59.000] 你是Pycon 2015
[01:45:59.000 --> 01:46:01.000] 是Pycon的那次
[01:46:01.000 --> 01:46:03.000] 就是他手写教大家
[01:46:03.000 --> 01:46:05.000] 如何用Yield实现写程
[01:46:05.000 --> 01:46:07.000] 以及Ioloop的调度吗
[01:46:07.000 --> 01:46:09.000] 对 2009年的时候
[01:46:09.000 --> 01:46:12.000] 为什么是15年的
[01:46:12.000 --> 01:46:13.000] 我看他
[01:46:13.000 --> 01:46:14.000] 我当时说15年
[01:46:14.000 --> 01:46:15.000] 是因为我又去他个人的
[01:46:15.000 --> 01:46:17.000] Talk页面看了一下
[01:46:17.000 --> 01:46:18.000] 我这边看到是
[01:46:18.000 --> 01:46:20.000] 好吧那正枪了
[01:46:20.000 --> 01:46:21.000] 那正枪的话
[01:46:21.000 --> 01:46:23.000] 今天我就不推荐文章了吧
[01:46:23.000 --> 01:46:24.000] 然后的话
[01:46:24.000 --> 01:46:25.000] 没事没事
[01:46:25.000 --> 01:46:26.000] 但是这篇的话
[01:46:26.000 --> 01:46:28.000] 也是非常非常推荐的
[01:46:28.000 --> 01:46:30.000] 然后大家可以有兴趣
[01:46:30.000 --> 01:46:32.000] 可以去看一看
[01:46:32.000 --> 01:46:33.000] 然后的话
[01:46:33.000 --> 01:46:34.000] 然后的话
[01:46:34.000 --> 01:46:37.000] 那我们今天的主要内容就差不多
[01:46:37.000 --> 01:46:39.000] 我看一下
[01:46:39.000 --> 01:46:40.000] 不是
[01:46:40.000 --> 01:46:42.000] 不是你上次推荐的是另外一个
[01:46:42.000 --> 01:46:44.000] 是Python那个
[01:46:44.000 --> 01:46:46.000] Python Concurrency
[01:46:46.000 --> 01:46:48.000] From the Ground Up
[01:46:48.000 --> 01:46:49.000] 嗯
[01:46:49.000 --> 01:46:50.000] 对
[01:46:50.000 --> 01:46:51.000] 这个题目是不太
[01:46:51.000 --> 01:46:52.000] 好像是内容
[01:46:52.000 --> 01:46:54.000] 好像是有一些区别的
[01:46:54.000 --> 01:46:56.000] OK好
[01:46:56.000 --> 01:46:58.000] 然后那我们今天的话
[01:46:58.000 --> 01:47:00.000] 然后我们今天就
[01:47:00.000 --> 01:47:02.000] 差不多就是这样
[01:47:02.000 --> 01:47:03.000] 然后的话
[01:47:03.000 --> 01:47:04.000] 最后的话
[01:47:04.000 --> 01:47:06.000] 我们要不要来一个
[01:47:06.000 --> 01:47:08.000] 算了我们就不来什么
[01:47:08.000 --> 01:47:09.000] 来大家就是说是
[01:47:09.000 --> 01:47:10.000] 你们看一下有没有
[01:47:10.000 --> 01:47:12.000] 还有什么对听众朋友想说的
[01:47:12.000 --> 01:47:13.000] 或者说是一些小Tip
[01:47:13.000 --> 01:47:15.000] 或者说是其他的
[01:47:15.000 --> 01:47:16.000] 然后我们说两句
[01:47:16.000 --> 01:47:18.000] 然后今天的节目就ending
[01:47:18.000 --> 01:47:21.000] 就是我其实是想和各位听众抱歉
[01:47:21.000 --> 01:47:23.000] 我们录的真的有点长
[01:47:23.000 --> 01:47:26.000] 但是希望大家还是能
[01:47:26.000 --> 01:47:28.000] 能学到不少东西吧
[01:47:28.000 --> 01:47:30.000] 对至少我是学到了不少
[01:47:30.000 --> 01:47:31.000] 我天天都在学习
[01:47:31.000 --> 01:47:33.000] 天天上午另外三位搭档同学学习
[01:47:33.000 --> 01:47:34.000] 然后来
[01:47:34.000 --> 01:47:36.000] 那安桑木老师还有新涛
[01:47:38.000 --> 01:47:39.000] 嗯
[01:47:39.000 --> 01:47:40.000] 我
[01:47:40.000 --> 01:47:42.000] 我也跟大家学到很多东西
[01:47:42.000 --> 01:47:43.000] 嗯
[01:47:43.000 --> 01:47:45.000] 希望大家也能学到东西吧
[01:47:45.000 --> 01:47:47.000] 如果我们录制的过程中
[01:47:47.000 --> 01:47:48.000] 有什么错误
[01:47:48.000 --> 01:47:49.000] 欢迎指出来
[01:47:49.000 --> 01:47:51.000] 因为大家都水平有限嘛
[01:47:52.000 --> 01:47:53.000] 然后安桑木老师呢
[01:47:55.000 --> 01:47:56.000] 哦
[01:47:56.000 --> 01:47:57.000] 我觉得没什么吧
[01:47:57.000 --> 01:47:58.000] 就总结一下
[01:47:58.000 --> 01:48:00.000] 我们未来争取能把时间空在
[01:48:00.000 --> 01:48:01.000] 你不要理Fly了
[01:48:01.000 --> 01:48:02.000] 不要理Fly了
[01:48:02.000 --> 01:48:04.000] 我觉得这是个超大的
[01:48:04.000 --> 01:48:05.000] 争取争取争取
[01:48:05.000 --> 01:48:07.000] 然后的话Life is short
[01:48:07.000 --> 01:48:08.000] we use Python
[01:48:08.000 --> 01:48:09.000] 然后所以说
[01:48:09.000 --> 01:48:12.000] 然后祝大家写Python写的愉快
[01:48:12.000 --> 01:48:14.000] 当然听我们节目也听的愉快
[01:48:14.000 --> 01:48:15.000] 然后的话
[01:48:15.000 --> 01:48:16.000] 如果大家有什么建议
[01:48:16.000 --> 01:48:19.000] 或者说是有什么意见的话
[01:48:19.000 --> 01:48:21.000] 都可以通过我们的知乎
[01:48:21.000 --> 01:48:22.000] 我们的Twitter
[01:48:22.000 --> 01:48:24.000] 或者是在Telegram群组里面
[01:48:24.000 --> 01:48:26.000] 向我们思维组创
[01:48:26.000 --> 01:48:28.000] 然后你私聊都可以
[01:48:28.000 --> 01:48:29.000] 我们一直在线
[01:48:29.000 --> 01:48:30.000] 欢迎大家的
[01:48:30.000 --> 01:48:31.000] 我们希望听到你的声音
[01:48:31.000 --> 01:48:32.000] 欢迎大家向我们提出
[01:48:32.000 --> 01:48:47.000] 对你的建议和意见
[01:49:02.000 --> 01:49:04.000] 嗯
