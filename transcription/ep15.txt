[00:30.000 --> 00:35.880] 大家好欢迎来到补舌者说第16期
[00:35.880 --> 00:39.800] 这期的主题是Python开发工作流
[00:39.800 --> 00:42.640] 然后这次也是我们非常特别的一期
[00:42.640 --> 00:45.680] 因为我们第一次请到了两位嘉宾
[00:45.680 --> 00:51.000] 然后两位嘉宾分别是明希和TP
[00:51.000 --> 00:54.000] 我们先请嘉宾来自我介绍一下
[00:54.000 --> 00:55.519] 明希由你开始
[00:55.519 --> 00:57.280] 听众朋友大家好
[00:57.280 --> 00:58.280] 我是明希
[00:58.280 --> 01:00.840] 然后ID是Frost的名
[01:00.840 --> 01:03.560] 也是我们Python社区的老熟人了
[01:03.560 --> 01:06.760] 我现在是PPMV的合作者
[01:06.760 --> 01:08.400] PYPA的成员
[01:08.400 --> 01:12.480] 然后现在在腾讯做测试开发的工程师
[01:12.480 --> 01:17.800] 然后我也是自从2014年就开始用Python了
[01:17.800 --> 01:21.400] 现在也用也有6年的时间了
[01:21.400 --> 01:23.400] OK就这样
[01:23.400 --> 01:25.120] 然后TP
[01:25.120 --> 01:27.400] 好我是TP
[01:27.400 --> 01:30.160] 听众应该都比较不认识我
[01:30.160 --> 01:31.760] 我是来自台湾的
[01:31.760 --> 01:36.200] 我现在是在参与PIP的一个外包工作
[01:36.200 --> 01:40.000] 就是为他们开发一个新的依赖解析器
[01:40.000 --> 01:40.720] 是这样说吗
[01:40.720 --> 01:43.720] 其实我不太就是这些词我都不太熟中文怎么讲
[01:43.720 --> 01:47.320] 所以可以可能需要大家帮我翻译一下
[01:47.320 --> 01:48.560] 对是依赖解析器
[01:48.560 --> 01:51.440] 对啊我只是想说我写Python已经不知道多久了
[01:51.440 --> 01:53.240] 我自己都记不太得
[01:53.240 --> 01:54.880] 大概10年吧
[01:54.880 --> 01:55.920] 10年
[01:55.920 --> 01:58.360] 10年前你最开始写的时候是什么版本
[01:58.360 --> 02:01.360] 可以通过版本号来精确的回忆一下
[02:01.360 --> 02:05.160] 10年前我开始写的时候
[02:05.160 --> 02:10.360] 就是刚刚出了Python3.2吧
[02:10.360 --> 02:12.360] 3.2OK
[02:12.360 --> 02:15.720] 对然后我一开始从Python
[02:15.720 --> 02:17.600] 就是从3.2开始学的
[02:17.600 --> 02:21.480] 然后结果学了之后大家都跟我说要写Python2.7
[02:21.480 --> 02:23.800] 所以我就跑去回头学了2.7
[02:23.800 --> 02:26.240] 结果现在大家又都不写2.7了
[02:26.240 --> 02:28.840] 你知道吗我的那个学习路径跟你很像
[02:28.840 --> 02:31.360] 我是一开始学的3.3
[02:31.360 --> 02:34.520] 然后学了之后发现大家都在用2.7
[02:34.520 --> 02:36.280] 对OK
[02:36.280 --> 02:39.520] 然后其实说到两位嘉宾的话
[02:39.520 --> 02:40.840] 为什么请他们两个来呢
[02:40.840 --> 02:42.800] 因为两位都有一个共同点
[02:42.800 --> 02:47.640] 就是他们都是Pypa这个组织的议员
[02:47.640 --> 02:53.360] 那其实很多听众可能不太了解Pypa是一个什么样的组织
[02:53.360 --> 02:55.600] 我们要不请TP来介绍一下
[02:55.600 --> 02:57.320] 因为你加入的时间比较久
[02:57.320 --> 03:02.240] Pypa就是不知道大家都怎么发音的
[03:02.240 --> 03:04.240] Pypa
[03:04.240 --> 03:06.760] Pypa随便啦没有人知道怎么发音
[03:06.760 --> 03:11.560] 是一个就是它全名叫做Python Packaging Authority
[03:11.560 --> 03:15.360] 那如果直接翻译的话就是Python包装
[03:15.360 --> 03:17.560] Authority怎么翻呢权威
[03:17.560 --> 03:20.920] 但是就是这是一个完全没有权威的组织
[03:20.920 --> 03:25.399] 就是它完全是一个由自由贡献者所组成的一个组织
[03:25.399 --> 03:29.679] 然后他们的目标是要让Python的包装更好
[03:29.679 --> 03:32.000] 那它一开始创立的
[03:32.000 --> 03:35.920] 一开始创立大概是六七年前吧
[03:35.920 --> 03:38.519] 是由Nick Coglian跟一群人创立的
[03:38.519 --> 03:41.959] 那时候就是因为Python的包装就是一团混乱
[03:41.959 --> 03:44.519] 就是完全没有中心的标准
[03:44.519 --> 03:49.920] 就是同时有Setup Tools有Pip有DistLib
[03:49.920 --> 03:51.920] 还有DistUtils2
[03:51.920 --> 03:55.040] 那所有的就是大家都乱成一团
[03:55.040 --> 03:57.040] 然后他们就决定组合起来
[03:57.040 --> 04:00.040] 就是为Python包装写一些
[04:00.040 --> 04:04.519] 就是共同的PVP让大家能够共享同样的标准
[04:04.519 --> 04:06.200] 所以成立了这个组织
[04:06.200 --> 04:12.519] 所以它一开始就相当于是完全由一个个人发起的类似于
[04:12.519 --> 04:14.000] 对
[04:14.000 --> 04:17.839] 就是基本上就是一群开发者
[04:17.839 --> 04:19.719] 就是他们各自写各自的专案
[04:19.720 --> 04:20.840] 然后发现这样不行啊
[04:20.840 --> 04:23.920] 我们写专案然后就是你安装的我不能反安装
[04:23.920 --> 04:25.840] 然后你打包的我也不能安装
[04:25.840 --> 04:27.560] 这样下去不行啊
[04:27.560 --> 04:31.000] 所以那因为这些开发者就是一年也只见一次面
[04:31.000 --> 04:32.000] 就在PyCon
[04:32.000 --> 04:33.040] 那这样不行啊
[04:33.040 --> 04:35.320] 所以大家就集合起来
[04:35.320 --> 04:37.040] 那我们就随便成立一个组织
[04:37.040 --> 04:40.400] 让大家能够至少有一个地方可以互动这样
[04:40.400 --> 04:41.200] 嗯
[04:41.200 --> 04:46.920] 那PyPA现在是在Python的整个生态里是处于一个什么样的位置呢
[04:46.920 --> 04:48.240] 或者发挥一种什么作用
[04:48.240 --> 04:51.200] 它现在的位置其实非常微妙
[04:51.200 --> 04:56.720] 就是因为前面有讲到它其实就完全是一个自愿的组织
[04:56.720 --> 04:59.720] 所以它也完全没有任何开官方的
[04:59.720 --> 05:02.160] 就是官方的性质
[05:02.160 --> 05:06.600] 就是跟那个说CPython Core Maintainer就是完全不一样的
[05:06.600 --> 05:11.800] 就是我们完全没有任何获得就是PSF的承认
[05:11.800 --> 05:13.400] 没有任何法律上的地位
[05:13.400 --> 05:16.440] 但是他们就是在一个实质上
[05:16.440 --> 05:21.120] 就是很多在PyPA的开发者同时也是Core Maintainer
[05:21.120 --> 05:25.080] 然后他们就会在Core Maintainer里面去发挥影响力说
[05:25.080 --> 05:28.120] 我们就是packaging上面需要什么东西
[05:28.120 --> 05:31.200] 就是可以不可以合作一下帮我们加一下
[05:31.200 --> 05:34.680] 然后Griddle有时候也会就是
[05:34.680 --> 05:36.080] 去委托
[05:36.080 --> 05:41.320] 就是因为Griddle本身也不是说特别懂packaging这方面的东西
[05:41.320 --> 05:44.000] 所以它就会委托PyPA里面的成员
[05:44.000 --> 05:47.560] 就是他比较信任的那些去制定一些相关的标准
[05:47.560 --> 05:49.080] 就比如说你吗
[05:49.080 --> 05:51.360] 我当然是没有的
[05:51.360 --> 05:55.000] 当然就是像Nick Coughlin或者是Paul Moore
[05:55.000 --> 05:58.400] 或者是Nathan Neal J. Smith之类的大佬
[05:58.400 --> 06:00.680] 大大大佬才会获得他的信任
[06:00.680 --> 06:03.160] 我跟Griddle是连一次话都没有说的
[06:03.160 --> 06:04.800] 他是不肯信任我的吧
[06:04.800 --> 06:07.480] OK
[06:07.480 --> 06:08.240] 好的
[06:08.240 --> 06:11.440] 那然后明锡是最近加入了PyPA对吧
[06:11.440 --> 06:12.360] 对
[06:12.360 --> 06:16.000] 我可以补充一下就是刚才TP没有说到
[06:16.000 --> 06:18.880] 就是如果听众朋友们不了解PyPA
[06:18.880 --> 06:24.360] 我可以介绍一下它里面都有哪些包或者工具在里面
[06:24.360 --> 06:29.360] PyPA它主要是负责我们最熟悉的PIP安装器
[06:29.360 --> 06:32.520] 还有Virtual Environment虚拟环境的管理
[06:32.520 --> 06:36.320] 然后还包括PyPI的warehouse
[06:36.320 --> 06:39.160] 就是我们或者说叫cheatshop
[06:39.160 --> 06:42.440] 就是我们放包的一个服务器
[06:42.440 --> 06:44.600] 就我们经常从那里下包的PyPI
[06:44.600 --> 06:45.000] 对
[06:45.000 --> 06:48.360] 然后对还包括PPM对也在里面
[06:48.360 --> 06:55.120] 所以基本上我们关于包管理安装包这些东西的一些工具链
[06:55.120 --> 06:59.400] 都是在PyPA或者PYPA里面去管理的
[06:59.400 --> 07:00.520] 好的
[07:00.520 --> 07:03.680] 然后我们今天的另外一个主播是小白
[07:03.680 --> 07:06.400] 这是小白第二次来参与我们录音
[07:06.400 --> 07:07.920] 然后你也来自我介绍一下吧
[07:07.920 --> 07:09.640] Hello大家好我是小白
[07:09.640 --> 07:11.000] 还需要自我介绍吗
[07:11.000 --> 07:11.960] 你自我介绍一下吧
[07:11.960 --> 07:14.320] 第二次可能听众还不是很熟悉你
[07:14.320 --> 07:17.120] 对我是一个新人
[07:17.120 --> 07:19.240] 无论是对于不识者来说
[07:19.240 --> 07:21.360] 还是对于Python来说都是一个新人
[07:21.360 --> 07:25.400] 我目前是在我大学导师的一个项目里
[07:25.400 --> 07:30.360] 然后我是2018年开始接触的Python
[07:30.360 --> 07:30.640] 对
[07:30.640 --> 07:32.600] 然后到现在是几年
[07:32.600 --> 07:33.360] 两年
[07:33.360 --> 07:34.600] 两三年吧
[07:34.600 --> 07:37.560] 目前的话主要是用那个django来写web
[07:37.560 --> 07:38.640] 对就这样
[07:38.640 --> 07:43.480] 然后小白说他对于今天聊的很多话题都不懂
[07:43.480 --> 07:46.480] 然后其实我们待会也可以请他来多提一些问题
[07:46.480 --> 07:49.320] 我们就正式进入今天的主题
[07:49.320 --> 07:53.120] 今天主题是Python的开发工作流
[07:53.120 --> 07:57.240] 这个概念其实说起来是比较虚的
[07:57.240 --> 08:02.160] 它里面有一些更刺激的主题
[08:02.160 --> 08:05.560] 比如说包括虚拟环境管理
[08:05.560 --> 08:09.200] 依赖管理和打包发布这三个方面
[08:09.200 --> 08:13.000] 然后明锡之前有写一篇文章
[08:13.000 --> 08:17.040] 他提到就是说Python的工作流工具无非是解决
[08:17.040 --> 08:18.320] 这三个方面的问题
[08:18.320 --> 08:21.200] 也就是虚拟环境管理依赖管理和打包发布
[08:21.200 --> 08:24.120] 明锡你要不要就这个问题来
[08:24.120 --> 08:26.760] 给听众们做一下更深入的介绍
[08:26.760 --> 08:27.840] 对
[08:27.840 --> 08:31.840] 我们工作流就是包括我们Python开发
[08:31.840 --> 08:33.960] 然后包发布的整个方方面面
[08:33.960 --> 08:39.320] 虚拟环境管理就包括我们平常非常
[08:39.320 --> 08:41.800] 经常使用的Virtual Lab
[08:41.800 --> 08:45.640] 和包括Python内置的VMV包
[08:45.640 --> 08:48.040] 这个是用来创建一个虚拟环境的
[08:48.040 --> 08:51.160] 虚拟环境就是用来去隔离你的
[08:51.160 --> 08:53.080] Python安装的库的路径
[08:53.080 --> 08:56.480] 然后把它不同项目的安装包都隔离开来
[08:56.480 --> 08:58.480] 依赖管理这是一个
[08:58.480 --> 09:01.800] 就是说你的项目里面的一些依赖
[09:01.800 --> 09:03.320] 你可以把它给写下来
[09:03.320 --> 09:04.440] 或者把它给定下来
[09:04.440 --> 09:06.760] 然后方便部署的时候
[09:06.760 --> 09:08.760] 就从这个依赖里面
[09:08.760 --> 09:11.960] 再重新把你的项目给安装起来
[09:11.960 --> 09:16.920] 那么依赖管理其实这里还包含了一个
[09:16.920 --> 09:19.040] 就是后面我们会讲到的依赖解析
[09:19.040 --> 09:20.320] 这部分的东西
[09:20.320 --> 09:22.160] 对
[09:22.160 --> 09:24.880] 然后打包发布就是
[09:24.880 --> 09:27.960] 一般情况下我们做Python开发的话
[09:27.960 --> 09:29.440] 很多都是写应用
[09:29.440 --> 09:31.720] 比如说写一个Django或者写一个
[09:31.720 --> 09:34.960] Flask的这样一个APP
[09:34.960 --> 09:38.320] 那么这种情况我们就不需要去把它打包发布
[09:38.320 --> 09:41.280] 打包发布就是说我们把我们的包打成一个包
[09:41.280 --> 09:45.760] 然后上传到PyPy上去供别人去下载
[09:45.760 --> 09:47.600] 或者叫分发
[09:47.600 --> 09:48.960] distribute
[09:48.960 --> 09:53.560] 那么这个工具现在我们Python里面用的最多的
[09:53.560 --> 09:55.160] 就是setup tools
[09:55.160 --> 09:58.960] 也是PyPy里面的一个项目
[09:58.960 --> 10:01.160] 对就是这三个方面
[10:01.160 --> 10:05.439] 然后我们来问一下小白吧
[10:05.439 --> 10:09.040] 你看到这个你有没有什么问题想问
[10:09.040 --> 10:12.040] 就是作为一个新人来说
[10:12.040 --> 10:17.439] 虚拟环境跟这个打包发布我是有了解过
[10:17.439 --> 10:19.280] 但是这个依赖管理说实话
[10:19.280 --> 10:21.280] 我当时在学Python的时候
[10:21.280 --> 10:23.640] 根本就没有介绍这一块的资料
[10:23.640 --> 10:26.439] 就是我在看的一些资料里都没有介绍这个东西
[10:26.439 --> 10:30.160] 然后我后来写web应用的时候
[10:30.160 --> 10:34.079] 也是直接用了那个PyP的就是PyP的那个
[10:34.079 --> 10:36.040] 就是那个TXT文件
[10:36.040 --> 10:38.240] requirements.txt
[10:38.240 --> 10:39.439] 对我直接用的那个
[10:39.439 --> 10:42.319] 我就一直以为那个东西就相当于是那个
[10:42.319 --> 10:44.520] Node.js里边的那个叫什么
[10:44.520 --> 10:46.760] package.json
[10:46.760 --> 10:48.199] 我就感觉这个东西很像
[10:48.199 --> 10:49.760] 所以我也没有深究这个问题
[10:49.760 --> 10:51.640] 我就一直以为这个东西是一个传统
[10:51.640 --> 10:52.880] 然后就这么用下去了
[10:52.880 --> 10:57.160] 完全不知道这个依赖管理还是一个单独的一个项目
[10:57.160 --> 11:01.240] 所以说就是一个依赖管理就是除了这个
[11:01.240 --> 11:04.000] PyP带的这个默认的东西之外
[11:04.000 --> 11:04.880] 还有别的东西吗
[11:04.880 --> 11:06.360] 他们的区别是在哪呢
[11:06.360 --> 11:09.800] 那我们就顺便聊一下这个一些热门的库
[11:09.800 --> 11:12.360] 就是说一些主流的依赖管理的库
[11:12.360 --> 11:13.680] TP你想介绍一下吗
[11:13.680 --> 11:15.000] 我们其实列了一张表对吧
[11:15.000 --> 11:16.600] 有好多然后
[11:16.600 --> 11:19.240] 你说下面那个那个表吗
[11:19.240 --> 11:19.800] 对
[11:19.800 --> 11:23.880] 那要从哪里开始说起比较好呢
[11:23.880 --> 11:26.120] 当然从PIP开始说起了
[11:26.120 --> 11:27.880] 从PIP嘛
[11:27.880 --> 11:29.920] 好吧那就从PIP开始说起
[11:29.920 --> 11:31.560] 要从PIP
[11:31.560 --> 11:36.440] 然后我们我上就我这个月初的时候上了另外一个podcast
[11:36.440 --> 11:39.160] 然后我们才聊了一下就是PIP的历史
[11:39.160 --> 11:42.600] 就是PIP就是大家都知道setup tools嘛
[11:42.600 --> 11:47.200] 那大家知道setup tools有一个指令叫easy install吗
[11:47.200 --> 11:48.960] 迟早没用过
[11:48.960 --> 11:51.880] 那个是比较古老的工具我觉得
[11:51.880 --> 11:54.040] 对明昔知道这是一个很古老的工具
[11:54.040 --> 11:58.319] 但是大家知道PIP其实比easy install还要古老吗
[11:58.319 --> 11:59.280] 啊是吗
[11:59.280 --> 12:00.800] 对这是真的
[12:00.800 --> 12:03.680] 我后来去就是这个是Polmore跟我说的
[12:03.680 --> 12:05.680] 然后我后来去查了一下还真的
[12:05.680 --> 12:08.480] 就是PIP其实是一个非常非常古老的工具
[12:08.480 --> 12:12.839] 然后它一开始的功能就只有install就是安装套件
[12:12.839 --> 12:16.880] 那所有你现在看到的其他功能都是后来才加上去的
[12:16.880 --> 12:22.959] 所以才会变就是大家为什么都觉得PIP的指令有点混乱
[12:22.960 --> 12:24.240] 大概是这个原因
[12:24.240 --> 12:28.480] 那PIP最主要的目的就是PIP install
[12:28.480 --> 12:32.800] 那后来加了uninstall就是安装跟反安装
[12:32.800 --> 12:38.160] 那它一开始的目的就是我在Pipe.py上面有一个东西
[12:38.160 --> 12:39.760] 就有一个网址可以下载
[12:39.760 --> 12:41.680] 然后就PIP install
[12:41.680 --> 12:42.560] 例如说django
[12:42.560 --> 12:43.640] PIP install django
[12:43.640 --> 12:47.240] 然后它就会去一个网址叫pipe.org
[12:47.240 --> 12:48.240] 鞋心
[12:48.240 --> 12:50.200] simple 鞋心 django
[12:50.200 --> 12:51.320] 上面是一个网页
[12:51.320 --> 12:53.040] 然后它会去找上面的连接
[12:53.040 --> 12:55.440] 然后把那个连接下载到你的电脑上面
[12:55.440 --> 12:57.400] 然后反安装大概就是这样子
[12:57.400 --> 12:58.240] 不好意思打断一下
[12:58.240 --> 12:59.040] 我有个问题
[12:59.040 --> 13:01.600] 就是说因为我学Python也比较早
[13:01.600 --> 13:04.320] 那个时候PIP还不是Python自带的
[13:04.320 --> 13:06.600] 就还不是built-in的一个工具
[13:06.600 --> 13:10.720] 你还得去用get-pip.py
[13:10.720 --> 13:12.280] 那个东西先去安装PIP
[13:12.280 --> 13:12.720] 对
[13:12.720 --> 13:14.240] 然后你才能用PIP
[13:14.240 --> 13:17.760] 然后在那之前我很多库都是直接下载下来
[13:17.760 --> 13:18.840] 然后解压
[13:18.840 --> 13:19.800] 然后setup
[13:19.800 --> 13:22.920] 就那个Python setup.py install
[13:22.920 --> 13:24.400] 这样来安装
[13:24.400 --> 13:25.040] 对
[13:25.040 --> 13:29.400] 那就是PIP install做的事情一开始
[13:29.400 --> 13:31.959] 就是PIP install一开始就是帮你做这些
[13:31.959 --> 13:33.599] 它就只是一个脚本而已
[13:33.599 --> 13:33.959] 对
[13:33.959 --> 13:35.439] 所以我就觉得很奇怪
[13:35.439 --> 13:36.240] 就是说
[13:36.240 --> 13:40.920] 难道说Python在一开始设计的时候
[13:40.920 --> 13:43.199] 就是它设计的时候
[13:43.199 --> 13:45.719] 让大家安装包的方式就是下载下来
[13:45.719 --> 13:48.520] 然后setup.py install这样来安装吗
[13:48.520 --> 13:49.520] 还是说
[13:49.520 --> 13:50.319] 对
[13:50.319 --> 13:51.319] 怎么样
[13:51.319 --> 13:52.520] 就是这样吗
[13:52.520 --> 13:52.960] 对啊
[13:52.960 --> 13:56.040] 就是你要想Python一开始开发的时候
[13:56.040 --> 13:58.720] 那时候大家比较对象是像C
[13:58.720 --> 14:00.560] 就是那C你安装包怎么安装
[14:00.560 --> 14:03.840] 它就是下载一个zip解压缩
[14:03.840 --> 14:05.160] 然后make install
[14:05.160 --> 14:06.079] 就是一样的
[14:06.079 --> 14:08.319] 就是Python包就是下载下来解压缩
[14:08.319 --> 14:10.760] 然后setup.py install
[14:10.760 --> 14:13.920] 所以就是大家后来发现这样还是太原始了
[14:13.920 --> 14:18.120] 然后就把PIP然后在3.4里面做成了它内置的一个
[14:18.120 --> 14:18.880] 对
[14:18.880 --> 14:20.120] 主要的好处就是
[14:20.120 --> 14:23.400] 你可以把包都放在一个集中的地方
[14:23.400 --> 14:24.600] 然后我们就从那个地方
[14:24.600 --> 14:28.680] 就是现在的包管理都是这样的模式
[14:28.680 --> 14:29.320] 是
[14:29.320 --> 14:34.600] 你们知道getPIP.py这个脚本是怎么搞的吗
[14:34.600 --> 14:37.000] 你说getPIP.py吗
[14:37.000 --> 14:37.720] 对
[14:37.720 --> 14:39.040] 没太研究过
[14:39.040 --> 14:41.760] 它是把一个PIP的
[14:41.760 --> 14:43.600] 就是一个PIP的zip
[14:43.600 --> 14:45.200] 把它的那个by
[14:45.200 --> 14:48.320] 就是by的字节码给hardcode到脚本里面
[14:48.320 --> 14:52.320] 然后它安装的时候就把那个字节码解压出来
[14:52.320 --> 14:53.000] 进一个PIP
[14:53.000 --> 14:54.920] 然后PIP再安装自己
[14:54.920 --> 14:57.160] 那不是应该会很大吗
[14:57.160 --> 14:58.360] 就是
[14:58.360 --> 14:58.800] 对
[14:58.800 --> 15:00.280] 你可以打开那个脚本看
[15:00.280 --> 15:03.480] 那个浏览器都会变卡
[15:03.480 --> 15:03.880] 哇
[15:03.880 --> 15:05.040] 我用了那么多年
[15:05.040 --> 15:07.840] 我都没注意过它的那个实现
[15:07.840 --> 15:09.400] 是蛮大的
[15:09.400 --> 15:09.960] 我看一下
[15:09.960 --> 15:13.800] 我今天到现在电脑里还有一个setupgetPIP.py
[15:13.800 --> 15:15.320] 放在那
[15:15.320 --> 15:17.720] 都是以前刀根火种的时代
[15:17.720 --> 15:19.960] 千万不要用什么
[15:19.960 --> 15:21.360] Visual Studio
[15:21.360 --> 15:23.520] 就是从VS Code打开
[15:23.520 --> 15:26.920] 你整个电脑都没法用
[15:26.920 --> 15:28.520] 嗯
[15:28.520 --> 15:31.960] 所以其实这套东西也是逐渐进化来的
[15:31.960 --> 15:38.280] 那就是最近有一个关于PIP有一个UX studies
[15:38.280 --> 15:42.400] 然后TP也是着重强调我们要聊一下这个
[15:42.400 --> 15:42.840] 是吧
[15:42.840 --> 15:44.680] 你说一下吧
[15:44.680 --> 15:45.120] 对啊
[15:45.120 --> 15:46.600] 就是因为
[15:46.600 --> 15:47.000] 是啊
[15:47.000 --> 15:56.040] 因为就是前面刚刚说了PIP就是一个十年历史来的旁人大物
[15:56.040 --> 15:59.000] 然后里面藏了很多污垢
[15:59.000 --> 16:08.520] 那我们在那个就是我们developer channel里面有用一些比较粗俗的字眼描绘这个PIP的实作
[16:08.520 --> 16:10.600] 这里就不讲了
[16:10.600 --> 16:11.360] 那总之呢
[16:11.360 --> 16:14.840] 就是为了我们要把这个东西给清理一下
[16:14.840 --> 16:19.160] 让就是让一来是让使用者也比较清楚吧
[16:19.160 --> 16:20.640] 就是怎么用这个工具
[16:20.640 --> 16:29.360] 那二来其实比较重要是让我们就是维护的人能够就是跟使用者解释说这个东西到底是做什么用
[16:29.360 --> 16:30.520] 就是这样这样这样用
[16:30.520 --> 16:33.120] 那你这样这样这样用是不推荐的
[16:33.120 --> 16:34.520] 我们建议这样这样用
[16:34.520 --> 16:38.920] 那以现在的PIP的设计是很难解释这件事情的
[16:38.920 --> 16:40.960] 所以我们才想要做这件事情
[16:40.960 --> 16:45.800] 那在设计一个新的界面之前
[16:45.800 --> 16:51.560] 首先我们就需要先知道使用者希望在PIP上面看到什么东西
[16:51.560 --> 16:56.800] 那他们觉得这些东西应该是怎么怎么分配的
[16:56.800 --> 16:59.160] 就是哪一个指令是做什么事
[16:59.160 --> 17:00.080] 什么样的事情
[17:00.080 --> 17:04.280] 所以我们现在是在收集就是大家使用PIP上面经验
[17:04.280 --> 17:08.079] 然后最后让这些经验能够反馈回我们的设计上面
[17:08.079 --> 17:12.359] 所以就相当于这些最后是要由你来实现吗
[17:12.359 --> 17:12.960] 还是
[17:12.960 --> 17:14.879] 应该不是我吧
[17:14.879 --> 17:16.879] 希望不是我
[17:16.879 --> 17:19.599] OK
[17:19.599 --> 17:25.240] 对然后这个调查的链接我们也会在show notes里面放出来
[17:25.240 --> 17:34.760] 然后说完了就是PIP算是一个就是最应该算是最基础的做依赖管理的工具吗
[17:34.760 --> 17:39.840] 那其实在就是很多在很长时间
[17:39.840 --> 17:42.560] 就是最近几年以前吧
[17:42.560 --> 17:44.879] 其实大家一直就是靠PIP
[17:44.879 --> 17:49.120] 然后requirements.txt来做依赖管理
[17:49.120 --> 17:54.040] 就是我们把所有的包以及它的版本直接都写在requirements.txt里
[17:54.040 --> 17:58.120] 那就说就像小白刚才说的这套他也用的挺好
[17:58.120 --> 18:01.400] 那为什么大家会觉得发现有不足
[18:01.400 --> 18:04.320] 然后创造出了更多一些工具呢
[18:04.320 --> 18:06.320] 这个我说一下吧因为
[18:06.320 --> 18:08.919] 这个依赖管理
[18:08.919 --> 18:14.040] PIP的依赖管理之前有一个最大的问题就是它没有依赖解析
[18:14.040 --> 18:15.840] 或者说依赖解析很弱
[18:15.840 --> 18:20.760] 就比如说你安装了一个包A它依赖jungle 1.0
[18:20.760 --> 18:25.840] 然后你后面又安装了一个包B然后它依赖是jungle大于2.0
[18:25.840 --> 18:29.240] 那么你同时安装这两个包的时候
[18:29.240 --> 18:33.080] 那你那个jungle就会安装成2.0
[18:33.080 --> 18:36.360] 然后并不会告诉你这里面有出错
[18:36.360 --> 18:39.760] 然后你以为什么事都OK了
[18:39.760 --> 18:44.960] 然后最后发现那个A不兼容那个jungle的版本
[18:44.960 --> 18:46.960] 就会发生这样的情况
[18:46.960 --> 18:54.360] 所以就会出现一些依赖解析的东西
[18:54.360 --> 18:58.240] 比如说PPM PIPtools或者是Poetry
[18:58.240 --> 19:05.080] 就是这三个东西都是带有依赖解析的一个部分的
[19:05.080 --> 19:07.440] 不好意思打断一下
[19:07.440 --> 19:10.800] 就是被他这么一说然后我突然想起来
[19:10.800 --> 19:14.560] 就是我在写view的时候就是写JavaScript
[19:14.560 --> 19:16.800] 好像我从来就没有关心过这个问题
[19:16.800 --> 19:19.200] 然后但是我在写Python的时候
[19:19.200 --> 19:23.320] 我每次下载一个东西我都要去它的GitHub首页也好
[19:23.320 --> 19:25.480] 或者是它的网站也好去看一下
[19:25.480 --> 19:27.920] 它是否支持我当前的这个版本
[19:27.920 --> 19:30.480] 就是它有一个jungle大于等于多少多少
[19:30.480 --> 19:32.480] 然后我才敢放心的把它下下来
[19:32.480 --> 19:34.480] 好像确实是有这个事情
[19:34.480 --> 19:38.400] 这个就涉及到NPM放依赖的方式了
[19:38.400 --> 19:40.880] 它并不会发生这种冲突的问题
[19:40.880 --> 19:44.080] 所以NPM会有它的依赖
[19:44.080 --> 19:46.600] 可能同一个依赖它会有很多份
[19:46.600 --> 19:47.840] 然后在不同的位置
[19:47.840 --> 19:50.360] 就会导致你的node module是非常臃肿
[19:50.360 --> 19:52.160] 这个吐槽后面我们再吐槽吧
[19:52.160 --> 19:55.000] 对这个后面有专门部分要再吐槽
[19:55.000 --> 19:59.640] OK然后我们回到Python依赖管理的话题
[19:59.640 --> 20:00.320] 拉回来一点
[20:00.320 --> 20:02.680] 然后就是刚才明锡也提到了
[20:02.680 --> 20:05.600] 就是为了解决Pip不能做依赖管理的问题
[20:05.600 --> 20:07.720] 就有很多新的工具出现
[20:07.720 --> 20:09.560] 比如说PipAmp
[20:09.560 --> 20:10.560] 然后Portrait
[20:10.560 --> 20:12.280] 然后另外一个是PipTools
[20:12.280 --> 20:15.320] 然后据我所知PipTools应该是最早的
[20:15.320 --> 20:15.640] 对吧
[20:15.640 --> 20:19.280] 它相当于是在PipAmp和Portrait之前就出来了
[20:19.280 --> 20:19.800] 对
[20:19.800 --> 20:24.360] 它当时是用的一种什么方法来解决依赖管理的问题
[20:24.360 --> 20:25.760] 我其实没有太用过
[20:25.760 --> 20:27.399] 这我来说好了
[20:27.399 --> 20:32.399] 因为前面还有就是那个讲到requirements.txt
[20:32.399 --> 20:34.600] 为什么这个流程不好的关系
[20:34.600 --> 20:35.919] 就是如果你跟
[20:35.919 --> 20:37.840] 例如说我们跟node比好了
[20:37.840 --> 20:39.479] node就是node install
[20:39.479 --> 20:40.080] 不
[20:40.080 --> 20:42.240] npm install的做法是
[20:42.240 --> 20:45.080] 就是你首先会有一个package.json
[20:45.080 --> 20:50.439] 然后npm会把这个package.json做成一个
[20:50.439 --> 20:52.840] package.log.json
[20:52.840 --> 20:54.320] 还是什么名字我忘记了
[20:54.320 --> 20:57.399] 然后再从那个log里面去安装套件
[20:57.399 --> 20:59.480] 但requirements.txt是颠倒过来的
[20:59.480 --> 21:01.320] 就是你先有一个requirements.txt
[21:01.320 --> 21:05.919] 然后PipInstall进一个虚拟环境之后
[21:05.919 --> 21:09.760] 你再PipFreeze出来一个requirements.txt
[21:09.760 --> 21:11.600] 就是它的顺序其实是颠倒的
[21:11.600 --> 21:15.360] 就是你requirements.txt是基于你的环境的
[21:15.360 --> 21:17.120] 而不是说你的log档
[21:17.120 --> 21:20.240] 而不是说你的环境基于你的log档
[21:20.240 --> 21:21.399] 这样才是正确的
[21:21.400 --> 21:26.040] 所以PipTools基本上就是想要把这个状态颠倒过来
[21:26.040 --> 21:32.720] 就是让你能够在安装之前就能够产生一个requirements.txt
[21:32.720 --> 21:35.520] 所以PipTools里面有一个
[21:35.520 --> 21:40.360] 它最重要的一个指令是pipcompile
[21:40.360 --> 21:44.480] 就是它会去调用Pip里面的解析器
[21:44.480 --> 21:47.680] 然后但是把那个安装那个部分拿掉
[21:47.680 --> 21:49.800] 它只是把那个解析的结果拿出来
[21:49.800 --> 21:52.280] 然后产生一个requirements.txt
[21:52.280 --> 21:57.080] 让你可以在后面再去用这个requirements.txt做安装
[21:57.080 --> 21:59.080] 这是它最主要的目的
[21:59.080 --> 22:03.080] 这个不就是那个PipFreeze的功能吗?
[22:03.080 --> 22:05.080] 还是有什么不太一样?
[22:05.080 --> 22:08.080] 对,但是PipFreeze必须要
[22:08.080 --> 22:12.080] PipFreeze你必须要先有环境你才可以Freeze它
[22:12.080 --> 22:15.879] 那所以如果你Freeze出来的结果是有冲突的
[22:15.879 --> 22:18.360] 那代表说你的环境已经坏了
[22:18.360 --> 22:21.000] 那这时候你就没有办法去解决它了
[22:21.000 --> 22:24.760] 所以PipCompile就是先让你产生一个requirements.txt
[22:24.760 --> 22:27.760] 然后让你去检查里面有没有冲突
[22:27.760 --> 22:29.560] 如果没有的话你再去
[22:29.560 --> 22:31.560] 它还有另外一个指令叫PipSync
[22:31.560 --> 22:34.560] 那就是调用那个requirements.txt去安装
[22:34.560 --> 22:37.560] 那它这个产生,我比较好奇
[22:37.560 --> 22:40.560] 它产生requirements.txt这个
[22:40.560 --> 22:44.560] 就是说它怎么知道你现在用的这些包的版本是什么
[22:44.560 --> 22:46.560] 它从哪里拿到这个信息?
[22:46.560 --> 22:49.560] 你可以就是你在Compile的时候
[22:49.560 --> 22:52.560] 你就可以像PipInstall一样去给它一个
[22:52.560 --> 22:55.560] 就是给它一个列表就是你需要安装的包是哪些
[22:55.560 --> 22:59.560] 或者是你也可以给它另外一个requirements档案
[22:59.560 --> 23:02.560] 就是它们通常叫做requirements.in
[23:02.560 --> 23:05.560] 去告诉它你要什么包
[23:05.560 --> 23:09.560] 那requirements.in就会比较像package.json
[23:09.560 --> 23:13.560] 然后requirements.txt就会比较像package.lock
[23:13.560 --> 23:17.560] OK,我现在大概理解PipTools是在干什么了
[23:17.560 --> 23:20.560] 然后那就是说
[23:20.560 --> 23:25.560] 我记得PipAmp应该是PipTools的上面的一个wrapper
[23:25.560 --> 23:28.560] 就是它一开始,至少在最一开始的时候
[23:28.560 --> 23:31.560] 对,现在应该还是吧
[23:31.560 --> 23:34.560] 就是它解决的问题就只有
[23:34.560 --> 23:37.560] 就是Amp的那个部分,就是PipTools是没有
[23:37.560 --> 23:41.560] 管理那个虚拟环境的
[23:41.560 --> 23:43.560] 所以你必须就是每一个虚拟环境里面
[23:43.560 --> 23:46.560] 你都必须要装一份PipTools
[23:46.560 --> 23:48.560] 就跟Pip一样,你必须要装一份PipTools
[23:48.560 --> 23:54.560] 然后才能用那个PipTools去lock跟去sync
[23:54.560 --> 23:57.560] 所以PipTools就是解决这个部分
[23:57.560 --> 24:00.560] 就是你不用在每一个环境里面就安装PipTools
[24:00.560 --> 24:03.560] 那它的做法其实就是它自己建立一个虚拟环境
[24:03.560 --> 24:07.560] 然后它自己里面有带一个PipTools的
[24:07.560 --> 24:11.560] 就是它有vendor一个PipTools的版本
[24:11.560 --> 24:14.560] 然后它会把它inject到那个环境里面去解析
[24:14.560 --> 24:18.560] 然后另外一个解决的部分就是它
[24:18.560 --> 24:20.560] 因为requirements.txt
[24:20.560 --> 24:23.560] 我们后面会不会讲requirements.txt到底哪里不好啊
[24:23.560 --> 24:25.560] 还是这里就讲一下
[24:25.560 --> 24:28.560] 我是说在格式上面的不好
[24:28.560 --> 24:31.560] 那你可以现在讲啊
[24:31.560 --> 24:35.560] requirements.txt就是它格式上面也有蛮多的问题
[24:35.560 --> 24:37.560] 第一个它完全没有任何的规范
[24:37.560 --> 24:40.560] 它完全就是Pip内部的实作
[24:40.560 --> 24:42.560] 就是因为它是Pip内部的实作
[24:42.560 --> 24:46.560] 所以它的所有的选项所有的flag
[24:46.560 --> 24:50.560] 比如说你要指定我不要用pypi.org
[24:50.560 --> 24:53.560] 我要用另外一个source另外一个index
[24:53.560 --> 24:59.560] 那我是用Pip的指令去在requirements.txt里面指定的
[24:59.560 --> 25:02.560] 然后还有一个就是它也没有办法分类
[25:02.560 --> 25:05.560] 就是分...怎么说
[25:05.560 --> 25:09.560] 就是像那个package.json里面你可以分dependencies跟devdependencies
[25:09.560 --> 25:11.560] 那这个在requirements.txt里面没有办法做
[25:11.560 --> 25:13.560] 你必须要分两个档案写
[25:13.560 --> 25:15.560] 那还有其他种种的问题
[25:15.560 --> 25:19.560] 就是让这个格式非常非常的难用
[25:19.560 --> 25:21.560] 尤其是如果你必须要
[25:21.560 --> 25:26.560] 如果你只是要用它来当freeze的output的话还行
[25:26.560 --> 25:30.560] 但是如果说你要让它当input的话就非常困难
[25:30.560 --> 25:35.560] 所以就是那个Pipenv一开始是基于
[25:35.560 --> 25:37.560] 我忘了是谁写的
[25:37.560 --> 25:38.560] 好像是Donald Stauf吧
[25:38.560 --> 25:43.560] 提出的一个就是Pipfile这个格式去取代requirements.txt
[25:43.560 --> 25:46.560] 这两个才是它主要的目的
[25:46.560 --> 25:48.560] 不是它是...对
[25:48.560 --> 25:52.560] 一开始是Donald Stauf提出来想要把它直接整合进Pip里面
[25:52.560 --> 25:54.560] 但是后来就是问题一大堆
[25:54.560 --> 25:56.560] 所以最后也就是不了了之了
[25:56.560 --> 26:00.560] 最后就是Candice把它又从坟墓里面挖出来
[26:00.560 --> 26:02.560] 做了Pipenv
[26:02.560 --> 26:06.560] 我一直以为Pipfile是Candice提出的
[26:06.560 --> 26:08.560] 其实不是是吗
[26:08.560 --> 26:13.560] OK,然后我觉得就其实可以详细聊一下Pipenv这个工具
[26:13.560 --> 26:18.560] 因为Pipenv其实是也就是Pipenv是PyPA
[26:18.560 --> 26:24.560] 现在在它的官网上花最大篇幅介绍的一个依赖管理工具
[26:24.560 --> 26:29.560] 甚至可以说是PyPA背书的一个工具
[26:29.560 --> 26:31.560] 我不知道你们同不同意这种说法
[26:31.560 --> 26:37.560] 然后明锡是Pipenv的一个核心开发者
[26:37.560 --> 26:40.560] 也是主要的现在主要的Maintainer之一吧
[26:40.560 --> 26:44.560] 然后你要不要从Pipenv的历史以及它解决的问题
[26:44.560 --> 26:47.560] 然后来给听众们做一个介绍
[26:47.560 --> 26:49.560] 好的
[26:49.560 --> 26:52.560] Pipenv从它的名字就可以看到
[26:52.560 --> 26:54.560] 可以拆成Pipenv
[26:54.560 --> 27:00.560] 它是把安装器跟虚拟环境管理给合成一个命令
[27:00.560 --> 27:02.560] 就是原来你安装一个包
[27:02.560 --> 27:04.560] 你可能要先创建一个虚拟环境
[27:04.560 --> 27:06.560] 然后在那个虚拟环境里
[27:06.560 --> 27:08.560] 然后先把它给激活了
[27:08.560 --> 27:11.560] 然后再用里面的Pip去安装你的包
[27:11.560 --> 27:16.560] 那么Pipenv就把这两个动作合成一个动作
[27:16.560 --> 27:19.560] 就是如果你去Pipenv install something的话
[27:19.560 --> 27:23.560] 它首先会检查你有没有已经创建好虚拟环境
[27:23.560 --> 27:24.560] 如果没有的话
[27:24.560 --> 27:26.560] 它会帮你创建一个虚拟环境
[27:26.560 --> 27:29.560] 然后在里面也是调Pip去安装你的包
[27:29.560 --> 27:34.560] 所以它可以让这个过程就是你感知不到
[27:34.560 --> 27:36.560] 然后第二个是
[27:36.560 --> 27:37.560] 也是刚才说的
[27:37.560 --> 27:43.560] 它也是用了新的一个依赖定义的文件格式
[27:43.560 --> 27:44.560] 就是Pipfile
[27:44.560 --> 27:48.560] 然后基于这个Pipfile去调用PipTools的能力
[27:48.560 --> 27:51.560] 去生成Pipfile的Lock档
[27:51.560 --> 27:54.560] 然后你安装包的时候
[27:54.560 --> 27:57.560] 安装包的时候它会自动生成这个Lock档
[27:57.560 --> 27:59.560] 等你要部署的时候
[27:59.560 --> 28:02.560] 你只要把这个Pipfile和PipfileLock这两个档
[28:02.560 --> 28:04.560] 放到远程服务器上
[28:04.560 --> 28:09.560] 然后在远程服务器上执行一次install
[28:09.560 --> 28:11.560] 或者说Pipenv sync
[28:11.560 --> 28:15.560] 就可以把里面的所有的依赖全部都复制
[28:15.560 --> 28:17.560] 等于说复制到你的服务器上
[28:17.560 --> 28:21.560] 这样就实现了你的部署的时候
[28:21.560 --> 28:24.560] 不会因为你的机器差异而装的包不一样
[28:24.560 --> 28:28.560] 不知道为什么我会说档这个文件
[28:28.560 --> 28:30.560] 被带跑偏了
[28:30.560 --> 28:32.560] 应该说文件
[28:32.560 --> 28:34.560] OK对我来补充一下
[28:34.560 --> 28:36.560] 可能有的听众不知道Lockfile
[28:36.560 --> 28:37.560] 就是Lock文件是什么
[28:37.560 --> 28:38.560] 它其实就是说白了
[28:38.560 --> 28:42.560] 就是把你所有的当前的依赖版本去做一个Hash
[28:42.560 --> 28:45.560] 然后把那些Hash记在这个Lockfile里面
[28:45.560 --> 28:47.560] 然后因为你比如说
[28:47.560 --> 28:51.560] 你就算同一个版本的库
[28:51.560 --> 28:53.560] 然后你也可能只是版本号相同
[28:53.560 --> 28:55.560] 而它实际的内容不同
[28:55.560 --> 28:57.560] 比如说被一些Hacker给偷偷的替换掉了
[28:57.560 --> 28:59.560] 但是如果你把Hash记起来的话
[28:59.560 --> 29:00.560] 你就可以保证
[29:00.560 --> 29:03.560] Under包的内容是绝对一致的
[29:03.560 --> 29:04.560] 对吧
[29:04.560 --> 29:06.560] 对然后Pipenv就是刚才说到的
[29:06.560 --> 29:08.560] 虚拟环境管理跟依赖管理
[29:08.560 --> 29:12.560] 但是它并没有包含打包发布这一部分
[29:12.560 --> 29:15.560] 因为Pipenv最开始设计的时候
[29:15.560 --> 29:19.560] 就是为了Application的一个依赖管理的
[29:19.560 --> 29:22.560] 它并没有去为Library
[29:22.560 --> 29:24.560] 就是说Python库去服务
[29:24.560 --> 29:25.560] 那Python库的话
[29:25.560 --> 29:28.560] 在Pipenv里面还是推荐用原来的
[29:28.560 --> 29:31.560] setup.py这个文件去做管理
[29:31.560 --> 29:34.560] 所以很多人在用这个工具的时候
[29:34.560 --> 29:36.560] 就会产生疑惑
[29:36.560 --> 29:38.560] 就是如果我是开发一个库的话
[29:38.560 --> 29:40.560] 那我首先要在setup.py里面
[29:40.560 --> 29:42.560] 去写我的install request
[29:42.560 --> 29:43.560] 这样一个列表
[29:43.560 --> 29:46.560] 然后我又要有一个pip file
[29:46.560 --> 29:48.560] 他会觉得这两个比较confusing
[29:48.560 --> 29:49.560] 因为同一份依赖
[29:49.560 --> 29:51.560] 我们要在两个地方写
[29:51.560 --> 29:54.560] 但是这是因为Pipenv最开始设计的时候
[29:54.560 --> 29:56.560] 就是仅仅考虑的是
[29:56.560 --> 30:00.560] Application的一个依赖管理这部分
[30:00.560 --> 30:02.560] 对这个我们下面可以详细聊
[30:02.560 --> 30:05.560] 其实这个又是另外一个话题
[30:05.560 --> 30:08.560] 但我们其实刚才可能听众们发现了
[30:08.560 --> 30:10.560] 我们跳过了一个很重要的部分
[30:10.560 --> 30:12.560] 就是我们一直在说虚拟环境
[30:12.560 --> 30:13.560] 虚拟环境
[30:13.560 --> 30:16.560] 然后虚拟环境的工具到底有哪些呢
[30:16.560 --> 30:18.560] 其实我们还没有介绍对吧
[30:18.560 --> 30:22.560] 然后就是其实不管是Pipenv还是Portrait
[30:22.560 --> 30:24.560] 它底层依赖的应该都是
[30:24.560 --> 30:27.560] Virtualenv或者Venv对吧
[30:27.560 --> 30:29.560] 这两个应该是现在就是
[30:29.560 --> 30:31.560] 两种创建虚拟环境的工具
[30:31.560 --> 30:34.560] 对然后这两个就是
[30:34.560 --> 30:36.560] Virtualenv应该是第三方
[30:36.560 --> 30:38.560] 然后Venv是Python自带的
[30:38.560 --> 30:40.560] 那它们有什么不同吗
[30:40.560 --> 30:41.560] 那这个我来说好了
[30:41.560 --> 30:42.560] 因为明细这样说
[30:42.560 --> 30:46.560] 所以这其实要分三个阶段来看
[30:46.560 --> 30:49.560] 第一个就是四个阶段吧
[30:49.560 --> 30:51.560] 就是一开始当然Python是没有这种东西的
[30:51.560 --> 30:54.560] 所以就是如果你要一个干净的环境
[30:54.560 --> 30:57.560] 你就是重新自己compile一个Python就干净了
[30:57.560 --> 30:59.560] 那后来大家发现说
[30:59.560 --> 31:01.560] 其实因为你重新compile一个Python
[31:01.560 --> 31:03.560] 其实你就是标准库里面的东西是一模一样的
[31:03.560 --> 31:05.560] 那你的interpreter是一模一样的
[31:05.560 --> 31:07.560] 所以就是有人就想到了
[31:07.560 --> 31:09.560] 那其实我们可以把就是
[31:09.560 --> 31:14.560] 那个Python安装套件的那个结构
[31:14.560 --> 31:15.560] 给它复制一个出来
[31:15.560 --> 31:17.560] 然后在运行Python的时候
[31:17.560 --> 31:21.560] 把那个对应的路径给覆盖掉
[31:21.560 --> 31:22.560] 就搞定了
[31:22.560 --> 31:24.560] 所以就是这个应该
[31:24.560 --> 31:27.560] 我记得是enbking就做了一个
[31:27.560 --> 31:30.560] 就叫做Virtualenv的东西来做这件事情
[31:30.560 --> 31:34.560] 那它的原理是用一个叫做site.py的档案
[31:34.560 --> 31:36.560] 那大家可以去查一下这个
[31:36.560 --> 31:38.560] 有在标准库里面有文件
[31:38.560 --> 31:41.560] 就是它可以在Python一开始运行的时候
[31:41.560 --> 31:42.560] 就是它刚开始运行
[31:42.560 --> 31:46.560] 但是还没有执行你给它那个文件的时候
[31:46.560 --> 31:50.560] 去先对就是Python的内部做一些改动
[31:50.560 --> 31:52.560] 所以它就是用site.py这个档案
[31:52.560 --> 31:55.560] 去把你的sys.path全部都给换掉
[31:55.560 --> 31:57.560] 然后就可以达到就是
[31:57.560 --> 32:01.560] import到就是每一个目录结构
[32:01.560 --> 32:04.560] 都可以import它自己内部的套件
[32:04.560 --> 32:07.560] 那后来就是在Python 3.4的时候
[32:07.560 --> 32:09.560] 因为觉得这个主意不错
[32:09.560 --> 32:13.560] 但是就是Virtualenv就是第三方套件
[32:13.560 --> 32:14.560] 那就是有点麻烦
[32:14.560 --> 32:15.560] 而且Python就是
[32:15.560 --> 32:17.560] seePython自己内部的开发
[32:17.560 --> 32:19.560] 有时候也很需要这个功能
[32:19.560 --> 32:22.560] 所以就在标准库里面添加了一个
[32:22.560 --> 32:24.560] 就是venv这个套件
[32:24.560 --> 32:28.560] 那venv这个套件就是比较
[32:28.560 --> 32:31.560] 不知道怎么说就是比较
[32:31.560 --> 32:32.560] 也不是说比较原始
[32:32.560 --> 32:34.560] 就是功能比较少一点
[32:34.560 --> 32:36.560] 就是它基本上是只为了
[32:36.560 --> 32:39.560] 就是CodeDeveloper自己需要的那些功能去服务的
[32:39.560 --> 32:42.560] 所以就是你知道venv在Python
[32:42.560 --> 32:44.560] 它一开始第一次添加是在Python 3.3
[32:44.560 --> 32:47.560] 那它里面是没有自带piff跟setup tools的
[32:47.560 --> 32:48.560] 就是因为他们用不到
[32:48.560 --> 32:50.560] 所以就不自带了
[32:50.560 --> 32:53.560] 那结果后来就是因为你建了一个venv
[32:53.560 --> 32:55.560] 然后还要再去get piff
[32:55.560 --> 32:56.560] 打py实在是太愚蠢了
[32:56.560 --> 32:58.560] 所以后来就至少
[32:58.560 --> 33:00.560] 好那我们就添加个piff吧这样子
[33:00.560 --> 33:02.560] 所以3.4开始才有piff的
[33:02.560 --> 33:04.560] 对那最近呢就是
[33:04.560 --> 33:09.560] 因为virtualenv它就是架构比较古老
[33:09.560 --> 33:12.560] 但是在那个venv出现了之后
[33:12.560 --> 33:15.560] 它对那个就是interpreter内部
[33:15.560 --> 33:16.560] 做了一些改动
[33:16.560 --> 33:20.560] 让它可以原生支持就是虚拟环境这个概念
[33:20.560 --> 33:22.560] 就是Python现在可以原生有
[33:22.560 --> 33:25.560] 就是认识到自己是不是跑在一个虚拟环境里面
[33:25.560 --> 33:26.560] 所以这个叫做
[33:26.560 --> 33:29.560] 我忘了这个叫做pp多少了
[33:29.560 --> 33:31.560] 好像是503之类的吧
[33:31.560 --> 33:33.560] 忘记了随便讲个数字
[33:33.560 --> 33:35.560] 那就是有了这个piff之后
[33:35.560 --> 33:38.560] 就是virtualenv 20.0开始
[33:38.560 --> 33:40.560] 就是它也改了架构
[33:40.560 --> 33:43.560] 就是让它跟venv能够完全相容
[33:43.560 --> 33:46.560] 就是你一个python就是跑在一个
[33:46.560 --> 33:50.560] virtualenv 20.0的环境里面
[33:50.560 --> 33:52.560] 它是分不出来自己是跑在virtualenv
[33:52.560 --> 33:54.560] 还是venv串建的环境里面的
[33:54.560 --> 33:57.560] 所以现在基本上有三种解决方案
[33:57.560 --> 33:59.560] 就是旧的virtualenv
[33:59.560 --> 34:01.560] 然后标准库的venv
[34:01.560 --> 34:05.560] 跟virtualenv 20.0以后的版本
[34:05.560 --> 34:06.560] 够复杂吗
[34:06.560 --> 34:10.560] 我觉得对
[34:10.560 --> 34:14.560] 就是可能听众们都听过那个
[34:14.560 --> 34:15.560] Zen of Python
[34:15.560 --> 34:17.560] 就是Python的哲学里面
[34:17.560 --> 34:21.560] 就是说应该是只有最好是只有一种方法
[34:21.560 --> 34:23.560] 只有一种最好的方法来做一件事
[34:23.560 --> 34:26.560] 然后就是我听你们讲很多这些依赖管理
[34:26.560 --> 34:28.560] 然后虚拟环境的东西
[34:28.560 --> 34:32.560] 就感觉这些是非常违背python的哲学
[34:32.560 --> 34:35.560] 对因为就是怎么说
[34:35.560 --> 34:37.560] 对core developer来讲
[34:37.560 --> 34:41.560] 就是那个有权限添加那个标准库的人
[34:41.560 --> 34:43.560] 而言是只有一个obvious way
[34:43.560 --> 34:44.560] 那就是venv
[34:44.560 --> 34:46.560] 那其他你们这个我们都不用管的
[34:46.560 --> 34:49.560] 所以对他们而言这是obvious way
[34:49.560 --> 34:52.560] 但是对其他人来讲就不是了
[34:52.560 --> 34:56.560] 因为他们的obvious way我们就用不了
[34:56.560 --> 34:57.560] 太原始了
[34:57.560 --> 34:58.560] 如果是最
[34:58.560 --> 35:00.560] 如果就是以一般人而言
[35:00.560 --> 35:01.560] 我自己也是
[35:01.560 --> 35:04.560] 就是如果你只想要一个方法的话
[35:04.560 --> 35:07.560] 那我建议就是装最新版的virtualenv
[35:07.560 --> 35:08.560] 这是应该是
[35:08.560 --> 35:11.560] 对这是最快最经济
[35:11.560 --> 35:14.560] 而且就是速度也最快的一个方案
[35:14.560 --> 35:16.560] 打断一下不好意思
[35:16.560 --> 35:19.560] 那TP刚才如果讲的比较硬核的话
[35:19.560 --> 35:22.560] 我可以简单的说一下
[35:22.560 --> 35:25.560] 就是venv跟那个virtualenv
[35:25.560 --> 35:29.560] 20.0版本之前的virtualenv有什么区别
[35:29.560 --> 35:31.560] 就是假如说你有一个virtualenv
[35:31.560 --> 35:35.560] 然后你是用3.8.2去创建的
[35:35.560 --> 35:37.560] 然后假如你的这个3.8.2升级了
[35:37.560 --> 35:38.560] 然后是inplace升级
[35:38.560 --> 35:40.560] 直接把它换成3.8.3
[35:40.560 --> 35:44.560] 那么virtualenv它20.0版本之前
[35:44.560 --> 35:45.560] 创建的那个虚拟环境
[35:45.560 --> 35:46.560] 这是直接用不了的
[35:46.560 --> 35:49.560] 而venv是可以的
[35:49.560 --> 35:53.560] 因为它的那个读取Python路径的方法不一样
[35:53.560 --> 35:58.560] 当然了现在它那个virtualenv升到20版本以后
[35:58.560 --> 36:02.560] 它已经和venv行为差不多了
[36:02.560 --> 36:06.560] 而且我感觉它创建起来还稍微更快一点
[36:06.560 --> 36:08.560] 所以我也是推荐大家
[36:08.560 --> 36:10.560] 现在如果创建虚拟环境的话
[36:10.560 --> 36:13.560] 就直接只用一个virtualenv就可以了
[36:13.560 --> 36:17.560] 好两位都是推荐用virtualenv
[36:17.560 --> 36:20.560] ok那这个应该是比较明确了
[36:20.560 --> 36:23.560] 因为我们是PyPA的成员嘛
[36:23.560 --> 36:25.560] 所以PyPA当然推荐自己的包
[36:25.560 --> 36:30.560] PyPA和Python官方还不太一样
[36:30.560 --> 36:32.560] 这个太有意思了
[36:32.560 --> 36:37.560] 那小白你平时工作的时候会用虚拟环境吗
[36:37.560 --> 36:41.560] 会我是直接用的那个pyenv
[36:41.560 --> 36:44.560] 就是它会集成一个virtualenv
[36:44.560 --> 36:47.560] pyenv可不集成virtualenv
[36:47.560 --> 36:50.560] 它在那个Mac上它是有一个插件的
[36:50.560 --> 36:54.560] 就是pyenv-virtualenv
[36:54.560 --> 36:57.560] 对对对它需要是这个是另外一个
[36:57.560 --> 36:59.560] 这个和pyenv还不是一个
[36:59.560 --> 37:01.560] 对这是要另外装的
[37:01.560 --> 37:04.560] 那好吧我是用的就是
[37:04.560 --> 37:06.560] 对我是用的这个pyenv
[37:06.560 --> 37:10.560] 然后配合这个pyenv-virtualenv
[37:10.560 --> 37:12.560] 对你平时是这样
[37:12.560 --> 37:14.560] 我觉得用起来还挺舒服的
[37:14.560 --> 37:16.560] 我也是这么用的其实
[37:16.560 --> 37:20.560] 对pyenv的那个virtualenv插件
[37:20.560 --> 37:24.560] 它其实下面用的还是上面说的这两个
[37:24.560 --> 37:28.560] 它首先会检查你当前路径里面
[37:28.560 --> 37:29.560] 有没有安装virtualenv
[37:29.560 --> 37:33.560] 如果没有的话它就会用python自带的venv
[37:33.560 --> 37:36.560] 所以你用pyenv的话
[37:36.560 --> 37:37.560] 其实用的还是这两个
[37:37.560 --> 37:39.560] 对就其他工具其实都是
[37:39.560 --> 37:41.560] 要么是venv上面包一层
[37:41.560 --> 37:42.560] 要么是virtualenv上面包一层
[37:42.560 --> 37:43.560] 或者是在两个中选一个
[37:43.560 --> 37:45.560] 刚才好像又提到一个pyenv
[37:45.560 --> 37:47.560] 其实我们之前都没有写在
[37:47.560 --> 37:49.560] 就是这个要讲的东西里面
[37:49.560 --> 37:51.560] 就这部分这部分酷太多了
[37:51.560 --> 37:54.560] 但我们既然提到就还是提一下吧
[37:54.560 --> 37:57.560] 然后pyenv我用的比较多
[37:57.560 --> 37:58.560] 所以我来说一下吧
[37:58.560 --> 38:01.560] 就是pyenv它是干什么的
[38:01.560 --> 38:02.560] 它既不是虚拟环境
[38:02.560 --> 38:03.560] 也不是依赖管理
[38:03.560 --> 38:07.560] 它是一个帮你装不同的python版本的东西
[38:07.560 --> 38:10.560] 这个不同的python版本不是虚拟环境
[38:10.560 --> 38:12.560] 因为你虚拟环境实际上是
[38:12.560 --> 38:15.560] 从同一个已经安装的python版本上来
[38:15.560 --> 38:17.560] 就相当于派生出不同的
[38:17.560 --> 38:20.560] 就是都是使用这个版本的python的环境
[38:20.560 --> 38:22.560] 然后pyenv它是
[38:22.560 --> 38:25.560] 比如说你想装一个3.7.1
[38:25.560 --> 38:27.560] 又想装一个3.7.2
[38:27.560 --> 38:29.560] 又想装一个3.8.2
[38:29.560 --> 38:31.560] 然后你想同时装这些
[38:31.560 --> 38:33.560] 然后那怎么办呢
[38:33.560 --> 38:35.560] 你就可以直接先装一个pyenv
[38:35.560 --> 38:37.560] 然后pyenv install
[38:37.560 --> 38:38.560] 比如说3.7.1
[38:38.560 --> 38:40.560] pyenv install 3.7.2
[38:40.560 --> 38:42.560] 然后这些都可以装上
[38:42.560 --> 38:46.560] 它其实就可以说节省了你直接去python官网
[38:46.560 --> 38:48.560] 然后把那个包下下来
[38:48.560 --> 38:51.560] 或者用你的比如说homebrew
[38:51.560 --> 38:56.560] 或者是其他系统自带的包管理
[38:56.560 --> 39:00.560] 来装这些python版本的一个时间吧
[39:00.560 --> 39:03.560] 我其实不知道pyenv除了
[39:03.560 --> 39:06.560] 安装python然后切换不同的python版本
[39:06.560 --> 39:08.560] 还有没有什么别的功能
[39:08.560 --> 39:10.560] 感觉应该也就这些差不多
[39:10.560 --> 39:13.560] 然后对常用的就这两个
[39:13.560 --> 39:15.560] 对我记得那个Node.js里面
[39:15.560 --> 39:18.560] Node.js里面也有一个类似的那个叫什么来着
[39:18.560 --> 39:19.560] 是叫N吗
[39:19.560 --> 39:21.560] NVM
[39:21.560 --> 39:22.560] NVM还是N
[39:22.560 --> 39:28.560] 对反正也是pyenv最开始是模仿那个RBENV来的
[39:28.560 --> 39:32.560] 就是Ruby的那个也是类似的
[39:32.560 --> 39:34.560] 哦OK
[39:34.560 --> 39:36.560] 然后你比如说你安了pyenv之后
[39:36.560 --> 39:42.560] 你就可以在不同的系统的路径下
[39:42.560 --> 39:45.560] 指定它当前要用的这个python的版本
[39:45.560 --> 39:48.560] 然后你在这个环境下
[39:48.560 --> 39:50.560] 比如说你用pyenv指定一个python版本
[39:50.560 --> 39:53.560] 然后你再用virtualenv创建一个虚拟环境
[39:53.560 --> 39:55.560] 它实际上就会默认使用
[39:55.560 --> 39:57.560] 当前你的这个python版本
[39:57.560 --> 40:00.560] 当然你也可以用pyenv-virtualenv
[40:00.560 --> 40:02.560] 就是也方便一些
[40:02.560 --> 40:05.560] 好然后聊完了那个pyenv
[40:05.560 --> 40:09.560] 我们再切回就是依赖管理这个话题
[40:09.560 --> 40:12.560] 然后就是pyenv出了之后
[40:12.560 --> 40:16.560] 就感觉python的就是依赖管理这块
[40:16.560 --> 40:19.560] 好像又大家又开始创建很多新的工具了
[40:19.560 --> 40:22.560] 然后其中比较流行的一个就是portrait
[40:22.560 --> 40:24.560] 然后portrait其实也是我特别喜欢
[40:24.560 --> 40:26.560] 并且我一直在用的一个库
[40:26.560 --> 40:30.560] 然后我不知道两位对于portrait是有什么看法
[40:30.560 --> 40:31.560] 你们可以来聊一聊
[40:31.560 --> 40:33.560] 要不明星你先聊一下
[40:33.560 --> 40:35.560] 你作为portrait的对手
[40:35.560 --> 40:38.560] pyenv的维护者肯定有些看法
[40:38.560 --> 40:39.560] 没有没有
[40:39.560 --> 40:43.560] 我也是觉得poetry非常好用
[40:43.560 --> 40:46.560] 首先它的UI是比较好看的
[40:46.560 --> 40:49.560] 然后的话它的依赖解析的部分
[40:49.560 --> 40:53.560] 不像pyenv它是wrap了tools
[40:53.560 --> 40:58.560] poetry它的依赖解析是它完全自己开发的一个工具
[40:58.560 --> 41:00.560] 叫mixology
[41:00.560 --> 41:05.560] 它现在是嵌在poetry的项目里面的
[41:05.560 --> 41:10.560] 所以pbmv跟poetry可能你解析起同一个依赖的话
[41:10.560 --> 41:12.560] 它的行为有可能会不一致
[41:12.560 --> 41:14.560] 这是因为它们的依赖解析不一样
[41:14.560 --> 41:16.560] 然后poetry它还有一个特点是
[41:16.560 --> 41:23.560] 它把依赖定义在pyproject.toml这个文件里面
[41:23.560 --> 41:31.560] 这个文件也是最新的python推荐的一个文件格式
[41:31.560 --> 41:38.560] 而且它同时还实现了pip517的build
[41:38.560 --> 41:41.560] 就是说poetry的项目
[41:41.560 --> 41:45.560] 你可以完全不需要之前的setup.py这个文件
[41:45.560 --> 41:48.560] 你只需要一个pyproject.toml这个文件
[41:48.560 --> 41:54.560] 然后peep也能正常的安装poetry的包
[41:54.560 --> 41:59.560] 所以poetry它是比ppmv多了一部分
[41:59.560 --> 42:02.560] 就是把包发布的这部分
[42:02.560 --> 42:04.560] 我问一个问题
[42:04.560 --> 42:09.560] 它pyproject.toml是官方的吗
[42:09.560 --> 42:14.560] 这个是定义在peep518里面的一个标准的文件格式
[42:14.560 --> 42:21.560] 它是推荐其他外部工具里面的
[42:21.560 --> 42:25.560] 其实更多意义上是跟打包相关的工具
[42:25.560 --> 42:29.560] 把它的配置写到pyproject.toml里面
[42:29.560 --> 42:35.560] 也就是说这个东西的服务对象是那些
[42:35.560 --> 42:39.560] 编写需要打包的程序的程序员吗
[42:39.560 --> 42:42.560] 还是说像我这种写外部开发的也可以用
[42:42.560 --> 42:49.560] 你可以理解为node的package.json这个文件
[42:49.560 --> 42:53.560] 对,这个是最接近node的package.json的
[42:53.560 --> 43:02.560] 明白了,但是为什么我没有看到官方在推这个东西
[43:02.560 --> 43:05.560] 官方的部分我说一下好了
[43:05.560 --> 43:13.560] 因为大家都觉得你去看python packaging guide
[43:13.560 --> 43:16.560] 就是packaging.python.org
[43:16.560 --> 43:18.560] 那个是官方的文件
[43:18.560 --> 43:20.560] 其实也不是那个
[43:20.560 --> 43:22.560] 其实就是一个Github上面的repo
[43:22.560 --> 43:24.560] 然后大家都可以去贡献的
[43:24.560 --> 43:27.560] 所以为什么写portrait少,ppm多
[43:27.560 --> 43:29.560] 其实原因很简单
[43:29.560 --> 43:33.560] 就是因为有人提交了ppm pull request
[43:33.560 --> 43:36.560] 没有人提交portrait pull request
[43:36.560 --> 43:38.560] 就是这么简单的原因
[43:38.560 --> 43:40.560] 我觉得就是说
[43:40.560 --> 43:43.560] 其实关于pyproject.toml
[43:43.560 --> 43:45.560] 我和TP的观点是有点不同
[43:45.560 --> 43:48.560] 我们之前在群里也提到过
[43:48.560 --> 43:51.560] 就像刚才明锡说的pyproject.toml
[43:51.560 --> 43:55.560] 一开始其实是只是让打包的一些工具
[43:55.560 --> 43:57.560] 把它的一些配置写在里面
[43:57.560 --> 44:00.560] 但它现在其实逐渐变成了一个
[44:00.560 --> 44:07.560] 就是所有的python周边的一些生态的库
[44:07.560 --> 44:09.560] 比如说一些linter
[44:09.560 --> 44:11.560] 或者是像black
[44:11.560 --> 44:14.560] 就是这种做formatter的工具
[44:14.560 --> 44:18.560] 它都会把配置放在pyproject.toml里
[44:18.560 --> 44:21.560] 然后我个人觉得其实这是一件挺好的事情
[44:21.560 --> 44:23.560] 但是TP可能不太同意
[44:23.560 --> 44:26.560] 就是说我觉得往后可能这个东西会逐渐的
[44:26.560 --> 44:28.560] 越来越被大家接受
[44:28.560 --> 44:31.560] 就因为它有一些在我看来显著的优势
[44:31.560 --> 44:35.560] 就是它能让你的配置文件都放在一个里面
[44:35.560 --> 44:37.560] TP你想反驳我吗
[44:37.560 --> 44:39.560] 感觉你要反驳我的样子
[44:39.560 --> 44:41.560] 没有,我觉得这就是个人偏好
[44:41.560 --> 44:44.560] 而且我个人觉得
[44:44.560 --> 44:47.560] 这个也不是那么明显的事情
[44:47.560 --> 44:51.560] 就是大家都很期望可以把设定放在同一个档案里面
[44:51.560 --> 44:53.560] 但是你看就是放眼
[44:53.560 --> 44:58.560] 看各个社群各个生态系其实都没有这么做
[44:58.560 --> 45:02.560] 就是像node你也是要写一个package.json
[45:02.560 --> 45:04.560] 然后写一个webpack的文件
[45:04.560 --> 45:08.560] 然后写一个JSlinter的文件
[45:08.560 --> 45:11.560] 然后写一个不知道什么东西都要写一个文件
[45:11.560 --> 45:12.560] 其实也是分开的
[45:12.560 --> 45:21.560] 那你看rost的cargo跟cargo的linter叫什么忘了
[45:21.560 --> 45:26.560] 就是cargo跟clippy的配置文件也是分开的
[45:26.560 --> 45:28.560] 那其实就是大家都是分开的
[45:28.560 --> 45:33.560] 所以可能分开的才是一个自然发展的状态吧
[45:33.560 --> 45:36.560] OK,那对,这就是不同观点了
[45:36.560 --> 45:44.560] 但是我觉得像javascript它那个webpack跟package.json分开
[45:44.560 --> 45:46.560] 是因为它两个的功能不太一样吧
[45:46.560 --> 45:48.560] 它们是按功能去分的
[45:48.560 --> 45:50.560] 一个是依赖管理,一个是打包管理
[45:50.560 --> 45:52.560] 是这样吧
[45:52.560 --> 45:56.560] 对啊,所以就是像linter就是进linter自己的设定
[45:56.560 --> 45:58.560] 那打包就是进打包的设定
[45:58.560 --> 46:00.560] 我是这样觉得的
[46:00.560 --> 46:09.560] 那也就是说这个pyproject.tom它是混在一起的吗
[46:09.560 --> 46:12.560] 对,它就是所有工具,每个工具有一个entry
[46:12.560 --> 46:14.560] 就是所有东西都在这个文件里
[46:14.560 --> 46:16.560] 哦,明白了,好吧
[46:16.560 --> 46:18.560] OK,这个话题我们就打住了
[46:18.560 --> 46:20.560] 因为我又想说很多东西了
[46:20.560 --> 46:22.560] 然后对,就其实我们已经
[46:22.560 --> 46:25.560] 好,我们就介绍一下portrait嘛
[46:25.560 --> 46:29.560] 其实我觉得就portrait和p5哪个更好用
[46:29.560 --> 46:31.560] 其实我觉得大家见仁见智了
[46:31.560 --> 46:34.560] 但是就是说如果你是一个python core的开发者
[46:34.560 --> 46:36.560] 你可能还是更需要portrait一些
[46:36.560 --> 46:40.560] 因为就是p5没有这个打包成library的功能
[46:40.560 --> 46:44.560] 但是就是除了这两个非常流行的工具之外
[46:44.560 --> 46:46.560] 还有另外一个就是和以前
[46:46.560 --> 46:49.560] 和上述我们说的这些都有点不同的东西
[46:49.560 --> 46:53.560] 它也非常流行,然后它是conda
[46:53.560 --> 46:57.560] 然后就是说其实我关于conda一直
[46:57.560 --> 47:00.560] 就怎么说,就是有点
[47:00.560 --> 47:03.560] 它的流行程度有点超出我想象
[47:03.560 --> 47:07.560] 因为我以及我周边的人感觉好像都没有在用
[47:07.560 --> 47:09.560] 但是呢我又看到一些调查
[47:09.560 --> 47:13.560] 就是说好像有百分之可能四五十的人
[47:13.560 --> 47:15.560] python开发者都在用conda
[47:15.560 --> 47:18.560] 我就觉得还挺震惊的
[47:18.560 --> 47:21.560] 所以就不知道你们对于conda怎么看
[47:21.560 --> 47:24.560] 它肯定还是解决了一些问题的
[47:24.560 --> 47:26.560] 我来说一下吧
[47:26.560 --> 47:29.560] 那conda它最大的杀手特性
[47:29.560 --> 47:34.560] 就是它可以把你的整个环境都把它给freeze下来
[47:34.560 --> 47:38.560] freeze成一个environment yaml文件
[47:38.560 --> 47:39.560] 然后这个yaml文件
[47:39.560 --> 47:42.560] 然后你把这个yaml文件推到别的机器上
[47:42.560 --> 47:46.560] 然后也用conda从这里面就能复制出一模一样的环境出来
[47:46.560 --> 47:49.560] 但是呢它跟peep有一点不同的地方
[47:49.560 --> 47:52.560] 就是conda它的源是独立的
[47:52.560 --> 47:54.560] 就是它是有一个自己的源的
[47:54.560 --> 47:57.560] 所以它这个源里面有什么好处
[47:57.560 --> 47:59.560] 就是它有它解决了一些
[47:59.560 --> 48:02.560] 比如说你windows上装那个
[48:02.560 --> 48:04.560] 装那个二进制的那种版本很困难
[48:04.560 --> 48:07.560] 因为很多需要那种编译的那种包
[48:07.560 --> 48:12.560] 那么conda就提供了这个很完善的binary的wheel
[48:12.560 --> 48:14.560] 在它的源里面
[48:14.560 --> 48:17.560] 当然了你conda同样也可以装peep
[48:17.560 --> 48:20.560] 就是说如果你在conda里面装peep
[48:20.560 --> 48:23.560] 你也同样可以用peep去安装pypy上面的包
[48:23.560 --> 48:27.560] 所以conda这个用的人多
[48:27.560 --> 48:30.560] 其实还是一个原因也是
[48:30.560 --> 48:33.560] 因为它主要是服务于科学计算的
[48:33.560 --> 48:37.560] 因为它是最开始是anaconda里面的
[48:37.560 --> 48:38.560] 附属的一个东西
[48:38.560 --> 48:43.560] anaconda就是也是专门为科学计算的一个python的
[48:43.560 --> 48:46.560] 发布版本
[48:46.560 --> 48:52.560] 对所以你如果是科学计算的这个技术站的话
[48:52.560 --> 48:54.560] 比如numpy比如说sklearn
[48:54.560 --> 48:58.560] 那你可能就我会比较推荐用conda了
[48:58.560 --> 49:01.560] 就说我说一个我理解你们看对不对
[49:01.560 --> 49:07.560] conda是pyenv加peep加virtualenv加peepenv加portrait
[49:07.560 --> 49:11.560] 就把这些全部集成在一个东西里面
[49:11.560 --> 49:12.560] 是吗
[49:12.560 --> 49:14.560] 它有没有依赖解析的部分
[49:14.560 --> 49:15.560] 这个我不太了解
[49:15.560 --> 49:17.560] 我不太确定它有没有这个
[49:17.560 --> 49:19.560] 它可能没有吗
[49:19.560 --> 49:20.560] 那它如果没有的话
[49:20.560 --> 49:23.560] 岂不是就会遇到很多问题
[49:23.560 --> 49:27.560] 它有但是是不太一样的依赖解析
[49:27.560 --> 49:31.560] 就是conda的就是conda运作原理
[49:31.560 --> 49:32.560] 其实你要说像peep
[49:32.560 --> 49:35.560] 其实它比较像apt或者像homebrew
[49:35.560 --> 49:38.560] 就是它其实是一个系统管理包
[49:38.560 --> 49:39.560] 系统包管理器
[49:39.560 --> 49:42.560] 就是它所有的东西都是在它一个系统下面的
[49:42.560 --> 49:46.560] 就是假设你在mac上面装一个conda
[49:46.560 --> 49:48.560] 然后用conda装一个环境
[49:48.560 --> 49:51.560] 它其实是从python开始装起的
[49:51.560 --> 49:52.560] 就是它会先装个python
[49:52.560 --> 49:54.560] 然后建立一个python的环境
[49:54.560 --> 49:58.560] 然后再往那个环境里面安装东西
[49:58.560 --> 50:00.560] 所以它其实比较像是一个系统管理
[50:00.560 --> 50:02.560] 就是系统包管理器
[50:02.560 --> 50:05.560] 那它的好处就是
[50:05.560 --> 50:07.560] 因为它是系统包管理器
[50:07.560 --> 50:10.560] 所以基本上它什么东西都是预先设定好
[50:10.560 --> 50:12.560] 就像apt或者是homebrew一样
[50:12.560 --> 50:15.560] 就是它所有的包都是
[50:15.560 --> 50:16.560] 怎么说呢
[50:16.560 --> 50:19.560] 都是它有好好的管理的
[50:19.560 --> 50:21.560] 就是它知道这些东西会怎么样冲突
[50:21.560 --> 50:22.560] 怎么样不冲突
[50:22.560 --> 50:24.560] 就是它可以预先知道
[50:24.560 --> 50:28.560] 所以它在那个environment.yaml里面
[50:28.560 --> 50:29.560] 就可以写得非常精简
[50:29.560 --> 50:33.560] 因为它只要有一些非常基础的设定
[50:33.560 --> 50:39.560] 它就可以直接去它之前已经规划好的那些套件里面
[50:39.560 --> 50:40.560] 去选择需要的套件
[50:40.560 --> 50:43.560] 那pypi就是像pip它
[50:43.560 --> 50:49.560] 基本上pypi是所有人都可以随时都可以上传新的套件
[50:49.560 --> 50:54.560] 所以它要达到可以lock的状态
[50:54.560 --> 50:56.560] 就是比较复杂一些
[50:56.560 --> 50:58.560] 对
[50:58.560 --> 51:01.560] 反正就是说我感觉
[51:01.560 --> 51:06.560] 可能是不是对于一个新入门python的人来讲
[51:06.560 --> 51:10.560] 用conda上手是一件相对更容易的事情
[51:10.560 --> 51:11.560] 你们觉得
[51:11.560 --> 51:12.560] 因为它都包含了嘛
[51:12.560 --> 51:14.560] 然后你也不用想太多
[51:14.560 --> 51:16.560] 你就用它这个就好了
[51:16.560 --> 51:18.560] 对我也觉得是这样子
[51:18.560 --> 51:21.560] 但是缺点就是你可能用不到最新的套件
[51:21.560 --> 51:24.560] 因为就是你新的套件释出了
[51:24.560 --> 51:28.560] 那那个conda官方还需要先审核过
[51:28.560 --> 51:29.560] 然后重新打包
[51:29.560 --> 51:31.560] 然后才能进他们的库
[51:31.560 --> 51:33.560] ok了解
[51:33.560 --> 51:38.560] 然后就我们其实花了比预想中更多的时间
[51:38.560 --> 51:41.560] 来介绍一些现在一些主流的
[51:41.560 --> 51:44.560] 就是和python工作流相关的工具
[51:44.560 --> 51:49.560] 然后就是这方面的内容其实还远远不止我们聊的这些
[51:49.560 --> 51:52.560] 然后我们在show notes里面也会提供一些链接
[51:52.560 --> 51:54.560] 然后方便听众们进一步的去了解
[51:54.560 --> 51:58.560] 那么我们下面来聊一聊嘉宾们最近的工作吧
[51:58.560 --> 52:03.560] 因为两位其实都有在做一些自己的工具
[52:03.560 --> 52:05.560] 工具实在太多了
[52:05.560 --> 52:08.560] 对然后我们就从TP开始吧
[52:08.560 --> 52:12.560] 然后你有在做一个叫做pyem的工具
[52:12.560 --> 52:13.560] 对吧
[52:13.560 --> 52:15.560] pyem基本上是environment manager
[52:15.560 --> 52:19.560] 就是它是用来管理虚拟环境
[52:19.560 --> 52:25.560] 就是它的出发环就是前面就是明细的那个blog post里面有提到说
[52:25.560 --> 52:29.560] 就是python的工作流就是虚拟环境管理依赖管理跟打包嘛
[52:29.560 --> 52:32.560] 那就是后面两个基本上我们做的还是
[52:32.560 --> 52:35.560] 就是python社群里面做的还是不错的
[52:35.560 --> 52:38.560] 但是前面一个其实就是做的没有很好
[52:38.560 --> 52:45.560] 就是虽然说virtualenv跟vnv在技术上是非常的完善了
[52:45.560 --> 52:48.560] 但是它对初学者是不太友好的
[52:48.560 --> 52:52.560] 就是你必须要学会用那个命令列
[52:52.560 --> 52:54.560] 然后你还需要会
[52:54.560 --> 52:57.560] 就如果说你用Mac或用Linux还需要会用source
[52:57.560 --> 52:59.560] 知道source是什么东西
[52:59.560 --> 53:01.560] 然后还要deactivate才可以去切换
[53:01.560 --> 53:04.560] 所以在对初学者上面是比较不友好的
[53:04.560 --> 53:10.560] 那之前那个Steve Dower就提出了一个新的PPP
[53:10.560 --> 53:17.560] 就是可以就是那个底线底线拍package这个标准嘛
[53:17.560 --> 53:20.560] 那之前在别的地方有聊到
[53:20.560 --> 53:23.560] 但是这个标准就是有另外的问题
[53:23.560 --> 53:28.560] 就是它没有办法去很正确的很完整的识别一个python
[53:28.560 --> 53:33.560] 就是这个标准里面它只就是识别了就是python的版本号
[53:33.560 --> 53:35.560] 但是它没有识别其他一些
[53:35.560 --> 53:39.560] 例如说python是32bit还是64bit还是ARM
[53:39.560 --> 53:41.560] 或者是说你在Windows上面
[53:41.560 --> 53:45.560] 如果你用那个Windows Subsystem for Linux的话
[53:45.560 --> 53:49.560] 你可能会同时需要管理Windows跟Linux的虚拟环境
[53:49.560 --> 53:52.560] 那这些东西它都没有办法兼顾
[53:52.560 --> 53:57.560] 所以这个工具其实本质上是一个过渡性的工具
[53:57.560 --> 54:01.560] 就是我是想要用它来就是了解说
[54:01.560 --> 54:06.560] 我到底需要就是一个工具到底需要知道多少东西
[54:06.560 --> 54:08.560] 才可以很正确的识别一个python
[54:08.560 --> 54:14.560] 然后最终的目标是把这个东西就是提成一个PPP
[54:14.560 --> 54:17.560] 然后就是让别的工具来使用
[54:17.560 --> 54:26.560] 就是让例如说Portrait啊或者是PPM能够就是很正确的管理很多个
[54:26.560 --> 54:29.560] 就是在同一个专案下面管理很多个虚拟环境
[54:29.560 --> 54:31.560] 然后可以正确的去识别它们
[54:31.560 --> 54:38.560] 也就是说相当于你的PYEM是类似于去实现了那个
[54:38.560 --> 54:40.560] 刚才你提到的那个PEP对吧
[54:40.560 --> 54:42.560] 是这样吗还是说
[54:42.560 --> 54:48.560] 它是我是希望能够重新写过那个PEP
[54:48.560 --> 54:51.560] 就是因为那个PEP就是它只有分版本号
[54:51.560 --> 54:54.560] 所以我只做了一个不一样的实现
[54:54.560 --> 54:56.560] 就相当于因为那个你提PEP的时候
[54:56.560 --> 54:59.560] 可能你也要提一个就是reference implementation
[54:59.560 --> 55:01.560] 就是你要先实现一遍
[55:01.560 --> 55:03.560] 然后你这个就相当于是你在实现一个
[55:03.560 --> 55:05.560] 然后你再去修改它的PEP
[55:05.560 --> 55:07.560] 就这样你就可以说我现在已经有这样一个东西了
[55:07.560 --> 55:09.560] 然后你们可以来试一下
[55:09.560 --> 55:11.560] 就它比原来的好很多
[55:11.560 --> 55:13.560] 那希望你成功啊
[55:13.560 --> 55:17.560] 就是因为我认识的人里还没有就是真正去提PEP
[55:17.560 --> 55:20.560] 我之前一直鼓动张强去提但是他也没有提
[55:20.560 --> 55:22.560] 然后就是我还想了解一点
[55:22.560 --> 55:24.560] 就是PYEM你刚才说是
[55:24.560 --> 55:30.560] 为了解决现在一些就是识别Python版本的问题
[55:30.560 --> 55:33.560] 那你这个就假设你最终提了一个PEP
[55:33.560 --> 55:34.560] 并且被接受了
[55:34.560 --> 55:40.560] 那它和VEMV和那个VirtualEMV的关系又是怎么样的呢
[55:40.560 --> 55:42.560] 它是怎么协同工作的呢
[55:42.560 --> 55:47.560] 基本上就是它底层可能还是会用VEMV或VirtualEMV
[55:47.560 --> 55:50.560] 或者是用别的其他的技术
[55:50.560 --> 55:52.560] 这个再说
[55:52.560 --> 55:55.560] 但是主要的就是它要用来
[55:55.560 --> 56:00.560] 就是它的功能不是去建立一个VirtualEMV
[56:00.560 --> 56:04.560] 而是例如说使用者告诉我说我要Python 3.8
[56:04.560 --> 56:07.560] 那我要怎么去把这个3.8去对应到
[56:07.560 --> 56:09.560] 他想要的那个VirtualEMV
[56:09.560 --> 56:11.560] 而不用他自己去那个路径里面
[56:11.560 --> 56:15.560] 提那个路径然后activate它才找得到
[56:15.560 --> 56:16.560] OK
[56:16.560 --> 56:17.560] 我大概明白
[56:17.560 --> 56:23.560] 就相当于你是一个中间的一层
[56:23.560 --> 56:27.560] 就相当于可以集成到现在的虚拟环境管理里面
[56:27.560 --> 56:30.560] 就是他们如果用了你这个就会更
[56:30.560 --> 56:33.560] 就相当于他们有些功能就能更方便的实现
[56:33.560 --> 56:34.560] 对
[56:34.560 --> 56:37.560] 就例如说像那个PEP EMV跟
[56:37.560 --> 56:39.560] 我不确定Portrait现在是不是这样
[56:39.560 --> 56:41.560] 就是至少我之前看的时候是这样
[56:41.560 --> 56:44.560] 就是一个专案是只能对应一个虚拟环境的
[56:44.560 --> 56:45.560] 就是为什么呢
[56:45.560 --> 56:47.560] 因为你就是如果对应两个虚拟环境
[56:47.560 --> 56:50.560] 我怎么知道你什么时候要用哪一个
[56:50.560 --> 56:53.560] 那就是希望能够提供一个中间层
[56:53.560 --> 56:57.560] 让这些专案能够解决这个问题
[56:57.560 --> 56:59.560] 就是你可能要同时
[56:59.560 --> 57:02.560] 就是如果你要开发就是一个package的时候
[57:02.560 --> 57:03.560] 你可能要测
[57:03.560 --> 57:06.560] 就是我可能主要是在3.8上开发
[57:06.560 --> 57:07.560] 但是我有时候要测试一下
[57:07.560 --> 57:10.560] 我在2.7上面到底能不能跑
[57:10.560 --> 57:11.560] 对
[57:11.560 --> 57:13.560] 但是TOX也是一样的状况
[57:13.560 --> 57:17.560] 就是TOX也只能识别Python版本号
[57:17.560 --> 57:21.560] 就是没有办法识别其他的
[57:21.560 --> 57:25.560] 就是其他的Python特性吧
[57:25.560 --> 57:29.560] 就例如说位元之类的
[57:29.560 --> 57:31.560] 就它的功能还是比较局限
[57:31.560 --> 57:34.560] 就例如说32位元64位元
[57:34.560 --> 57:40.560] 这可能只有像我这种用Windows才会遇到的问题
[57:40.560 --> 57:42.560] 我可以告诉你一下我现在是怎么做的
[57:42.560 --> 57:45.560] 这个是我日常的工作流的一部分
[57:45.560 --> 57:48.560] 就是说我是用TOX
[57:48.560 --> 57:49.560] 就TOX
[57:49.560 --> 57:52.560] 然后在TOX里面你可以写上多个Python的不同版本
[57:52.560 --> 57:55.560] 然后你用TOX来跑测试的时候
[57:55.560 --> 57:59.560] 它会每个版本跟你单独再起一个虚拟环境去跑这个测试
[57:59.560 --> 58:02.560] 其实是可以实现至少在测试层面
[58:02.560 --> 58:04.560] cover多个Python版本这样的需求
[58:04.560 --> 58:05.560] 对
[58:05.560 --> 58:11.560] 但是你还是要手动去为每一个专案去建立这些东西
[58:11.560 --> 58:16.560] 其实如果你用PyEnv的话这个是能解决的
[58:16.560 --> 58:20.560] 因为PyEnv里面可以针对不同的Python版本
[58:20.560 --> 58:21.560] 它的名字是不一样的
[58:21.560 --> 58:23.560] 就是对
[58:23.560 --> 58:25.560] OK
[58:25.560 --> 58:27.560] 反正就是等你这个做出来
[58:27.560 --> 58:29.560] 我们应该会进一步详细的了解
[58:29.560 --> 58:31.560] 就还是祝你好运
[58:31.560 --> 58:32.560] OK
[58:32.560 --> 58:37.560] 然后明晰最近在做的其实也是一个非常新的东西
[58:37.560 --> 58:40.560] 我感觉你们都是cutting edge technology
[58:40.560 --> 58:42.560] 明晰在做一个东西叫PDM
[58:42.560 --> 58:44.560] 然后他也在很多场合下介绍了
[58:44.560 --> 58:46.560] 不过我们还是请他来再介绍一下吧
[58:46.560 --> 58:53.560] PDM最初的想法就是Python Developer Manager
[58:53.560 --> 58:54.560] 或者叫Master
[58:54.560 --> 58:55.560] 随便了
[58:55.560 --> 58:56.560] Whatever
[58:56.560 --> 59:04.560] 它主要是基于最新的PEP582做的一个包管理器
[59:04.560 --> 59:09.560] 灵感是来自于一个Rust做的一个工具叫PyFlow
[59:09.560 --> 59:11.560] 它是PEP582
[59:11.560 --> 59:12.560] 我简单介绍一下
[59:12.560 --> 59:18.560] 就是它会把安装包安装在一个项目本地的目录
[59:18.560 --> 59:21.560] 就是项目目录之内
[59:21.560 --> 59:24.560] 如果有点类似于那个NodeModules
[59:24.560 --> 59:26.560] 这样的最大的好处就是说
[59:26.560 --> 59:30.560] 它是可以把你安装的依赖和你的解释器分开
[59:30.560 --> 59:33.560] 因为以前用Virtualenv的方式是
[59:33.560 --> 59:35.560] 你要建一个隔离的环境
[59:35.560 --> 59:38.560] 你要去复制一个Python解释器出来
[59:38.560 --> 59:42.560] 我想换这个解释器的话
[59:42.560 --> 59:45.560] 我就要重新建一个Virtualenv出来
[59:45.560 --> 59:49.560] 这样的话就感觉不是那么灵活
[59:49.560 --> 59:53.560] 如果你能把这个解释器跟它的依赖包给分开的话
[59:53.560 --> 59:56.560] 那么我换起解释器来就会比较容易一些
[59:56.560 --> 01:00:00.560] 不管你是用拍EMV或者说其他的什么方式去换
[01:00:00.560 --> 01:00:02.560] 都是比较容易
[01:00:02.560 --> 01:00:08.560] 但是PIP582还有很多需要完善的地方
[01:00:08.560 --> 01:00:11.560] 因为它现在也只是一个草案
[01:00:11.560 --> 01:00:14.560] 比如说刚才TP提到的
[01:00:14.560 --> 01:00:16.560] 它如果是不同位的
[01:00:16.560 --> 01:00:20.560] 32位跟64位的Python包的话
[01:00:20.560 --> 01:00:23.560] 它现在是没办法去隔离开区分开的
[01:00:23.560 --> 01:00:26.560] 对我现在PDM
[01:00:26.560 --> 01:00:32.560] 我还做了一个我感觉个人比较觉得好用的功能
[01:00:32.560 --> 01:00:35.560] 就是说它可以自动去识别
[01:00:35.560 --> 01:00:39.560] 你是要工作在项目环境中还是在全局环境中
[01:00:39.560 --> 01:00:41.560] 就是如果它能检测到你
[01:00:41.560 --> 01:00:44.560] 现在目前能找到一个PyProject跟TOMO
[01:00:44.560 --> 01:00:47.560] 那么它就会去用你项目环境中的包
[01:00:47.560 --> 01:00:49.560] 然后如果没有找到的话
[01:00:49.560 --> 01:00:53.560] 它会去回退到你用系统的Python
[01:00:53.560 --> 01:00:56.560] 就是用起来的话如果是用系统Python的话
[01:00:56.560 --> 01:00:59.560] 用起来就会和那个PIP差不多
[01:00:59.560 --> 01:01:03.560] 那相当于你的PDM是一个包含了
[01:01:03.560 --> 01:01:05.560] 虚拟环境管理
[01:01:05.560 --> 01:01:06.560] 但已经没有虚拟环境
[01:01:06.560 --> 01:01:07.560] 你把虚拟环境干掉了
[01:01:07.560 --> 01:01:10.560] 就是包含了以前的虚拟环境管理的功能
[01:01:10.560 --> 01:01:13.560] 和依赖管理和打包发布的这样一个
[01:01:13.560 --> 01:01:15.560] 比较全面的工具对吧
[01:01:15.560 --> 01:01:17.560] 对没有虚拟环境了
[01:01:17.560 --> 01:01:21.560] 对因为我就是刚才提到
[01:01:21.560 --> 01:01:24.560] 就是RUST写的那个工具PyFlow
[01:01:24.560 --> 01:01:26.560] 其实基本上功能都比较像
[01:01:26.560 --> 01:01:28.560] 但是RUST写的有一个问题
[01:01:28.560 --> 01:01:31.560] 就是它没办法去集成进我们的打包发布来
[01:01:31.560 --> 01:01:34.560] 因为我们现在打包发布的话
[01:01:34.560 --> 01:01:38.560] 工具是基于PIP517去做的
[01:01:38.560 --> 01:01:42.560] 那么PIP517要求你的库
[01:01:42.560 --> 01:01:44.560] 要暴露一个API出来
[01:01:44.560 --> 01:01:46.560] 供前端去调
[01:01:46.560 --> 01:01:48.560] 那么这个前端有可能是PIP
[01:01:48.560 --> 01:01:49.560] 有可能是Poetry
[01:01:49.560 --> 01:01:50.560] 有可能是其他的什么东西
[01:01:50.560 --> 01:01:54.560] 所以如果你是用RUST写的话
[01:01:54.560 --> 01:01:56.560] 你就没办法暴露这个API出来
[01:01:56.560 --> 01:01:58.560] 或者硬要暴露也可以
[01:01:58.560 --> 01:02:01.560] 你只能写一个Python wrapper去wrap它
[01:02:01.560 --> 01:02:04.560] 所以用PDM的话
[01:02:04.560 --> 01:02:09.560] 它也是实现了PIP517的这样一个打包的API
[01:02:09.560 --> 01:02:11.560] 所以用它去打包的话
[01:02:11.560 --> 01:02:15.560] 也可以正常的被PIP那些工具所安装
[01:02:15.560 --> 01:02:16.560] 这是没问题的
[01:02:16.560 --> 01:02:18.560] 那你可以就是说
[01:02:18.560 --> 01:02:21.560] 比如给听众介绍一下我在什么情况下
[01:02:21.560 --> 01:02:24.560] 我才就是为什么我应该用PDM
[01:02:24.560 --> 01:02:25.560] 而不应该用Poetry
[01:02:25.560 --> 01:02:27.560] 因为我觉得你们这两个是一个
[01:02:27.560 --> 01:02:29.560] 有直接竞争关系的工具
[01:02:29.560 --> 01:02:31.560] 什么情况
[01:02:31.560 --> 01:02:38.560] 我觉得就是你如果比较习惯用虚拟环境的方式管理的话
[01:02:38.560 --> 01:02:40.560] 你用Poetry也无可厚非
[01:02:40.560 --> 01:02:42.560] 但是你如果想尝试一下
[01:02:42.560 --> 01:02:46.560] 比如说我对虚拟环境遇到一些很多问题
[01:02:46.560 --> 01:02:50.560] 你不想再管理那么多虚拟环境
[01:02:50.560 --> 01:02:55.560] 你可以尝试PDM用本地的那种暴露
[01:02:55.560 --> 01:02:58.560] 有点像NodeModules
[01:02:58.560 --> 01:03:01.560] 不好意思我打断一下
[01:03:01.560 --> 01:03:02.560] 我刚才试了一下
[01:03:02.560 --> 01:03:05.560] 好像用PyCharm可以直接创建
[01:03:05.560 --> 01:03:08.560] 就是怎么说呢
[01:03:08.560 --> 01:03:11.560] 就是PyCharm你creator project之后
[01:03:11.560 --> 01:03:14.560] 它可以选择一个新的
[01:03:14.560 --> 01:03:15.560] 新建一个虚拟环境
[01:03:15.560 --> 01:03:17.560] 然后它就会把新的虚拟环境
[01:03:17.560 --> 01:03:20.560] 拉到你的项目目录下面
[01:03:20.560 --> 01:03:28.560] 虽然它没有像JavaScript那样
[01:03:28.560 --> 01:03:34.560] 但是它是直接新建了一个VNV的目录
[01:03:34.560 --> 01:03:35.560] 对
[01:03:35.560 --> 01:03:39.560] 它这个跟你说的有什么不一样吗
[01:03:39.560 --> 01:03:41.560] 就是刚才提到的VNV里面
[01:03:41.560 --> 01:03:45.560] 比NodeModules里面多了一个Python解释器
[01:03:45.560 --> 01:03:47.560] 但是VNV里面的解释器
[01:03:47.560 --> 01:03:50.560] 它又不是完整形态的解释器
[01:03:50.560 --> 01:03:53.560] 就是如果它原来基于的解释器
[01:03:53.560 --> 01:03:55.560] 灭失了或者消失了不存在了
[01:03:55.560 --> 01:03:56.560] VNV就不能用了
[01:03:56.560 --> 01:03:59.560] 它的劣势是在这里
[01:03:59.560 --> 01:04:00.560] 我明白了
[01:04:00.560 --> 01:04:03.560] 我可以给你介绍一个优势
[01:04:03.560 --> 01:04:06.560] 对我来讲还是比较有用的场景
[01:04:06.560 --> 01:04:09.560] 比如说你的开发环境原来是3.8.2
[01:04:09.560 --> 01:04:14.560] 升级到完全无缝的升级到3.8.3
[01:04:14.560 --> 01:04:16.560] 那你原来可能要
[01:04:16.560 --> 01:04:17.560] 就如果你用VirtualENV的话
[01:04:17.560 --> 01:04:21.560] 你要再创建一个3.8.3的Virtual的虚拟环境
[01:04:21.560 --> 01:04:23.560] 那如果你用PDM的话
[01:04:23.560 --> 01:04:26.560] 你可以直接就比如说升系统的Python
[01:04:26.560 --> 01:04:28.560] 然后你的当前的所有的包
[01:04:28.560 --> 01:04:29.560] 你不需要重新装一遍
[01:04:29.560 --> 01:04:31.560] 也不需要再创建一个新的虚拟环境
[01:04:31.560 --> 01:04:34.560] 我觉得这点还是有一定优势的
[01:04:34.560 --> 01:04:35.560] 对
[01:04:35.560 --> 01:04:37.560] 明白了
[01:04:37.560 --> 01:04:38.560] 对
[01:04:38.560 --> 01:04:42.560] 还有一个是如果你的专案想要移动的话
[01:04:42.560 --> 01:04:45.560] 就例如说我本来专案是放在什么Documents下面
[01:04:45.560 --> 01:04:47.560] 那我想要把它移到我的
[01:04:47.560 --> 01:04:49.560] 就反正就是移动你整个专案的话
[01:04:49.560 --> 01:04:51.560] 那你虚拟环境就整个就坏了
[01:04:51.560 --> 01:04:54.560] 对VirtualENV里面它有很多就是
[01:04:54.560 --> 01:04:56.560] 那个软链接什么的嘛
[01:04:56.560 --> 01:04:57.560] 就很麻烦
[01:04:57.560 --> 01:04:58.560] 感觉
[01:04:58.560 --> 01:04:59.560] OK
[01:04:59.560 --> 01:05:00.560] 好
[01:05:00.560 --> 01:05:02.560] 然后下面我们还有两个
[01:05:02.560 --> 01:05:05.560] 就是一个是应该是TP最近在做的
[01:05:05.560 --> 01:05:08.560] 就是新的PIP的依赖解析器对吧
[01:05:08.560 --> 01:05:10.560] 对
[01:05:10.560 --> 01:05:13.560] 这个算是我现在的正职吧
[01:05:13.560 --> 01:05:18.560] 就是那个就是那个PSF在去年的时候
[01:05:18.560 --> 01:05:20.560] 就是发了一个就是
[01:05:20.560 --> 01:05:22.560] 类似像外包性质的专案
[01:05:22.560 --> 01:05:26.560] 就是让那个原本在PIP里面的贡献的人
[01:05:26.560 --> 01:05:28.560] 可以去就是拿薪水去做这个
[01:05:28.560 --> 01:05:32.560] 因为之前他们是就是那个PIP
[01:05:32.560 --> 01:05:34.560] 之前有一个Maintainer
[01:05:34.560 --> 01:05:35.560] 不是之前啦
[01:05:35.560 --> 01:05:37.560] 就他现在还是Maintainer
[01:05:37.560 --> 01:05:40.560] 就是有一个Maintainer就是Proddingeden
[01:05:40.560 --> 01:05:44.560] 他本来是拿那个Google Summer of Code的专案
[01:05:44.560 --> 01:05:45.560] 去想要做这件事情
[01:05:45.560 --> 01:05:47.560] 结果做下去之后发现这个
[01:05:47.560 --> 01:05:50.560] 就是PIP里面实在是太混乱了
[01:05:50.560 --> 01:05:52.560] 就是完全做不出来
[01:05:52.560 --> 01:05:54.560] 所以就跟PSF商量之后
[01:05:54.560 --> 01:05:57.560] 那我们就多找几个人
[01:05:57.560 --> 01:05:59.560] 就多找几个职业的人直接来写吧
[01:05:59.560 --> 01:06:04.560] 所以现在就是有三个全职
[01:06:04.560 --> 01:06:06.560] 应该算是兼职吧
[01:06:06.560 --> 01:06:10.560] 就是算人年的话就是1.5个吧
[01:06:10.560 --> 01:06:12.560] 的开发者在做这个专案
[01:06:12.560 --> 01:06:16.560] 那预计我们是会在六月底的时候
[01:06:16.560 --> 01:06:18.560] 把它正式的放到PIP里面
[01:06:18.560 --> 01:06:21.560] 那现在它是一个Alpha版的方式存在
[01:06:21.560 --> 01:06:25.560] 我们前几天才刚发了一个新的版本
[01:06:25.560 --> 01:06:26.560] 我有点好奇
[01:06:26.560 --> 01:06:28.560] 你刚才不是说你是全职的吗
[01:06:28.560 --> 01:06:30.560] 相当于你算一个人
[01:06:30.560 --> 01:06:33.560] 那另外两个人加起来算半个人
[01:06:33.560 --> 01:06:35.560] 不是
[01:06:35.560 --> 01:06:37.560] 就是我一个
[01:06:37.560 --> 01:06:40.560] 就是在这个专案上面工作的时间是
[01:06:40.560 --> 01:06:43.560] 就是一个礼拜是20个小时
[01:06:43.560 --> 01:06:45.560] 所以我也算是半个人
[01:06:45.560 --> 01:06:47.560] OK你是半个人
[01:06:47.560 --> 01:06:49.560] OK
[01:06:49.560 --> 01:06:50.560] 那我还有点好奇
[01:06:50.560 --> 01:06:52.560] 就是和技术无关
[01:06:52.560 --> 01:06:57.560] 就是你在接这个PSF的外包之前
[01:06:57.560 --> 01:06:59.560] 你的全职工作是什么
[01:06:59.560 --> 01:07:01.560] 还是说你本来就是freelancer
[01:07:01.560 --> 01:07:04.560] 我本来就是接近freelancer的性质
[01:07:04.560 --> 01:07:08.560] 就是我有在跟朋友的公司里面帮忙
[01:07:08.560 --> 01:07:13.560] 但是也是时间自由的性质
[01:07:13.560 --> 01:07:14.560] 哇
[01:07:14.560 --> 01:07:15.560] 我突然有点羡慕
[01:07:15.560 --> 01:07:18.560] 我就可以有时间来接一些这种
[01:07:18.560 --> 01:07:22.560] 真正有很大impact的项目
[01:07:22.560 --> 01:07:24.560] 影响所有Python开发者
[01:07:24.560 --> 01:07:27.560] 你要想就是接不到的时候怎么办
[01:07:27.560 --> 01:07:30.560] 就6月之后我还不知道要干嘛
[01:07:30.560 --> 01:07:34.560] 你做得好的话他们会PSF可以再给你一个活
[01:07:34.560 --> 01:07:35.560] 感觉肯定有
[01:07:35.560 --> 01:07:36.560] anyway
[01:07:36.560 --> 01:07:41.560] 那好先就是要再提一个新的project出来
[01:07:41.560 --> 01:07:43.560] 然后给他们审核过了才会有
[01:07:43.560 --> 01:07:44.560] 就还是挺麻烦的
[01:07:44.560 --> 01:07:49.560] 但是嗯对就还是有得有失吧可能就是
[01:07:49.560 --> 01:07:52.560] 然后你提到就是说测试
[01:07:52.560 --> 01:07:55.560] 发布了一个你们刚发布了一个测试版对吧
[01:07:55.560 --> 01:07:56.560] 就是是alpha版本吗
[01:07:56.560 --> 01:08:01.560] 那那鉴于这个版本是大家要怎么用呢
[01:08:01.560 --> 01:08:02.560] 就如果想用起来的话
[01:08:02.560 --> 01:08:06.560] 就是peep里面好像从20
[01:08:06.560 --> 01:08:07.560] 今年2020
[01:08:07.560 --> 01:08:12.560] 所以从20.0开始有一个新的指令叫做
[01:08:12.560 --> 01:08:15.560] 就是dash dash unstable feature
[01:08:15.560 --> 01:08:17.559] 就是非常的长
[01:08:17.559 --> 01:08:19.559] 但是就是如果你用那个的话
[01:08:19.560 --> 01:08:22.560] 你去access一些peep里面还没有完善的功能
[01:08:22.560 --> 01:08:27.560] 就是像这个功能就是你可以使用peep install
[01:08:27.560 --> 01:08:30.560] dash dash unstable feature resolver
[01:08:30.560 --> 01:08:34.560] 这样他就peep就会切换到新的解释器
[01:08:34.560 --> 01:08:38.560] 那新的解释器就是用一些比较好的技术
[01:08:38.560 --> 01:08:42.560] 就是因为之前peep的解析器就是非常的懒
[01:08:42.560 --> 01:08:46.560] 这样对我想原本写的人大概也不会反对
[01:08:46.560 --> 01:08:51.560] 就是所以我们就用了一个比较好的实作去
[01:08:51.560 --> 01:08:52.560] 试着去取代它
[01:08:52.560 --> 01:08:55.560] 那那那是不是可以理解为就是
[01:08:55.560 --> 01:08:59.560] 如果你用了这个新的peep里的功能
[01:08:59.560 --> 01:09:01.560] 你就不需要peepenv
[01:09:01.560 --> 01:09:03.560] 或者portrait的依赖解析的那部分
[01:09:03.560 --> 01:09:04.560] 你就
[01:09:04.560 --> 01:09:06.560] 对但是peep还是没有办
[01:09:06.560 --> 01:09:09.560] 就是目前还是没有办法生成那个log file
[01:09:09.560 --> 01:09:11.560] 所以如果你要生成log file的话
[01:09:11.560 --> 01:09:14.560] 还是会暂时会需要借助一些别的工具
[01:09:14.560 --> 01:09:18.560] 那就相当于他做的只是从pyproject.toml
[01:09:18.560 --> 01:09:21.560] 里来读取依赖并且解析吗
[01:09:21.560 --> 01:09:24.560] 因为他现在也没有从pyproject.toml
[01:09:24.560 --> 01:09:29.560] 他现在还是只能从peepinstall里面的参数去解析
[01:09:29.560 --> 01:09:33.560] 我就比较好奇他最终的形态会是怎么样
[01:09:33.560 --> 01:09:39.560] 就是这其实是一个就是很多步骤的一个进程吧
[01:09:39.560 --> 01:09:40.560] 就是第一个步骤
[01:09:40.560 --> 01:09:44.560] 你要先把这个依赖解析器放进peep里面
[01:09:44.560 --> 01:09:45.560] 现在还在这个阶段
[01:09:45.560 --> 01:09:48.560] 那下一个阶段我们有计划的是
[01:09:48.560 --> 01:09:51.560] 可能会有一个新的指令
[01:09:51.560 --> 01:09:53.560] 就可能就是说peepresolve
[01:09:53.560 --> 01:09:54.560] 或是peeplock
[01:09:54.560 --> 01:09:59.560] 或者是叫什么peepinstall –lockonly之类的
[01:09:59.560 --> 01:10:01.560] 有很多现在还在想
[01:10:01.560 --> 01:10:05.560] 就是这个指令就是不会真的安装套件
[01:10:05.560 --> 01:10:08.560] 他只会生成一个requirements.txt
[01:10:08.560 --> 01:10:15.560] 那就会等同于就是peepenv或是portrait里面lock的功能
[01:10:15.560 --> 01:10:16.560] 就是第二步
[01:10:16.560 --> 01:10:20.560] 那第三步就是去读
[01:10:20.560 --> 01:10:22.560] 比如说pyproject.toml
[01:10:22.560 --> 01:10:26.560] 而不用你每次都手动下peepinstall
[01:10:26.560 --> 01:10:29.560] 什么flask一大堆很长很长的这样子
[01:10:29.560 --> 01:10:31.560] OK
[01:10:31.560 --> 01:10:35.560] 就感觉好像又多了一个工具了
[01:10:35.560 --> 01:10:38.560] 在原来的基础上有这种感觉
[01:10:38.560 --> 01:10:43.560] 对 但是就是最后的期望还是这个东西能够
[01:10:43.560 --> 01:10:46.560] 就因为peep还是大家都会用到的吧
[01:10:46.560 --> 01:10:48.560] 对 所以还是如果你没有特殊需求的话
[01:10:48.560 --> 01:10:53.560] 就是这样子的功能可以满足大部分的需求
[01:10:53.560 --> 01:10:58.560] 我在想未来比如说你是一个你不喜欢虚拟环境
[01:10:58.560 --> 01:11:00.560] 那你就可以用新的peep加上PDM
[01:11:00.560 --> 01:11:02.560] 然后就可以满足你的整个
[01:11:02.560 --> 01:11:04.560] 不过PDM也有依赖解析
[01:11:04.560 --> 01:11:06.560] 感觉
[01:11:06.560 --> 01:11:08.560] 好 就说如果你不需要
[01:11:08.560 --> 01:11:10.560] 就virtualenv的话
[01:11:10.560 --> 01:11:12.560] 你用peep就足够了这样
[01:11:12.560 --> 01:11:15.560] 对 然后你也不需要就是打包成库
[01:11:15.560 --> 01:11:18.560] 可能会有人觉得说怎么会有这种人
[01:11:18.560 --> 01:11:21.560] 但是我们前面有提到我们有那个UX survey
[01:11:21.560 --> 01:11:23.560] 就还真的很多这种人
[01:11:23.560 --> 01:11:27.560] 所以我们还是要满足一下他们的需求
[01:11:27.560 --> 01:11:28.560] 对 我觉得也可以理解吧
[01:11:28.560 --> 01:11:30.560] 就类似于那个
[01:11:30.560 --> 01:11:33.560] 就是原来在Python加入那个data class之前
[01:11:33.560 --> 01:11:35.560] 不是有那个Atters那个库吗
[01:11:35.560 --> 01:11:36.560] attrs
[01:11:36.560 --> 01:11:38.560] 然后大家都用Atters
[01:11:38.560 --> 01:11:42.560] 但是后来还是决定在标准库里面加入data class
[01:11:42.560 --> 01:11:43.560] 其实就也类似吧
[01:11:43.560 --> 01:11:47.560] 就希望大家有一个更好的开箱即用的工具
[01:11:47.560 --> 01:11:49.560] 就这样的考虑
[01:11:49.560 --> 01:11:51.560] 对 而且当初在加那个data class的时候
[01:11:51.560 --> 01:11:54.560] 大家也是说你这个功能就是比Atters少
[01:11:54.560 --> 01:11:56.560] 那为什么不用Atters就好
[01:11:56.560 --> 01:12:00.560] 结果就是data class出来大家还是争相
[01:12:00.560 --> 01:12:03.560] 所以可能也是类似的状况吧
[01:12:03.560 --> 01:12:06.560] 然后我们关于两位最近在工作
[01:12:06.560 --> 01:12:09.560] 还有一个点是那个Locker file
[01:12:09.560 --> 01:12:12.560] 其实我们就是我不知道这个你们想不想聊
[01:12:12.560 --> 01:12:14.560] 因为我们其实已经聊了蛮长时间
[01:12:14.560 --> 01:12:16.560] 这个要不你们简单说一下
[01:12:16.560 --> 01:12:18.560] 就不用说太详细
[01:12:18.560 --> 01:12:20.560] 对 就我这边来讲的话
[01:12:20.560 --> 01:12:23.560] 就是前面提到的就是requirements.txt的问题
[01:12:23.560 --> 01:12:24.560] 还是很多的
[01:12:24.560 --> 01:12:26.560] 所以就是想要把它改进一下
[01:12:26.560 --> 01:12:29.560] 这个其实也不是就是谁先提出来
[01:12:29.560 --> 01:12:32.560] 这个大概也是四五年久的历史了
[01:12:32.560 --> 01:12:34.560] 但是就是没有人真的要去做
[01:12:34.560 --> 01:12:38.560] 那就可能真的去做一下这样
[01:12:38.560 --> 01:12:43.560] ATP我看你最近开了一个repo
[01:12:43.560 --> 01:12:45.560] 就是写这个Locker file的标准
[01:12:45.560 --> 01:12:48.560] 看你选择的是用的JSON格式
[01:12:48.560 --> 01:12:51.560] 这个是通过讨论得出的吗
[01:12:51.560 --> 01:12:54.560] 还是你觉得JSON比较好
[01:12:54.560 --> 01:12:58.560] 这是我希望能够说服大家的事情
[01:12:58.560 --> 01:13:01.560] 就是我知道很多人会想要用别的格式
[01:13:01.560 --> 01:13:02.560] 例如说TOML
[01:13:02.560 --> 01:13:04.560] 但是就是我被提了一个反馈
[01:13:04.560 --> 01:13:06.560] 就是那个TOML的
[01:13:06.560 --> 01:13:09.560] 就是在同一个资料结构下面
[01:13:09.560 --> 01:13:12.560] 就是在Serialize进TOML的时候
[01:13:12.560 --> 01:13:14.560] 它的格式并不是唯一的
[01:13:14.560 --> 01:13:18.560] 就是TOML允许有很多种不同的Syntax表达
[01:13:18.560 --> 01:13:19.560] 都是同样的东西
[01:13:19.560 --> 01:13:22.560] 那就是这个在就是互用上面
[01:13:22.560 --> 01:13:24.560] 尤其是在就是你产出之后
[01:13:24.560 --> 01:13:29.560] 你在那个Git Diff上面会产生很多问题
[01:13:29.560 --> 01:13:33.560] 尤其是像现在那个Poetry Lock
[01:13:33.560 --> 01:13:35.560] 就是有很多人提出说
[01:13:35.560 --> 01:13:38.560] 就是那个你重新Lock了之后
[01:13:38.560 --> 01:13:39.560] 你那个Git Diff就是一团混乱
[01:13:39.560 --> 01:13:42.560] 都不知道到底更新了什么
[01:13:42.560 --> 01:13:47.560] 那用JSON就是再加上那个Python内建的Indent
[01:13:47.560 --> 01:13:51.560] 就是会有比较好的Diff产出
[01:13:51.560 --> 01:13:54.560] 所以我现在是选择用JSON
[01:13:54.560 --> 01:13:56.560] OK 我看Poetry的那个Lock
[01:13:56.560 --> 01:13:58.560] 好像用的不是JSON
[01:13:58.560 --> 01:14:00.560] 但我也不知道它是什么
[01:14:00.560 --> 01:14:01.560] 我不知道是TOML还是
[01:14:01.560 --> 01:14:03.560] 是TOML啦 那个用的是TOML
[01:14:03.560 --> 01:14:05.560] 是TOML是吗 OK
[01:14:05.560 --> 01:14:09.560] 对 我其实还蛮希望Lockerfile能标准化的
[01:14:09.560 --> 01:14:13.560] 但就看TP你的了
[01:14:13.560 --> 01:14:15.560] 就是你去看我不知道这里面有
[01:14:15.560 --> 01:14:18.560] 就是你在那个讨论区上面
[01:14:18.560 --> 01:14:20.560] 关于这个的那个Topic上面
[01:14:20.560 --> 01:14:23.560] 就是反对Lockerfile标准化的
[01:14:23.560 --> 01:14:26.560] 所以就是路还比较长
[01:14:26.560 --> 01:14:27.560] 太难了 太难了
[01:14:27.560 --> 01:14:30.560] 就是 但我们还是
[01:14:30.560 --> 01:14:35.560] 就还是希望能有一个官方的观点吧
[01:14:35.560 --> 01:14:37.560] 就比如说要标准化还是不要标准化
[01:14:37.560 --> 01:14:40.560] 就我个人还是觉得标准化还好一点
[01:14:40.560 --> 01:14:45.560] OK 好 然后下面一个部分
[01:14:45.560 --> 01:14:48.560] 我们来聊一下当前社区的一些热点
[01:14:48.560 --> 01:14:50.560] 和开发者的痛点吧
[01:14:50.560 --> 01:14:53.560] 就因为其实我们也发现有很多
[01:14:53.560 --> 01:14:55.560] 就刚刚提到很多新的一些名词
[01:14:55.560 --> 01:14:57.560] 比如说Pipe517
[01:14:57.560 --> 01:14:59.560] 然后Pipe518
[01:14:59.560 --> 01:15:01.560] 这两个Pipe其实是
[01:15:01.560 --> 01:15:04.560] 就是对于整个Python的
[01:15:04.560 --> 01:15:07.560] 这样一个工作流的环境影响是比较大
[01:15:07.560 --> 01:15:10.560] 然后并且已经被接受的Pipe
[01:15:10.560 --> 01:15:12.560] 然后对
[01:15:12.560 --> 01:15:14.560] 就是其实刚才是谁提到了
[01:15:14.560 --> 01:15:15.560] 我有点忘了
[01:15:15.560 --> 01:15:18.560] 我说的 要不我先说一下
[01:15:18.560 --> 01:15:19.560] OK 就你说吧
[01:15:19.560 --> 01:15:21.560] 对 Pipe517跟518
[01:15:21.560 --> 01:15:23.560] 其实是两个相互配合的Pipe
[01:15:23.560 --> 01:15:25.560] 所以我把它合在一起讲吧
[01:15:25.560 --> 01:15:27.560] 就是说先说Pipe518
[01:15:27.560 --> 01:15:30.560] 它是提出了一种新的定义
[01:15:30.560 --> 01:15:32.560] 打包配置的一个文件格式
[01:15:32.560 --> 01:15:34.560] PipeProject跟TOMO
[01:15:34.560 --> 01:15:38.560] 那么它可以把你的工具相关的配置
[01:15:38.560 --> 01:15:40.560] 放到一个特有的entry下面
[01:15:40.560 --> 01:15:44.560] 那么既然你能支持别的工具来打包的话
[01:15:44.560 --> 01:15:48.560] 就是说原来只有setup.to一个东西
[01:15:48.560 --> 01:15:50.560] 如果你能支持别的工具打包
[01:15:50.560 --> 01:15:53.560] 我们就必须定义一个协议规范
[01:15:53.560 --> 01:15:56.560] 去让前端跟后端相互去调用
[01:15:56.560 --> 01:15:59.560] 那么这个就是Pipe517的内容
[01:15:59.560 --> 01:16:00.560] 就是它定义了
[01:16:00.560 --> 01:16:02.560] 就是说你如果要
[01:16:02.560 --> 01:16:04.560] 做我们的打包的工具的话
[01:16:04.560 --> 01:16:07.560] 你必须实现几个接口
[01:16:07.560 --> 01:16:10.560] 然后这个接口也是协议规定好了
[01:16:10.560 --> 01:16:13.560] 那么我们前端就会去调用你的接口
[01:16:13.560 --> 01:16:15.560] 去生成你的打包的内容
[01:16:15.560 --> 01:16:17.560] 那我再说一下
[01:16:17.560 --> 01:16:19.560] 现在打包安装的过程主要是这样
[01:16:19.560 --> 01:16:21.560] 就是先是
[01:16:21.560 --> 01:16:23.560] 就是从刚才说的
[01:16:23.560 --> 01:16:29.560] 从PipeOrg上面去download一个文件下来
[01:16:29.560 --> 01:16:32.560] 然后首先如果它是wheel格式的话
[01:16:32.560 --> 01:16:33.560] wheel格式的话最简单
[01:16:33.560 --> 01:16:34.560] 没有什么好说的
[01:16:34.560 --> 01:16:35.560] wheel格式直接把它解压出来
[01:16:35.560 --> 01:16:38.560] 然后把文件移到目标目录里面就可以了
[01:16:38.560 --> 01:16:40.560] 就是wheel格式是最简单的
[01:16:40.560 --> 01:16:42.560] 如果它不是wheel格式的话
[01:16:42.560 --> 01:16:44.560] 比如说它是source source
[01:16:44.560 --> 01:16:48.560] 比如说它是gz或者是zip格式的
[01:16:48.560 --> 01:16:51.560] 那么它就会去首先把文件解压出来
[01:16:51.560 --> 01:16:53.560] 这个文件解压出来里面应该都是它的原代码
[01:16:53.560 --> 01:16:55.560] 然后去调用你的
[01:16:55.560 --> 01:16:58.560] 刚才定义好的一个打包的接口
[01:16:58.560 --> 01:16:59.560] 叫做buildwheel
[01:16:59.560 --> 01:17:01.560] 它会调用你这个接口
[01:17:01.560 --> 01:17:05.560] 你这个接口负责把你原代码去构建出一个wheel包出来
[01:17:05.560 --> 01:17:07.560] 那么得到这个wheel包以后
[01:17:07.560 --> 01:17:09.560] 然后我们就可以通过wheel的方式
[01:17:09.560 --> 01:17:12.560] 就把那个文件直接复制过去就可以了
[01:17:12.560 --> 01:17:16.560] 所以这是PEP 517定义的一个事情
[01:17:16.560 --> 01:17:23.560] 但是PEP 517没有定义的是editable install的一个规范
[01:17:23.560 --> 01:17:26.560] 因为这部分的话也比较tricky
[01:17:26.560 --> 01:17:29.560] 就是我看这个PEP 517里面的话
[01:17:29.560 --> 01:17:33.560] 它原先是准备要说这部分的规范的话
[01:17:33.560 --> 01:17:37.560] 但是后来被拒绝了
[01:17:37.560 --> 01:17:39.560] 就是说这个比较tricky
[01:17:39.560 --> 01:17:41.560] 不适合放在我们的规范里面
[01:17:41.560 --> 01:17:44.560] 现在也没有讨论下来如何去的
[01:17:44.560 --> 01:17:48.560] 先给听众们介绍一下什么是editable install
[01:17:48.560 --> 01:17:51.560] editable install就是
[01:17:51.560 --> 01:17:57.560] 现在你用PEP install然后加一个-1的选项的话
[01:17:57.560 --> 01:18:03.560] 它会把你的原代码目录装成一个editable的mod
[01:18:03.560 --> 01:18:04.560] editable mod它其实就是
[01:18:04.560 --> 01:18:07.560] 直接把你的当前的目录加到Python pass里面去而已
[01:18:07.560 --> 01:18:10.560] 所以你可以直接在你的原代码上做修改
[01:18:10.560 --> 01:18:14.560] 然后那个包的行为就能立即更新
[01:18:14.560 --> 01:18:17.560] 不用你重新安装uninstall install这些步骤
[01:18:17.560 --> 01:18:19.560] 那这个就是editable install
[01:18:19.560 --> 01:18:23.560] 它其实主要是在开发过程中的一个
[01:18:23.560 --> 01:18:25.560] 就方便开发者的一种方式
[01:18:25.560 --> 01:18:28.560] 那么editable install的问题到底在哪
[01:18:28.560 --> 01:18:31.560] 它首先一个问题就是console script
[01:18:31.560 --> 01:18:34.560] 因为console script这个配置是在你
[01:18:34.560 --> 01:18:36.560] 你install的那个时间点生成的
[01:18:36.560 --> 01:18:39.560] 然后这个配置会放在一个
[01:18:39.560 --> 01:18:43.560] 一个egg info的文件夹里面
[01:18:43.560 --> 01:18:46.560] 然后这个文件夹你平常是不会去动它的
[01:18:46.560 --> 01:18:48.560] 所以你就算更新了原代码
[01:18:48.560 --> 01:18:51.560] 比如说我的console script的名字变了
[01:18:51.560 --> 01:18:52.560] 我把它名字改一下
[01:18:52.560 --> 01:18:57.560] 那么这个更新是没办法去反映到你的包中的
[01:18:57.560 --> 01:18:59.560] 所以如果你做了这种变更的话
[01:18:59.560 --> 01:19:03.560] 你还是要把那个egg info目录删掉
[01:19:03.560 --> 01:19:04.560] 然后重新再安装一次
[01:19:04.560 --> 01:19:07.560] 所以等于还是没有editable install
[01:19:07.560 --> 01:19:08.560] 没有达到这个目标
[01:19:08.560 --> 01:19:12.560] 那所以我们就有了一个pep610对吧
[01:19:12.560 --> 01:19:17.560] 然后它是就是完善了你之前说的editable install的
[01:19:17.560 --> 01:19:20.560] 这样一个就规范了它的行为是吗
[01:19:20.560 --> 01:19:22.560] 可以这么理解吗
[01:19:22.560 --> 01:19:23.560] 还没还没
[01:19:23.560 --> 01:19:28.560] 只是后面应该还需要一个pep去规划这个
[01:19:28.560 --> 01:19:30.560] 还没还没
[01:19:34.560 --> 01:19:36.560] OK那好吧
[01:19:36.560 --> 01:19:38.560] 那我们就就是站在一个更高角度说一下
[01:19:38.560 --> 01:19:42.560] 就比如说当这些517 518
[01:19:42.560 --> 01:19:45.560] 然后610这些都全部实现了之后
[01:19:45.560 --> 01:19:53.560] 它就是说它的效果是可以让整个社区能够创建出
[01:19:53.560 --> 01:19:57.560] 更多的一些打包工具打包工具了是吗
[01:19:57.560 --> 01:19:58.560] 它就创建出打包工具了
[01:19:58.560 --> 01:20:00.560] 其实它就是在做这样一件事情
[01:20:00.560 --> 01:20:04.560] 应该是产生出一个怎么讲
[01:20:04.560 --> 01:20:08.560] 就是那个开发者的工作流的模式吧
[01:20:08.560 --> 01:20:13.560] 就是你可以就对于说我今天想要开发一个新的库
[01:20:13.560 --> 01:20:16.560] 那我就先就是建立一个目录嘛
[01:20:16.560 --> 01:20:19.560] 然后建立一个那个虚拟环境
[01:20:19.560 --> 01:20:20.560] 那这些都做完之后
[01:20:20.560 --> 01:20:23.560] 我就可以用那个editable去安装
[01:20:23.560 --> 01:20:27.560] 就是本地我要用的开发用的环境
[01:20:27.560 --> 01:20:28.560] 然后开发完之后
[01:20:28.560 --> 01:20:31.560] 我就可以用517 518去生成一个
[01:20:31.560 --> 01:20:36.560] 那个生成一个就是去打包然后上传这样子
[01:20:36.560 --> 01:20:39.560] 就是可以在同一个工具里面
[01:20:39.560 --> 01:20:41.560] 就可以达到我想要做的所有事情
[01:20:41.560 --> 01:20:44.560] 而且这个工具就是如果我习惯用工具A
[01:20:44.560 --> 01:20:45.560] 我就用工具A
[01:20:45.560 --> 01:20:48.560] 那我习惯用工具B我就用工具B
[01:20:48.560 --> 01:20:51.560] 然后因为它们的行为都是标准化的
[01:20:51.560 --> 01:20:54.560] 所以最后做出来的东西都会是一样可以互通的
[01:20:54.560 --> 01:20:55.560] OK
[01:20:55.560 --> 01:20:58.560] 那我大致就就相当于原来很多工具
[01:20:58.560 --> 01:20:59.560] 它的行为是不同意的
[01:20:59.560 --> 01:21:02.560] 然后有一些工具可能有缺失的功能
[01:21:02.560 --> 01:21:05.560] 然后现在就想把这些他们行为标准化一下
[01:21:05.560 --> 01:21:10.560] 就然后开发者就可以选择他们喜好的工具
[01:21:10.560 --> 01:21:12.560] 然后但他做的事情都是一样的
[01:21:12.560 --> 01:21:16.560] 好所以这样就就带来我们下面要讲的一个问题
[01:21:16.560 --> 01:21:19.560] 就是说就是说我们聊了这么多东西
[01:21:19.560 --> 01:21:20.560] 这么多Pip这么多工具
[01:21:20.560 --> 01:21:23.560] 然后如果你是一个就是小白
[01:21:23.560 --> 01:21:25.560] 但可能不是就不是不是说你
[01:21:25.560 --> 01:21:28.560] 就是一个新接触Python的的的开发者
[01:21:28.560 --> 01:21:32.560] 然后你可能就完全不知道应该用什么
[01:21:32.560 --> 01:21:37.560] 嗯因为他很多工具其实都是有一些有一些重合的部分的
[01:21:37.560 --> 01:21:42.560] 然后他比如说某些工具可以做打包和发打包和依赖管理
[01:21:42.560 --> 01:21:45.560] 然后有些又可以做虚拟环境管理和依赖管理
[01:21:45.560 --> 01:21:49.560] 就他们并不是完全正交的这样一个关系
[01:21:49.560 --> 01:21:52.560] 那我想讨论的一个问题就是说
[01:21:52.560 --> 01:21:57.560] 就是为什么Python会发展到目前这样一个
[01:21:57.560 --> 01:21:59.560] 就是你可以说是繁荣的
[01:21:59.560 --> 01:22:01.560] 也可以说是有些混乱的这样一个状况
[01:22:01.560 --> 01:22:06.560] 然后就两位嘉宾觉得他的原因到底是怎么样的
[01:22:06.560 --> 01:22:09.560] 或者说和Python类似的语言里面
[01:22:09.560 --> 01:22:11.560] 有没有也出现这样的情况
[01:22:11.560 --> 01:22:14.560] 如果要说跟Python类似的语言的话
[01:22:14.560 --> 01:22:16.560] 那有啊就是C++
[01:22:16.560 --> 01:22:19.560] 那C++比Python更混乱就是什么东西都有
[01:22:19.560 --> 01:22:25.560] 那我觉得我个人觉得就是Python会走到今天这样子的状况
[01:22:25.560 --> 01:22:29.560] 的一个很大的原因就是Python能做的事情实在是太多了
[01:22:29.560 --> 01:22:34.560] 就是例如说就是大家现在就是就是不满
[01:22:34.560 --> 01:22:40.560] 以Python有这么多工具的很多人会举的例子都是NPM
[01:22:40.560 --> 01:22:42.560] 但是你说NPM能做什么事情吗
[01:22:42.560 --> 01:22:44.560] 他能做的事情就两个
[01:22:44.560 --> 01:22:47.560] 一个是web开发一个就可能写给Electron App
[01:22:47.560 --> 01:22:49.560] 没了就这样
[01:22:49.560 --> 01:22:53.560] 就是你写个后段写个前端就这样没有了
[01:22:53.560 --> 01:22:55.560] 那就这种开发环境里面
[01:22:55.560 --> 01:22:59.560] 你当然你的就是需要做的事情是非常非常的单纯
[01:22:59.560 --> 01:23:03.560] 尤其是如果说你是写那个前端的话
[01:23:03.560 --> 01:23:06.560] 你所有的套件都是纯JavaScript
[01:23:06.560 --> 01:23:11.560] 就是他基本上都是以JavaScript的方式来发行的
[01:23:11.560 --> 01:23:13.560] 所以你根本不会有编译的问题
[01:23:13.560 --> 01:23:15.560] 也不会有虚拟环境的问题
[01:23:15.560 --> 01:23:18.560] 也不会有就是跟系统套件连接
[01:23:18.560 --> 01:23:22.560] 例如说我可能要点个PostgreSQL driver的问题
[01:23:22.560 --> 01:23:23.560] 都不会有
[01:23:23.560 --> 01:23:27.560] 那当然他就是能够做出非常简洁
[01:23:27.560 --> 01:23:31.560] 然后就是一个工具大家都能用
[01:23:31.560 --> 01:23:34.560] 因为他就是做这么点事情
[01:23:34.560 --> 01:23:37.560] 那以Python来讲的话就是有些人写web
[01:23:37.560 --> 01:23:39.560] 那有些人做Data Science
[01:23:39.560 --> 01:23:44.560] 那有些人像我一样是就是只是写一些后段的程式的
[01:23:44.560 --> 01:23:50.560] 就是写一些Script也没有要组合成一个网站什么的
[01:23:50.560 --> 01:23:53.560] 那这些人的需求都非常的不一样
[01:23:53.560 --> 01:23:56.560] 那他们的工作流程也是非常的不一样
[01:23:56.560 --> 01:24:00.560] 像就是你写web的人完全不会接受到打包
[01:24:00.560 --> 01:24:03.560] 那像写我就是做我这一类东西的人
[01:24:03.560 --> 01:24:07.560] 就是每天都在打包
[01:24:07.560 --> 01:24:09.560] 那就是打包对我来讲就是至关重要
[01:24:09.560 --> 01:24:14.560] 那当然我用的工具就必须要有集成打包的功能
[01:24:14.560 --> 01:24:16.560] 那对写web来讲就是我从来不打包
[01:24:16.560 --> 01:24:18.560] 那为什么我的工具要
[01:24:18.560 --> 01:24:23.560] 就是如果有一个写web的人为他自己的工作流建立一个工具
[01:24:23.560 --> 01:24:25.560] 那当然就是我当然就是不要打包
[01:24:25.560 --> 01:24:30.560] 就是当初就是Kenneth Wright本身也是就是写web出身的
[01:24:30.560 --> 01:24:34.560] 所以就是PPF也是继承了他的这个心态吧
[01:24:34.560 --> 01:24:39.560] 对啊所以当然就是造成了今天就是有这么多奇奇怪怪的工具
[01:24:39.560 --> 01:24:43.560] 那他们各自有一些各自不一样的功能
[01:24:43.560 --> 01:24:47.560] 然后又有一些功能是共同的大概就是这个原因
[01:24:47.560 --> 01:24:50.560] 这个问题Python为什么走到今天这一步
[01:24:50.560 --> 01:24:53.560] 第一个是Python历史也很悠久了
[01:24:53.560 --> 01:24:55.560] 一个三四岁的语言了
[01:24:55.560 --> 01:25:00.560] 然后语之相伴随的是它的流行度也很强
[01:25:00.560 --> 01:25:04.560] 这就造成了有很多人去自发的去改进它
[01:25:04.560 --> 01:25:06.560] 那么这样又带来一个问题
[01:25:06.560 --> 01:25:08.560] 就是说Python官方的这个
[01:25:08.560 --> 01:25:13.560] 它作为官方的这样一个管控力度可能权威力度还不够
[01:25:13.560 --> 01:25:19.560] 所以它可能会去任由你的社区去自由去发展出这些工具出来
[01:25:19.560 --> 01:25:24.560] 所以我说这些因素可能比较那种心儿上学吧
[01:25:24.560 --> 01:25:27.560] 反正有一点就是历史原因
[01:25:27.560 --> 01:25:30.560] 对这个其实也可以提一下
[01:25:30.560 --> 01:25:35.560] 就是像那个NPM跟YARN都是背后有家公司在支持
[01:25:35.560 --> 01:25:37.560] NPM后面本身是一个Startup
[01:25:37.560 --> 01:25:39.560] 那YARN后面大家都知道是Facebook嘛
[01:25:39.560 --> 01:25:44.560] 那在Python这边基本上是没有任何一个工具是背后有公司在支持的
[01:25:44.560 --> 01:25:50.560] 所以就是大家在社区里面的声量都差不多
[01:25:50.560 --> 01:25:52.560] 所以也可能有这一个问题吧
[01:25:52.560 --> 01:25:54.560] 如果今天哪一天Google真的就跳出来
[01:25:54.560 --> 01:25:57.560] 就写了一个Python包管理器
[01:25:57.560 --> 01:26:02.560] 那大概五成开发者会去用吧我觉得
[01:26:02.560 --> 01:26:03.560] 但是就没有
[01:26:03.560 --> 01:26:07.560] Google有一套开发流程叫Bezel
[01:26:07.560 --> 01:26:08.560] 我不知道你们知不知道
[01:26:08.560 --> 01:26:11.560] 它不仅可以写Python的依赖管理
[01:26:11.560 --> 01:26:12.560] 它可以写任何语言
[01:26:12.560 --> 01:26:16.560] 但它又是另外一套完全不同的东西
[01:26:16.560 --> 01:26:20.560] 对就是说我其实也可以理解
[01:26:20.560 --> 01:26:23.560] 它的本质上原因还是因为Python
[01:26:23.560 --> 01:26:25.560] 就是这本语言在发展过程中
[01:26:25.560 --> 01:26:28.560] 它的组织结构就是一个比较松散的
[01:26:28.560 --> 01:26:32.560] 依靠个人开发者来contribute这样一种结构
[01:26:32.560 --> 01:26:33.560] 它没有一个自上而下的
[01:26:33.560 --> 01:26:37.560] 比如说一个公司来控制这后面的一整套
[01:26:37.560 --> 01:26:39.560] 就是一整套流程该怎么做
[01:26:39.560 --> 01:26:44.560] 所以它自然而然就发展出了各种不同的一些
[01:26:44.560 --> 01:26:47.560] 就是工作的方法
[01:26:47.560 --> 01:26:48.560] 可以这样理解
[01:26:48.560 --> 01:26:53.560] 所以当然我觉得它相对于就是它当然也有好的一点
[01:26:53.560 --> 01:26:57.560] 就是说它避免了就是一个大家都用的工具
[01:26:57.560 --> 01:26:58.560] 被某个大公司控制
[01:26:58.560 --> 01:27:00.560] 然后这个大公司突然开始作恶的情况
[01:27:00.560 --> 01:27:03.560] 就这个在Python社区里基本上是不太可能出现
[01:27:03.560 --> 01:27:10.560] OK那其实就是Python当然也有一些就是工具过多的问题
[01:27:10.560 --> 01:27:14.560] 但是可能它相对Node.js
[01:27:14.560 --> 01:27:18.560] 是还是有一些好就是做更好的地方
[01:27:18.560 --> 01:27:21.560] 然后我们下面就把时间给TP来抱怨NPM
[01:27:21.560 --> 01:27:23.560] 其实我刚刚已经讲了一些了
[01:27:23.560 --> 01:27:26.560] 就是NPM就是很多人都说
[01:27:26.560 --> 01:27:31.560] 为什么Python没有就是一个Node module就完事了
[01:27:31.560 --> 01:27:33.560] 还要搞那么多Virtual Environment
[01:27:33.560 --> 01:27:36.560] 那我就跟你说你是绝对没有写过Electron的
[01:27:36.560 --> 01:27:38.560] 每次写Electron首先
[01:27:38.560 --> 01:27:43.560] 是出手先全部的binary package全部重新编译一次
[01:27:43.560 --> 01:27:46.560] 然后全部都找不到C compiler
[01:27:46.560 --> 01:27:52.560] 那对然后例如说如果你在你的Electron App里面
[01:27:52.560 --> 01:27:55.560] 你可能要用到一些C driver的话就是更痛苦
[01:27:55.560 --> 01:27:58.560] 然后如果那就是说Node没有
[01:27:58.560 --> 01:28:01.560] 就是例如说Node 8升级到Node 9
[01:28:01.560 --> 01:28:03.560] 就是没有相同的问题的时候
[01:28:03.560 --> 01:28:06.560] 那你肯定是没有写过C module的
[01:28:06.560 --> 01:28:10.560] 就是我从8升级到9全部的东西都坏了
[01:28:10.560 --> 01:28:12.560] 重新再编译一次还编译不起来
[01:28:12.560 --> 01:28:16.560] 然后我要回退到Node 8还没有办法
[01:28:16.560 --> 01:28:19.560] 就就是让你非常崩溃
[01:28:19.560 --> 01:28:26.560] 所以其实像那个MVM还有那个RBEMV吧
[01:28:26.560 --> 01:28:28.560] 就是都是解决类似的问题
[01:28:28.560 --> 01:28:31.560] 就是你可以就是你升级系统的那个
[01:28:31.560 --> 01:28:33.560] 系统的interpreter的时候
[01:28:33.560 --> 01:28:37.560] 你不需要升级你就是专案里面那个interpreter
[01:28:37.560 --> 01:28:41.560] 那所以就是PyEMV也是解决类似的状况
[01:28:41.560 --> 01:28:45.560] 但是就是PyEMV本质上就是一个很特别的产物
[01:28:45.560 --> 01:28:50.560] 就是它解决的use case
[01:28:50.560 --> 01:28:55.560] 就是已经在就是有一部分已经被VirtualEMV解决掉了
[01:28:55.560 --> 01:28:58.560] 所以它就变成一个很碟床架屋的状态
[01:28:58.560 --> 01:29:02.560] 就是又有PyEMV然后它同时可以管理系统
[01:29:02.560 --> 01:29:04.560] 就是系统的Python版本
[01:29:04.560 --> 01:29:08.560] 然后又可以管理专案里面的Python版本
[01:29:08.560 --> 01:29:10.560] 那这两个东西是混在一起的
[01:29:10.560 --> 01:29:13.560] 就变成比较尴尬的状态
[01:29:13.560 --> 01:29:16.560] 所以我觉得就是这个也是
[01:29:16.560 --> 01:29:19.560] 就是Node在这里还是有一些后发优势吧
[01:29:19.560 --> 01:29:22.560] 就是它毕竟是一个比较新的生态
[01:29:22.560 --> 01:29:25.560] 所以它就不会有Python之前走过的那些路
[01:29:25.560 --> 01:29:27.560] 它就看了那些Python之前走过的路
[01:29:27.560 --> 01:29:29.560] 就可以直接不走
[01:29:29.560 --> 01:29:32.560] 但是就是它为了不走Python这个路
[01:29:32.560 --> 01:29:34.560] 所以就创造了一些其他的问题
[01:29:34.560 --> 01:29:37.560] 就例如说那个dependency hail嘛
[01:29:37.560 --> 01:29:40.560] 就是你的Node module是一个就一G
[01:29:40.560 --> 01:29:43.560] 那这个在Python里面是比较不会看到的
[01:29:43.560 --> 01:29:45.560] 所以对
[01:29:45.560 --> 01:29:49.560] 我觉得就是如果你要说Python就是做得不好嘛
[01:29:49.560 --> 01:29:53.560] 其实我个人觉得Python在
[01:29:53.560 --> 01:29:55.560] 就是专案管理
[01:29:55.560 --> 01:29:57.560] 不是说专案管理吧
[01:29:57.560 --> 01:30:02.560] 就是它在分隔各个专案的环境这件事情上面
[01:30:02.560 --> 01:30:05.560] 在技术上Python其实是走在非常前面的
[01:30:05.560 --> 01:30:10.560] 那其实我个人觉得它比Node比Ruby都要做得更好
[01:30:10.560 --> 01:30:11.560] 那有些我是不敢说
[01:30:11.560 --> 01:30:12.560] 像Rust我不敢说
[01:30:12.560 --> 01:30:15.560] Rust其实做得大概是更好一些
[01:30:15.560 --> 01:30:17.560] 但是Rust也有一些它自己的优势
[01:30:17.560 --> 01:30:19.560] 例如说它是就是编译语言
[01:30:19.560 --> 01:30:22.560] 所以它当然可以做一些比较
[01:30:22.560 --> 01:30:23.560] 就是Python做不到的事情
[01:30:23.560 --> 01:30:27.560] 它可以在那个编译期的时候就改写你的
[01:30:27.560 --> 01:30:29.560] 那个module名称之类的
[01:30:29.560 --> 01:30:31.560] 这些在Python是没有办法做到的
[01:30:31.560 --> 01:30:37.560] 但是我觉得在就是纯interpreter的语言里面
[01:30:37.560 --> 01:30:41.560] 来说就是Python在技术上算是做得不错的
[01:30:41.560 --> 01:30:46.560] 但是也可能是因为就是管理上的问题
[01:30:46.560 --> 01:30:51.560] 所以Python并没有办法很好地把这些技术
[01:30:51.560 --> 01:30:55.560] 就是转化成使用者看得到的界面
[01:30:55.560 --> 01:30:57.560] 是Python比较大的问题
[01:30:57.560 --> 01:31:01.560] 但是这也是前面说了就是有利有弊的部分
[01:31:01.560 --> 01:31:04.560] 嗯,OK
[01:31:04.560 --> 01:31:07.560] 就可能Node的开发者
[01:31:07.560 --> 01:31:13.560] 他也会抱怨就是Node的一些就是依赖管理的问题
[01:31:13.560 --> 01:31:16.560] 然后发现某个Python的工具特别好用
[01:31:16.560 --> 01:31:17.560] 也是有可能的
[01:31:17.560 --> 01:31:18.560] 这也是有可能的
[01:31:18.560 --> 01:31:21.560] 但是更多的可能是Node的开发者
[01:31:21.560 --> 01:31:23.560] 就是完全不会遇到这些问题
[01:31:23.560 --> 01:31:28.560] 对,因为它就是相当于你说的
[01:31:28.560 --> 01:31:31.560] 就是它的应用范围更局限一点
[01:31:31.560 --> 01:31:33.560] 那说回来就是
[01:31:33.560 --> 01:31:36.560] 你们觉得哪门语言
[01:31:36.560 --> 01:31:41.560] 它在就是工作流管理上是做得最好的呢?
[01:31:41.560 --> 01:31:43.560] 我现在觉得Rust目前还是做
[01:31:43.560 --> 01:31:46.560] 但是怎么说呢
[01:31:46.560 --> 01:31:49.560] Rust做得最不好的地方是
[01:31:49.560 --> 01:31:51.560] 如果你要用Rust
[01:31:51.560 --> 01:31:53.560] 就是你要写一个Rust binding
[01:31:53.560 --> 01:31:56.560] 给例如说一个C project的时候
[01:31:56.560 --> 01:31:58.560] Rust在这里是做得比较不好的
[01:31:58.560 --> 01:32:02.560] 就是它在呼叫C compiler这地方
[01:32:02.560 --> 01:32:04.560] 是还没有很明确的规范
[01:32:04.560 --> 01:32:06.560] 所以大家都是各写各的
[01:32:06.560 --> 01:32:09.560] 就是有些人会用C make
[01:32:09.560 --> 01:32:12.560] 有些人会用Auto tools之类的
[01:32:12.560 --> 01:32:15.560] 那它是没有很好的整合
[01:32:15.560 --> 01:32:18.560] 就是它在Rust的包裹引擎叫Cargo
[01:32:18.560 --> 01:32:21.560] 那方面是没有很好的整合
[01:32:21.560 --> 01:32:23.560] 但是我是可以预见这件事情
[01:32:23.560 --> 01:32:25.560] 就是它们是有一个很好的框架
[01:32:25.560 --> 01:32:27.560] 可以慢慢地改善
[01:32:27.560 --> 01:32:30.560] 而且Python也没有做得特别好
[01:32:30.560 --> 01:32:32.560] 所以就半斤八两吧
[01:32:32.560 --> 01:32:34.560] 我没用过我不知道
[01:32:34.560 --> 01:32:38.560] 但是我感觉Rust那些都是官方提供的
[01:32:38.560 --> 01:32:41.560] 就我是感觉你如果提供一个
[01:32:41.560 --> 01:32:44.560] 一开始就提供了一个官方的这样一套框架
[01:32:44.560 --> 01:32:47.560] 你后面后续改进都可以在这套框架里发生
[01:32:47.560 --> 01:32:51.560] 但是会导致开发者他选择困难
[01:32:51.560 --> 01:32:56.560] 就是Rust毕竟是一个相对于Python
[01:32:56.560 --> 01:32:58.560] 新太多的语言
[01:32:58.560 --> 01:33:01.560] 所以它就是从一开始做了更好的选择
[01:33:01.560 --> 01:33:03.560] 我觉得也是可以理解的
[01:33:03.560 --> 01:33:04.560] 明昕你觉得呢
[01:33:04.560 --> 01:33:05.560] 你写Rust吗
[01:33:05.560 --> 01:33:06.560] 我不写Rust
[01:33:06.560 --> 01:33:10.560] 但是我从各种渠道都是听到夸Cargo
[01:33:10.560 --> 01:33:12.560] 这个工具好的
[01:33:12.560 --> 01:33:16.560] 所以我们也会把Python的意外管理
[01:33:16.560 --> 01:33:18.560] 尽量向那边靠拢吧
[01:33:18.560 --> 01:33:20.560] 不过Rust也是有公司的
[01:33:20.560 --> 01:33:21.560] Rust也有Mozilla
[01:33:21.560 --> 01:33:27.560] 所以可能还是有一些组织架构上的区别
[01:33:27.560 --> 01:33:29.560] 对Rust是比较特殊一点
[01:33:29.560 --> 01:33:31.560] 他们其实就是Mozilla
[01:33:31.560 --> 01:33:34.560] 就是Rust也有Rust自己的基金会
[01:33:34.560 --> 01:33:36.560] 跟Mozilla其实是分开的
[01:33:36.560 --> 01:33:40.560] 但是就是Mozilla是有往那边送人吧
[01:33:40.560 --> 01:33:44.560] 所以对就是一些比较隐藏的影响力
[01:33:44.560 --> 01:33:49.560] 说到底都是人和钱的问题
[01:33:49.560 --> 01:33:52.560] OK好
[01:33:52.560 --> 01:33:58.560] 然后我们也聊了这么多各种细节
[01:33:58.560 --> 01:34:02.560] 然后我们下面想说
[01:34:02.560 --> 01:34:06.560] 比如说我就是一个普通的开发者
[01:34:06.560 --> 01:34:08.560] 我在2020年我想
[01:34:08.560 --> 01:34:11.560] 我就是要写一些Python的程序
[01:34:11.560 --> 01:34:14.560] 那我没有时间去了解这么多库
[01:34:14.560 --> 01:34:16.560] 这么多细节
[01:34:16.560 --> 01:34:19.560] 能不能请两位就直接了当地告诉我
[01:34:19.560 --> 01:34:21.560] 我应该怎么选
[01:34:21.560 --> 01:34:23.560] 我应该怎么搭建我的这样一个工作流
[01:34:23.560 --> 01:34:25.560] 就是你们可以从我要开发一个库
[01:34:25.560 --> 01:34:27.560] 或者开发一个应用程序
[01:34:27.560 --> 01:34:30.560] Application这两方面来聊一聊
[01:34:30.560 --> 01:34:33.560] 我们就直接了当地来推荐一些
[01:34:33.560 --> 01:34:36.560] 推荐你们觉得最好的工作流吧
[01:34:36.560 --> 01:34:38.560] 那我先说一下
[01:34:38.560 --> 01:34:41.560] 如果你是一个库的开发者
[01:34:41.560 --> 01:34:44.560] 因为我知道就是库的开发者
[01:34:44.560 --> 01:34:46.560] 跟Application的开发者
[01:34:46.560 --> 01:34:48.560] 很多时候是不是重合的
[01:34:48.560 --> 01:34:50.560] 然后如果你是一个库的开发者的话
[01:34:50.560 --> 01:34:53.560] 如果你不想去管那些奇奇怪怪的工具
[01:34:53.560 --> 01:34:55.560] 不想去学那些东西
[01:34:55.560 --> 01:34:57.560] 你就直接用最原始的
[01:34:57.560 --> 01:34:59.560] Setup and Tools就可以了
[01:34:59.560 --> 01:35:02.560] 然后用Setup and Py这个文件去定义
[01:35:02.560 --> 01:35:04.560] 你的你的包名依赖
[01:35:04.560 --> 01:35:07.560] 还有那些原信息和这些东西
[01:35:07.560 --> 01:35:09.560] 然后开发的话
[01:35:09.560 --> 01:35:12.560] 还是用Virtual Lab去做开发
[01:35:12.560 --> 01:35:17.560] 如果你觉得Setup and Py这个文件
[01:35:17.560 --> 01:35:21.560] 它主要问题是配置很难写
[01:35:21.560 --> 01:35:25.560] 因为我就算也是做过很多个Library
[01:35:25.560 --> 01:35:27.560] 但是我还是记不住那Setup and Py里面的
[01:35:27.560 --> 01:35:29.560] 每一个配置项它是怎么写的
[01:35:29.560 --> 01:35:31.560] 每次我都要去查文档
[01:35:31.560 --> 01:35:34.560] 那么你可以用一下Poetry
[01:35:34.560 --> 01:35:37.560] Poetry的话它是用TOMO的文件方式
[01:35:37.560 --> 01:35:40.560] 去组织你的项目的原数据
[01:35:40.560 --> 01:35:42.560] 这个配置的话
[01:35:42.560 --> 01:35:45.560] 写上去会比较直观一些
[01:35:45.560 --> 01:35:47.560] 当然了最后还是要打一下广告
[01:35:47.560 --> 01:35:50.560] 就是说如果你想尝试一下新东西的话
[01:35:50.560 --> 01:35:52.560] 欢迎使用PDM
[01:35:52.560 --> 01:35:53.560] 那么第二个是
[01:35:53.560 --> 01:35:55.560] 假如你是做Web开发的
[01:35:55.560 --> 01:35:57.560] Web开发的话
[01:35:57.560 --> 01:35:59.560] 基本上你就是不需要有
[01:35:59.560 --> 01:36:01.560] 打包上传的这一个需求
[01:36:01.560 --> 01:36:04.560] 那么你可以去用PPMV
[01:36:04.560 --> 01:36:08.560] 因为之前我在2019的Survey上
[01:36:08.560 --> 01:36:11.560] 也看到用PPMV的人数
[01:36:11.560 --> 01:36:14.560] 是比用Poetry的人多很多倍的
[01:36:14.560 --> 01:36:18.560] 所以也算是经受了战斗的考验吧
[01:36:18.560 --> 01:36:20.560] 所以可以选择用PPMV
[01:36:20.560 --> 01:36:25.560] 而且PPMV最近要发正式版了
[01:36:25.560 --> 01:36:29.560] 所以用2020年的新版的话
[01:36:29.560 --> 01:36:31.560] 可能会以前一些遗留的问题
[01:36:31.560 --> 01:36:33.560] 会得到很多的解决
[01:36:33.560 --> 01:36:36.560] 其实差不了太多
[01:36:36.560 --> 01:36:39.560] 但我推荐就是
[01:36:39.560 --> 01:36:41.560] 如果你要开发Library的话
[01:36:41.560 --> 01:36:45.560] 就是我会推荐使用Tox
[01:36:45.560 --> 01:36:48.560] 或者是Nox
[01:36:48.560 --> 01:36:50.560] 就是一个差不多的管理器
[01:36:50.560 --> 01:36:53.560] 就是前面有稍微聊到
[01:36:53.560 --> 01:36:55.560] 就是它可以同时管理很多个
[01:36:55.560 --> 01:36:58.560] 那个版本的Python
[01:36:58.560 --> 01:37:01.560] 那这个在开发Library的时候
[01:37:01.560 --> 01:37:04.560] 是非常有用处的
[01:37:04.560 --> 01:37:06.560] 那如果是开发Application
[01:37:06.560 --> 01:37:08.560] 我会建议的流程是
[01:37:08.560 --> 01:37:11.560] 就是当然你建立一个新的专案
[01:37:11.560 --> 01:37:13.560] 就是先不要管你是
[01:37:13.560 --> 01:37:15.560] 要想要写Library还是Application
[01:37:15.560 --> 01:37:19.560] 都是先从Application开始想
[01:37:19.560 --> 01:37:21.560] 就是你先建立一个专案
[01:37:21.560 --> 01:37:24.560] 然后开始往里面塞程式
[01:37:24.560 --> 01:37:26.560] 那当你想要
[01:37:26.560 --> 01:37:29.560] 但是在你写程式的时候
[01:37:29.560 --> 01:37:32.560] 就是在你写这个Application的时候
[01:37:32.560 --> 01:37:33.560] 你就尽量预想到说
[01:37:33.560 --> 01:37:35.560] 之后可能会有打包的需求
[01:37:35.560 --> 01:37:38.560] 所以你就把你的那个
[01:37:38.560 --> 01:37:41.560] 就是你的.py档
[01:37:41.560 --> 01:37:42.560] 就是整理好
[01:37:42.560 --> 01:37:44.560] 然后放在一个package下面
[01:37:44.560 --> 01:37:47.560] 就是有一个底线底线init.py
[01:37:47.560 --> 01:37:49.560] 这样子有一个结构下面
[01:37:49.560 --> 01:37:51.560] 那当你要打包的时候
[01:37:51.560 --> 01:37:57.560] 你这时候再建立你的setup.py
[01:37:57.560 --> 01:37:59.560] 或是setup.cfg
[01:37:59.560 --> 01:38:05.560] 去把那个需要的打包的设定写起来
[01:38:05.560 --> 01:38:09.560] 我会比较建议这样子的流程
[01:38:09.560 --> 01:38:11.560] OK
[01:38:11.560 --> 01:38:14.560] 那就是说打包用什么东西呢
[01:38:14.560 --> 01:38:18.560] 总得用一个什么东西吧
[01:38:18.560 --> 01:38:21.560] 我还是用setup tools最多
[01:38:21.560 --> 01:38:22.560] OK
[01:38:22.560 --> 01:38:26.560] 那就是前面明秀说
[01:38:26.560 --> 01:38:28.560] 就是用Portrait可能比较直观
[01:38:28.560 --> 01:38:31.560] 但是可能是我用Portrait不够多吧
[01:38:31.560 --> 01:38:34.560] 就是我还是得查文档
[01:38:34.560 --> 01:38:38.560] 而且我不知道是我自己的感觉还是怎么样
[01:38:38.560 --> 01:38:39.560] 就是Portrait文档
[01:38:39.560 --> 01:38:42.560] 其实写的没有特别完整
[01:38:42.560 --> 01:38:45.560] 就是很多时候我都要去
[01:38:45.560 --> 01:38:48.560] 对,所以我还是习惯
[01:38:48.560 --> 01:38:50.560] 也不是说习惯吧
[01:38:50.560 --> 01:38:53.560] 就是觉得setup tools的文档写的比较好一点
[01:38:53.560 --> 01:38:55.560] 嗯
[01:38:55.560 --> 01:38:58.560] 毕竟是久经考验的一个
[01:38:58.560 --> 01:39:00.560] Portrait还比较新
[01:39:00.560 --> 01:39:02.560] 才1.0没多久
[01:39:02.560 --> 01:39:04.560] OK
[01:39:04.560 --> 01:39:06.560] 然后我们到时候也会贴一个链接
[01:39:06.560 --> 01:39:08.560] 就是Python Packaging User Guide
[01:39:08.560 --> 01:39:11.560] 就是像是PyPA一个官方的文档
[01:39:11.560 --> 01:39:13.560] 然后它里面涵盖的内容
[01:39:13.560 --> 01:39:16.560] 其实比我们今天要聊的还多一些
[01:39:16.560 --> 01:39:18.560] 就是在各种场景下
[01:39:18.560 --> 01:39:21.560] 你可以有哪些选择
[01:39:21.560 --> 01:39:23.560] 然后包括一些我们今天没聊到的
[01:39:23.560 --> 01:39:25.560] 比如说用Docker
[01:39:25.560 --> 01:39:28.560] 或者是用OpenStack
[01:39:28.560 --> 01:39:30.560] 甚至就是说你直接在硬件上面
[01:39:30.560 --> 01:39:33.560] 就有一个专属的硬件
[01:39:33.560 --> 01:39:35.560] 比如说CircuitPy
[01:39:35.560 --> 01:39:38.560] 就是一个专属的板子
[01:39:38.560 --> 01:39:42.560] 然后你可以开发一些IoT的东西
[01:39:42.560 --> 01:39:44.560] 然后其实是有在不同场景下
[01:39:44.560 --> 01:39:45.560] 有很多选择
[01:39:45.560 --> 01:39:46.560] 就还是那句话
[01:39:46.560 --> 01:39:48.560] Python能做的事情实在是太多了
[01:39:48.560 --> 01:39:50.560] 然后就在不同场景下
[01:39:50.560 --> 01:39:53.560] 可能也有一些就是最适合的选择
[01:39:53.560 --> 01:39:55.560] 然后对
[01:39:55.560 --> 01:39:58.560] 大家还是根据自己的场景来选择吧
[01:39:58.560 --> 01:40:01.560] 但是如果就是说针对最普遍的需求
[01:40:01.560 --> 01:40:02.560] 如果你想开发一个库
[01:40:02.560 --> 01:40:03.560] 或者是一个应用程序的话
[01:40:03.560 --> 01:40:06.560] 可以参考刚才两位大佬的建议
[01:40:06.560 --> 01:40:08.560] 嗯好
[01:40:08.560 --> 01:40:10.560] 然后其实我们今天主要内容
[01:40:10.560 --> 01:40:12.560] 就聊这么就主要内容
[01:40:12.560 --> 01:40:13.560] 其实就是这些
[01:40:13.560 --> 01:40:15.560] 然后但我这里突然想插播一个广告
[01:40:15.560 --> 01:40:17.560] 就发现我这边好像忘打了
[01:40:17.560 --> 01:40:18.560] PyChina现在在
[01:40:18.560 --> 01:40:21.560] 他们一直很缺志愿者
[01:40:21.560 --> 01:40:24.560] 那PyChina这个组织是以前
[01:40:24.560 --> 01:40:27.560] 组织历年的PyCon China的
[01:40:27.560 --> 01:40:30.560] 就是他们负责组织历年的PyCon China
[01:40:30.560 --> 01:40:32.560] 然后平时也会有一些很有意思的
[01:40:32.560 --> 01:40:34.560] Python的技术分享
[01:40:34.560 --> 01:40:38.560] 他们一直是非常希望有新鲜血液加入的
[01:40:38.560 --> 01:40:42.560] 然后如果说你们有兴趣去参与
[01:40:42.560 --> 01:40:44.560] 组织一些Python相关的活动
[01:40:44.560 --> 01:40:47.560] 然后认识一些Python社区里的大佬
[01:40:47.560 --> 01:40:48.560] 比如说Manzu Saka
[01:40:48.560 --> 01:40:51.560] 然后你们可以考虑加入一下
[01:40:51.560 --> 01:40:55.560] 然后方式的话我们会也贴在show notes里
[01:40:55.560 --> 01:40:57.560] OK好广告打完了
[01:40:57.560 --> 01:41:02.560] 我问一下就是你们那个叫什么
[01:41:02.560 --> 01:41:05.560] 就是反正那个PyChina不知道
[01:41:05.560 --> 01:41:06.560] 就是那个组织是怎么样
[01:41:06.560 --> 01:41:08.560] 就是有实体的聚会吗
[01:41:08.560 --> 01:41:09.560] 还是都是线上的
[01:41:09.560 --> 01:41:12.560] 因为像我们就是台湾很小嘛
[01:41:12.560 --> 01:41:15.560] 所以基本上要实体聚会是没有什么问题的
[01:41:15.560 --> 01:41:20.560] 但是就像你们那边是怎么样进行
[01:41:20.560 --> 01:41:23.560] 我不是这个组织的一员不好意思
[01:41:23.560 --> 01:41:25.560] 但是据我了解的情况
[01:41:25.560 --> 01:41:30.560] 他们是他们有一些微信群用来日常讨论
[01:41:30.560 --> 01:41:35.560] 但是有没有实体我其实也不太清楚
[01:41:35.560 --> 01:41:38.560] 对然后可能那个Manzu Saka他比较清楚
[01:41:38.560 --> 01:41:40.560] 他是老成员
[01:41:40.560 --> 01:41:45.560] 好然后最后就是我还列了一个
[01:41:45.560 --> 01:41:49.560] 就是一小部分就是一些思考吧
[01:41:49.560 --> 01:41:56.560] 就是我其实在就像一做就策划这些节目的过程中
[01:41:56.560 --> 01:42:00.560] 我也是看到了那个Gradle他在
[01:42:00.560 --> 01:42:02.560] 他做和Python Bites这个播客的时候
[01:42:02.560 --> 01:42:04.560] 他说了一句话
[01:42:04.560 --> 01:42:09.560] 就是他说就我先把英文原文念出来
[01:42:09.560 --> 01:42:13.560] 原文是Design is not final until it's implemented
[01:42:13.560 --> 01:42:18.560] 然后翻译过来就是说你你做对一个产品
[01:42:18.560 --> 01:42:24.560] 做它的设计的过程是直到你真正把这个产品实现完了
[01:42:24.560 --> 01:42:25.560] 它才完成的
[01:42:25.560 --> 01:42:30.560] 那我觉得其实这就很好的描述了Python的工作流的这样一个演化的过程
[01:42:30.560 --> 01:42:34.560] 就是说他一开始其实并没有一个明确的设计
[01:42:34.560 --> 01:42:38.560] 然后大家在使用过程中发现有这样那样的需求
[01:42:38.560 --> 01:42:41.560] 然后大家就开始添加这样那样的工具
[01:42:41.560 --> 01:42:43.560] 然后呢在这过程中可能有一些
[01:42:43.560 --> 01:42:49.560] 有些人会试图把这样的工具去做一些标准化的工作
[01:42:49.560 --> 01:42:53.560] 然后或者说是创建一些就是写一些新的Design
[01:42:53.560 --> 01:42:56.560] 就是就是未来我们可能加什么功能
[01:42:56.560 --> 01:43:02.560] 其实这一切都是在就是说实现和设计是在同步进行的
[01:43:02.560 --> 01:43:09.560] 然后我觉得这可能也是就是尤其是这种社区主导的项目的一个常态吧
[01:43:09.560 --> 01:43:14.560] 对然后我不知道嘉宾们同不同意我这个看法
[01:43:14.560 --> 01:43:18.560] 反正我就可能是这样子
[01:43:20.560 --> 01:43:23.560] 对啊其实就是前面有说到吗
[01:43:23.560 --> 01:43:25.560] 就是我现在在做那个Pip的解析器
[01:43:25.560 --> 01:43:30.560] 就是其实就老实说反正这讲中文的大概就PSF也不会听到
[01:43:30.560 --> 01:43:34.560] 就是那时候我提就是这一个就是那一个半年计划的时候
[01:43:34.560 --> 01:43:39.560] 觉得这钱就是钱是不是有点多会不会白给啊
[01:43:39.560 --> 01:43:41.560] 但实际做下去的时候
[01:43:41.560 --> 01:43:45.560] 没有我觉得这太少了
[01:43:45.560 --> 01:43:48.560] 就是时间根本不够啊
[01:43:48.560 --> 01:43:50.560] 时间根本就不够啊
[01:43:50.560 --> 01:43:53.560] 就是这个时做下去发现实在是问题一大堆
[01:43:53.560 --> 01:43:57.560] 你就是想很简单就是就是我Pip install这些套件吧
[01:43:57.560 --> 01:43:59.560] 然后这些套件就拿去解析一下
[01:43:59.560 --> 01:44:02.560] 然后把结果传回来这不就完了吗
[01:44:02.560 --> 01:44:05.560] 就哪那么简单就是后面的问题一大堆
[01:44:05.560 --> 01:44:09.560] 那一开始想好的那些设计吧
[01:44:09.560 --> 01:44:17.560] 现在就是大概至少至少四分之一是完全跟一开始预期是不一样的
[01:44:17.560 --> 01:44:20.560] 所以我还是蛮同意这句话的
[01:44:20.560 --> 01:44:23.560] 就是像那个packaging社群里面也是吧
[01:44:23.560 --> 01:44:25.560] 就是常常会有人就是进PipA
[01:44:25.560 --> 01:44:31.560] 然后提一些非常就是非常美好的愿景
[01:44:31.560 --> 01:44:36.560] 然后想说就是他们都觉得就是提的人都觉得就是非常完美
[01:44:36.560 --> 01:44:38.560] 就是Python就这样做就完了
[01:44:38.560 --> 01:44:45.560] 然后下面就会各种批斗就是这样这样这样就是就不行了
[01:44:45.560 --> 01:44:46.560] 就是这样这样这样就不行
[01:44:46.560 --> 01:44:48.560] 然后就马上就打退堂鼓
[01:44:48.560 --> 01:44:53.560] 所以我觉得如果对那个packaging有一些想法的话
[01:44:53.560 --> 01:44:57.560] 还是尽量的从实作开始着手
[01:44:57.560 --> 01:44:59.560] 就是如果你做出了什么东西之后
[01:44:59.560 --> 01:45:04.560] 大家都会比较愿意去理解你的想法这样子
[01:45:04.560 --> 01:45:08.560] 就反正我觉得就是自然而然吧
[01:45:08.560 --> 01:45:11.560] 然后就是我就给予时间的话
[01:45:11.560 --> 01:45:15.560] 它总会发展到一个就是大家都比较满意的状态
[01:45:15.560 --> 01:45:18.560] 但是就这一切都需要时间
[01:45:18.560 --> 01:45:22.560] 而且Python的问题就是就是我们所有的过程都是公开的
[01:45:22.560 --> 01:45:25.560] 所以你那些非常丑陋的这些过程都是大家看得到的
[01:45:25.560 --> 01:45:29.560] 而不是像就是像YARM就是你在Facebook内部
[01:45:29.560 --> 01:45:31.560] 就是可能还是有一些丑陋的过程
[01:45:31.560 --> 01:45:32.560] 只是我们都不知道而已
[01:45:32.560 --> 01:45:35.560] 我们看到的就是1.0了
[01:45:35.560 --> 01:45:39.560] 是的是的
[01:45:39.560 --> 01:45:45.560] 好那我们这期其实也真的聊了特别多的内容
[01:45:45.560 --> 01:45:49.560] 然后肯定也有很多东西给听众们去消化
[01:45:49.560 --> 01:45:52.560] 那最后我是还是我们的惯例
[01:45:52.560 --> 01:45:54.560] 然后想请两位嘉宾
[01:45:54.560 --> 01:45:59.560] 然后来还有什么给还有什么想给听众说的
[01:45:59.560 --> 01:46:02.560] 然后就是来做一个总结吧
[01:46:02.560 --> 01:46:04.560] 就是也不一定要局限于packaging
[01:46:04.560 --> 01:46:07.560] 就比如说你们要怎么学习编程啊
[01:46:07.560 --> 01:46:13.560] 或者是怎么加入社区开发就anything
[01:46:13.560 --> 01:46:15.560] 怎么会学习编程
[01:46:15.560 --> 01:46:21.560] 我觉得先学英文吧还是最重要的
[01:46:21.560 --> 01:46:24.560] 但是我觉得对
[01:46:24.560 --> 01:46:28.560] 就是学习可能还有一些就是学习文化吧
[01:46:28.560 --> 01:46:30.560] 就是实际工作过
[01:46:30.560 --> 01:46:33.560] 就是像因为现在是真的只是跟那个
[01:46:33.560 --> 01:46:37.560] 就是跟美国人跟英国人跟印度人工作
[01:46:37.560 --> 01:46:40.560] 就是实际上文化还是真的是蛮不一样的
[01:46:40.560 --> 01:46:45.560] 所以预先有理解的话还是比较容易一些
[01:46:45.560 --> 01:46:48.560] 对所以就是学习外语吧
[01:46:48.560 --> 01:46:51.560] 学习外国文化还是最重要的
[01:46:51.560 --> 01:46:53.560] ok
[01:46:53.560 --> 01:46:59.560] 对我们来说可能还有学习翻墙的这个障碍在里面
[01:46:59.560 --> 01:47:00.560] 对还有像相反过来吧
[01:47:00.560 --> 01:47:02.560] 就是他们讲的就是你看的
[01:47:02.560 --> 01:47:04.560] 就是这怎么就是在骂我吗
[01:47:04.560 --> 01:47:06.560] 就其实也可能也不是
[01:47:06.560 --> 01:47:08.560] 他们平常就是这样表达的
[01:47:08.560 --> 01:47:10.560] 对我我很同意
[01:47:10.560 --> 01:47:13.560] 就是有时候就有时候你的中文里的一些表达
[01:47:13.560 --> 01:47:14.560] 直接翻译过去
[01:47:14.560 --> 01:47:17.560] 其实是会显得很不礼貌的
[01:47:17.560 --> 01:47:20.560] 就是可能这些东西都需要注意一下
[01:47:20.560 --> 01:47:22.560] 嗯
[01:47:22.560 --> 01:47:24.560] 其实开源社区一般都还是对式的
[01:47:24.560 --> 01:47:26.560] 就是就事论事
[01:47:26.560 --> 01:47:28.560] 相对来讲对
[01:47:28.560 --> 01:47:30.560] ok好那那明昕
[01:47:30.560 --> 01:47:32.560] 我这边没有什么好说
[01:47:32.560 --> 01:47:34.560] 不如来推荐一个库吧
[01:47:34.560 --> 01:47:37.560] 那你推荐吧既然你都准备了
[01:47:37.560 --> 01:47:39.560] 我是考虑本来时间太长了
[01:47:39.560 --> 01:47:40.560] 我就不让你们推荐
[01:47:40.560 --> 01:47:42.560] 但如果你们想推荐当然可以推荐
[01:47:42.560 --> 01:47:44.560] 对来吧
[01:47:44.560 --> 01:47:47.560] ok我推荐这个库就是Rich
[01:47:47.560 --> 01:47:51.560] 是一个专门让终端花里胡哨的一个库
[01:47:51.560 --> 01:47:54.560] 我好像见过嗯你介绍一下吧
[01:47:54.560 --> 01:47:56.560] 它的主要亮点是
[01:47:56.560 --> 01:47:57.560] 第一个我觉得
[01:47:57.560 --> 01:48:00.560] 第一个是它去应用样式的话
[01:48:00.560 --> 01:48:02.560] 就是说把你的文字去改个颜色什么
[01:48:02.560 --> 01:48:05.560] 它是用类似于HTML tag的方式
[01:48:05.560 --> 01:48:08.560] 就是你不用去跳出你的字符串去
[01:48:08.560 --> 01:48:09.560] 去应用一个函数
[01:48:09.560 --> 01:48:12.560] 你直接在字符串里面去写一个tag
[01:48:12.560 --> 01:48:14.560] 然后你那个颜色就会改变
[01:48:14.560 --> 01:48:16.560] 第二个是它的这个颜色输出
[01:48:16.560 --> 01:48:18.560] 它是true color的
[01:48:18.560 --> 01:48:20.560] 那么true color就是说
[01:48:20.560 --> 01:48:23.560] 它可能有几百万种颜色在可以选择
[01:48:23.560 --> 01:48:25.560] 当然了这需要
[01:48:25.560 --> 01:48:27.560] 终端的支持
[01:48:27.560 --> 01:48:30.560] 如果你万年是使用Windows的CMD的话
[01:48:30.560 --> 01:48:33.560] 那这个就就没戏了
[01:48:33.560 --> 01:48:36.560] 第三个我比较喜欢的一个功能是
[01:48:36.560 --> 01:48:41.560] 它有它里面集成了pigments做语法高亮
[01:48:41.560 --> 01:48:43.560] 就是你可以通过Rich去
[01:48:43.560 --> 01:48:47.560] 很容易可以做自己的那个自定义的一个
[01:48:47.560 --> 01:48:50.560] 我觉得最主要的用处就是可以去展示你的traceback
[01:48:50.560 --> 01:48:52.560] 就是说你如果报错的话
[01:48:52.560 --> 01:48:55.560] 你可以去渲染你的traceback
[01:48:55.560 --> 01:48:56.560] 让它有语法高亮
[01:48:56.560 --> 01:48:59.560] 我觉得这个Rich如果配合上
[01:48:59.560 --> 01:49:02.560] Trump2Kit两个加起来
[01:49:02.560 --> 01:49:05.560] 那简直是你的那个CMD的UI
[01:49:05.560 --> 01:49:08.560] 可以无限的花里胡哨
[01:49:08.560 --> 01:49:11.560] 对我觉得是很有用的
[01:49:11.560 --> 01:49:16.560] 对于做一些就是命令行里的工具的同学来说
[01:49:16.560 --> 01:49:17.560] OK
[01:49:17.560 --> 01:49:21.560] 那如果大家都说完
[01:49:21.560 --> 01:49:24.560] 那我们今天节目差不多就这样
[01:49:24.560 --> 01:49:27.560] 然后感谢TP和明希
[01:49:27.560 --> 01:49:30.560] 然后以及小白来做这期节目
[01:49:30.560 --> 01:49:34.560] 然后真的是很荣幸请到两位
[01:49:34.560 --> 01:49:35.560] OK
[01:49:35.560 --> 01:49:37.560] 好那我们就今天节目就到这样
[01:49:37.560 --> 01:49:40.560] 然后各位听众我们就下期再见
[01:49:40.560 --> 01:49:41.560] 拜拜
[01:49:41.560 --> 01:49:42.560] 好
[01:49:42.560 --> 01:49:44.560] 本期捕蛇者说的播客就到这里
[01:49:44.560 --> 01:49:45.560] 感谢您的收听
[01:49:45.560 --> 01:49:49.560] 本期内容中提到的资料链接都会放到我们的网站上
[01:49:49.560 --> 01:49:52.560] 我们的网址是pythonhunter.org
[01:49:52.560 --> 01:49:55.560] 由于我们主播的知乎账号被禁
[01:49:55.560 --> 01:49:58.560] 所以以后的更新都不会再发布到知乎上
[01:49:58.560 --> 01:49:59.560] 请您留意
[01:49:59.560 --> 01:50:02.560] 推荐您使用泛用型客户单订阅我们的播客
[01:50:02.560 --> 01:50:04.560] 也欢迎您关注我们的推特
[01:50:04.560 --> 01:50:07.560] 加入我们的Telegram群组和其他听众一起聊天
[01:50:07.560 --> 01:50:11.560] 我们的推特是pythonhunter加一个下滑线
[01:50:11.560 --> 01:50:14.560] Telegram群组的链接可以在我们的网站上找到
[01:50:14.560 --> 01:50:20.560] 我们下期再见
[01:50:44.560 --> 01:51:12.560] 欢迎订阅我们的频道
[01:51:12.560 --> 01:51:14.560] 各位好,我是ManjuSasha
[01:51:14.560 --> 01:51:18.560] 听说有很多朋友想听我很大声的
[01:51:18.560 --> 01:51:21.560] 羞耻的说出来
[01:51:21.560 --> 01:51:23.560] 感谢Sasha送的内裤
[01:51:23.560 --> 01:51:25.560] 没问题,满足你们
[01:51:25.560 --> 01:51:27.560] 首先,第一位
[01:51:27.560 --> 01:51:30.560] 感谢陶子酱送出的内裤
[01:51:30.560 --> 01:51:36.560] 然后,感谢Lynskelet送出的内裤
[01:51:36.560 --> 01:51:39.560] 大声,你看我已经很大声了
[01:51:39.560 --> 01:51:42.560] 感谢Hedas送出的内裤
[01:51:42.560 --> 01:51:43.560] 放心,我不买咖啡
[01:51:43.560 --> 01:51:45.560] 谢谢你喜欢我的播客
[01:51:45.560 --> 01:51:47.560] 然后,还有
[01:51:47.560 --> 01:51:51.560] 突然发现有点多
[01:51:51.560 --> 01:51:58.560] 谢谢Hone送出的内裤
[01:51:58.560 --> 01:52:04.560] 谢谢Flaptor送出的三条内裤
[01:52:04.560 --> 01:52:09.560] 谢谢Sys送出的一条内裤
[01:52:09.560 --> 01:52:13.560] 谢谢3HotLin3S送出的两条内裤
[01:52:13.560 --> 01:52:18.560] 谢谢人工智障兔兔送出的一条内裤
[01:52:18.560 --> 01:52:22.560] 我好羞耻啊
[01:52:22.560 --> 01:52:26.560] 然后,有一位匿名用户送了我三条内裤
[01:52:26.560 --> 01:52:29.560] 在这里表示非常感谢
[01:52:29.560 --> 01:52:30.560] ID可以发我们
[01:52:30.560 --> 01:52:31.560] 我们已经私信了你
[01:52:31.560 --> 01:52:33.560] 等一下ID可以发我们一下
[01:52:33.560 --> 01:52:36.560] 我们有机会再郑重感谢一下
[01:52:36.560 --> 01:52:40.560] 然后,谢谢大卫猫送出的三条内裤
[01:52:40.560 --> 01:52:42.560] 我突然发现我现在内裤已经很多了
[01:52:42.560 --> 01:52:43.560] 多少条了?
[01:52:43.560 --> 01:52:44.560] 有技术基因吗?
[01:52:44.560 --> 01:52:50.560] 然后,谢谢Tomano送出的六条内裤
[01:52:50.560 --> 01:52:55.560] 然后,谢谢Keg送出的六条内裤
[01:52:55.560 --> 01:52:58.560] 谢谢非法操作送出的一条内裤
[01:52:58.560 --> 01:53:03.560] 谢谢9Y4千秋送出的一条内裤
[01:53:03.560 --> 01:53:08.560] 谢谢David送出的三条内裤
[01:53:08.560 --> 01:53:15.560] 抱歉啊,我要哭了
[01:53:15.560 --> 01:53:19.560] 然后,谢谢MikeJun送出的一条内裤
[01:53:19.560 --> 01:53:23.560] 好的,以上是我感谢所有朋友们
[01:53:23.560 --> 01:53:25.560] 愿意送我的内裤
[01:53:25.560 --> 01:53:27.560] 然后,我现在内裤已经很多了
[01:53:27.560 --> 01:53:30.560] 谢谢你们让孩子体会了夏天的温暖
[01:53:30.560 --> 01:53:57.560] 谢谢大家
