[00:30.000 --> 00:34.680] 欢迎大家来到捕蛇者说
[00:34.880 --> 00:36.600] 本期我们邀请到F叔
[00:36.600 --> 00:38.640] 一起来聊一下Python与服务化
[00:39.240 --> 00:43.320] 同时捕蛇者说也迎来一位新的主持小白同学
[00:43.640 --> 00:45.519] 小白同学先介绍一下自己吧
[00:46.519 --> 00:47.560] Hello 大家好
[00:47.560 --> 00:50.000] 我是捕蛇者说的新人编辑小白
[00:50.240 --> 00:53.360] 我的常用ID是ryoma
[00:53.560 --> 00:57.000] 这个是取自网球王子李月钱龙马的英文名
[00:57.320 --> 00:58.400] 按照常理来说
[00:58.400 --> 01:01.360] 我是去年毕业到现在工作刚刚满一年
[01:01.680 --> 01:05.200] 目前我是在自己大学导师成立的公司工作
[01:05.440 --> 01:07.840] 公司是做车联网套件开发的
[01:07.840 --> 01:09.400] 我负责的是软件部分
[01:09.679 --> 01:12.360] 主要的开发语言是Python和JavaScript
[01:12.560 --> 01:14.520] 使用的框架是Django和Vue
[01:15.520 --> 01:16.960] OK 欢迎小白
[01:18.000 --> 01:21.200] 以及我们今天邀请到的嘉宾F叔
[01:21.320 --> 01:23.039] 可以先自我介绍一下
[01:23.560 --> 01:24.240] 大家好
[01:24.240 --> 01:25.160] 我叫李亚洲
[01:25.160 --> 01:27.480] 我觉得在网上大家有很多人叫我F叔
[01:27.480 --> 01:30.440] 我是Haskell取写指南的益者
[01:30.560 --> 01:36.040] 之前几年曾在豆瓣IBM之呼工作过
[01:36.040 --> 01:39.760] 主要的工作语言是Python和Go
[01:39.920 --> 01:48.960] 然后在之呼的经历是在做服务化相关和平台建设
[01:48.960 --> 01:51.800] 就是在负责马斯克平台
[01:52.000 --> 01:55.000] 然后现在在元辅导做容器平台
[01:55.000 --> 01:58.360] 我们先照例进行第一个话题
[01:59.200 --> 02:01.320] 大家都是怎么接触到Python的呢
[02:01.320 --> 02:01.800] 对
[02:01.800 --> 02:03.840] 因为每次我们邀请到嘉宾的时候
[02:03.840 --> 02:05.840] 其实都会想简单的聊一下
[02:05.840 --> 02:08.400] 说大家是如何接触并开始使用Python
[02:08.400 --> 02:14.720] 我接触Python是在06年
[02:14.720 --> 02:19.720] 在QQ群里认识一个朋友叫王毛毛
[02:19.720 --> 02:24.400] 他当时在翻译一个Python经要的参考
[02:24.400 --> 02:26.160] 这个哥们挺牛的
[02:26.160 --> 02:29.120] 然后就那时候开始了解了Python
[02:29.120 --> 02:31.440] 不过真正使用Python还是在毕业之后
[02:31.440 --> 02:32.760] 到了豆瓣工作
[02:32.760 --> 02:35.080] Python作为一个工作语言
[02:35.080 --> 02:36.400] 不过当时
[02:37.160 --> 02:37.520] 对
[02:37.520 --> 02:41.480] 那个哥们他是专门研究Python研究的挺蛮厉害的
[02:41.480 --> 02:43.760] 但不过当时我跟他说他玩Python
[02:43.760 --> 02:45.960] 然后我跟着看了一会
[02:45.960 --> 02:48.080] 然后我去学Ruby了
[02:48.080 --> 02:52.880] 所以当时我自己去学的
[02:52.880 --> 02:55.680] 还是往后只是了解了Python
[02:55.680 --> 02:58.079] 后面就去学Ruby了
[02:58.079 --> 02:59.880] 但工作的时候Ruby找不到工作
[02:59.880 --> 03:02.320] 就去了用了Python
[03:02.320 --> 03:06.600] 06年你已经上大学了吗
[03:06.600 --> 03:07.000] 没有
[03:07.000 --> 03:09.400] 那时候上高一
[03:09.400 --> 03:12.720] 高一就已经开始接触编程了
[03:12.720 --> 03:14.120] 嗯
[03:14.120 --> 03:15.240] OK
[03:15.240 --> 03:16.000] 小白你呢
[03:16.000 --> 03:19.560] 你是怎么接触了解到Python的呢
[03:19.560 --> 03:20.960] 我最早的时候
[03:20.960 --> 03:23.400] 其实我是学PHP的
[03:23.400 --> 03:25.720] 然后就是做网站
[03:25.720 --> 03:27.800] 然后PHP那个时候你懂的
[03:27.800 --> 03:30.000] 就是总说太复杂了
[03:30.000 --> 03:32.640] 因为各种调用
[03:32.640 --> 03:37.000] 他那个箭头那种实在是就是习惯不了
[03:37.000 --> 03:39.240] 然后后边就后面就学长
[03:39.240 --> 03:41.400] 学长就说你要是喜欢简单一点的
[03:41.400 --> 03:42.560] 你就去学学Python
[03:42.560 --> 03:46.840] 然后16年16年那时候就刚开始接触
[03:46.840 --> 03:50.200] 然后16年自己学了一点
[03:50.200 --> 03:53.040] 17年的时候我们导师这个项目开始做
[03:53.040 --> 03:54.679] 他就让我选语言
[03:54.679 --> 03:57.440] 然后给我的选择是Python和Java
[03:57.440 --> 03:58.359] 我看了下Java
[03:58.359 --> 04:01.040] 我是感觉我自己接受不了
[04:01.040 --> 04:03.000] 然后就就就就选了Python
[04:03.000 --> 04:04.119] 就一直用到现在
[04:04.119 --> 04:04.440] 对
[04:05.959 --> 04:06.880] 嗯
[04:06.880 --> 04:07.959] 相比于Java
[04:07.959 --> 04:11.640] 好像Python是不是确实对新人上手来说
[04:11.640 --> 04:13.480] 应该会轻松一些
[04:13.480 --> 04:13.799] 对
[04:13.799 --> 04:15.480] 这不只是轻松了
[04:15.480 --> 04:18.800] 就理解理解上也是很容易理解
[04:18.800 --> 04:22.560] 而且不需要配各种东西就可以直接跑起来
[04:22.560 --> 04:24.040] 对对对
[04:24.040 --> 04:27.040] 那不如你对Java有有何感受
[04:27.040 --> 04:28.440] 你也是做过Java的人
[04:29.480 --> 04:30.280] 哦
[04:31.520 --> 04:31.880] 哦
[04:31.880 --> 04:33.240] Java还真没做过
[04:33.240 --> 04:35.440] 就不过现在是在一个Java厂里
[04:35.440 --> 04:38.720] 就是给我感觉会是
[04:41.160 --> 04:43.440] 就是Java的
[04:43.440 --> 04:49.719] 像Supreme他们整整一套给人的一些魔法款
[04:49.719 --> 04:51.160] 可能会少一点
[04:51.160 --> 04:58.240] 就是各个项目里面就分层分的好像还挺挺标致的
[04:58.240 --> 05:00.400] 就比如说最下层我有个数据层
[05:00.400 --> 05:02.000] 然后中间有个service层
[05:02.000 --> 05:03.480] 再上层一个接口层
[05:03.480 --> 05:05.440] 好像有经验没经验的人
[05:05.440 --> 05:07.920] 好像都会照着这个样子来来写
[05:07.920 --> 05:09.800] 而且命名好像还挺规范的
[05:09.800 --> 05:12.120] 比如呢
[05:14.240 --> 05:19.800] 就比如说我下层就拿一个model里面防御数据
[05:19.800 --> 05:23.560] 比如说我可能有一个answer
[05:23.560 --> 05:24.840] 他们可能会都叫
[05:24.840 --> 05:28.600] list answers by xx
[05:28.600 --> 05:31.120] get answers by xxx
[05:31.120 --> 05:34.920] 好像全都意味着挺规范的
[05:34.920 --> 05:40.440] 就是在代码结构组织和一些命名上
[05:40.440 --> 05:42.720] 应该会有一些较强的规范性对吧
[05:42.720 --> 05:44.600] 对对对
[05:44.600 --> 05:50.240] 而且可能给人的发挥空间可能没那么大
[05:50.240 --> 05:54.000] 所以我就都照着框架的架子去来
[05:54.000 --> 05:58.400] 可能不会每个人的写法不一样这种感觉
[05:58.400 --> 06:01.760] 不像python
[06:01.760 --> 06:05.760] 对这点ruby是更严重的
[06:05.760 --> 06:11.000] 你看一个不同的项目基本上是一个不同的语言那种感觉
[06:11.000 --> 06:15.599] 那你觉得比如说python在规范化方面可以有哪些提升吗
[06:15.599 --> 06:19.520] python在规范化方面
[06:19.520 --> 06:21.120] 我想一想
[06:21.120 --> 06:24.760] python我感觉最恐怖的是metaclass
[06:24.760 --> 06:27.680] python里面反正各个公司里面用python公司里面
[06:27.680 --> 06:28.880] 反正大家都见过metaclass
[06:28.880 --> 06:32.480] 但是也许应不应该用在那个里面
[06:32.480 --> 06:36.000] 那个地方可能是很多时候是有待商榷的
[06:36.000 --> 06:39.000] 所以就是有的时候语法的一些灵活度
[06:39.000 --> 06:42.480] 对我们工程对工程不一定是好事
[06:42.480 --> 06:47.640] 但是给我还有一种感觉是用python框架的开发
[06:47.640 --> 06:49.280] 我们做一般一个项目的工程师
[06:49.280 --> 06:53.080] 他会对整个的墙后端的完整的这个流程
[06:53.080 --> 06:54.280] 他都会比较熟悉
[06:54.280 --> 06:56.600] 比如说我这个框架可能没那么厚
[06:56.600 --> 06:58.200] 但是问了一个java的工程师
[06:58.200 --> 07:01.360] 他说我这个请求是的是生命周期的话
[07:01.360 --> 07:03.080] 他们可能很多时候没有概念
[07:03.080 --> 07:06.840] 有可能就是这种抽象的包装有点太厚这种感觉
[07:06.840 --> 07:10.240] 但python的框架层面好像没有这么
[07:10.240 --> 07:12.840] 反而没有那么厚的那种抽象的包装
[07:12.840 --> 07:15.400] 这个我不太清楚java
[07:15.400 --> 07:16.200] 因为我没写过
[07:16.200 --> 07:19.000] 所以我理解就是比如说同样是做web
[07:19.000 --> 07:22.159] 对上层的互动公司来说
[07:22.159 --> 07:24.800] 大家可能先专注于实现业务逻辑对吧
[07:24.800 --> 07:29.120] 那主要实现的是handler这一层以及往下
[07:29.120 --> 07:33.160] 但是对于一个http请求的整个生命周期
[07:33.160 --> 07:34.880] 在框架里是如何流转的
[07:34.880 --> 07:37.360] 然后被做了哪些调整
[07:37.360 --> 07:38.440] 添加了哪些属性
[07:38.440 --> 07:40.720] 可能因为java包裹的太厚了
[07:40.720 --> 07:42.240] 不是特别的清晰
[07:42.240 --> 07:44.240] 对对对对对
[07:44.240 --> 07:47.440] 那如果java做服务化
[07:47.440 --> 07:48.960] 他们也会有这种问题吗
[07:48.960 --> 07:50.960] 可能会有这种感觉
[07:50.960 --> 07:54.440] 就是同样一个RPC请求进来
[07:54.440 --> 07:56.120] 也会被包裹的
[07:56.120 --> 08:00.320] 这样就不那么了解了
[08:00.320 --> 08:03.280] 不过我理解说java的RPC框架
[08:03.280 --> 08:05.080] 应该也会在一个ROC框架内
[08:05.080 --> 08:07.320] ROC框架会有一个问题
[08:07.320 --> 08:09.600] 就是说它会让你的站特别丑陋
[08:09.600 --> 08:13.720] 就是说你的站其实是一个动态注入进去的
[08:13.720 --> 08:17.320] 你并不是说我这一个点调用另一个点
[08:17.320 --> 08:20.680] 而是说我这个注入的是一个接口
[08:20.680 --> 08:21.600] 输入一个interface
[08:21.600 --> 08:25.040] 然后那个对象类是在哪里
[08:25.040 --> 08:27.960] 它是这么动态的组成的
[08:27.960 --> 08:30.720] 所以java的站会特别丑
[08:30.720 --> 08:33.480] 不过Python的话
[08:33.480 --> 08:37.680] 你像从一个WSJI进去外部框架的话
[08:37.680 --> 08:39.600] 其实站板没有很厚
[08:39.600 --> 08:44.720] 中间可能就经过一层处理
[08:44.720 --> 08:47.440] 外加几层框架的middleware
[08:47.440 --> 08:51.240] 对基本上就会进到用户的写的handler上
[08:51.240 --> 08:54.600] 对而且还有一点是我不太清楚
[08:54.600 --> 08:56.320] 是我对java了解可能比较少
[08:56.320 --> 09:00.080] 但是像Juncoin它的原码是非常精简的
[09:00.080 --> 09:03.040] 就是Python的应用服务器这一层
[09:03.040 --> 09:08.040] 就是Juncoin可能花个一个来星期就可以把它代码过一遍
[09:08.040 --> 09:10.040] 但是看了一下java的tomcat
[09:10.040 --> 09:13.200] 哇真的小时十几万行
[09:13.200 --> 09:15.360] 可能做的事情会更多一些
[09:15.360 --> 09:18.280] 而且我想说一下
[09:18.280 --> 09:22.920] 我接受不了java项目的那种配置文件
[09:22.920 --> 09:25.000] 它那个配置我感觉有点逆天了
[09:25.000 --> 09:28.920] 像新版的java的话
[09:28.920 --> 09:32.720] 可能如果是过去插Mail会比较逆天
[09:32.720 --> 09:34.720] 不过最近好像用了助解之后
[09:34.720 --> 09:38.640] 很多配置可以干掉了
[09:38.640 --> 09:41.160] 好像用了助解的代码还是挺蛮清爽的
[09:41.160 --> 09:44.360] 但是助解它跟decorator不一样
[09:44.360 --> 09:47.160] 助解它比decorator难写很多
[09:47.160 --> 09:49.600] 好像得有很专家的人才会写助解
[09:49.600 --> 09:52.719] 所以说还是不是那么实用
[09:52.719 --> 09:53.719] 对新手而言
[09:53.719 --> 09:58.199] 对新手的话可能会很难去写好一个助解
[09:58.199 --> 10:01.839] 因为python的decorator是直接在对一个函数来附加行为
[10:01.839 --> 10:06.040] 但是助解它真的是只是一个标记
[10:06.040 --> 10:10.400] 然后你要在启动的时候scan你的java的类
[10:10.400 --> 10:14.040] 然后通过反射找出来哪些类打的助解
[10:14.040 --> 10:15.360] 哪个方法打的助解
[10:15.360 --> 10:17.840] 然后再通过反射修改那个方法
[10:17.840 --> 10:19.440] 对这个方法增加行为
[10:20.520 --> 10:22.200] 但是我可能理解不对
[10:22.200 --> 10:25.000] 没事我们可以之后出刊物之类的
[10:25.560 --> 10:27.680] 好那我们今天聊一下今天的主题
[10:27.960 --> 10:29.400] 因为我们邀请到F叔
[10:29.400 --> 10:33.600] 还是想聊一下和服务化相关的一些话题
[10:33.600 --> 10:35.560] F叔之前在知乎对吧
[10:35.560 --> 10:38.640] 相当于也是推动了很多服务化的事情
[10:38.760 --> 10:42.480] 所以想先来聊一下到底什么是服务化
[10:42.480 --> 10:47.400] 因为其实感觉不同的人不同公司背景的人
[10:47.400 --> 10:49.000] 大家在聊服务化的时候
[10:49.000 --> 10:50.440] 在聊服务化方案的时候
[10:50.440 --> 10:53.040] 好像也是千差万别的
[10:54.680 --> 10:56.120] 理解是的
[10:56.120 --> 11:02.480] 其实像现在粉丝处都能见到微服务这个名词
[11:02.920 --> 11:05.480] 可能叫服务化可能叫的比较顺
[11:05.480 --> 11:11.480] 就是现在外面大家其实都更多常说的是微服务
[11:11.480 --> 11:14.560] 但是在公司里面你在做微服务的时候
[11:14.560 --> 11:17.000] 你可能会说我在有一个服务化项目
[11:17.000 --> 11:20.080] 然后我们再把公司在做服务化改造
[11:20.080 --> 11:21.480] 这里面服务化或者微服务
[11:21.480 --> 11:23.640] 它好像是有一点经久不衰了
[11:23.640 --> 11:26.720] 像最近几年大家比较普遍
[11:26.720 --> 11:29.240] 也是行业内普遍接受的这么一个事件
[11:29.240 --> 11:32.880] 它肯定是有一定的背景能解决一定的问题
[11:32.880 --> 11:37.120] 我个人理解说服务化它主要的出发点还是
[11:37.120 --> 11:38.920] 一是项目规模
[11:38.920 --> 11:40.160] 二是data速度
[11:40.160 --> 11:44.160] 一是适应业务的增长和人员规模的增长
[11:44.160 --> 11:47.480] 另外一个是适应一个data速度的增长
[11:47.480 --> 11:50.360] 然后另外还有一点还比较重要
[11:50.360 --> 11:53.600] 就是说业务访问量的规模的增加
[11:53.600 --> 11:59.439] 也是也这种技术因素也是提出服务化
[11:59.439 --> 12:01.520] 通过服务化的一个一个concern
[12:01.520 --> 12:04.760] 也有助于业务的稳定性
[12:04.760 --> 12:08.240] 就是在业务的data速度方面
[12:08.240 --> 12:12.360] 就是说你有那种有年份的老的monolist代码
[12:12.360 --> 12:13.960] 就是单体仓库的代码
[12:13.960 --> 12:18.200] 就是比较有毒是在于说你跑一次购件
[12:18.200 --> 12:21.040] 可能一跑就是能跑一天
[12:21.040 --> 12:24.200] 然后开发者如果在微服务架构里面
[12:24.200 --> 12:27.760] 可以比较轻松的去清创上阵
[12:27.760 --> 12:29.760] 假如说我有一个大单体仓库
[12:29.760 --> 12:34.160] 假如说你要在里面加一个你喜欢的一个三方库
[12:34.160 --> 12:37.120] 很容易被人砍死的
[12:37.120 --> 12:39.120] 你如果单纯提出来这个想法
[12:39.120 --> 12:41.240] 就会被人砍追着砍
[12:41.240 --> 12:45.040] 然后而且你要是在里面加上三方库的时候
[12:45.040 --> 12:47.680] 它的风险代价其实也确实是非常高的
[12:47.680 --> 12:49.680] 但是说如果你在你的微服务架构里面
[12:49.680 --> 12:51.880] 你可以用你更喜欢的一个
[12:51.880 --> 12:54.200] 或者你认为更合适的一些三方库
[12:54.200 --> 12:56.200] 和你深知语言
[12:56.200 --> 12:59.080] 来轻轻装上阵的独立开发
[12:59.080 --> 13:03.400] 然后也可以与其他同事并行开发
[13:03.400 --> 13:04.760] 像并行开发这一点
[13:04.760 --> 13:07.840] 其实这是可能是各个公司的老板
[13:07.840 --> 13:10.720] 可能比较比较中意的一点
[13:10.720 --> 13:14.480] 因为像像人月神话里面提到说我们不能
[13:14.480 --> 13:18.080] 就是你有10个女人你也不能在
[13:18.080 --> 13:20.080] 生孩子的问题是吗
[13:20.080 --> 13:22.400] 对你也不能生孩子
[13:22.400 --> 13:24.760] 在一个月内生出孩子来
[13:24.760 --> 13:26.960] 但是我们可以把一个系统呢
[13:26.960 --> 13:28.160] 拆解成不同的部分
[13:28.160 --> 13:29.319] 这些人可以并行的
[13:29.319 --> 13:30.800] 并行的去开发
[13:30.800 --> 13:32.960] 而且人生话也提到有一点是说
[13:32.960 --> 13:37.960] 一个项目要有
[13:37.960 --> 13:43.240] 它在设计层面要有少部分人来做
[13:43.240 --> 13:46.840] 要用少部分人来实现概念的一致性
[13:46.840 --> 13:49.280] 就是说当一个大单体仓库
[13:49.280 --> 13:51.600] 它面对了二三百个人同时开发的时候
[13:51.600 --> 13:54.000] 你是很难保证这种概念的一致性的
[13:54.000 --> 13:55.880] 如果你是通过系统
[13:55.880 --> 13:57.480] 通过合理的拆分
[13:57.480 --> 13:59.400] 把它分配给不同的人去
[13:59.400 --> 14:01.560] 维护的不同的子系统
[14:01.560 --> 14:03.199] 那么这个不同的子系统层面
[14:03.199 --> 14:05.239] 也可以维护起来一个比较好的
[14:05.239 --> 14:08.319] 一个设计层面的一致性
[14:08.319 --> 14:10.719] 而且它可以并行的并行开发
[14:10.719 --> 14:16.239] 但是拆分应该不是一个
[14:16.239 --> 14:19.560] 拆分应该不是一个特别容易的活
[14:19.560 --> 14:22.400] 有过经历的同学应该都知道说
[14:22.400 --> 14:23.560] 拆一个服务
[14:23.560 --> 14:26.359] 就不论是从沟通上
[14:26.359 --> 14:28.319] 还是说这个服务的设计
[14:28.319 --> 14:29.239] 以及最后的落地
[14:29.240 --> 14:32.520] 应该都是一个成本不低的事情
[14:34.680 --> 14:35.600] 是的
[14:35.600 --> 14:38.880] 不过在过去
[14:38.880 --> 14:40.720] 我主要是在智库的经历说
[14:40.720 --> 14:42.880] 在做拆分的时候
[14:42.880 --> 14:47.880] 其实走了很长的一段曲折的道路
[14:47.880 --> 14:48.640] 不能说弯路
[14:48.640 --> 14:50.520] 等于说会比较曲折
[14:50.520 --> 14:56.120] 但是也可能是说会跟现在一些新的公司
[14:56.120 --> 15:00.080] 可能不一定有拆分这一个步骤
[15:00.080 --> 15:01.840] 可能大家一起步的时候
[15:01.840 --> 15:05.400] 可能就划分好了各个子系统子项目
[15:05.400 --> 15:06.600] 可能有一些项目一开始
[15:06.600 --> 15:08.080] 它就是一个微服务架构
[15:08.080 --> 15:11.440] 可能它就没有这么一个拆分上
[15:11.440 --> 15:14.840] 走的特别曲折的这么一段经历了
[15:14.840 --> 15:17.120] 我有个疑问
[15:17.120 --> 15:18.680] 就是您刚才有提到说
[15:18.680 --> 15:19.520] 现在很多公司
[15:19.520 --> 15:21.480] 比如说它一诞生的时候
[15:21.480 --> 15:23.800] 就是一个微服务的这么一个架构
[15:23.800 --> 15:27.120] 但是其实比如说我们去看
[15:27.120 --> 15:29.319] Martin Fuller一些文章
[15:29.319 --> 15:32.240] 他其实是比较推崇说
[15:32.240 --> 15:34.079] 你上来应该先做monolith
[15:34.079 --> 15:37.680] 你应该做一个大单体先跑起来
[15:37.680 --> 15:40.839] 然后等到你的monolith逐渐大的时候
[15:40.839 --> 15:42.680] 你再去尝试做一个splitting的
[15:42.680 --> 15:44.760] 这么一个划分和拆解
[15:44.760 --> 15:48.160] 但是现在很多公司看起来
[15:48.160 --> 15:50.800] 确实是在一上来就用微服务
[15:50.800 --> 15:52.479] 你如何看这个事情呢
[15:52.480 --> 15:59.040] 如果是其实像Martin Fuller也提到说
[15:59.040 --> 16:02.480] 微服务的时候也不应该太微
[16:02.480 --> 16:05.480] 如果你有一个特别小的一个功能点的话
[16:05.480 --> 16:07.920] 其实你不能你没必要把它做成服务
[16:07.920 --> 16:10.320] 你把它加到现有的服务里面就可以
[16:10.320 --> 16:17.400] 我感觉比较好的一个划分的方式
[16:17.400 --> 16:20.200] 不管是提前划分还是事后的一些拆分
[16:20.200 --> 16:25.520] 都是按照业务的边界来去做拆分
[16:25.520 --> 16:29.000] 就比如说我有一个直播服务
[16:29.000 --> 16:32.160] 假如我有个社区
[16:32.160 --> 16:35.720] 社区它是一个很大的一个社区模块
[16:35.720 --> 16:40.080] 那我可以把社区整个放在一个服务里
[16:40.080 --> 16:42.600] 但是可能有一块东西叫直播
[16:42.600 --> 16:44.920] 它是给用户的单独的一块UI
[16:44.920 --> 16:47.880] 那么我可以把直播提前划分成一个服务
[16:47.880 --> 16:50.280] 我觉得这样也是蛮合理的
[16:50.280 --> 16:54.000] 前提是可能直播跟社区这两块可能都不小
[16:54.000 --> 16:57.360] 就是这个可能拆的时候还是要看业务对吗
[16:57.360 --> 16:59.320] 按照业务的为多来拆
[16:59.320 --> 17:01.600] 按照业务的边界
[17:01.600 --> 17:06.520] 小白你们做这种物联网车联网的公司
[17:06.520 --> 17:10.280] 会有什么考虑服务化之类的吗
[17:10.280 --> 17:14.240] 有 我现在其实就正在做这个
[17:14.240 --> 17:18.520] 但是其实我也是就是边了解然后边推进
[17:18.520 --> 17:21.400] 我们就是属于先做了一个单体应用
[17:21.400 --> 17:23.240] 然后一点点往外拆
[17:23.240 --> 17:27.680] 但是对我来说最麻烦的其实还不是说学习微服务
[17:27.680 --> 17:29.320] 而是怎么拆出来
[17:29.320 --> 17:31.800] 怎么把这个单体拆成微服务
[17:31.800 --> 17:39.200] 我现在读很多资料都是在去理解他们拆服务的思路
[17:39.200 --> 17:43.120] 然后再套在我们现在有现有的这个机制上
[17:43.120 --> 17:46.040] 那你们现在是什么思路呢
[17:46.040 --> 17:48.520] 很乱因为这个事主要是我负责的
[17:48.520 --> 17:51.120] 而且我发现一个事就是你要做微服务的话
[17:51.120 --> 17:54.840] 就是你必须要对这个业务非常了解
[17:54.840 --> 17:55.919] 是的是的
[17:55.919 --> 18:02.679] 但是我又对这个我们做这个现在做的是一个环卫项目
[18:02.679 --> 18:05.639] 我对这个流程其实并不是那么了解
[18:05.639 --> 18:10.520] 然后所以说在推进的时候就怎么去拆业务部分就很麻烦
[18:10.520 --> 18:13.000] 之前F叔应该有过这种经历吧
[18:13.000 --> 18:17.200] 就是知乎之前的服务化拆分也是F叔在推的
[18:17.200 --> 18:19.360] 对你可以简单介绍一下
[18:19.360 --> 18:22.440] 你是怎么去了解各个业务
[18:22.440 --> 18:24.320] 然后推动各个业务去拆的吗
[18:24.320 --> 18:27.200] 你是把所有的业务都了解过了吗
[18:27.200 --> 18:32.240] 其实我的出发点并不是说实话
[18:32.240 --> 18:34.520] 我其实不是从业务的出发点
[18:34.520 --> 18:40.600] 而是说当时RPC框架和发布系统都在我们团队
[18:40.600 --> 18:45.719] 所以如果服务拆分有一些不合理的地方
[18:45.719 --> 18:47.240] 大家会暴露出一些痛点
[18:47.240 --> 18:50.040] 那大家可能都不会返回给发布系统
[18:50.040 --> 18:53.800] 就比如说我这项目特别难连条
[18:53.800 --> 18:56.399] 那我们应该怎么去连条呢
[18:56.399 --> 18:59.959] 然后好像想来想去包括一些外部调研
[18:59.959 --> 19:03.000] 然后除了只能给出两个建议
[19:03.000 --> 19:05.159] 一个是说你mock掉下层的依赖
[19:05.159 --> 19:10.399] 另外一个就是说你这个服务好像确实只有你自己在调
[19:10.400 --> 19:14.040] 然后你自己一个人在调
[19:14.040 --> 19:16.560] 在你一个服务里面调另一个服务
[19:16.560 --> 19:19.040] 你把它合并起来的话
[19:19.040 --> 19:22.960] 你要去做集成测试会容易很多
[19:22.960 --> 19:30.640] 所以这是当时去推动服务支理的一个出发点
[19:30.640 --> 19:38.600] 其实是从一个连条和上线的整个流程上来出发的
[19:38.600 --> 19:45.000] 当然我可能不是从业务能格角度上讲来的
[19:45.000 --> 19:49.360] 感觉和小白遇到的问题还不太一样
[19:49.360 --> 19:52.639] 之前应该F叔推服务化的时候
[19:52.639 --> 19:55.040] 其实是有业务同学在配合的
[19:55.040 --> 19:56.879] F叔可能会出一个大的架构
[19:56.879 --> 19:59.159] 以及说提供技术方案
[19:59.159 --> 20:00.439] 比如说如何做测试
[20:00.439 --> 20:02.919] 对如何做开发
[20:02.919 --> 20:04.240] 如何做部署
[20:04.240 --> 20:05.639] 然后如何做集成
[20:05.640 --> 20:09.560] 这些基础化平台化的方案
[20:09.560 --> 20:09.840] 对
[20:09.840 --> 20:12.800] 然后由各个业务自己来根据这个
[20:12.800 --> 20:14.840] 加固化分也好
[20:14.840 --> 20:16.200] 然后现有的工具也好
[20:16.200 --> 20:18.040] 然后去把自己的代码去迁过去
[20:18.040 --> 20:20.720] 我觉得你也可以考虑一下小白
[20:20.720 --> 20:22.160] 对
[20:22.160 --> 20:25.320] 你给他提供好足够的工具
[20:25.320 --> 20:29.360] 然后你们一起把公司的整个服务的架构捋清楚了之后
[20:29.360 --> 20:32.720] 让大家各自去拆自己的业务
[20:32.720 --> 20:36.640] 不然的话你就要相当于是了解全公司的所有的业务
[20:36.640 --> 20:39.200] 你才能知道要怎么做
[20:39.200 --> 20:40.680] 对
[20:40.680 --> 20:43.240] 现在确实也是有这个思路
[20:43.240 --> 20:46.840] 其实当时我说是在推动一些服务化的事情
[20:46.840 --> 20:51.360] 其实更多其实是业务同学自身去
[20:51.360 --> 20:52.800] 大家一起来思考
[20:52.800 --> 20:55.600] 我们去怎么去让我的业务更稳定
[20:55.600 --> 20:58.520] 然后性能更好
[20:58.520 --> 21:01.200] 然后来发布
[21:01.200 --> 21:04.320] 能更平测试能整个流程可以更平滑
[21:04.320 --> 21:10.080] 然后因为我们去我们团队比较关心的点是发布的过程足够平滑
[21:10.080 --> 21:12.920] 而且发布的过程足够可靠
[21:12.920 --> 21:19.280] 就是然后顺便去有一些业务的性能问题
[21:19.280 --> 21:22.960] 我们可能会跟业务同学一起看一下
[21:22.960 --> 21:28.720] 就是不过总的来说发布的可靠性跟那个稳定性
[21:28.720 --> 21:30.840] 这是最关心的一个点
[21:30.840 --> 21:34.320] 但是因为我们服务发分早期的服务发分
[21:34.320 --> 21:39.320] 是会有一个分层的一个架构
[21:39.320 --> 21:41.399] 大家会比较了解MVC这个架构
[21:41.399 --> 21:44.080] 但是说MVC如果在做
[21:44.080 --> 21:46.800] 如果你把MVC整个拆成三层服务的话
[21:46.800 --> 21:49.320] 你会发现你的上线过程
[21:49.320 --> 21:52.120] 你的日常接一个feature的一个过程会变成
[21:52.120 --> 21:54.280] 我先改我的数据服务
[21:54.280 --> 21:56.840] 然后我再改我的controller服务
[21:56.840 --> 21:58.679] 然后我再改我的view服务
[21:58.680 --> 22:02.640] 然后你会发现你没有办法写自动化测试
[22:02.640 --> 22:03.760] 这是一点
[22:03.760 --> 22:05.760] 另外一点是说你
[22:07.520 --> 22:09.600] 你每一步如果出了错误
[22:09.600 --> 22:13.240] 你怎么去快速的恢复它
[22:13.240 --> 22:15.120] 然后你这三层是紧密的
[22:15.120 --> 22:20.120] 你是没有办法去回馈某一个服务的
[22:20.120 --> 22:23.000] 然后另外一点就是平时开发
[22:23.000 --> 22:25.200] 原先我可能在我一个人在电脑上
[22:25.200 --> 22:26.960] 我写一个单元的集成测试
[22:26.960 --> 22:29.000] 我就可以完成我的测试了
[22:29.000 --> 22:31.120] 但是说我拆分了成三层之后
[22:31.120 --> 22:34.680] 我必须得在某一个想办法去跟人连条
[22:34.680 --> 22:36.920] 这个连条的过程实是非常痛苦的
[22:36.920 --> 22:39.680] 尤其是说如果你这三层服务
[22:39.680 --> 22:41.160] 还有三个人的话
[22:41.160 --> 22:44.200] 可能平时我可能一个人
[22:44.200 --> 22:46.600] 可能花两天可以做完的事情
[22:46.600 --> 22:47.960] 但是我三个人的话
[22:47.960 --> 22:49.600] 我可能要排期排到
[22:49.600 --> 22:51.600] 选首先要选一个排期
[22:51.600 --> 22:52.840] 然后有一个人开发完了
[22:52.840 --> 22:55.400] 他要等着到那个排期的连条的日子
[22:55.400 --> 22:56.520] 然后再去连条
[22:56.520 --> 22:57.879] 然后再去测试
[22:57.879 --> 23:00.000] 然后测试出了问题了
[23:00.000 --> 23:02.400] 然后再去带三个人去
[23:02.400 --> 23:05.120] 肯定都烙刻延印在这个地方了
[23:05.120 --> 23:11.400] 所以这个地方其实是非常疼痛的
[23:11.400 --> 23:15.080] 就是说写代码是用大家
[23:15.080 --> 23:17.920] 其实写代码其实并不是最耽误大家时间的
[23:17.920 --> 23:20.160] 最耽误大家时间其实往往是沟通和协调
[23:20.160 --> 23:23.240] 如果是说如果能在沟通和协调上
[23:23.240 --> 23:27.280] 如果能让每一个人尽可能做完成一个feature
[23:27.280 --> 23:29.000] 尽可能少的去沟通协调
[23:29.000 --> 23:31.560] 尤其甚至是尤其是跨部门协调
[23:31.560 --> 23:33.800] 这样的话其实你的开发效率可以
[23:33.800 --> 23:36.200] 可以减少很多阻塞的点
[23:39.040 --> 23:42.000] 对这其实是服务化比较重要的
[23:42.000 --> 23:46.320] 其实说白了还是说要增加业务研发的
[23:46.320 --> 23:48.760] 研发部署测试的效率
[23:48.760 --> 23:51.800] 对就是当当我的项目规模变大之后
[23:51.800 --> 23:54.800] 但是其实有的时候也会看到有一些公司
[23:54.800 --> 23:57.960] 可能他们会有个专门的服务化治理团队
[23:57.960 --> 24:01.159] 但是这个团队里可能没有引入业务同学
[24:01.159 --> 24:02.840] 或者说直接就出方案了
[24:02.840 --> 24:04.280] 不和业务同学沟通
[24:04.280 --> 24:06.800] 那其实可能就会影响比较大
[24:08.000 --> 24:13.399] 是有一些因为像服务治理的工作量确实会比较大
[24:13.399 --> 24:18.520] 但是关于建设工具的话其实也需要蛮多精力的
[24:18.520 --> 24:25.480] 但是如果以后有业务的同学来一起来更主导整件事情的话
[24:25.480 --> 24:27.879] 其实我有可能会更顺利一些
[24:28.639 --> 24:33.320] 对因为因为其实服务化说白了还是你业务架构的一个变更
[24:33.320 --> 24:39.080] 对如果这个过程中你的架构设计调整没有业务同学参与的话
[24:39.080 --> 24:42.639] 那就可能做出来不是很适用于业务同学
[24:42.639 --> 24:47.800] 是的我会感觉一个比较合理的一个划分是
[24:47.800 --> 24:51.919] 工具团队要首先理解一定的业务
[24:51.919 --> 25:02.120] 另外但是工具团队要给出最起码的支持就是服务的链路的监控
[25:02.960 --> 25:08.399] 没有这个一切设计和重复都是进化水域
[25:08.399 --> 25:17.080] 就是说你如果你对你的调用链路是没有一个没有一个可视化的一个了解的话
[25:17.080 --> 25:22.159] 你是不知道你是没有办法去去那个业务层也是没有办法去做重构的
[25:22.159 --> 25:32.800] 另外另外我感觉是业务层要要关注的要更多的关注一些连条和上线层面的事情
[25:32.800 --> 25:36.040] 如果也发现以我做一个事情要不停不停的连条
[25:36.040 --> 25:39.840] 那我可能是是可能是一个smile
[25:39.840 --> 25:42.879] 我插入一个跑题的
[25:42.880 --> 25:49.240] 我们新加入了一位主播赖信涛打个招呼
[25:49.240 --> 25:55.400] 我们可以就是这样原版的剪进去乱入环节
[25:55.400 --> 25:58.320] 大家好我是赖信涛
[25:58.320 --> 26:01.920] 因为刚刚在问Adam线上的IPC有没有健全的问题
[26:01.920 --> 26:04.440] 是不是就跟ADDP一样有图片的健全
[26:04.440 --> 26:07.640] 然后他说他们在录音就直接把我给拉进来了
[26:07.640 --> 26:10.920] 好我们就当做热心观众提问了
[26:10.920 --> 26:13.000] 待会我们可以做个解答
[26:13.000 --> 26:15.000] 刚才那个话题我其实还有个疑问
[26:15.000 --> 26:19.920] F叔说就是做服务化其实很重要的是要梳理调用链路
[26:19.920 --> 26:21.920] 对对对
[26:21.920 --> 26:25.720] 我我有点好奇这个调用链路是指说
[26:25.720 --> 26:29.440] 比如说我们做完服务化之后的这种调用链路追踪
[26:29.440 --> 26:35.720] 还是说在我们做拆分的过程中就要先梳理出来去如何做
[26:35.720 --> 26:38.320] 我觉得这两个好像还有点区别
[26:38.320 --> 26:42.120] 可能一方面是比较无脑的工具支持
[26:42.120 --> 26:44.840] 这工具支持我可能是跟业务无关的
[26:44.840 --> 26:48.399] 可能各家公司其实做起来没有太大区别的
[26:48.399 --> 26:53.399] 它是本身这一套技术体系内也比较成型的
[26:53.399 --> 26:59.320] 应该是像我做服务化我可能就要做这些无脑做这些工具的支持
[26:59.320 --> 27:03.080] 另一方面是业务的拆分的话
[27:03.080 --> 27:07.840] 这方面就需要从业务层过来梳理了各个业务模块了
[27:07.840 --> 27:11.240] 其实我大概就会有一种感受
[27:11.240 --> 27:14.600] 其实说最做对服务化助力最大的其实是老板
[27:14.600 --> 27:17.000] 其实大老板CEO
[27:17.000 --> 27:22.120] 就是说老板他也会面临说一个公司人员特别多
[27:22.120 --> 27:27.760] 然后他要把让各个部门能够独立的比较能独立的运转
[27:27.760 --> 27:31.280] 他会把各个业务模块尽可能的独立开
[27:31.280 --> 27:36.280] 让他能在一定程度上独立工作这种节奏
[27:36.280 --> 27:39.560] 其实像老板设计的一些组织结构
[27:39.560 --> 27:43.560] 其实到最后其实也都是服务化的边界
[27:43.560 --> 27:45.840] 这好像是前段时间比较火的
[27:45.840 --> 27:52.080] 就是说如果你想做一个成功的服务化微服务的这种架构的话
[27:52.080 --> 27:55.440] 你其实要公司里要有对应的人员组织结构
[27:55.440 --> 27:58.600] 你才能够把微服务这个事情做得比较好
[27:58.600 --> 28:00.320] 是的 是的
[28:00.320 --> 28:06.320] 嗯 匡位法则就是说有一个匡位法则说如果
[28:06.320 --> 28:09.800] 嗯 软件架构的形式一般都反映出
[28:09.800 --> 28:11.879] 他的人员架构
[28:11.879 --> 28:14.919] 他组织架构的一个反应
[28:14.919 --> 28:16.879] 哦 这里面有一个段子就是说
[28:16.879 --> 28:22.800] 如果你有4个人4个团队来做一个编译编译器的话
[28:22.800 --> 28:25.120] 那么你得到的一个编译器呢
[28:25.120 --> 28:28.520] 一定是个4pass compiler
[28:28.520 --> 28:34.320] 哦 就会你的代码会变会follow便利4遍
[28:34.320 --> 28:37.240] 会分成4层来follow4遍
[28:37.240 --> 28:40.280] 就是会被拆分成4个模块是吗
[28:40.280 --> 28:42.360] 对这个我也听说过
[28:42.360 --> 28:44.760] 而且我也遇到过就有一个系统
[28:44.760 --> 28:47.320] 他分的那个模块非常奇怪
[28:47.320 --> 28:51.400] 但是如果你去看他们那个组织结构的话就明白了
[28:51.400 --> 28:51.639] 对
[28:51.639 --> 28:55.960] 所以说想提高一个项目整体的这种架构
[28:55.960 --> 28:59.000] 可能还要调整自己的这种团队架构
[28:59.000 --> 28:59.680] 是的
[28:59.680 --> 29:02.320] 就是比如说公司有几
[29:02.320 --> 29:04.560] 至少说你有公司里有几个事业部
[29:04.560 --> 29:09.240] 至少这可能是你的服务的最少的数量
[29:09.240 --> 29:11.400] 因为你有4个事业部的话
[29:11.400 --> 29:13.880] 事业部之间的沟通成本会比较高
[29:13.880 --> 29:19.920] 那么你这时候再用单体来做开发也变得不可能
[29:19.920 --> 29:25.480] 所以会通过服务化来解决这种协作的成本
[29:25.480 --> 29:28.160] 对就可以减少协作
[29:28.160 --> 29:29.440] 只做必要的沟通
[29:29.440 --> 29:32.480] 沟通成本它是客观的
[29:32.480 --> 29:34.840] 可能只是说用服务化
[29:34.840 --> 29:40.120] 如果只是说把沟通的一个界面的收敛到了服务的接口上
[29:40.120 --> 29:43.440] 我们刚才有提到F叔有提到说
[29:43.440 --> 29:46.440] 就是服务化的链路追踪有很多工具
[29:46.440 --> 29:48.200] 有什么推荐给大家的吗
[29:48.200 --> 29:54.320] 最近可能了解的没有那么多了
[29:54.320 --> 29:58.280] 像他最近可能像有些jigger之类
[29:58.280 --> 30:01.960] 还有像kibana之类
[30:01.960 --> 30:05.560] 可能因为在之后在调用工具
[30:05.560 --> 30:08.240] 可能是在5年前的用zipkin
[30:08.240 --> 30:10.399] 可能现在zipkin可能用的没那么多了
[30:10.399 --> 30:12.560] 可能最近可能用很多人都用的jigger
[30:12.560 --> 30:15.520] 可能会比那个时候工具链更成熟一些
[30:15.520 --> 30:17.600] 更开箱机用一些
[30:17.600 --> 30:21.080] 因为现在可能不会像之后那时候在做服务化的时候
[30:21.080 --> 30:24.600] 可能还需要再做自己去解决一些工具层面的问题
[30:24.600 --> 30:28.560] 现在可能开源的工具这方面会更成熟一些
[30:28.560 --> 30:30.159] 我有个问题
[30:30.159 --> 30:35.720] 就是这些工具是可视化一次IPC调用的
[30:35.720 --> 30:37.639] 还是说可视化很多次
[30:37.639 --> 30:42.520] 就假如说每一次调用它走的链路都不太一样的话
[30:42.520 --> 30:44.560] 就比如说有一些eaf掉了不同的系统
[30:44.560 --> 30:45.280] 这个怎么办
[30:48.159 --> 30:48.960] 是这样子
[30:48.960 --> 30:55.800] 像trace它确实是跟踪的是单次的一个调用
[30:55.800 --> 31:00.160] 因为它是有甚至每次请求的时候发产生一次traceid
[31:00.160 --> 31:01.280] 然后这个traceid呢
[31:01.280 --> 31:05.480] 然后我去跟踪这个traceid经历了哪些链路
[31:05.480 --> 31:06.800] 但是它最容易展现出来的
[31:06.800 --> 31:09.480] 是比如说它是一个汇总的一个链路关系
[31:09.480 --> 31:11.800] 就是说我从哪里去调哪里
[31:11.800 --> 31:14.400] 但是trace是一方面
[31:14.400 --> 31:16.440] 另一方面trace
[31:16.440 --> 31:20.800] 但是有的时候可能对电路链路
[31:20.800 --> 31:24.600] 你其实没有那么单次的电路链路
[31:24.600 --> 31:26.400] 其实你并不那么关心
[31:26.400 --> 31:30.360] 其实你有时候你要关心说你这个服务挂了
[31:30.360 --> 31:32.000] 然后它会影响哪些服务
[31:32.000 --> 31:37.320] 然后这个时候它其实就不需要trace这个程序的信息
[31:37.320 --> 31:40.640] 其实你只需要通过IPC的一个请求来源和请求目标
[31:40.640 --> 31:42.800] 这么一个指标信息就可以得到
[31:42.800 --> 31:47.919] 信涛说的那个其实trace应该能解决吧
[31:47.919 --> 31:52.200] 就配上那个比如说Jager或者是Zipkin
[31:52.200 --> 31:53.800] 就是说每一个请求
[31:53.800 --> 31:57.000] 它都会给你颁发一个独立的记录的traceid
[31:57.000 --> 32:00.000] 对如果你能找到那个请求
[32:00.000 --> 32:03.600] 你就可以看它走的哪个分支去调了哪个服务
[32:03.600 --> 32:05.600] 对然后调了几次这种
[32:05.600 --> 32:08.800] 它可以帮你显示一个总的应用的关系吗
[32:08.800 --> 32:14.200] 比如说我有50%的请求调了A
[32:14.200 --> 32:16.000] 然后25%的调了B
[32:16.000 --> 32:17.399] 25%的调了C
[32:17.399 --> 32:19.399] 取决于业务的判断
[32:19.399 --> 32:23.600] 这种情况下你有没有一个总体的应用调用的关系的图
[32:23.600 --> 32:26.200] 可以看到通过这些工具
[32:26.200 --> 32:28.200] 得想一想
[32:28.200 --> 32:32.600] 因为在朱布是自己内部做的自己的工具
[32:32.600 --> 32:35.600] 所以我对开源的工具可能没有那么了解
[32:35.600 --> 32:37.000] Skywalking可以吧
[32:37.000 --> 32:39.600] 应该是可以的
[32:39.600 --> 32:43.200] 就是信涛的需求是不是说
[32:43.200 --> 32:45.000] 比如说我想看一个时间段
[32:45.000 --> 32:47.800] 我自身比如说调了A服务多少次
[32:47.800 --> 32:48.800] 调了B服务多少次
[32:48.800 --> 32:50.000] 调了C服务多少次
[32:50.000 --> 32:53.200] 对因为有一个情况是
[32:53.200 --> 32:57.400] 他比如说只有10%的流量调了一个D
[32:57.400 --> 32:59.600] 但是那个D挂了可能对我没什么影响
[32:59.600 --> 33:00.600] 我就会认为这样
[33:00.600 --> 33:04.200] 可能会有这种
[33:04.200 --> 33:08.000] 就是比如说因为你关心的是你自己的对外的调用
[33:08.000 --> 33:11.800] 其实这方面你不需要trace这么重的一个一套机制
[33:11.800 --> 33:15.200] 你只需要通过从RPC客户端里有一定的
[33:15.200 --> 33:16.100] 有一定的买点
[33:16.100 --> 33:18.500] 就比如说我调用了A调用了B
[33:18.500 --> 33:20.100] 这是然后我记一个metric
[33:20.100 --> 33:21.300] 然后增加一个计数
[33:21.300 --> 33:22.500] 然后我调用失败的时候
[33:22.500 --> 33:24.600] 增加一个错误计数增加1
[33:24.600 --> 33:27.400] 然后这样的话你能你通过这个
[33:27.400 --> 33:28.400] 通过普通语言收撕
[33:28.400 --> 33:32.400] 然后你可以聚合出来我这个我自己这个服务调用了
[33:32.400 --> 33:34.400] N个服务里面有哪一些是成功的
[33:34.400 --> 33:35.200] 哪一些失败的
[33:35.200 --> 33:37.400] 对对外的QPS多少
[33:37.400 --> 33:40.800] 嗯这一边部分可以用metrics来解决
[33:40.800 --> 33:44.600] 像像这种可就服务的可见性就两个
[33:44.600 --> 33:46.200] 像其实这是两个工具
[33:46.200 --> 33:48.800] 一个是trace一个是metric
[33:48.800 --> 33:50.400] 还有一个就是log
[33:50.400 --> 33:52.600] log就比较比较
[33:52.600 --> 33:54.400] 比较好理解
[33:55.600 --> 33:58.400] 嗯就其实就是说有很多时候trace
[33:58.400 --> 34:03.600] 嗯会发现说哦在过去我们的经验和在外面交流
[34:03.600 --> 34:07.400] 是说发现trace在后面的
[34:07.400 --> 34:13.400] 嗯到后到技术科技术点的后期之后trace的用处
[34:13.400 --> 34:16.800] 嗯没有没有那么大了会变得没那么大
[34:16.800 --> 34:18.800] 就是因为说我们通过trace的
[34:18.800 --> 34:21.400] 我可以看出来一个我的应用程序
[34:21.400 --> 34:22.400] 免否循环
[34:22.400 --> 34:24.600] 然后打了一些很慢的circle
[34:24.600 --> 34:26.400] 然后比如说我一个请求
[34:26.400 --> 34:28.600] 请求了200次数据库这一种事情
[34:28.600 --> 34:30.800] 我可以通过trace来发现这种事情
[34:30.800 --> 34:33.600] 这种问题这种很这种性能问题
[34:33.600 --> 34:36.200] 嗯trace是非常有利有利的工具
[34:36.200 --> 34:40.000] 嗯像但是说呃大家发现了trace之后
[34:40.000 --> 34:44.200] 大家可能会一看哎呀我操现在的情况怎么这么糟糕
[34:44.200 --> 34:49.000] 然后有一个这么多这么多很low的性能问题
[34:49.000 --> 34:50.400] 这么傻的后期循环
[34:50.400 --> 34:53.400] 然后可能一波一波人们全都优化完了
[34:53.400 --> 34:55.400] 然后等等人们做完直播优化之后
[34:55.400 --> 34:59.400] 反而嗯会看trace看到会相对少一些
[34:59.400 --> 35:00.400] 嗯嗯
[35:00.400 --> 35:03.400] 到那时候人们更关心的可能还是那个metric层面的时候
[35:03.400 --> 35:05.400] 我的服务调用了a调用了b
[35:05.400 --> 35:06.400] 然后失败了
[35:06.400 --> 35:08.400] 然后我关心的我自己的服务
[35:08.400 --> 35:10.400] 而且我对我的metric自己报警
[35:10.400 --> 35:12.400] 当然我发现我自己的服务挂掉的时候
[35:12.400 --> 35:16.400] 我会看我的服务对外调用的那些有哪些失败的那些指标
[35:16.400 --> 35:18.400] 然后我可以看出来
[35:18.400 --> 35:21.400] 我可以定位出来我的呃我的root cost在哪里
[35:21.400 --> 35:25.400] OK所以我们说case的说trace的时候
[35:25.400 --> 35:28.400] 大部分人都说的是一次调用的trace
[35:30.400 --> 35:33.400] 对因为trace嗯在嗯我不这样
[35:33.400 --> 35:35.400] 我不太清楚现在的trace在实践哈
[35:35.400 --> 35:37.400] 在之后的trace是是采样的
[35:38.400 --> 35:40.400] 就是说我可以通过呃
[35:40.400 --> 35:44.400] 所以他的定位是说去发现那个for循环里面
[35:44.400 --> 35:49.400] 打了很多rpc或打了很多circle这样的一些呃性能问题
[35:49.400 --> 35:51.400] 的优化上面
[35:52.400 --> 35:54.400] 嗯所以也可以看到说很多trace的功能
[35:54.400 --> 35:58.400] 它是在它是一些以apm功能的形式来来体现的
[35:58.400 --> 35:59.400] 像开源的一些软件
[35:59.400 --> 36:01.400] 像kibana它有apm
[36:01.400 --> 36:03.400] 其实那个就是一个trace工具
[36:05.400 --> 36:10.400] 那这样像开始跟数据库之类的东西都要支持trace
[36:12.400 --> 36:13.400] 对对
[36:13.400 --> 36:16.400] 是的所以他其实对嗯嗯
[36:16.400 --> 36:20.400] 所以trace其实就很难做就是这一点
[36:20.400 --> 36:23.400] 所以我要把我的所有的所有的那个使用的
[36:23.400 --> 36:26.400] 公司里使用的标准库全都打上一套嗯
[36:26.400 --> 36:30.400] 打上trace这点其实其实还蛮不错的
[36:30.400 --> 36:33.400] 嗯这点好处是之后可能做的比较早
[36:33.400 --> 36:35.400] 好像那个做trace那位同学
[36:35.400 --> 36:38.400] 他把所有的之后用的所有的标准库全都打了一波
[36:38.400 --> 36:41.400] python的优势就是又打了一波monkey patch
[36:41.400 --> 36:43.400] 对python可以这么做
[36:43.400 --> 36:46.400] 可以import hook或者是monkey patch
[36:46.400 --> 36:49.400] 但是其他语言可能就要去改原代码
[36:49.400 --> 36:51.400] 然后打patch
[36:51.400 --> 36:53.400] 对go可能会比较难做
[36:53.400 --> 36:55.400] java可能还还真能做
[36:55.400 --> 36:56.400] 他有自己码编辑
[36:56.400 --> 36:58.400] 好像可以在呃
[36:58.400 --> 37:00.400] 可以在外部强行的patch它
[37:00.400 --> 37:02.400] go可能是比较难做的
[37:02.400 --> 37:04.400] 对就相当于trace
[37:04.400 --> 37:05.400] 应该matrix也是
[37:05.400 --> 37:07.400] 就是trace matrix都会要求你
[37:07.400 --> 37:12.400] 对你自身现有的所有的这种和外部的接口
[37:12.400 --> 37:14.400] 比如说redis啊数据库啊
[37:14.400 --> 37:17.400] 然后全部都要去自己封装一个库
[37:17.400 --> 37:19.400] 然后去采集这个数据
[37:19.400 --> 37:24.400] 你们你们做的那个trace是把trace的数据发到一个server
[37:24.400 --> 37:26.400] 还是说server过来采集
[37:27.400 --> 37:29.400] 哦这块我其实没有那么了解的
[37:29.400 --> 37:32.400] 这是我们是是另外一个同事做的
[37:32.400 --> 37:36.400] 嗯不过我印象中好像是会发到kafka里
[37:36.400 --> 37:38.400] 会把trace的信息
[37:38.400 --> 37:40.400] 后来好像有改动
[37:40.400 --> 37:42.400] 嗯我们我们比较古老
[37:42.400 --> 37:45.400] 我们是我们是基于log的
[37:45.400 --> 37:47.400] 就是所有的应用直观打自己log
[37:47.400 --> 37:48.400] 然后再收集起来
[37:48.400 --> 37:50.400] 根据log里面的trace
[37:50.400 --> 37:52.400] 对这个其实没有没有任何问题
[37:52.400 --> 37:54.400] 这其实其实其实其实很好的
[37:54.400 --> 37:56.400] 就是说日志染色嘛
[37:56.400 --> 37:59.400] 对这个实施成本相对会低一点
[37:59.400 --> 38:02.400] 我可能不需要去把每个全都打上
[38:02.400 --> 38:05.400] 我只要把我的日志给cover住
[38:05.400 --> 38:07.400] 然后我就可以把那个收集起来
[38:07.400 --> 38:09.400] 我的trace信息
[38:09.400 --> 38:10.400] 而且我的日志呢
[38:10.400 --> 38:12.400] 其实也可以也可以反映到
[38:12.400 --> 38:14.400] 我可以通过日志的配置呢
[38:14.400 --> 38:16.400] 然后让我的三方库也按照我的
[38:16.400 --> 38:19.400] 我的这个去带trace的日志来打出来
[38:19.400 --> 38:22.400] 而且感觉也不需要引入额外的组件
[38:22.400 --> 38:23.400] 像kafka这种
[38:23.400 --> 38:26.400] 是的你就是实现一个logger就可以了
[38:26.400 --> 38:28.400] 然后第三方库用log的时候
[38:28.400 --> 38:30.400] 都会走你的这个logger
[38:30.400 --> 38:32.400] 对这样还有一个好处就是
[38:32.400 --> 38:34.400] 你有你有一个trace请求
[38:34.400 --> 38:37.400] 你可以把所有相关的log都grab出来
[38:37.400 --> 38:39.400] 所有机器上的
[38:39.400 --> 38:42.400] 对这点非常好的非常好的
[38:42.400 --> 38:45.400] 对我觉得我觉得发到kafka这种方案
[38:45.400 --> 38:49.400] 也是可以把trace的信息打在log里面的
[38:49.400 --> 38:50.400] 对因为我不太清楚
[38:50.400 --> 38:52.400] 现在的trace方案是应该
[38:52.400 --> 38:55.400] 像过去中国是是一个采样的方案
[38:55.400 --> 38:58.400] 所以因为它定位只是如果用来个性能分析
[38:58.400 --> 39:00.400] 所以它采样是可以接受的
[39:00.400 --> 39:02.400] 不过现在不知道有没有
[39:02.400 --> 39:04.400] 是不是社区里的工具
[39:04.400 --> 39:07.400] 是不是都能做到全量分析
[39:07.400 --> 39:10.400] 我听下全量分析会更promising一些
[39:10.400 --> 39:15.400] 对但是我我们公司也是自研的嘛
[39:15.400 --> 39:17.400] 我就随便看了一些开源的
[39:17.400 --> 39:19.400] 我看到他们基本上也是提供了
[39:19.400 --> 39:22.400] 一些采样的函数支持之类的
[39:22.400 --> 39:24.400] 就怎么随机怎么采样
[39:24.400 --> 39:27.400] 你可以采特定的IPC请求
[39:27.400 --> 39:31.400] 对全量的感觉应该是不是一个技术问题
[39:31.400 --> 39:32.400] 是一个钱的问题
[39:32.400 --> 39:35.400] 对对对对
[39:35.400 --> 39:39.400] 对但是你metrics指标是可以是是可以全量的
[39:39.400 --> 39:41.400] 因为指标的代价是特别低的
[39:41.400 --> 39:43.400] 所以像前面说的
[39:43.400 --> 39:46.400] 我说我能20%请求达到A服务
[39:46.400 --> 39:47.400] 还30%请求达到B服务
[39:47.400 --> 39:50.400] 听起来这个就metrics可能是一个更合适的一个工具
[39:50.400 --> 39:53.400] 但是这metrics只有说我A和B
[39:53.400 --> 39:54.400] 但是他没有一个全链路
[39:54.400 --> 39:57.400] 他他没有一个全链路的这么一个信息
[39:57.400 --> 39:58.400] 对
[39:58.400 --> 40:02.400] 知乎是基于metrics做了一个全链路分析的工具
[40:02.400 --> 40:03.400] 对吧
[40:03.400 --> 40:07.400] 对知乎的是因为你就A和B嘛
[40:07.400 --> 40:09.400] 然后然后B他知道B和C
[40:09.400 --> 40:12.400] 然后里面上你可以在外部呢再做一下缩印
[40:12.400 --> 40:15.400] 然后把ABC这样去去串起来串起来
[40:15.400 --> 40:17.400] A掉了用B掉了百分之多少
[40:17.400 --> 40:18.400] B掉了C掉了百分之多少
[40:18.400 --> 40:20.400] 然后C如果如果故障的话
[40:20.400 --> 40:23.400] 你你也是可以通过这外部的信息来还原出来
[40:23.400 --> 40:25.400] CB可能有风险
[40:25.400 --> 40:27.400] 然后A可能要挂这种情况
[40:27.400 --> 40:31.400] 我们是把每一次IPC调用都标一个序号
[40:31.400 --> 40:34.400] 比如说A掉了B那就是1
[40:34.400 --> 40:35.400] B掉了C那就是1.1
[40:35.400 --> 40:37.400] B掉了D就是1.2
[40:37.400 --> 40:41.400] 对然后再通过线下的分析把所有的trace
[40:41.400 --> 40:43.400] 就比如说百分之多少掉了几
[40:43.400 --> 40:48.400] 就通过分析trace来搞了一个全链路的这个数据
[40:48.400 --> 40:51.400] 对应该实际上方案都是类似的吧
[40:51.400 --> 40:54.400] 就是在指标层面就是做一个规范
[40:54.400 --> 40:57.400] 就是能够反映出它的调用链来
[40:57.400 --> 41:01.400] 然后再通过你的自己构建一个分析工具
[41:01.400 --> 41:03.400] 然后把这个事情做可视化
[41:03.400 --> 41:05.400] 是的可视化对
[41:05.400 --> 41:08.400] 你们各个公司都会自己做一层
[41:08.400 --> 41:11.400] 其实我觉得知乎的服务化
[41:11.400 --> 41:14.400] 其实都是站在一超的肩膀上
[41:14.400 --> 41:21.400] 就因为一超做了这种trace matrix和可视化
[41:21.400 --> 41:23.400] 这样这一整套东西
[41:23.400 --> 41:29.400] 会可以比较比较轻松的能看到说服务化的一个电影关系
[41:29.400 --> 41:32.400] 早期的时候大家都做了这服务化的时候
[41:32.400 --> 41:34.400] 其实都是缺少规划的
[41:34.400 --> 41:37.400] 其实很难说某一个公司在做服务化的时候
[41:37.400 --> 41:40.400] 会有一个架构师来来做个规划
[41:40.400 --> 41:42.400] 因为架构师的知识也有限了
[41:42.400 --> 41:43.400] 他不可能理解所有的业务
[41:43.400 --> 41:46.400] 更多时候服务你接受微服务的时候
[41:46.400 --> 41:48.400] 会是一个野蛮生长的一个状态
[41:48.400 --> 41:50.400] 就是可能有一个工程师
[41:50.400 --> 41:52.400] 他会他会收到一个需求
[41:52.400 --> 41:55.400] 他会他会建立起一个新的微服务出来
[41:55.400 --> 41:59.400] 然后然后另一个公司又又建出一个微服务出来
[41:59.400 --> 42:01.400] 所以会在很在早期的时候
[42:01.400 --> 42:04.400] 你会很难嗯没有一个任何一个人能知道
[42:04.400 --> 42:06.400] 说说我们现在的整体的架构
[42:06.400 --> 42:09.400] 因为他早期可能是没有这种一个
[42:09.400 --> 42:13.400] 呃他就是一个野蛮野蛮生长的出来一个状态
[42:13.400 --> 42:15.400] 当当这个工具成熟了
[42:15.400 --> 42:19.400] 或者说发现了一些发现一些不合理的服务拆分
[42:19.400 --> 42:21.400] 慢慢经历出来的痛点之后啊
[42:21.400 --> 42:23.400] 大家可能会回复头来
[42:23.400 --> 42:25.400] 然后去看整件事情
[42:25.400 --> 42:28.400] 然后从从总体上来看这个事情
[42:28.400 --> 42:31.400] 对我我其实一直坚持的观点就是服务的拆分
[42:31.400 --> 42:35.400] 一定要有自身的业务同学参与
[42:35.400 --> 42:38.400] 他要知道说这个业务是在干嘛
[42:38.400 --> 42:39.400] 然后他要做哪些事情
[42:39.400 --> 42:42.400] 他要怎么拆对这个事情很难说
[42:42.400 --> 42:45.400] 有服务治理团队能够直接来说
[42:45.400 --> 42:46.400] 他来怎么拆
[42:46.400 --> 42:48.400] 我觉得福利服务治理团队
[42:48.400 --> 42:50.400] 也许可以给一些拆分的原则呀
[42:50.400 --> 42:53.400] 规范呀这种最佳实践呀
[42:53.400 --> 42:55.400] 但是说具体是要怎么拆
[42:55.400 --> 42:59.400] 应该还是要由相关的业务同学来做决定
[42:59.400 --> 43:00.400] 会好一些
[43:00.400 --> 43:04.400] 因为因为他对自身的这个开发成本是什么样子的
[43:04.400 --> 43:06.400] 测试成本是什么样子的
[43:06.400 --> 43:07.400] 调试成本是什么样子的
[43:07.400 --> 43:08.400] 是最清楚的
[43:09.400 --> 43:10.400] 是的对
[43:10.400 --> 43:12.400] 其实其实有个发现说
[43:12.400 --> 43:14.400] 就像安大姆有关心的
[43:14.400 --> 43:16.400] 其实都是开发成本和调试成本
[43:16.400 --> 43:22.400] 其实这些问题到最后都会归结到这么个服务
[43:22.400 --> 43:25.400] 服务治理上服务跟服务架构上
[43:25.400 --> 43:28.400] 因为就是说当公司里面人比较多的时候
[43:28.400 --> 43:35.400] 可能那个关心到也从假如如果我从性能或者从开发成本和测试成本
[43:35.400 --> 43:37.400] 和之类的沟通成本上
[43:37.400 --> 43:41.400] 最后可能会自然的会往这个微服务架构去走
[43:41.400 --> 43:44.400] 至少你要可能在我在微服务的架构
[43:44.400 --> 43:47.400] 体系内去思考整件事情
[43:47.400 --> 43:50.400] 那F叔想问一下
[43:50.400 --> 43:53.400] 就是比如说如果现在有公司他决定做服务化的话
[43:53.400 --> 43:55.400] 你有什么推荐吗
[43:55.400 --> 43:56.400] 就是还要自己写框架吗
[43:56.400 --> 43:59.400] 因为我知道知乎在当年做的时候
[43:59.400 --> 44:04.400] 其实业界没有什么开源的成熟的这种服务化框架
[44:04.400 --> 44:08.400] 对那如果是现在呢你有什么推荐吗
[44:08.400 --> 44:14.400] 就是说很容易很容易会把那个RPC这个事情
[44:14.400 --> 44:18.400] RPC框架这个事情想的过于简单
[44:18.400 --> 44:21.400] 因为就是我就发一个请求
[44:21.400 --> 44:23.400] 然后序列化一下发一个请求
[44:23.400 --> 44:25.400] 然后返序列化一下嘛
[44:25.400 --> 44:27.400] 也确实是这样子
[44:27.400 --> 44:33.400] 但是但是他这里有一个有一个很恶心的一些点
[44:33.400 --> 44:36.400] 就是在于我这个框架是作为一个三线框库
[44:36.400 --> 44:39.400] 我要发给所有的业务所有业务使用
[44:39.400 --> 44:42.400] 其实我的演进成本是非常高的
[44:42.400 --> 44:45.400] 你会时不时的发现我又要加一个新的小需求
[44:45.400 --> 44:47.400] 就比如说我要加一个监控
[44:47.400 --> 44:49.400] 我我之前没有监控
[44:49.400 --> 44:50.400] 我之前没有想到监控
[44:50.400 --> 44:52.400] 我现在再加上监控指标
[44:52.400 --> 44:54.400] 然后哎我又没有加上trace
[44:54.400 --> 44:56.400] 然后我要再加上trace
[44:56.400 --> 44:59.400] 然后然后我想起来我没有加上
[44:59.400 --> 45:01.400] 我这个绘度发布不好使
[45:01.400 --> 45:05.400] 然后我要再加上绘度发布等等等等
[45:05.400 --> 45:08.400] 这这种小东西其实技术含量都很低
[45:08.400 --> 45:13.400] 但是嗯这是当你当你想到你需要这个东西的时候
[45:13.400 --> 45:15.400] 你可能早期你嗯你想起来
[45:15.400 --> 45:19.400] 你没有没有没有加这个指标或者是之类
[45:19.400 --> 45:22.400] 后面你可能就得追着所有的业务
[45:22.400 --> 45:24.400] 一个个一家一家的去升级
[45:24.400 --> 45:26.400] 这是一个是风险非常大
[45:26.400 --> 45:31.400] 2020其实投入产生比是特别特别低
[45:31.400 --> 45:33.400] 当然现在会有service mesh
[45:33.400 --> 45:36.400] 然后然后来降低这种客户端升级成本
[45:36.400 --> 45:42.400] 但是但是感觉现在你去选择一个成熟的框架
[45:42.400 --> 45:44.400] 然后真的是可以
[45:44.400 --> 45:48.400] 然后这些方案呢都有些成绩现成的
[45:48.400 --> 45:52.400] 然后你在真的是可以节约你很多的精力
[45:52.400 --> 45:55.400] 在这种追着业务去升级方面
[45:55.400 --> 45:57.400] 而且有一些升级会特别难做
[45:57.400 --> 45:59.400] 就是说你既要跑去升级
[45:59.400 --> 46:01.400] 你还要考虑跟旧版本的兼容性
[46:01.400 --> 46:06.400] 这方面就就这种升级就会特别特别恶心
[46:08.400 --> 46:11.400] 我我前段时间看了这家PC
[46:11.400 --> 46:15.400] 感觉这家PC真是特别上线非常高的一个
[46:15.400 --> 46:16.400] RPC框架
[46:16.400 --> 46:20.400] 真的现成的一些中间件和以及像trace啊和
[46:20.400 --> 46:25.400] 和指标窥图发布啊之类都整合的非常好
[46:25.400 --> 46:28.400] 我根据我个人观察
[46:28.400 --> 46:31.400] 国内很多公司的RPC框架其实都在用TCP
[46:31.400 --> 46:35.400] 然后在TCP上自己封装去再去做通信
[46:35.400 --> 46:42.400] 其实我会强烈建议在一个应用层协议上去做RPC框架
[46:42.400 --> 46:44.400] 就像这RPC中我在TCP2上
[46:44.400 --> 46:46.400] 然后这样的话我可以在中间件上
[46:46.400 --> 46:48.400] 我可以中间放一个中间件
[46:48.400 --> 46:50.400] 这个中间件可以截住我的请求
[46:50.400 --> 46:51.400] 我可以知道我的
[46:51.400 --> 46:53.400] 我里面有这个请求的概念
[46:53.400 --> 46:54.400] 我有多少个QPS
[46:54.400 --> 46:57.400] 我中间件的这层面可以拿到很多很多有用的信息
[46:57.400 --> 46:59.400] 也可以做一些很有用的事情
[46:59.400 --> 47:02.400] 比如说我要断路掉这个RPC请求
[47:02.400 --> 47:04.400] 或者想加一个建议加一层键权
[47:04.400 --> 47:07.400] 把这个在中间件上把这个键权
[47:07.400 --> 47:08.400] 把这个请求给咔嚓掉
[47:08.400 --> 47:10.400] 类似会特别灵活一点
[47:10.400 --> 47:15.400] 如果你用一个TCP在这个来做通信的话
[47:15.400 --> 47:20.400] 会比较中间件层面会难介入一些
[47:20.400 --> 47:23.400] 就是中间件拿不到你应用层的一些信息
[47:23.400 --> 47:26.400] 就没办法走一些更逻辑上的事情
[47:26.400 --> 47:31.400] 是的而且HTTP本身会有很好的扩展性
[47:31.400 --> 47:33.400] 比如说原先没有trace ID
[47:33.400 --> 47:34.400] 我传一个trace ID
[47:34.400 --> 47:36.400] 然后我这家黑店里面加上一个trace ID就好了
[47:36.400 --> 47:38.400] 我现在原先没有键权
[47:38.400 --> 47:39.400] 后来我需要做键权了
[47:39.400 --> 47:42.400] 我在黑店里面再加上一个键权通就好了
[47:43.400 --> 47:47.400] 信涛之前乱入的时候有问说
[47:47.400 --> 47:50.400] RPC框架需要做键权吗
[47:51.400 --> 47:53.400] 我是这么理解的
[47:53.400 --> 47:57.400] 一般是说我们HTTP的给业务的给OS
[47:57.400 --> 47:59.400] 安卓的对接的这些API
[47:59.400 --> 48:01.400] 它是有一个明显的键权
[48:01.400 --> 48:02.400] 它有一个code
[48:02.400 --> 48:04.400] 然后传一个asset token过来
[48:04.400 --> 48:06.400] 然后我会通过asset token解出来
[48:06.400 --> 48:07.400] 这个user ID是谁
[48:08.400 --> 48:09.400] 对吧
[48:09.400 --> 48:12.400] 但是我个人理解说到了RPC这一层面
[48:12.400 --> 48:14.400] 它就没有这asset token了
[48:14.400 --> 48:15.400] 你一进来的时候
[48:15.400 --> 48:17.400] 我就认为它是一个
[48:17.400 --> 48:19.400] 它就是这个用户了
[48:19.400 --> 48:24.400] 比如说我在那个接口下面是有一个点赞接口
[48:24.400 --> 48:25.400] 点赞的接口
[48:25.400 --> 48:27.400] 然后它带着一个asset token
[48:27.400 --> 48:30.400] 然后我如果要转成RPC的话
[48:30.400 --> 48:33.400] 它是说某一个user要点赞
[48:33.400 --> 48:35.400] 然后你要把这个user ID
[48:35.400 --> 48:37.400] 直接传给这个RPC接口
[48:37.400 --> 48:39.400] 那我有一个问题
[48:39.400 --> 48:42.400] 线上的RPC就没有键权的话
[48:42.400 --> 48:44.400] 那我是不是随便登录一台机器上
[48:44.400 --> 48:47.400] 发一个TTP的请求
[48:47.400 --> 48:50.400] 那就RPC的键权是另一个
[48:50.400 --> 48:51.400] 对吧
[48:51.400 --> 48:54.400] 就数据对RPC的键权是是另一个问题
[48:54.400 --> 48:56.400] 因为API的键权是
[48:56.400 --> 49:00.400] 是判定的这个用户是谁
[49:00.400 --> 49:02.400] 当然RPC键权的关系呢
[49:02.400 --> 49:04.400] 是说哪些服务可以调用我
[49:04.400 --> 49:06.400] 哪些服务不可以调用我
[49:06.400 --> 49:08.400] 它是一个白名单黑名单的
[49:08.400 --> 49:10.400] 对它在实现上可能是说这个服务
[49:10.400 --> 49:12.400] 它有一个服务的token
[49:12.400 --> 49:15.400] 然后在然后这个服务调A服务A调服务B的时候
[49:15.400 --> 49:17.400] 它会带着服务A的token
[49:17.400 --> 49:19.400] 服务B它会谈判定说这个服务A的token
[49:19.400 --> 49:21.400] 可不可以调用我
[49:21.400 --> 49:25.400] 这个键权也是包含在RPC框架里面的吗
[49:25.400 --> 49:28.400] 就是如果一个RPC框架是是一个框架的话
[49:28.400 --> 49:30.400] 它应该提供这个功能
[49:30.400 --> 49:32.400] 对讲到底它要在服务这里里面
[49:32.400 --> 49:34.400] 它要在广义的框架上
[49:34.400 --> 49:36.400] 因为这个层面键权功能
[49:36.400 --> 49:38.400] 可能会做到中间键层面
[49:38.400 --> 49:40.400] 就比如说我在SendCard
[49:40.400 --> 49:42.400] 或者有一个中间代理上面
[49:42.400 --> 49:43.400] 我判定这个token
[49:43.400 --> 49:46.400] 它是不是在这个在这个用户
[49:46.400 --> 49:48.400] 这个服务是不是能调用
[49:48.400 --> 49:51.400] 另一个服务就不一定是在那个
[49:51.400 --> 49:53.400] 库的源代码上
[49:53.400 --> 49:55.400] 对它可能是中间组件之类的
[49:55.400 --> 49:56.400] 对对对
[49:56.400 --> 49:59.400] 对因为这个层面
[49:59.400 --> 50:03.400] 它涉及到说两个服务的开发者
[50:03.400 --> 50:05.400] 他们之间的沟通了
[50:05.400 --> 50:08.400] 就比如说我要A我要调B
[50:08.400 --> 50:11.400] 那我要A我要找B的维护者说我想调你
[50:11.400 --> 50:14.400] 然后B说好你要调多少QPS
[50:14.400 --> 50:16.400] 然后A说不高
[50:16.400 --> 50:17.400] 我就调你10QPS
[50:17.400 --> 50:20.400] 好B就说好我给你加个100
[50:20.400 --> 50:22.400] 因为咱设一个QPS上限是100
[50:22.400 --> 50:26.400] 然后A到第2天掉了1万QPS掉了
[50:26.400 --> 50:27.400] 掉了B然后啪一下
[50:27.400 --> 50:30.400] 然后一看QPS上限只有到100
[50:30.400 --> 50:32.400] 然后A就挂了
[50:32.400 --> 50:33.400] 他活该
[50:34.400 --> 50:36.400] 是吧因为你对因为你
[50:36.400 --> 50:38.400] 因为你这是你们两个人的约定吗
[50:38.400 --> 50:41.400] 当然确实会有这种情况说
[50:41.400 --> 50:42.400] 有一个服务A掉了B
[50:42.400 --> 50:45.400] 可能B可能觉得这A的调用量很小
[50:45.400 --> 50:46.400] 也没有管他
[50:46.400 --> 50:49.400] 然后突然有一天不知道
[50:49.400 --> 50:51.400] 因为什么什么原因
[50:51.400 --> 50:54.400] 然后A突然过来掉了1万QPS掉了B
[50:54.400 --> 50:55.400] 然后B就死了
[50:55.400 --> 50:57.400] 然后所有调B的人全都跟着死了
[50:57.400 --> 50:58.400] 会有这种情况
[50:59.400 --> 51:02.400] 所以这个是不是框架的功能
[51:02.400 --> 51:05.400] 框架就是给你提供一个外面可以根据
[51:05.400 --> 51:07.400] 某个东西来限制请求的能力
[51:07.400 --> 51:09.400] 如果你要加渐远或者限流
[51:09.400 --> 51:12.400] 这个需要其他的一些中间键
[51:13.400 --> 51:15.400] 对也可以做在框架里
[51:15.400 --> 51:16.400] 但是做框架里
[51:16.400 --> 51:19.400] 可能这也可能会不如做在中间键里
[51:19.400 --> 51:20.400] 舒服一点
[51:21.400 --> 51:23.400] 就比如说我在Sidecar里面
[51:23.400 --> 51:26.400] 我做在后面我要改这种逻辑的话
[51:26.400 --> 51:28.400] 我可能直接改中间键就可以了
[51:28.400 --> 51:31.400] 毕竟我只需要把流量掐断就可以
[51:32.400 --> 51:35.400] 对如果如果做到框架里的话
[51:35.400 --> 51:38.400] 你应该就真的要推动所有服务去升级支持
[51:38.400 --> 51:40.400] 因为之前没有这个键权机制
[51:41.400 --> 51:44.400] 你就要推动所有的调用方和服务方
[51:44.400 --> 51:45.400] 都要升级自己的框架
[51:45.400 --> 51:48.400] 对感觉Surfsmash成本还是挺高的
[51:48.400 --> 51:51.400] 这样的话不就是相当于是Surfsmash吗
[51:52.400 --> 51:55.400] 对吧就不要给自己的框架搞太多的
[51:55.400 --> 51:57.400] 这种治理上的东西
[51:58.400 --> 51:59.400] 哦是哦
[52:00.400 --> 52:04.400] 这不又好像如果是SDK升级
[52:04.400 --> 52:06.400] 维护起来真的太累了
[52:07.400 --> 52:10.400] 那你怎么看现在的Surfsmash的方案呢
[52:10.400 --> 52:14.400] 因为其实Surfsmash现在也已经越来越火了
[52:15.400 --> 52:16.400] 哦是是哦
[52:16.400 --> 52:18.400] 就是我们Surfsmash能提出来
[52:18.400 --> 52:22.400] 可能也是大家都维护SDK维护的特别痛
[52:22.400 --> 52:26.400] 就是就是特别特别小的一个一个功能点
[52:26.400 --> 52:30.400] 可能又是说可能大家又多有需要需要
[52:30.400 --> 52:31.400] 可能我开发起来
[52:31.400 --> 52:32.400] 可能真的两天就开发完了
[52:32.400 --> 52:34.400] 然后追着所有的业务去升级
[52:34.400 --> 52:36.400] 可能升级到小小一年
[52:36.400 --> 52:38.400] 然后然后Surfsmash
[52:38.400 --> 52:40.400] 可能比较好的一点就是说
[52:40.400 --> 52:42.400] 把这部分框架的维护压力
[52:42.400 --> 52:44.400] 结合到了SDK里
[52:44.400 --> 52:46.400] 然后我要我要去演进它的话
[52:46.400 --> 52:48.400] 我不需要追着所有业务去升级
[52:48.400 --> 52:51.400] 然后我可能服务治理团队
[52:51.400 --> 52:54.400] 特别是直接PII一个个的去去升
[52:54.400 --> 52:56.400] 去升SDK就可以了
[52:57.400 --> 52:58.400] 但是可能是
[52:58.400 --> 53:01.400] 但是Surfsmash中间层面
[53:01.400 --> 53:04.400] 它增加了一些调量度会更复杂一点
[53:04.400 --> 53:07.400] 我就比如说我在我这个sidecar
[53:07.400 --> 53:09.400] 出去是一个sidecar
[53:09.400 --> 53:11.400] 进去也是一个sidecar
[53:11.400 --> 53:15.400] 然后可能至少会增加两层两层转发
[53:15.400 --> 53:18.400] 但是大部分业务可能对这方面并不
[53:18.400 --> 53:19.400] 并不那么敏感
[53:19.400 --> 53:23.400] 这个对对业务方应该是透明的吧
[53:23.400 --> 53:25.400] 因为这部分转发的成本
[53:25.400 --> 53:27.400] 对但是这部分转发的成本
[53:27.400 --> 53:31.400] 应该还是比比业务的这样
[53:31.400 --> 53:34.400] 一个数据库的成本要低很多很多的
[53:34.400 --> 53:36.400] 所以听起来Surfsmash也是对
[53:36.400 --> 53:40.400] 即将上服务化的一些公司的一个推荐方案
[53:40.400 --> 53:40.400] 是吧
[53:40.400 --> 53:43.400] 不然的话你未来可能会面临
[53:43.400 --> 53:46.400] 面临着加一些统一中间件
[53:46.400 --> 53:49.400] 然后推所有人去升级的一个过程
[53:50.400 --> 53:53.400] 各种各种小修小补
[53:53.400 --> 53:54.400] 对对对
[53:54.400 --> 53:57.400] 对对对这家East2现在社区
[53:57.400 --> 53:58.400] 好像发展的很好
[53:58.400 --> 54:03.400] 但是但是也有一些一些问题会比较多
[54:03.400 --> 54:05.400] 如果有一些去用East2的朋友
[54:05.400 --> 54:08.400] 他们他们会说这个东西过于黑和
[54:08.400 --> 54:09.400] 自己比较难掌控
[54:09.400 --> 54:12.400] 所以也希望自己能在上面再做一些
[54:12.400 --> 54:14.400] 二次开发或甚至做一些组件的替换
[54:14.400 --> 54:17.400] 然后为了让自己能够好地掌控它
[54:17.400 --> 54:19.400] 我们最后再来聊一下怎么做服务治理吧
[54:19.400 --> 54:22.400] 我觉得这个可能是很多很多同学
[54:22.400 --> 54:23.400] 关心的一个话题
[54:23.400 --> 54:26.400] 就是其实服务治理到底要怎么做
[54:26.400 --> 54:27.400] 都要关心哪些事情
[54:27.400 --> 54:29.400] 我个人感觉服务治理
[54:29.400 --> 54:31.400] 它其实一些单纯从工具的角度上讲
[54:31.400 --> 54:33.400] 不考虑说业务架构层面的话
[54:33.400 --> 54:35.400] 其实它的事情特别明确
[54:35.400 --> 54:36.400] 可能各个公司做的事情
[54:36.400 --> 54:38.400] 其实差异不那么大
[54:38.400 --> 54:40.400] 就是几项基础能力
[54:40.400 --> 54:42.400] 其实都是比较比较明确
[54:42.400 --> 54:44.400] 是一个熔断降级
[54:44.400 --> 54:49.400] 限流限速健全Tris监控
[54:49.400 --> 54:51.400] 甚至服务容器的扩容
[54:51.400 --> 54:54.400] 无非就是这几样了
[54:54.400 --> 54:56.400] 那你觉得会有什么坑吗
[54:56.400 --> 54:58.400] 就是做这些的时候
[54:58.400 --> 55:00.400] 对就服务治理会有一些复杂点
[55:00.400 --> 55:04.400] 就是说当你肯定是难受了之后
[55:04.400 --> 55:06.400] 你才会想起来有服务治理
[55:06.400 --> 55:08.400] 需要做服务治理整件事情
[55:08.400 --> 55:10.400] 就比如说有个RPC掉容量太大了
[55:10.400 --> 55:12.400] 怎么一个范儿循环掉出来几十万QPS
[55:12.400 --> 55:15.400] 然后把另一个服务给掉死了
[55:15.400 --> 55:17.400] 然后这个服务这RPC卡死了
[55:17.400 --> 55:21.400] 然后我这个写入也跟着失败了
[55:21.400 --> 55:23.400] 然后我还不敢重试
[55:23.400 --> 55:25.400] 然后这个RPC卡死了
[55:25.400 --> 55:26.400] 我也跟着卡死了
[55:26.400 --> 55:27.400] 掉我的人也跟着卡死了
[55:27.400 --> 55:29.400] 全公司全都跟着卡死了
[55:29.400 --> 55:31.400] 真的这种卡死会
[55:31.400 --> 55:32.400] 但是你不怕挂
[55:32.400 --> 55:33.400] 你最怕的就是阻塞
[55:33.400 --> 55:35.400] 这种阻塞就会特别
[55:35.400 --> 55:36.400] 它会有传播性
[55:36.400 --> 55:39.400] 直接会把全公司整个全都给带死
[55:39.400 --> 55:41.400] 然后解决起来
[55:41.400 --> 55:43.400] 其实没有那么一朝鲜的
[55:43.400 --> 55:45.400] 但是说当你的工具链足够丰富的时候
[55:45.400 --> 55:49.400] 你在每一个方式都有每一个问题
[55:49.400 --> 55:50.400] 每个故障
[55:50.400 --> 55:52.400] 你都有对应的方法去解决
[55:52.400 --> 55:53.400] 都有对应的方法解决
[55:53.400 --> 55:54.400] 比如首先
[55:54.400 --> 55:56.400] 首先最重要的是输入掉容量路
[55:56.400 --> 55:59.400] 然后就关键的掉容量路的时候
[55:59.400 --> 56:01.400] 你要覆盖上段路器
[56:01.400 --> 56:03.400] 甚至说功能开关
[56:03.400 --> 56:04.400] 这是一个业务层面
[56:04.400 --> 56:05.400] 工作需要做的事
[56:05.400 --> 56:06.400] 为什么要用段路器呢
[56:06.400 --> 56:07.400] 就是说段路器
[56:07.400 --> 56:10.400] 它是来自release it那本书
[56:10.400 --> 56:11.400] 就是说
[56:11.400 --> 56:14.400] 就是说当一个服务阻塞的时候
[56:14.400 --> 56:17.400] 然后调用它的服务也会跟着阻塞
[56:17.400 --> 56:18.400] 用段路器呢
[56:18.400 --> 56:19.400] 可以开刹掉
[56:19.400 --> 56:22.400] 开刹掉对另一个服务的这种阻塞
[56:22.400 --> 56:24.400] 可以阻断这种服务之间的阻塞行为
[56:24.400 --> 56:26.400] 当时我们开始说了
[56:26.400 --> 56:28.400] 如果说我设置设置那个超时
[56:28.400 --> 56:30.400] 设短一点不行吗
[56:30.400 --> 56:31.400] 原先我设置超时是一秒
[56:31.400 --> 56:33.400] 然后设置个0.1秒
[56:33.400 --> 56:34.400] 这样不行吗
[56:34.400 --> 56:37.400] 后来之前我们在实践中
[56:37.400 --> 56:38.400] 其实也是不行的
[56:38.400 --> 56:40.400] 就是就是设置成0.1秒
[56:40.400 --> 56:42.400] 它也是100毫秒的阻塞
[56:42.400 --> 56:43.400] 你所有的请求过来
[56:43.400 --> 56:44.400] 全都是100毫秒的阻塞
[56:44.400 --> 56:46.400] 然后然后请求它的人
[56:46.400 --> 56:48.400] 也全都跟着阻塞死了
[56:48.400 --> 56:51.400] 然后只靠一个较短的超时时间
[56:51.400 --> 56:52.400] 仍然不能让你自己
[56:52.400 --> 56:54.400] 自己从阻塞中恢复出来
[56:54.400 --> 56:55.400] 而这种阻塞呢
[56:55.400 --> 56:58.400] 它有它有那种自我维持的能力
[56:58.400 --> 56:59.400] 就会特别难受
[56:59.400 --> 57:02.400] 是说当我的服务阻塞的时候
[57:02.400 --> 57:04.400] 我在外面的请求会进来排队
[57:04.400 --> 57:06.400] 然后排队多了之后
[57:06.400 --> 57:07.400] 排队过来
[57:07.400 --> 57:08.400] 这些排队还不停的增加
[57:08.400 --> 57:10.400] 不停的在增大我的压力
[57:10.400 --> 57:12.400] 就是这时候说我阻塞死了
[57:12.400 --> 57:14.400] 如果没有来请求人来请求我
[57:14.400 --> 57:16.400] 然后我过上一会儿
[57:16.400 --> 57:17.400] 我应该还是能恢复的
[57:17.400 --> 57:19.400] 但是说因为你在阻塞的时候
[57:19.400 --> 57:21.400] 不停的积压的腿排队
[57:21.400 --> 57:22.400] 还不停的在积压
[57:22.400 --> 57:23.400] 即使外部没有阻塞的时候
[57:23.400 --> 57:25.400] 你的队列还要消化一段时间
[57:25.400 --> 57:28.400] 所以所以断路器就这个东西
[57:28.400 --> 57:30.400] 其实是异常的有用
[57:30.400 --> 57:32.400] 就是说它可以阻断服务之间的阻塞行为
[57:32.400 --> 57:35.400] 就是嗯
[57:37.400 --> 57:39.400] 然后另外一点就是说
[57:39.400 --> 57:41.400] 写写链路写链路
[57:41.400 --> 57:43.400] 如果说嗯就前面说的写链路
[57:43.400 --> 57:45.400] 你是不敢从轻易重视的
[57:45.400 --> 57:46.400] 这时候怎么办呢
[57:46.400 --> 57:48.400] 我又希望我又不想说
[57:48.400 --> 57:49.400] 我这个写入不能丢
[57:49.400 --> 57:51.400] 我的写入又不真的不能丢
[57:51.400 --> 57:52.400] 怎么办呢
[57:52.400 --> 57:53.400] 你就发一个消息
[57:53.400 --> 57:55.400] 有这种对你不希望失败的事情
[57:55.400 --> 57:57.400] 全都变的写入操作
[57:57.400 --> 57:59.400] 全都转化成消息
[57:59.400 --> 58:01.400] 因为消息它有它有密等性
[58:01.400 --> 58:04.400] 它有一个不停的重视的这么
[58:04.400 --> 58:06.400] 它有不停重视这么一个机制
[58:06.400 --> 58:08.400] 如果你这个你的消息队列完
[58:08.400 --> 58:09.400] 应该可以支持你
[58:09.400 --> 58:11.400] 如果你没有在执行成功之前
[58:11.400 --> 58:12.400] 它不停的重视
[58:12.400 --> 58:15.400] 当然你也可以试着一个最大的重视时间
[58:15.400 --> 58:17.400] 对所以就是rpc
[58:17.400 --> 58:22.400] 它你要假定说所有的rpc的调用都是不可靠的
[58:22.400 --> 58:23.400] 这个事实很残酷
[58:23.400 --> 58:25.400] 但确实是这样子
[58:25.400 --> 58:28.400] 对就是尤其当你的写入链路
[58:28.400 --> 58:30.400] 如果你要依赖说rpc的话
[58:30.400 --> 58:33.400] 那么你的写入链路肯定是会是特别
[58:33.400 --> 58:38.400] 很难做到做到哦不稳定
[58:38.400 --> 58:40.400] 很难做到稳定
[58:40.400 --> 58:42.400] 对所以要写入链路呢
[58:42.400 --> 58:43.400] 如果你用消息的话
[58:43.400 --> 58:45.400] 可能是一个更好的选择
[58:45.400 --> 58:48.400] 然后具体的业务
[58:48.400 --> 58:51.400] 你也可以在可以在业务层面来梳理出来
[58:51.400 --> 58:52.400] 哪些是关键功能
[58:52.400 --> 58:56.400] 然后在关键功能次一点的关键功能再说
[58:56.400 --> 58:57.400] 然后是不重要的功能
[58:57.400 --> 58:59.400] 然后你通过分级的
[58:59.400 --> 59:01.400] 然后然后当你出现故障的时候
[59:01.400 --> 59:05.400] 你可以去通过功能开关去把不那么重要的功能去关掉
[59:05.400 --> 59:10.400] 然后为你的关键功能来腾出腾出更多的可用资源
[59:12.400 --> 59:16.400] 感觉我们是不是今天已经把提提刚的都聊完了
[59:18.400 --> 59:20.400] 好那我们进到最后一个环节吧
[59:21.400 --> 59:26.400] 就是我们每期都会邀请嘉宾来为大家推荐一个python
[59:26.400 --> 59:31.400] 酷以及一篇他觉得不错的资料
[59:31.400 --> 59:33.400] 对F叔有什么推荐吗
[59:33.400 --> 59:38.400] 我想了半天我就是能想到就想了这一份
[59:38.400 --> 59:40.400] 对他这个酷可能又爱又恨
[59:40.400 --> 59:44.400] 然后对可能这个这个会比较常见
[59:45.400 --> 59:47.400] 又爱又恨的点是什么呢
[59:47.400 --> 59:50.400] 对因为又爱又恨就是说
[59:50.400 --> 59:54.400] 首先他是他真的能解决你的问题
[59:54.400 --> 59:56.400] 就是能解决你的扩展性问题
[59:56.400 --> 01:00:00.400] 他能把你的python的代码能不加修改的变成一个写程
[01:00:00.400 --> 01:00:01.400] 变成写程
[01:00:01.400 --> 01:00:03.400] 然后可以大幅的增加你的变化能力
[01:00:03.400 --> 01:00:09.400] 对很你你可以把你的python项目有这打上去
[01:00:09.400 --> 01:00:11.400] 这一问的就可以直接蓄起来
[01:00:11.400 --> 01:00:14.400] 因为这个对代码没有侵入
[01:00:14.400 --> 01:00:15.400] 但是又恨的一些点呢
[01:00:15.400 --> 01:00:19.400] 就是说他又不能做到说完全他说是无侵入吧
[01:00:19.400 --> 01:00:22.400] 但是说又有一些很诡异的一些坑
[01:00:22.400 --> 01:00:25.400] 就比如说有的时候他他有一些锁啊
[01:00:25.400 --> 01:00:26.400] 没有排斥到
[01:00:26.400 --> 01:00:30.400] 然后你如果import顺序不对的话
[01:00:30.400 --> 01:00:32.400] 他会把你的程序死锁掉
[01:00:32.400 --> 01:00:35.400] 然后他会他他是有一些坑的
[01:00:35.400 --> 01:00:39.400] 而且他并不是python官方的亲儿子
[01:00:40.400 --> 01:00:43.400] 而且python3呢也没有打算把它扶正
[01:00:43.400 --> 01:00:45.400] python官方可能想推一个aio
[01:00:46.400 --> 01:00:50.400] 但是aio就对程序的侵入性可能会巧一些
[01:00:50.400 --> 01:00:52.400] 就比如说你要打一个async的话
[01:00:52.400 --> 01:00:54.400] 你要对所有的段位
[01:00:54.400 --> 01:00:56.400] 他的地方全都打上async
[01:00:56.400 --> 01:00:58.400] 这种传染性是非常非常强的
[01:00:58.400 --> 01:01:00.400] 然后另外一点就是说
[01:01:00.400 --> 01:01:03.400] 有如果你有的时候你敲代码的时候忘了敲一个await
[01:01:04.400 --> 01:01:08.400] 你会有一些隐形的这种这种bug的行为
[01:01:08.400 --> 01:01:13.400] 然后也有一些呃也有一些嗯搞编程语言的专家
[01:01:13.400 --> 01:01:17.400] 他们他们会很很鄙视async await
[01:01:17.400 --> 01:01:20.400] 是因为说他呃他本质上是
[01:01:20.400 --> 01:01:23.400] 他会把它定义成一个函数染色的一个问题
[01:01:23.400 --> 01:01:26.400] 就是说我掉凡是async的函数呢
[01:01:26.400 --> 01:01:29.400] 他都是掉了async的地方全都要打上async
[01:01:29.400 --> 01:01:34.400] 然后他会对对代码有非常非常多的侵入
[01:01:34.400 --> 01:01:39.400] 而比较像go那种嗯那种呃
[01:01:40.400 --> 01:01:43.400] 默认的所有的代码都我都是写程
[01:01:43.400 --> 01:01:46.400] 这样的话你的逻辑性反而会会更一致一点
[01:01:46.400 --> 01:01:49.400] 然后像python的这一问他吧
[01:01:49.400 --> 01:01:52.400] 倒是其实是能做到这一点
[01:01:52.400 --> 01:01:54.400] 就是说我可以不侵入代码的
[01:01:54.400 --> 01:01:57.400] 然后把我从通过代码变成异步代码
[01:01:57.400 --> 01:01:59.400] 但是呢他又真的留了很多坑
[01:01:59.400 --> 01:02:04.400] 而且他可能大概率呢不会被python官方所否证
[01:02:04.400 --> 01:02:08.400] 嗯因为他是对python底层实现侵入性会会比较大
[01:02:08.400 --> 01:02:10.400] 但是有确实能解决问题
[01:02:10.400 --> 01:02:14.400] 对你又如果有一个python项目的话
[01:02:14.400 --> 01:02:17.400] 你可能会忍不住会打上一个这一问的
[01:02:17.400 --> 01:02:23.400] 嗯你对当然我也可以去用aio去整个重构他
[01:02:23.400 --> 01:02:26.400] 但是你可能重过了一半你可能还会忍不住
[01:02:26.400 --> 01:02:29.400] 会会打下去那个moneypatch的手
[01:02:29.400 --> 01:02:33.400] 对就是然后你又可以正常的写写你正常的代码了
[01:02:33.400 --> 01:02:38.400] 是吗对对而且而且那个基本有个好处
[01:02:38.400 --> 01:02:42.400] 就是第三方的库如果没有acintio的版本
[01:02:42.400 --> 01:02:43.400] 你可以用given的对吧
[01:02:43.400 --> 01:02:45.400] 但是如果你用acintio的话
[01:02:45.400 --> 01:02:47.400] 你只能去重写一下他考虑
[01:02:47.400 --> 01:02:52.400] 对而且我觉得aio对对整个生态的要求太高了
[01:02:52.400 --> 01:02:56.400] 你要保证你所有的以及你未来引入的组件都是aio的
[01:02:56.400 --> 01:03:00.400] 才能持续保持你的这个是的是的
[01:03:00.400 --> 01:03:06.400] 对所以那这种aio他是他是这样的传染性特别特别强
[01:03:06.400 --> 01:03:09.400] 对这时候你会我也不是怀疑自己
[01:03:09.400 --> 01:03:11.400] 我为什么我同样重写一遍
[01:03:11.400 --> 01:03:13.400] 为什么不直接用go呢
[01:03:13.400 --> 01:03:17.400] 嗯好推荐推荐一本书的话
[01:03:17.400 --> 01:03:21.400] 就是嗯data designing data intensive applications
[01:03:21.400 --> 01:03:24.400] 就是数据密集型应用程序设计
[01:03:24.400 --> 01:03:26.400] 哦这本书真特别好
[01:03:26.400 --> 01:03:31.400] 就是说一些分布式系统的一些哦一些基础的概念
[01:03:31.400 --> 01:03:35.400] 在这本书里讲的特别特别特别清晰
[01:03:35.400 --> 01:03:40.400] 而且也没有任何哦就分布式系统的这些理论知识
[01:03:40.400 --> 01:03:46.400] 其实有一些嗯有很多书就是讲的很容易过分的学术
[01:03:46.400 --> 01:03:50.400] 就是不那么呃工程就是比较少
[01:03:50.400 --> 01:03:53.400] 因为就有一些有一些分布式系统的一些技术
[01:03:53.400 --> 01:03:55.400] 其实在工程是完全没有落地的
[01:03:55.400 --> 01:04:02.400] 就是甚至说是说亚马逊的dynamo这种也是也是很坑的一套架构
[01:04:02.400 --> 01:04:06.400] 就像这本书里他能告诉你说哪一些东西是真是真正的
[01:04:06.400 --> 01:04:08.400] 在工程中是怎么实践的
[01:04:08.400 --> 01:04:11.400] 以及他有非常详细的参考资料
[01:04:11.400 --> 01:04:15.400] 他每一章节都有非常详细的一些啊参考文献
[01:04:15.400 --> 01:04:17.400] 有很多论文都很值得一看
[01:04:17.400 --> 01:04:20.400] ok 这个说也确实特别好
[01:04:20.400 --> 01:04:23.400] 我们应该在上一期节目的时候也推荐过一次
[01:04:23.400 --> 01:04:27.400] 对感觉可以再向听众们再强力推荐一下
[01:04:27.400 --> 01:04:29.400] 强烈安利
[01:04:30.400 --> 01:04:33.400] 是强力推荐
[01:04:33.400 --> 01:04:36.400] 对那那可以你们可以再找一位呃嘉宾
[01:04:36.400 --> 01:04:38.400] 然后让他再推荐一次
[01:04:38.400 --> 01:04:40.400] 这样是重要的事情可以说三遍
[01:04:40.400 --> 01:04:43.400] 可以的可以的
[01:04:43.400 --> 01:04:45.400] 小白你有什么推荐吗
[01:04:45.400 --> 01:04:48.400] 推荐一个库或者是资料
[01:04:48.400 --> 01:04:49.400] 嗯
[01:04:49.400 --> 01:04:51.400] 我我就没有了吧
[01:04:51.400 --> 01:04:53.400] 因为我现在说实话
[01:04:53.400 --> 01:04:55.400] 对也不是很深入
[01:04:55.400 --> 01:04:58.400] 而且我现在用的库都是比较常见的库
[01:04:59.400 --> 01:05:00.400] 也可以推荐啊
[01:05:00.400 --> 01:05:02.400] 常见的往往就是很好用的呀
[01:05:02.400 --> 01:05:06.400] 那我如果是硬让我推荐的话
[01:05:06.400 --> 01:05:08.400] 我推荐张狗
[01:05:08.400 --> 01:05:10.400] 原因呢
[01:05:10.400 --> 01:05:12.400] 原因就是
[01:05:12.400 --> 01:05:15.400] 其实我觉得很多人都说张狗很大
[01:05:15.400 --> 01:05:17.400] 就是他比较重
[01:05:17.400 --> 01:05:18.400] 但是我但是我相反的
[01:05:18.400 --> 01:05:20.400] 我却觉得张狗
[01:05:20.400 --> 01:05:21.400] 呃
[01:05:21.400 --> 01:05:23.400] 他大有大的原因就是他
[01:05:23.400 --> 01:05:25.400] 把很多东西都给你集成好了
[01:05:25.400 --> 01:05:27.400] 但是又给你修改他的权利
[01:05:27.400 --> 01:05:31.400] 这样的话就哪怕你这个功能是你不想用的
[01:05:31.400 --> 01:05:33.400] 那你直接把它给mute掉就好了
[01:05:33.400 --> 01:05:35.400] 你可以就是
[01:05:35.400 --> 01:05:38.400] 把自己要用的东西添进来就ok了
[01:05:38.400 --> 01:05:39.400] 对
[01:05:39.400 --> 01:05:40.400] 我还挺喜欢张狗的
[01:05:40.400 --> 01:05:43.400] 因为我觉得他可以让你在项目启动的时候
[01:05:43.400 --> 01:05:45.400] 省掉很多
[01:05:45.400 --> 01:05:47.400] 不必要的精力
[01:05:47.400 --> 01:05:48.400] 对
[01:05:48.400 --> 01:05:52.400] 你就只需要那个start project就ok了
[01:05:52.400 --> 01:05:54.400] 新涛你呢有什么推荐吗
[01:05:54.400 --> 01:05:56.400] 呃
[01:05:56.400 --> 01:05:59.400] 我给大家推荐一个库吧
[01:05:59.400 --> 01:06:01.400] 叫q
[01:06:01.400 --> 01:06:03.400] 这是很有意思的一个库
[01:06:03.400 --> 01:06:05.400] 就我给我给你们举个例子
[01:06:05.400 --> 01:06:09.400] 就是比如说你写的银行代码叫file.write
[01:06:09.400 --> 01:06:12.400] 然后括号里面是request.get一个东西
[01:06:12.400 --> 01:06:13.400] .json
[01:06:13.400 --> 01:06:15.400] 就是你把那个url取出来
[01:06:15.400 --> 01:06:17.400] 直接写到文件里面
[01:06:17.400 --> 01:06:19.400] 然后你发现那个文件里面内容不对
[01:06:19.400 --> 01:06:20.400] 你如果debug的话
[01:06:20.400 --> 01:06:22.400] 你会怎么做呢
[01:06:22.400 --> 01:06:24.400] 就是你只能把那个request.get
[01:06:24.400 --> 01:06:25.400] 移到上一行
[01:06:25.400 --> 01:06:26.400] 然后加一个临时变量
[01:06:26.400 --> 01:06:28.400] 把这个临时变量print出来
[01:06:28.400 --> 01:06:29.400] 对吧
[01:06:29.400 --> 01:06:30.400] 然后如果有q这个库的话
[01:06:30.400 --> 01:06:32.400] 你只要写几个字符
[01:06:32.400 --> 01:06:33.400] import q
[01:06:33.400 --> 01:06:37.400] 然后在那个request前面加一个q斜杠
[01:06:37.400 --> 01:06:39.400] 就是说你不用生成临时变量
[01:06:39.400 --> 01:06:40.400] 你只需要这么几个字符
[01:06:40.400 --> 01:06:43.400] 这个request的内容就会打出来
[01:06:43.400 --> 01:06:47.400] 因为它是实现了一个那个除号的那个
[01:06:47.400 --> 01:06:49.400] 去上代把那个除号重载了
[01:06:49.400 --> 01:06:50.400] 呃
[01:06:50.400 --> 01:06:53.400] 重载的做的事情就是把后面这个变量打印出来
[01:06:53.400 --> 01:06:54.400] 然后再返回
[01:06:54.400 --> 01:06:56.400] 所以它不会侵入你原来的代码
[01:06:56.400 --> 01:06:58.400] 就比较有意思
[01:06:58.400 --> 01:07:00.400] 300行代码
[01:07:00.400 --> 01:07:01.400] 呃
[01:07:01.400 --> 01:07:02.400] 我我没太理解
[01:07:02.400 --> 01:07:05.400] 就是你你刚刚说打印调试的时候
[01:07:05.400 --> 01:07:07.400] 是怎么打印就可以
[01:07:07.400 --> 01:07:10.400] 就是这个这个这个我能理解
[01:07:10.400 --> 01:07:11.400] 因为我经常遇到这种情况
[01:07:11.400 --> 01:07:13.400] 就是有时候吧
[01:07:13.400 --> 01:07:16.400] 我我的一些例子就是有时候你会直接return一个值
[01:07:16.400 --> 01:07:18.400] 然后你并没有定义一个变量
[01:07:18.400 --> 01:07:19.400] 就你只要把它return了
[01:07:19.400 --> 01:07:21.400] 但你调试的时候呢
[01:07:21.400 --> 01:07:24.400] 你又没办法去把这个值
[01:07:24.400 --> 01:07:26.400] 就是给给给print出来
[01:07:26.400 --> 01:07:28.400] 你要你要是想想调试的话
[01:07:28.400 --> 01:07:29.400] 就像就像其他说的
[01:07:29.400 --> 01:07:31.400] 你就必须得定一个变量
[01:07:31.400 --> 01:07:32.400] 然后你把它print出来
[01:07:32.400 --> 01:07:34.400] 但是如果有这个q的话
[01:07:34.400 --> 01:07:37.400] 它的意思就是你可以直接在前面加一个q斜杠
[01:07:37.400 --> 01:07:39.400] 然后它又会帮你打印出来
[01:07:39.400 --> 01:07:40.400] 是的是的
[01:07:40.400 --> 01:07:43.400] 这个东西我觉得有两个比较好玩的地方
[01:07:43.400 --> 01:07:44.400] 第一个是它重载
[01:07:44.400 --> 01:07:45.400] 它通过重载这个变量
[01:07:45.400 --> 01:07:50.400] 它就可以直接去打印一些匿名的匿名的值
[01:07:50.400 --> 01:07:53.400] 第二个是它这个模块不是fromq importq
[01:07:53.400 --> 01:07:55.400] 然后用的它是importq
[01:07:55.400 --> 01:07:57.400] 直接可以add这个q
[01:07:57.400 --> 01:08:00.400] 就是它里面做了一些magic
[01:08:00.400 --> 01:08:02.400] 这个你可以直接调用这个module
[01:08:02.400 --> 01:08:04.400] 因为它用重载的机制
[01:08:04.400 --> 01:08:06.400] 把你的那个值传进去
[01:08:06.400 --> 01:08:07.400] 然后再打印
[01:08:07.400 --> 01:08:10.400] 就不需要你手动的去定义变量打印
[01:08:10.400 --> 01:08:11.400] 对吗
[01:08:11.400 --> 01:08:12.400] 对对是的
[01:08:12.400 --> 01:08:14.400] 哦那还挺方便的
[01:08:14.400 --> 01:08:16.399] 哦
[01:08:16.399 --> 01:08:18.399] 这个module也可以接收参数
[01:08:18.399 --> 01:08:20.399] 然后直接来调用
[01:08:21.399 --> 01:08:22.399] 好
[01:08:22.399 --> 01:08:23.399] 好那我们今天先到这
[01:08:23.399 --> 01:08:24.399] 感谢F叔
[01:08:24.399 --> 01:08:25.399] 感谢大家收听
[01:08:25.399 --> 01:08:26.399] 拜拜
[01:08:26.399 --> 01:08:27.399] 拜拜
[01:08:27.399 --> 01:08:30.399] 好本期捕手者说的播客就到这里
[01:08:30.399 --> 01:08:31.399] 感谢您的收听
[01:08:31.399 --> 01:08:34.399] 本期内容中提到的资料链接都会放到我们的网站上
[01:08:34.399 --> 01:08:37.399] 我们的网址是pythonhunter.org
[01:08:37.399 --> 01:08:40.399] 由于我们主播的持户账号被禁
[01:08:40.399 --> 01:08:43.399] 所以以后的更新都不会再发布到持户上
[01:08:43.399 --> 01:08:44.399] 请您留意
[01:08:44.399 --> 01:08:47.399] 推荐您使用半用型客户端订阅我们的撲克
[01:08:47.399 --> 01:08:49.399] 也欢迎您关注我们的推特
[01:08:49.399 --> 01:08:52.399] 加入我们的Telegram群组和其他听众一起聊天
[01:08:52.399 --> 01:08:56.399] 我们的推特是pythonhunter加一个下滑线
[01:08:56.399 --> 01:08:59.399] Telegram群组的链接可以在我们的网站上找到
[01:08:59.399 --> 01:09:01.399] 我们下期再见
