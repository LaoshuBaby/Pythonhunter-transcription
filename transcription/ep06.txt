[00:00.000 --> 00:18.560] 【开场音乐】
[00:18.560 --> 00:21.600] 节目开始之前先插播一则广告
[00:21.600 --> 00:25.440] PiCon 2019上海站将于9月21日开始
[00:25.440 --> 00:29.000] 补收者说也将在现场布置展台参与PiCon
[00:29.000 --> 00:30.600] 也期待大家的到来
[00:31.480 --> 00:33.400] 欢迎大家收听补收者说
[00:33.400 --> 00:34.600] 我是Adam Wen
[00:35.000 --> 00:37.240] 这期我们邀请的嘉宾是胡杨
[00:37.240 --> 00:38.640] ID的FanFan
[00:38.880 --> 00:40.920] 也是一位活跃的Python开发者
[00:41.280 --> 00:43.080] 胡杨来和大家打个招呼吧
[00:43.640 --> 00:44.920] Hello 大家好
[00:44.960 --> 00:46.080] 各位听众朋友
[00:46.560 --> 00:47.920] 我是胡杨
[00:47.920 --> 00:49.000] 然后网名是Ofer
[00:49.000 --> 00:51.000] 大家可能有看到过这个ID
[00:51.519 --> 00:55.080] 基本上会在网上相对活跃
[00:55.200 --> 00:58.600] 会输出一些自己的工作经验
[00:58.600 --> 01:02.800] 或者学习技术的某项技术的一些技能的教程
[01:03.320 --> 01:03.720] 对
[01:03.720 --> 01:06.600] 然后今年是出了一本书
[01:06.600 --> 01:07.880] 将过企业开发实战
[01:08.440 --> 01:10.440] 目前是在支付工作
[01:11.000 --> 01:11.960] 对 大概这样
[01:13.320 --> 01:18.560] 以及本期还有的参与的开发者
[01:19.240 --> 01:23.000] 也是我们Python Hunter的常任的主持
[01:23.000 --> 01:23.960] LikeJM
[01:25.320 --> 01:26.720] LikeJM和大家打个招呼
[01:26.720 --> 01:28.520] 大家好
[01:28.520 --> 01:30.200] 这么熟悉了对吧
[01:30.200 --> 01:30.880] 老朋友
[01:30.880 --> 01:32.480] 然后还有赖信涛
[01:32.480 --> 01:33.560] 大家好
[01:34.480 --> 01:38.440] 胡杨你是怎么了解和学习Python的
[01:38.440 --> 01:40.240] 能和我们介绍一下吗
[01:40.960 --> 01:41.400] 可以
[01:41.400 --> 01:42.200] 这个其实
[01:43.120 --> 01:44.320] 就大家可以交流一下
[01:44.320 --> 01:46.960] 你们也可以讲一下你们的这个过程
[01:46.960 --> 01:48.440] 看有没有一些相同点
[01:48.680 --> 01:52.759] 或者让大家觉得每个人的学习方式不太一样的点
[01:52.760 --> 01:57.960] 就是我前天周四的时候还做了一个直播的分享
[01:57.960 --> 01:59.120] 语音直播的分享
[01:59.120 --> 02:01.120] 其实就讲到了这个学习
[02:01.120 --> 02:02.560] 其实我列了几个点
[02:02.800 --> 02:03.400] 第一个
[02:04.320 --> 02:05.840] 就是我在写Python之前
[02:06.720 --> 02:07.960] 其实是在写Java
[02:08.400 --> 02:11.320] 但是也不能说是完全写Java
[02:11.320 --> 02:13.160] 因为当时是在外包公司
[02:13.720 --> 02:15.960] 外包公司的这种特点就是啥都写
[02:16.280 --> 02:18.040] 他给你什么项目就全占
[02:18.040 --> 02:18.680] 真的
[02:18.680 --> 02:21.320] 那个时候2011年
[02:21.320 --> 02:23.440] 那个时候就是全占
[02:23.440 --> 02:26.640] 其实不像我们现在分的这么细
[02:26.640 --> 02:27.880] 什么大前端概念
[02:27.880 --> 02:29.400] 什么前端这种工程师
[02:29.959 --> 02:30.799] 其实没有那么细
[02:30.799 --> 02:31.560] 我觉得
[02:31.959 --> 02:34.239] 我不清楚你们是不是有这种感觉
[02:35.160 --> 02:36.600] 或者我们也可以插着聊
[02:36.600 --> 02:37.320] 就是你们
[02:37.840 --> 02:42.280] 比如说最早的开始做编程的时间大概是在什么时候
[02:42.840 --> 02:44.959] 我们应该开始的比你晚一些
[02:46.600 --> 02:48.480] 我11年还在上大学
[02:48.720 --> 02:49.920] 我还在上大二
[02:49.920 --> 02:50.720] 对我也是
[02:50.720 --> 02:54.640] 对然后我那个时候应该是刚刚接触Jango
[02:54.640 --> 02:59.560] 对那个时候好像是Jango1.3还是1.2
[02:59.560 --> 03:00.560] 我有点忘记了
[03:00.560 --> 03:01.800] 1.3对
[03:01.800 --> 03:04.800] 然后那个时候开始算是
[03:06.040 --> 03:07.440] 接触一些编程
[03:08.200 --> 03:10.120] 你们学校还挺好的
[03:10.440 --> 03:12.000] 大二的时候就可以接触到Jango
[03:12.440 --> 03:14.640] 没有自学的
[03:14.640 --> 03:16.400] 就自己去了解的
[03:16.680 --> 03:19.120] 因为其实我当时来看
[03:19.120 --> 03:22.440] 就是我11年转Python的时候
[03:22.440 --> 03:25.760] 其实我身边很多在做开发的人
[03:25.760 --> 03:27.680] 就是我们是计算机
[03:27.680 --> 03:29.960] 就计算信息计算科学
[03:29.960 --> 03:34.200] 也算是找工作基本上都会去做编程的岗位
[03:34.760 --> 03:37.400] 其实大家都没有听说过这样的一门语言
[03:37.760 --> 03:40.600] 其实当时是非常小众的一个语言
[03:41.120 --> 03:43.240] 对其实当时的背景是什么
[03:43.240 --> 03:47.400] 就是刚才说的就没有太多细分的概念
[03:47.400 --> 03:50.280] 大家就是有一个项目来
[03:50.280 --> 03:52.080] 无论前端后端数据库什么
[03:52.080 --> 03:53.680] 你都自己搞了就好了
[03:53.680 --> 03:56.680] 因为对待报公司其实就是项目为主
[03:56.680 --> 03:58.520] 它不是以技术为主的
[03:58.520 --> 04:04.600] 对然后之后是到了一个这种创业型的公司
[04:04.600 --> 04:09.480] 然后刚好那个场景下其实Python不太好招
[04:09.480 --> 04:11.760] 他们招人的这个包括其实现在也是
[04:11.760 --> 04:14.160] 招人的简历上会特别声明
[04:14.160 --> 04:16.160] 就是不需要有Python背景
[04:16.160 --> 04:17.960] 但是你需要对Python有兴趣
[04:18.640 --> 04:24.400] 所以这就是当时的一个转到Python的一个经历
[04:25.400 --> 04:28.840] 所以你当时是相当于换公司的时候
[04:29.200 --> 04:30.520] 然后转学了Python
[04:30.520 --> 04:32.520] 还是说你在做外包的时候
[04:32.520 --> 04:35.760] 因为听起来做外包整个项目都是你控制的
[04:36.040 --> 04:39.000] 也许说你也可以选择某个新项目
[04:39.000 --> 04:40.720] 我直接用Python一把搞
[04:40.720 --> 04:44.080] 并不是就是外包公司的特点
[04:44.080 --> 04:45.480] 或者说我们这种小外包公司
[04:45.480 --> 04:46.840] 只有几个人的特点是什么
[04:46.840 --> 04:50.000] 就是我找了一个开源的项目
[04:50.000 --> 04:53.560] 或者我找了一个之前我们给某个企业做过的项目
[04:53.560 --> 04:55.360] OK现在刚好另外一个企业需要
[04:55.360 --> 04:56.640] 但是需要的点不一样
[04:56.640 --> 04:57.960] 我们就把它改一下
[04:57.960 --> 05:02.600] 你没有机会去从头开发一个真实的项目
[05:03.360 --> 05:06.680] 所以就为什么说这个项目是什么语言
[05:06.680 --> 05:08.080] 那你就要去用什么语言
[05:08.440 --> 05:10.520] 就是并不是说你会什么语言
[05:10.520 --> 05:12.200] 才让你去写什么语言的项目
[05:12.200 --> 05:15.039] 这是一个很大的差别
[05:15.680 --> 05:20.640] 所以当时相当于是有一个之前的项目是拿Python写的
[05:20.640 --> 05:22.719] 所以就接触了这样子
[05:24.080 --> 05:24.880] 其实也没有
[05:24.880 --> 05:27.120] 其实但是我很迷茫
[05:27.120 --> 05:29.320] 就是在那样的场景下
[05:29.320 --> 05:31.320] 你们刚才其实也聊了一个事情
[05:31.320 --> 05:33.240] 就是在那样的场景下
[05:33.240 --> 05:37.000] 当你觉得做了n多个项目
[05:37.000 --> 05:38.760] 每个项目可能语言都不一样
[05:38.760 --> 05:41.760] 让你感觉在某个语言上没有办法去沉淀下来
[05:41.760 --> 05:43.400] 或者在某个产品上
[05:43.400 --> 05:47.760] 你不能完全的去hold住整个产品的节奏
[05:48.599 --> 05:50.480] 这个时候其实你非常迷茫
[05:50.719 --> 05:54.480] 然后之后就去想换一个工作好了
[05:54.480 --> 05:56.320] 就换一个去搞产品的工作
[05:56.640 --> 05:58.960] 这个时候其实也想换一门语言
[05:58.960 --> 06:03.440] 当时写Java写的对我的感觉来说
[06:03.440 --> 06:06.800] 就是我不清楚你们现在有没有人在写Java
[06:06.800 --> 06:08.680] 对我的感觉就是
[06:08.680 --> 06:09.440] 我在写
[06:09.440 --> 06:10.039] 你在写
[06:10.040 --> 06:11.800] 我会觉得他特别啰嗦
[06:11.800 --> 06:12.400] 是的
[06:12.400 --> 06:14.600] 就是这个事情我想的很清楚了
[06:14.600 --> 06:17.720] 然后我要把这个结构还要那样来写
[06:17.720 --> 06:19.120] 我就觉得很烦
[06:19.120 --> 06:20.720] 所以就是想
[06:21.080 --> 06:23.120] 如果能换语言的话更好
[06:23.120 --> 06:24.080] 然后换什么语言
[06:24.080 --> 06:25.960] 其实有一个语言就是
[06:25.960 --> 06:31.000] 我之前其实在最早开始正式学编程之前
[06:31.000 --> 06:34.760] 我其实是学了或者研究了一段时间的安全
[06:34.760 --> 06:36.040] 网络安全方面的东西
[06:36.600 --> 06:38.920] 那就是比如说关于入侵
[06:38.920 --> 06:39.800] 关于破解
[06:39.800 --> 06:40.400] 这方面的东西
[06:40.400 --> 06:42.200] 然后其中有一篇文章特别知名
[06:42.200 --> 06:44.120] 就是如何成为一个黑客
[06:44.120 --> 06:45.960] 或者如何成为一名黑客
[06:46.400 --> 06:48.200] 我不清楚你们看过这篇文章
[06:48.200 --> 06:50.440] 这里面其实写了几个语言
[06:50.440 --> 06:51.480] 对吧
[06:51.480 --> 06:52.760] 其中有一个就是Python
[06:52.760 --> 06:55.480] 这个我看过
[06:55.480 --> 06:57.160] 这个好像在我博客上还有原文
[06:57.160 --> 06:58.480] 我全文转载的
[06:58.480 --> 07:00.000] 是那个文章其实挺好的
[07:00.000 --> 07:03.240] 他不仅是对于如何成为一名黑客
[07:03.240 --> 07:05.320] 他更多的觉得是对于你
[07:05.960 --> 07:07.960] 技术热爱这个事情
[07:07.960 --> 07:09.040] 或者技术能干什么
[07:09.040 --> 07:10.600] 这个事情的一个指引
[07:11.480 --> 07:14.160] 所以通过了解Python
[07:14.160 --> 07:15.800] 然后当时其实并没有
[07:15.800 --> 07:17.280] 比如说你是因为用了Python
[07:17.280 --> 07:19.160] 然后你才去找一个Python工作
[07:19.560 --> 07:20.280] 其实并不是
[07:20.280 --> 07:21.480] 只是说对Python有兴趣
[07:21.480 --> 07:22.520] 但是没有写过Python
[07:23.200 --> 07:25.240] 所以就去面试了
[07:25.240 --> 07:27.480] 刚好当时的这个场景也是
[07:27.480 --> 07:28.880] 他不要求你写过Python
[07:28.880 --> 07:31.600] 只要求你对这个东西感兴趣就好了
[07:31.600 --> 07:36.200] 所以我第一本书就是简明Python教程
[07:36.200 --> 07:39.080] 大概花了一天或几个小时
[07:39.080 --> 07:41.120] 我记得把语法过了一遍
[07:41.120 --> 07:44.840] 其实你会感觉到从语法学习上
[07:44.840 --> 07:47.080] 他就比Java简洁了很多
[07:48.080 --> 07:50.280] 对这个阶段大概是这样
[07:50.280 --> 07:52.280] 我刚才想说的是我们
[07:52.280 --> 07:54.840] 你不是提到Java写起来很啰嗦
[07:54.840 --> 07:58.159] 然后我们其实都是有这种感觉的
[07:58.159 --> 07:58.640] 对
[07:58.640 --> 08:00.120] 我经常黑Java的
[08:01.039 --> 08:04.039] 所以现在其实也是这样
[08:04.040 --> 08:08.680] 现在写起来还是这样
[08:08.680 --> 08:10.800] 就是有很多代码密密麻麻的
[08:10.800 --> 08:12.720] 就是一行每一行都那么长
[08:12.720 --> 08:15.760] 但是我现在写感觉有一个稍微不一样的感觉
[08:15.760 --> 08:17.200] 就是Java8加了很多Lambda
[08:17.200 --> 08:21.640] 就是你有很多stream map那些方法可以用
[08:21.880 --> 08:23.840] 所以稍微好一点
[08:24.960 --> 08:29.200] 我觉得Lambda并不解决它本质问题
[08:29.400 --> 08:31.880] 它是怎么说
[08:31.880 --> 08:34.640] 从代码结构以及项目的设计就是
[08:34.640 --> 08:37.919] 封装比较多的那种设计
[08:37.919 --> 08:40.280] 所以加几个Lambda其实并不能
[08:40.840 --> 08:43.280] 是的现在还是有那么多getter setter
[08:43.280 --> 08:45.080] factory builder什么的
[08:45.320 --> 08:46.560] 写起来还是挺烦的
[08:47.280 --> 08:50.480] 就是这种学究派的这种写法
[08:51.960 --> 08:53.080] 我们不说Java
[08:53.080 --> 08:56.160] 然后我们继续说
[08:56.160 --> 08:58.240] 其实我到第一个公司
[08:58.600 --> 09:00.480] 就是在做一个旅游网站
[09:00.480 --> 09:02.400] 然后用的就是django
[09:03.080 --> 09:04.400] 其实在此之前
[09:04.400 --> 09:06.360] 比如说我对Python的了解
[09:06.360 --> 09:08.680] 就是通过简明Python教程
[09:09.120 --> 09:10.600] 来了解到的
[09:12.160 --> 09:13.680] 其实在这样的场景下
[09:13.680 --> 09:17.560] 其实你可以想见你对Python的掌握
[09:17.560 --> 09:20.360] 或者说对Python的全貌没有那么了解
[09:20.760 --> 09:22.440] 所以在第一年的场景下
[09:22.440 --> 09:26.440] 就是你看到同事
[09:26.720 --> 09:28.080] 他在怎么写Python
[09:28.080 --> 09:31.160] 你就去按照他的方式去写Python
[09:31.680 --> 09:32.840] 当时我们其实django
[09:32.960 --> 09:34.760] 你看他怎么去写django代码
[09:34.760 --> 09:38.000] 然后你就按照他的逻辑
[09:38.000 --> 09:40.120] 或者把它copy过来改一改
[09:40.480 --> 09:42.160] 这个东西也能运行
[09:42.840 --> 09:46.920] 对这是转到django的一个过程
[09:49.160 --> 09:51.640] 那你是从django什么版本开始用的
[09:51.640 --> 09:56.640] 当时应该是1.3吧
[09:58.080 --> 10:00.640] 1.3也挺早的一个版本
[10:01.280 --> 10:05.199] 那会觉得django本身有什么优势或好处吗
[10:05.199 --> 10:06.520] 就是转到django之后
[10:06.520 --> 10:09.960] 和你之前java的SSH相比
[10:11.319 --> 10:13.680] 其实我转之前
[10:13.680 --> 10:17.880] 我们在跟当时创业公司同事聊的时候
[10:17.880 --> 10:18.720] 就在面试的时候
[10:18.720 --> 10:20.520] 其实大家的点就在
[10:20.520 --> 10:22.160] 就跟我们今天聊一样的
[10:22.160 --> 10:24.720] 我们就在疯狂的黑java的
[10:24.720 --> 10:26.880] 这个也不算黑
[10:26.880 --> 10:28.920] 就吐槽java的这套模式太重了
[10:29.640 --> 10:34.680] 就是你从SSH这种东西切换到django
[10:35.120 --> 10:36.520] 从整体概念上来说
[10:36.520 --> 10:37.960] 你是无缝的替换
[10:38.160 --> 10:40.880] 但是你需要写的代码量急剧下降
[10:40.880 --> 10:41.880] 就会特别爽
[10:42.439 --> 10:44.560] 但其实真实的场景其实也是特别爽
[10:45.480 --> 10:48.000] 这个爽点主要是指
[10:48.000 --> 10:50.200] 比如说我可以小写很多代码
[10:50.200 --> 10:52.440] 以及通过model的OM
[10:52.440 --> 10:54.920] 可以很简单的去操作一些东西这种是吗
[10:55.920 --> 10:59.600] 对其实你比如说其实我们比较
[11:00.280 --> 11:02.720] 就我们好像我们一直在黑java
[11:02.720 --> 11:04.640] 其实只是它原特性
[11:04.920 --> 11:05.920] 你要用java写的话
[11:05.920 --> 11:08.200] 其实我把这个事情想明白
[11:08.200 --> 11:11.680] 那你就要去写按照它的结构
[11:12.080 --> 11:15.600] 完全把比如说可能一两句话要写清楚的事情
[11:15.600 --> 11:18.840] 你可能要延展成比如说十几行代码
[11:19.200 --> 11:20.720] 那在pattern里面可能就是两行代码
[11:20.720 --> 11:23.800] 那这是我们说这个语言的表达力是怎么样子的
[11:23.800 --> 11:24.880] 对吧这是它决定的
[11:25.320 --> 11:27.280] 那在其实在你写django的时候
[11:28.360 --> 11:30.320] 你当你把model写好之后
[11:30.720 --> 11:32.120] 我们剩下的就数据库
[11:32.520 --> 11:34.520] 所有的操作的封装都已经写完了
[11:34.520 --> 11:36.480] 并且按照django的model那种定义
[11:37.000 --> 11:38.160] 其实它的整个的
[11:38.960 --> 11:40.520] 你代码写的这个结构
[11:40.520 --> 11:43.080] 其实跟你写的这个表结构是非常类似
[11:43.080 --> 11:46.600] 并且它的这个语音化会特别好
[11:47.200 --> 11:51.480] 那所以你的关注点就会在你怎么用python代码
[11:51.920 --> 11:54.400] 去实现你的这个数据操作的这种逻辑
[11:54.840 --> 11:55.680] 它就很简单
[11:56.160 --> 11:57.440] 而java里面其实
[11:57.840 --> 11:59.600] 其实我现在记得不是很清楚
[11:59.600 --> 12:02.280] 但是你需要有很多繁琐的配置
[12:02.960 --> 12:05.440] 因为它不同的OI有不同的配置
[12:05.440 --> 12:06.400] 尤其是在java里面
[12:06.400 --> 12:10.600] 你需要写这种大量的XML的配置文件
[12:10.600 --> 12:13.880] 对那个确实很痛苦
[12:16.080 --> 12:18.160] 对我不知道为什么XML这么流行
[12:18.160 --> 12:23.360] XML编辑起来就比yaml这种东西差很多
[12:23.360 --> 12:24.040] 我觉得
[12:25.360 --> 12:28.800] 但是XML它是具有自描述性的
[12:29.520 --> 12:29.680] 对吧
[12:29.680 --> 12:32.720] 其实比如说类似于swift这种
[12:33.200 --> 12:35.720] 你可以在里面去定义它的类型是什么
[12:35.720 --> 12:38.120] 嗯
[12:39.960 --> 12:40.760] 这倒是对
[12:40.760 --> 12:43.160] 但是它作为一个配置文件确实比较臃肿
[12:43.160 --> 12:46.600] 对因为其实比如说它的这种
[12:47.200 --> 12:48.680] 我不确定这个我说对不对
[12:48.840 --> 12:51.400] 就是如果你们觉得不对
[12:51.400 --> 12:53.640] 或者那个可以直接指正
[12:54.040 --> 12:57.120] 就比如说它的这种叫什么依赖注入
[12:57.120 --> 12:59.280] 或者叫反射之类的东西
[12:59.280 --> 13:03.360] 那你就需要在XML里面配置好对应的这个名字
[13:03.360 --> 13:05.800] 以及它的类型像这样东西
[13:05.800 --> 13:09.040] 其实这种东西你也只能通过XML来配置
[13:09.040 --> 13:11.960] 你比如我们现在你通过json这种方式来配置
[13:13.160 --> 13:14.160] 其实好像很难实现
[13:15.760 --> 13:18.800] 比如说像我没有写过ssh的话
[13:18.800 --> 13:23.000] 就不懂为什么需要通过一个配置文件来配置
[13:23.560 --> 13:25.200] 像反射这种东西
[13:25.200 --> 13:26.440] 所以就比较难理解
[13:26.440 --> 13:29.440] 我感觉我的就思维没有转到java那边
[13:29.440 --> 13:33.720] 用java的同学可以阐述一下
[13:33.720 --> 13:37.240] 我现在是刚开始用java
[13:37.240 --> 13:38.440] 差不多知道葫芦发布校
[13:38.440 --> 13:39.400] 我也不太理解
[13:39.760 --> 13:41.640] 但是我知道你说的是什么
[13:42.120 --> 13:43.640] 我自己也在这样写
[13:43.960 --> 13:48.520] 对于这种java这种静态语言
[13:48.520 --> 13:50.840] 但其实它也是这种编译带编译的
[13:51.000 --> 13:53.000] 但是这个具体细节我不是很确定
[13:53.000 --> 13:56.960] 比如说你在动态运行的时候
[13:56.960 --> 14:00.880] 你在程序运行时你去做一些改变的话
[14:01.360 --> 14:04.800] 你只能去通过外部的租入的配置来去做改变
[14:04.800 --> 14:08.120] 那在python里面其实它有各种动态的特性让你去拿
[14:08.520 --> 14:10.920] 比如说你可以动态的替换成另外一个类
[14:11.320 --> 14:12.120] 是完全没问题的
[14:14.680 --> 14:16.240] 我抓住了
[14:16.240 --> 14:20.720] 就是它想实现一些动态的一些操作
[14:20.720 --> 14:21.880] 所以它需要一种
[14:21.880 --> 14:28.840] 我还是不明白为什么
[14:28.840 --> 14:31.360] 就是只能用charmel做这个事情
[14:31.360 --> 14:32.080] 不能用json
[14:32.080 --> 14:36.439] 如果把charmel的id或者什么各种属性都放到json里面
[14:36.439 --> 14:38.280] 然后用嵌套
[14:38.280 --> 14:39.600] 比如说在下一层的json这样
[14:39.600 --> 14:41.840] 我觉得可以实现跟charmel一样的表达
[14:41.840 --> 14:42.560] 其实可以
[14:42.560 --> 14:44.240] 不过这个话题我们可以先跳过去
[14:44.240 --> 14:44.720] 对
[14:44.720 --> 14:47.120] 我觉得我们是要聊一下
[14:47.120 --> 14:48.800] 比如说你去打开一个网站
[14:48.800 --> 14:51.959] 你去看它的源码
[14:51.959 --> 14:55.199] 它上面其实比如html本身它也是charmel的一种
[14:55.199 --> 14:56.400] 对
[14:56.400 --> 14:56.880] 对吧
[14:56.880 --> 14:57.680] 都是用标记的
[14:57.680 --> 15:01.880] 它其实是可以定义一些约束的
[15:01.880 --> 15:02.920] 对于charmel来说
[15:04.040 --> 15:05.079] 它可以定义一些约束
[15:05.079 --> 15:07.800] 但是json的话其实它没有那么多约束
[15:07.800 --> 15:11.599] 就它对你要的值是什么样类型
[15:11.599 --> 15:13.199] 它是完全没有约束的
[15:13.199 --> 15:13.640] 对吧
[15:13.640 --> 15:15.160] 它是非常松散的一种结构
[15:15.160 --> 15:21.640] 但是其实你可以在编译之前对json校验一下
[15:21.640 --> 15:23.160] 达到跟charmel类似的效果
[15:23.160 --> 15:32.160] 并且其实从应该是从传统流行下来的这种使用方式
[15:32.160 --> 15:33.800] 大家可能都在这么用
[15:33.800 --> 15:35.280] 自古以来
[15:35.280 --> 15:37.160] 对
[15:37.160 --> 15:38.760] 我觉得这就是个习惯问题了
[15:38.760 --> 15:43.520] 就像python要用rst来写文档
[15:43.520 --> 15:45.319] 而不用markdown一样
[15:45.319 --> 15:46.640] 就是一个习惯
[15:46.640 --> 15:48.880] 当然python一开始好像没有markdown
[15:48.880 --> 15:50.439] 但总之就是延续下来的
[15:50.439 --> 15:52.640] 那你们喜欢rst吗
[15:52.640 --> 15:54.360] 我肯定是喜欢markdown
[15:54.360 --> 15:56.040] rst我觉得挺好的
[15:56.040 --> 15:58.760] 我觉得比markdown表达能力要强一些
[15:58.760 --> 16:00.680] 而且就是在没有渲染的情况下
[16:00.680 --> 16:02.319] 我觉得rst比较好看一点
[16:02.319 --> 16:03.800] 真的假的
[16:03.800 --> 16:05.160] 好吧
[16:05.160 --> 16:08.880] 我不知道是不是我比较错
[16:08.880 --> 16:12.920] 就是我写rst我往往其实不会有清晰的概念
[16:12.920 --> 16:16.120] 就是我觉得我这样写它应该是这种样式
[16:16.120 --> 16:19.000] 等到我真正去拿模板渲染完之后
[16:19.000 --> 16:21.719] 好像发现有点差异
[16:21.719 --> 16:21.920] 对
[16:21.920 --> 16:23.439] 然后就比较难受
[16:23.439 --> 16:27.040] 我其实之前有写过一段时间rst
[16:27.040 --> 16:30.360] 就我之前的博客都是用rst写的
[16:30.360 --> 16:32.880] 然后写到后来发现我每次要写一个新的博客
[16:32.880 --> 16:36.520] 我都要去把rst的语法打开去看
[16:36.520 --> 16:38.680] 就你写了很长时间发现还记不住
[16:38.680 --> 16:40.319] 这倒是
[16:40.319 --> 16:40.520] 对
[16:40.520 --> 16:43.400] 但是markdown它其实就是语义性会特别好
[16:43.400 --> 16:46.240] 并且整个工具也会比较成熟
[16:46.240 --> 16:46.680] 对
[16:46.680 --> 16:50.120] 所以后来我就花了很长时间把它都转成markdown
[16:50.120 --> 16:53.240] 就有一点我觉得可以比较说明情况
[16:53.240 --> 16:55.040] 就是markdown的那种语法特别少
[16:55.040 --> 16:56.760] 比如说你插入一个链接
[16:56.760 --> 16:57.160] 对吧
[16:57.160 --> 16:58.280] 然后你插入一个图片
[16:58.280 --> 16:59.840] 就是链接的文字是变成空的
[16:59.840 --> 17:02.360] 你直接还是用链接的那种语法就可以了
[17:02.360 --> 17:05.200] 但是在rst里面你光插入链接
[17:05.200 --> 17:06.760] 你就有好几种插入方式
[17:06.760 --> 17:08.920] 然后插入图片也有好几种插入方式
[17:08.920 --> 17:12.360] 其实markdown对
[17:12.360 --> 17:14.600] 我觉得markdown还是更简明一些
[17:14.600 --> 17:17.720] 但markdown有个最大问题就是它没有一个统一的标准
[17:17.720 --> 17:20.480] 就是各家都有自己的方言
[17:20.480 --> 17:21.160] 对
[17:21.160 --> 17:22.480] 我刚要说这个问题
[17:22.480 --> 17:24.080] 各种方言
[17:24.080 --> 17:25.680] 对
[17:25.680 --> 17:27.160] 这是个很难受的问题
[17:27.160 --> 17:28.680] 我觉得Github那个是最好的
[17:28.680 --> 17:31.040] 而且Github的渲染也非常漂亮
[17:31.040 --> 17:31.640] 我觉得
[17:31.640 --> 17:33.120] GFM对
[17:33.120 --> 17:35.320] Github那个叫flavor markdown
[17:35.320 --> 17:35.760] 对吧
[17:35.760 --> 17:36.640] GFM
[17:36.640 --> 17:37.120] 对
[17:37.120 --> 17:39.800] 但是markdown我觉得它有能留心
[17:39.800 --> 17:40.919] 还有另外一个原因
[17:40.919 --> 17:44.719] 就是胡杨刚刚提到的工具栈真的比较完整
[17:44.719 --> 17:47.520] 就是它有好多编辑器可以让你去选择
[17:47.520 --> 17:48.560] 对
[17:48.560 --> 17:48.879] 对
[17:48.879 --> 17:50.760] 然后可以让你在输入完的时候
[17:50.760 --> 17:53.280] 就大致看一些排版和效果
[17:53.280 --> 17:56.479] 但是rst好像没有这种工具
[17:56.479 --> 17:59.959] 至少我没有用到过
[17:59.959 --> 18:03.479] 因为之前比如我是13年的时候
[18:03.480 --> 18:08.400] 我还在看用rst来写东西的格式是什么
[18:08.400 --> 18:12.560] 所以你最早的博客就是你找一个模板
[18:12.560 --> 18:15.840] 然后自己每次是一个就相当于是静态博客
[18:15.840 --> 18:16.160] 对吧
[18:16.160 --> 18:18.800] 那个时候虽然静态博客这个概念还没火
[18:18.800 --> 18:20.680] 但是你每次就添加一个rst
[18:20.680 --> 18:22.120] 然后来更新
[18:22.120 --> 18:22.880] 不是
[18:22.880 --> 18:23.560] 其实也不是这样
[18:23.560 --> 18:25.280] 就是我其实写博客是这样
[18:25.280 --> 18:26.760] 我会在本地写
[18:26.760 --> 18:29.080] 我本地用vim来写
[18:29.080 --> 18:31.520] 最早是这种写rst
[18:31.520 --> 18:35.520] 写rst的话我就找之前写过的IIT的文章
[18:35.520 --> 18:36.440] 然后去看它的格式
[18:36.440 --> 18:37.720] 然后参考它来写
[18:37.720 --> 18:40.200] 然后写完之后我放到
[18:40.200 --> 18:43.000] 因为我博客应该是12年的时候自己写
[18:43.000 --> 18:44.120] 用jango重写了
[18:44.120 --> 18:45.680] 然后重写了
[18:45.680 --> 18:46.960] 所以我把它贴进去
[18:46.960 --> 18:48.080] 然后自己再渲染出来
[18:48.080 --> 18:50.800] 然后展示成这样的副文本的样式
[18:50.800 --> 18:52.240] 你这跟我完全一样
[18:52.240 --> 18:53.639] 我现在都是这么做的
[18:53.639 --> 18:56.000] 那like9m我采访你一下
[18:56.000 --> 18:57.000] 你为什么要这么做
[18:57.000 --> 19:01.440] 可能是因为我当时看的一个教程是这么做的
[19:01.440 --> 19:02.800] 具体怎么样我记不清了
[19:02.800 --> 19:08.680] 但我现在觉得这套流程其实还算比较简单
[19:08.680 --> 19:12.880] 我知道有人很喜欢把所有东西都弄成自动化的
[19:12.880 --> 19:16.840] 就比如说我push一个markdown文档到github
[19:16.840 --> 19:19.440] 然后就后台自动部署怎么怎么样
[19:19.440 --> 19:20.000] 对
[19:20.000 --> 19:25.320] 其实我刚才跟你说用ci或者github的action把它自动化掉
[19:25.320 --> 19:26.560] 对肯定是可以的
[19:26.560 --> 19:28.240] 但是我比较
[19:28.240 --> 19:31.040] 我当时我博客也是自己用jango搭的
[19:31.040 --> 19:32.399] 然后是14年
[19:32.399 --> 19:34.960] 然后当时好像还没有
[19:34.960 --> 19:38.080] 就这套东西还没有很多很好的实践
[19:38.080 --> 19:41.159] 所以我就直接用最传统的这种方式
[19:43.960 --> 19:44.520] 其实也可以
[19:44.520 --> 19:50.680] 我其实主要的目的就是我要把这个东西留在本地
[19:50.680 --> 19:51.639] 那是为什么
[19:51.639 --> 19:54.240] 因为我最早写博客的时候
[19:54.240 --> 19:58.080] 我最早写博客的时候用的是一些公司的
[19:58.080 --> 19:59.440] 比如说我不知道你听说过没有
[19:59.440 --> 20:01.440] 比如说tom
[20:01.440 --> 20:03.640] 那个中文名叫啥忘了
[20:03.640 --> 20:06.280] 它也是一个类似于门户的网站
[20:06.280 --> 20:07.040] 我知道
[20:07.040 --> 20:09.320] 然后他有个博客
[20:09.320 --> 20:10.560] 然后之前是在他那写
[20:10.560 --> 20:11.600] 然后后来他关了
[20:11.600 --> 20:13.480] 关了之后所有的内容都丢了
[20:15.240 --> 20:16.760] 对虽然但是内容比较少
[20:16.760 --> 20:20.040] 所以我会现在是直接在本地写
[20:20.040 --> 20:21.240] 我也不会在线写
[20:21.240 --> 20:22.360] 我在本地写
[20:22.360 --> 20:23.960] 写完之后我检查没问题了
[20:23.960 --> 20:26.440] 然后再把它放到博客后台去
[20:26.440 --> 20:30.320] 那你的东西是完全没有持久化的吗
[20:30.320 --> 20:31.960] 还是在数据库里吗
[20:31.960 --> 20:35.400] 还是在数据库里
[20:35.400 --> 20:38.680] 就是一种习惯
[20:38.680 --> 20:41.080] 但是你本地会有很多IST文件是吗
[20:41.080 --> 20:41.560] 对
[20:41.560 --> 20:45.520] 就是其实你本地会构建一个跟博客目录不一样的
[20:45.520 --> 20:46.560] 不一样的目录
[20:46.560 --> 20:50.440] 比如我本地的目录就是年份和月份
[20:50.440 --> 20:53.000] 然后对应的文件
[20:53.000 --> 20:55.080] 你到博客上就是对应的目录
[20:55.080 --> 20:56.360] 对应的分类
[20:56.360 --> 20:58.120] 就不太一样
[20:58.120 --> 21:01.000] 所以同样是静态化
[21:01.000 --> 21:05.560] 对胡杨的需求听起来是web2.0时代的需求
[21:05.560 --> 21:08.040] 就是博客不是自托管的
[21:08.040 --> 21:09.320] 都是各种门户
[21:09.320 --> 21:13.080] 但是它有可能随时消失不见跑路
[21:13.080 --> 21:13.399] 对
[21:13.399 --> 21:16.600] 所以你就会倾向于自己要留一个底稿
[21:16.600 --> 21:18.120] 自己要留一份是很重要的
[21:18.120 --> 21:20.439] 对很重要一点就是你有时候你写的东西
[21:20.439 --> 21:22.879] 其实你并不想放上去
[21:22.879 --> 21:23.959] 其实这是个习惯
[21:23.959 --> 21:26.120] 就像你比如节日记一样的习惯
[21:26.120 --> 21:27.560] 有些东西是你不想放出来的
[21:27.560 --> 21:28.040] 是的
[21:28.040 --> 21:30.919] 其实我在本地我就会挑选哪些东西是可以放出去的
[21:30.919 --> 21:33.560] 我是在博客我用的wordpress
[21:33.560 --> 21:35.239] 然后我写了很多草稿在里面
[21:35.239 --> 21:37.159] 我觉得整理好了我再发
[21:37.159 --> 21:40.199] 但是wordpress可能会丢
[21:40.199 --> 21:44.600] 是的运维起来工作量就比较大了
[21:44.600 --> 21:45.199] 用的比较爽
[21:45.199 --> 21:47.239] 就是你得想办法备份之类的
[21:47.239 --> 21:50.439] 而且你备份的目标只有一个数据库
[21:50.439 --> 21:53.159] 你不能用什么静态的什么东西的备份
[21:53.160 --> 21:57.320] 我的做法是有一份数据在数据库里
[21:57.320 --> 22:01.160] 然后但是markdown我会传到Github上去
[22:01.160 --> 22:03.160] 所以就是有两个地方都有
[22:03.160 --> 22:05.000] Github as a backup
[22:05.000 --> 22:06.520] 因为也是就是markdown嘛
[22:06.520 --> 22:08.200] 所以就比较方便
[22:08.200 --> 22:11.240] 突然发现好像只有我的博客是纯静态的
[22:12.360 --> 22:16.040] 我现在把博客基于Hackthorne
[22:16.040 --> 22:19.080] 就是前端的一个静态博客的项目
[22:19.080 --> 22:20.200] 那也可以其实
[22:20.200 --> 22:23.000] 但其实对我来说比如说
[22:23.000 --> 22:25.640] 搞一个博客更大的
[22:25.640 --> 22:28.920] 至少在12年的时候更大的目标其实是
[22:28.920 --> 22:31.960] 要把公司里面用到的整套技术站
[22:31.960 --> 22:34.760] 在我自己的这种场景下
[22:34.760 --> 22:36.040] 我自己去实验一下
[22:36.040 --> 22:39.160] 然后尝试去引一些新的东西
[22:39.160 --> 22:41.000] 这样的话不至于
[22:41.000 --> 22:43.880] 就是我所用到技术站
[22:43.880 --> 22:50.520] 完全被这个公司用了东西所限制
[22:50.520 --> 22:52.920] 对我觉得大家可能多少个人项目
[22:52.920 --> 22:53.800] 都有点这样的目的
[22:53.800 --> 22:54.280] 是的
[22:54.280 --> 22:57.160] 对这不是python的两个梗吗
[22:57.160 --> 23:00.040] 一个就是用python的练手的项目
[23:00.040 --> 23:01.480] 如果你不是写爬虫
[23:01.480 --> 23:03.800] 就是写一个博客
[23:03.800 --> 23:06.920] 对现在用购语言就是写proxy是吗
[23:06.920 --> 23:08.840] 现在购语言的proxy好多
[23:08.840 --> 23:10.440] 对
[23:10.440 --> 23:13.960] 就真的很常见
[23:13.960 --> 23:16.520] 其实我特别想把博客搞成静态的
[23:16.520 --> 23:17.640] 因为现在像
[23:17.640 --> 23:21.560] 因为现在像Netlify这种东西实在太爽了
[23:21.560 --> 23:23.160] 你什么都不用配置
[23:23.160 --> 23:25.400] 你只要就是hackstore新建一个博客
[23:25.400 --> 23:26.280] 推到Github上
[23:26.280 --> 23:28.120] 然后去登录一下Netlify
[23:28.120 --> 23:30.680] 然后你每次push它都会自动更新
[23:30.680 --> 23:31.400] 特别爽
[23:31.400 --> 23:33.800] 这是一个服务吗
[23:33.800 --> 23:34.760] 是的
[23:34.760 --> 23:37.080] 就是那个Netlify你只要告诉它
[23:37.080 --> 23:38.280] 你的Github仓库哪里
[23:38.280 --> 23:39.720] 它自动会识别
[23:39.720 --> 23:41.720] 你是有哪一个静态博客的框架
[23:41.720 --> 23:44.040] 然后自动给你搞一个部署的流程
[23:44.040 --> 23:45.000] 特别爽
[23:46.840 --> 23:49.160] 我现在倒没有
[23:49.160 --> 23:51.000] 但是我用hackstore的时候
[23:51.000 --> 23:52.920] 其实你可以配置说
[23:52.920 --> 23:55.640] Github的选项要不要push上去
[23:55.640 --> 23:58.440] 以及你自己服务器的选项要不要push上去
[23:58.440 --> 24:00.760] 然后我写完之后只需要执行一个命令
[24:00.760 --> 24:04.200] 它就可以同时去push和部署
[24:04.200 --> 24:08.120] 你相当于commit之后还要再执行一个命令
[24:08.120 --> 24:09.800] 它那个相当于是ci
[24:09.800 --> 24:10.840] 你只要git push了
[24:10.840 --> 24:13.239] 它会相当于一个ci自动给你标的
[24:13.239 --> 24:14.280] 对
[24:14.280 --> 24:18.439] 但是那个hackstore它会把这几个命令封装成一个命令
[24:18.439 --> 24:20.600] 就是你只要配置好一次配置文件
[24:20.600 --> 24:21.959] 然后就可以了
[24:23.959 --> 24:24.199] 对
[24:24.199 --> 24:27.399] 但是我选hackstore其实最主要的原因
[24:28.439 --> 24:29.959] 其实是为了好看
[24:33.080 --> 24:37.479] 因为有一天我终于发现我对博客的终极需求了
[24:37.480 --> 24:39.640] 就是除了我自己写的内容之外
[24:39.640 --> 24:41.960] 另外一最大的需求就是好看
[24:41.960 --> 24:43.000] 对很关键
[24:44.520 --> 24:44.680] 对
[24:44.680 --> 24:49.560] 然后我就毅然决然的选了一个前端做的这种静态博客生成器
[24:49.560 --> 24:52.120] 对什么Ruby啊Python啊直接不考虑
[24:53.400 --> 24:55.880] 对因为界面确实没有前端同学做的漂亮
[24:55.880 --> 24:57.880] 这个审美这个问题很有意思
[24:57.880 --> 24:59.400] 我的博客我觉得很好看
[24:59.400 --> 25:01.080] 很平实
[25:01.080 --> 25:03.800] 但是所有看过我的博客的人都说非常丑
[25:03.800 --> 25:05.480] 然后有个人竟然还跟我说
[25:05.480 --> 25:08.040] 他只有用ISS阅读器里面渲染出来
[25:08.040 --> 25:08.920] 他才看得下去
[25:12.920 --> 25:13.800] 那可能是真的
[25:16.920 --> 25:18.600] 这是很传统的页面的博客
[25:18.600 --> 25:21.320] 当你和所有人不一样的时候就要怀疑是自己的问题
[25:22.360 --> 25:24.440] 我也会被吐槽
[25:24.440 --> 25:26.360] 比如博客那个顶部我之前是一个
[25:27.240 --> 25:27.880] 紫色的
[25:28.600 --> 25:31.240] 紫色的一个banner的一个导航
[25:31.240 --> 25:34.360] 然后有人吐槽说这个颜色太老了
[25:34.360 --> 25:37.399] 然后他吐槽完之后我就立马换成一个蓝色的了
[25:38.280 --> 25:40.600] 那个bone strap的那种紫色对吧
[25:40.600 --> 25:42.040] bone strap2的那个
[25:42.040 --> 25:43.080] 不是那种紫色
[25:43.080 --> 25:44.600] 对是那种紫色
[25:45.479 --> 25:47.959] 因为这个颜色我会自己去调
[25:49.240 --> 25:50.600] 你是自己调的颜色
[25:50.600 --> 25:52.919] 对我觉得看得顺眼的我就把它放上去了
[25:55.240 --> 25:56.520] 对我就是
[25:56.520 --> 25:57.639] 调颜色还蛮重要的
[25:57.639 --> 25:58.760] 对我觉得我意识到了
[25:59.479 --> 26:03.080] 我其实之前用jungle自己写博客的时候也意识到了
[26:03.080 --> 26:06.040] 就是最大的困难点就是我写不出好看的前端页面
[26:07.879 --> 26:09.639] 对然后就很难受
[26:09.639 --> 26:13.639] 然后就毅然决然的选了一个hacksaw
[26:19.879 --> 26:21.800] 好我们把主题回到jungle
[26:21.800 --> 26:22.679] 感觉跑远了
[26:25.960 --> 26:27.080] 对然后后来呢
[26:27.080 --> 26:28.199] 慧扬你的经历是什么
[26:28.199 --> 26:29.879] 就是你从外包到了
[26:30.840 --> 26:32.600] 到了一家新的创业公司
[26:32.600 --> 26:34.040] 对吧在这家公司
[26:34.040 --> 26:35.320] 然后开始接触python
[26:35.320 --> 26:36.360] 然后使用jungle
[26:38.040 --> 26:40.199] 这个时候其实并没有说
[26:41.159 --> 26:42.840] 比如说你一开始去
[26:42.840 --> 26:44.439] 比如像现在很多人就是
[26:45.000 --> 26:46.520] 比如你一开始学的就是python
[26:46.520 --> 26:48.360] 那你比如你想做外包开发的时候
[26:48.360 --> 26:49.719] 你会想我用哪个框架
[26:50.439 --> 26:52.199] 但在我这种场景下是不存在的
[26:52.199 --> 26:54.199] 就是因为我用的第一个框架就是jungle的框架
[26:54.840 --> 26:59.000] 所以但这种场景的坏处缺点就是
[26:59.000 --> 27:02.280] 其实我在第一年的这种用jungle的时间里面
[27:02.280 --> 27:05.320] 我其实对jungle没有什么特别清晰的概念
[27:05.320 --> 27:06.760] 就是你可以想象一下
[27:06.760 --> 27:09.720] 就是你被包在一个某个建筑物里面
[27:10.440 --> 27:12.920] 所以你从来不知道这个建筑物外面到底是什么样子的
[27:14.840 --> 27:17.240] 对只有到第二年的时候
[27:17.240 --> 27:19.080] 其实就是你去面试的时候
[27:19.080 --> 27:19.960] 大家才会问你
[27:20.680 --> 27:21.879] 这个里面有什么东西
[27:21.879 --> 27:22.680] 对吧你怎么用的
[27:23.320 --> 27:25.399] 这个时候你根本就不知道
[27:26.200 --> 27:27.639] 原来这个东西叫这个东西
[27:27.639 --> 27:29.399] 比如他问你中间键你有没有用过
[27:29.400 --> 27:31.800] 对吧jungle里面中间键你有没有用过
[27:32.440 --> 27:33.800] 你没有这个概念
[27:33.800 --> 27:34.520] 虽然你在写它
[27:34.520 --> 27:35.560] 你根本就不知道它是啥
[27:36.840 --> 27:39.960] 所以这是第一阶段的这个状态
[27:39.960 --> 27:42.680] 就是跟比如说你一开始学python
[27:42.680 --> 27:44.760] 然后后来你去选web框架
[27:45.320 --> 27:46.280] 这种感觉是不一样的
[27:46.760 --> 27:49.240] 我是直接从里面到外面的这种状态
[27:49.800 --> 27:53.080] 所以之后就会去对比
[27:53.080 --> 27:55.080] 比如说因为我后来到sophie之后
[27:56.440 --> 27:57.560] 我们用了两个框架
[27:57.560 --> 27:58.440] 第一个是jungle
[27:58.440 --> 28:00.200] 然后第二个就是tenedo
[28:00.200 --> 28:04.280] tenedo是用来做这个新闻门户的
[28:04.280 --> 28:05.720] 就是手机端的新闻门户的
[28:05.720 --> 28:08.520] 这样一个后端框架
[28:09.720 --> 28:11.480] 然后你就会去对比
[28:11.480 --> 28:13.800] ok那这两个框架它之间差别
[28:13.800 --> 28:18.040] 这个时候你才能对jungle有一个更深刻的认识
[28:18.600 --> 28:23.240] 就比如说tenedo跟jungle这个差别是什么
[28:23.960 --> 28:26.440] 其实你从学起来你就会发现
[28:26.440 --> 28:28.440] tenedo真的没什么可学的
[28:28.440 --> 28:30.920] 因为它提供的东西也就那样
[28:30.920 --> 28:35.720] 所以其实我想应该大家都不会用tenedo去写一个博客
[28:35.720 --> 28:37.320] 除非你是为了熟悉tenedo
[28:37.320 --> 28:39.160] 因为你要用它去写博客
[28:39.160 --> 28:41.320] 那你真的沟通量太大了
[28:41.960 --> 28:42.760] 对所以我发现
[28:42.760 --> 28:45.400] 核心难点是自己配OM数据库
[28:45.400 --> 28:46.920] 然后去建模
[28:46.920 --> 28:47.400] 对
[28:48.520 --> 28:49.480] 关键没必要
[28:49.480 --> 28:50.920] 博客也没多少访问量
[28:50.920 --> 28:53.640] 对其实就是一个快速出魂的一个东西
[28:53.640 --> 28:58.920] 所以其实对jungle它就是一个
[28:58.920 --> 29:01.800] 就是你看它的那个网站的口号是什么
[29:01.800 --> 29:05.160] 它其实就是给完美主义者准备的框架
[29:05.160 --> 29:09.800] 对就是让你能够快速的搞定你这个项目上线
[29:09.800 --> 29:11.560] 对这是它的目的
[29:11.560 --> 29:14.760] 所以我们说它是一个这种
[29:14.760 --> 29:19.080] 这个全站的框架或者说大一统的这种框架
[29:19.080 --> 29:21.240] 它所有东西都包到它这个里面
[29:21.240 --> 29:23.800] 那这种的好处就是
[29:23.800 --> 29:28.680] 你需要的这个知识或者你想学这个框架的时候
[29:28.680 --> 29:31.560] 或者你想开发一个web项目的时候
[29:31.560 --> 29:36.600] 你需要的知识就已经完全涵盖在它的框架以及它的文档里面
[29:36.600 --> 29:39.480] 就这里不得不说的就是jungle的文档
[29:39.480 --> 29:43.400] 应该是所有的这个开源项目里面最好的
[29:43.400 --> 29:44.280] 写的最好的
[29:44.280 --> 29:45.720] 或者写的最丰富的
[29:45.720 --> 29:52.440] 而且它有那种类似topic的那个文档组织
[29:52.440 --> 29:54.680] 就是你比如说你想了解一个template
[29:54.680 --> 29:56.920] 你可以看到很多文档都是一步一步来
[29:56.920 --> 29:59.640] 就是教你逐步的了解template的
[29:59.640 --> 30:01.160] 对
[30:01.160 --> 30:05.880] jungle的文档确实是业界良心
[30:05.880 --> 30:10.680] 对我觉得所有框架涉及到的点以及说
[30:10.680 --> 30:16.600] 一些web的概念其实全部会被里面会提及到
[30:16.600 --> 30:21.880] 对因为我之前有有尝试去把它的那个
[30:21.880 --> 30:24.120] 因为它是支持导成一part格式的嘛
[30:24.120 --> 30:27.320] 导成一part格式然后放到你的ipad上
[30:27.320 --> 30:29.240] 然后你发现它有一千多页
[30:29.240 --> 30:30.360] 我好你就不想读了
[30:30.360 --> 30:37.160] jungle其实它的文档
[30:37.160 --> 30:40.200] 因为我一开始是学用jungle
[30:40.200 --> 30:43.720] 我觉得它那个tutorials真的是特别好
[30:43.720 --> 30:44.680] 对对那个特别好
[30:44.680 --> 30:48.920] 就是它指引手册它不同的版本会教你做不同的东西
[30:48.920 --> 30:55.240] 对然后就是从0到1的去带你去
[30:55.240 --> 30:56.840] 如果你是一个初学者的话
[30:56.840 --> 30:57.880] 你什么都不知道
[30:57.880 --> 30:59.880] 从0到1的来告诉你说
[30:59.880 --> 31:03.640] 这个你怎么来实现一个简单的web程序
[31:03.640 --> 31:06.360] 对所以这里我们其实可以聊
[31:06.360 --> 31:11.639] 比如说新手要学习jungle的话或者学习其他框架的话的差别
[31:11.639 --> 31:13.479] 就是我可以先起个头
[31:13.479 --> 31:16.360] 就是很多人比如说一开始说
[31:16.360 --> 31:19.399] 那我去先选一个简单的框架
[31:19.399 --> 31:21.240] 我要去比如构建一个简单的
[31:21.240 --> 31:22.840] 我们就说博客好了
[31:22.840 --> 31:24.360] 大家比较耳熟能详
[31:24.360 --> 31:27.399] 我现在想去构建一个博客简单的博客
[31:27.399 --> 31:30.280] 我想要选一个简单的框架去搞这个博客
[31:30.280 --> 31:31.719] 那我要怎么搞呢
[31:31.720 --> 31:37.640] 其实这个简单的框架就是带引号的这个简单
[31:37.640 --> 31:40.040] 其实jungle应该是最简单的
[31:40.040 --> 31:42.600] 因为他把所有的这个信息都给你了
[31:42.600 --> 31:45.880] 你在这个文档上你把它tutorials走完
[31:45.880 --> 31:48.760] 那你就知道整个web的这个系统什么样子了
[31:48.760 --> 31:50.520] 那其实你换场景一下
[31:50.520 --> 31:52.440] 比如说你用flask或者用tornado
[31:52.440 --> 31:54.840] 然后你把tornado熟悉之后
[31:54.840 --> 31:57.160] 你要开始找这个orm用什么
[31:57.160 --> 31:58.920] 对吧你找找找完之后
[31:58.920 --> 32:01.880] 然后你要去想前面的form的部分用什么
[32:01.880 --> 32:04.600] 对flask来说也是一样的
[32:04.600 --> 32:06.040] 其实这种场景下
[32:06.040 --> 32:08.120] 就它的这个简单程度
[32:08.120 --> 32:11.400] 并不如这个框架所给你的这种程度
[32:11.400 --> 32:12.200] 对
[32:12.200 --> 32:17.640] 就我之前有一个项目我想一直用jungle
[32:17.640 --> 32:18.840] 我这次用一下flask
[32:18.840 --> 32:22.680] 结果我发现我花了半天的时间在配置orm
[32:22.680 --> 32:24.520] 然后配置完了orm配置template
[32:24.520 --> 32:28.520] 配置完了template还有managepy都得自己去搞
[32:28.520 --> 32:31.320] 然后就是你修改了代码
[32:31.320 --> 32:32.280] 它不能自动重启
[32:32.280 --> 32:34.920] 你得搞一个自动重启的那个插件装上去
[32:34.920 --> 32:37.879] 不知道现在是不是这样
[32:37.879 --> 32:39.720] 就花了很多时间在配置这个
[32:39.720 --> 32:43.560] 后来我还是执行了一下jungle project的start
[32:43.560 --> 32:50.200] 就是两种风格
[32:50.200 --> 32:53.000] 我个人其实是完全赞同虎杨的
[32:53.000 --> 32:57.240] 就是比如说如果不考虑你在现有的公司已有的技术站
[32:57.240 --> 32:59.800] 你想兴起一个项目
[32:59.800 --> 33:02.680] 那我自己的绝对首选是flask
[33:02.680 --> 33:03.640] 不是是jungle
[33:03.640 --> 33:05.240] 不好意思是jungle
[33:05.240 --> 33:06.600] 可以剪掉
[33:06.600 --> 33:12.360] 对就是你在兴起一个项目的时候
[33:12.360 --> 33:14.520] 我们说的兴起不是指重复了
[33:14.520 --> 33:15.640] 就是兴起的时候
[33:15.640 --> 33:19.480] 其实往往你是在快速的推动一个所谓的业务的实现
[33:19.480 --> 33:22.200] 不论它是一个技术型业务还是一个产品型业务
[33:22.200 --> 33:22.840] 对
[33:22.840 --> 33:26.040] 这个时候最关键最重要的
[33:26.040 --> 33:28.920] 其实是你对业务的这种描述建模
[33:28.920 --> 33:31.159] 以及最后的实现
[33:31.159 --> 33:35.879] 对其实这一步很少会一上来就涉及到性能瓶颈
[33:35.879 --> 33:37.879] 可扩展性
[33:37.879 --> 33:40.760] 对这些太早了这个时候
[33:40.760 --> 33:43.560] 对但是比如说你已经有个很重的服务了
[33:43.560 --> 33:45.480] 我现在要把某些模块拆出来
[33:45.480 --> 33:47.480] 对我出于高性能也好
[33:47.480 --> 33:49.480] 或者出于简洁也好
[33:49.480 --> 33:51.639] 那你选flask或tunado
[33:51.639 --> 33:55.080] 基于你的理由我是完全认同的
[33:55.080 --> 33:57.879] 但是你要比上手速度对吧
[33:57.879 --> 34:01.240] 看谁先做出一个可用的项目
[34:01.240 --> 34:03.399] 我觉得这jango确实是有
[34:03.399 --> 34:07.240] 超强的优势的在这个开发效率上
[34:07.240 --> 34:11.239] 对并且其实我们再说到一点就是比如他的这种
[34:11.239 --> 34:13.960] 我们常说的就是你写软件
[34:13.960 --> 34:17.639] 这个时间长了你肯定知道mvc这种分层的模式对吧
[34:17.639 --> 34:20.040] 其实我们在jango里面比如说它是这种
[34:20.040 --> 34:22.040] 我们大家都叫它mtv的这种模式
[34:22.040 --> 34:24.040] 那这种也是mvc的这种
[34:24.040 --> 34:27.400] 在jango里面一个别名吧
[34:27.400 --> 34:31.080] 但是呢比如说同样的这种分层模式
[34:31.080 --> 34:33.080] 我们去到用tunado来写
[34:33.080 --> 34:35.639] 那这种感觉就会不一样
[34:35.639 --> 34:39.480] 为什么这个感觉取决于就是你写成什么样子
[34:39.480 --> 34:41.480] 取决于第一个写这个代码
[34:41.480 --> 34:43.480] 就写这个项目的人把它写成什么样
[34:43.480 --> 34:47.960] 其实这个小斌应该会比较清楚
[34:47.960 --> 34:52.360] 就比如说我们用的这个项目的结构是什么样子的
[34:52.360 --> 34:54.520] 对吧就是这第一个人把它构造成什么样
[34:54.520 --> 34:56.520] 那它就是什么样子的
[34:56.520 --> 34:58.520] 这个时候的问题在于
[34:58.520 --> 35:00.520] OK你在这个公司这么写的
[35:00.520 --> 35:03.240] 然后你到另外一个公司你就觉得你们写的都不对
[35:03.240 --> 35:06.040] 因为我从入门开始就按照这种方式来写的
[35:06.040 --> 35:08.040] 我发现你们这写的完全不一样
[35:08.040 --> 35:10.040] 但其实这个东西没有标准
[35:10.040 --> 35:12.280] 对但其实这个东西到jango里面呢
[35:12.280 --> 35:14.280] 你会发现这是一个
[35:14.280 --> 35:16.280] 这个框架的一个规范
[35:16.280 --> 35:18.280] 大家其实都按照这种来写的
[35:18.280 --> 35:21.560] 虽然它会做很多种这种结构上调整
[35:21.560 --> 35:23.560] 但它不会差的很多
[35:23.560 --> 35:27.240] 对吧最起码从比如说代码布局层面
[35:27.240 --> 35:29.240] jango会有一个大致的规范
[35:29.240 --> 35:31.240] 你只要start一个app它帮你生成一下
[35:31.240 --> 35:34.520] 对但是你如果是其他框架
[35:34.520 --> 35:38.840] 那其实说白了就取决于你第一个写代码人的风格
[35:38.840 --> 35:43.160] 对以及说如果能统一的话那就是第一个代码人的风格
[35:43.160 --> 35:46.120] 如果不能统一的话那就是没有风格
[35:46.120 --> 35:48.120] 各种混乱的状态
[35:48.120 --> 35:51.640] 就完全取决于第一个人的风格是什么
[35:51.640 --> 35:57.480] 对这种但是我其实之前有见过有另外一种情况
[35:57.480 --> 36:01.960] 就是因为其实jango的代码布局在它早期的版本里
[36:01.960 --> 36:03.960] 也是在频繁迭代的
[36:03.960 --> 36:06.839] 从1.3到1.6其实也有很多的变化
[36:06.839 --> 36:08.839] 对然后就会
[36:08.839 --> 36:12.200] 然后我就会发现比如说如果有人是一路写1.3的
[36:12.200 --> 36:15.319] 但是他又不愿意往后跟进的话就会出现
[36:15.320 --> 36:23.000] 即使他新起一个项目他也会手动的把1.6的调整成1.3的布局风格
[36:23.000 --> 36:26.040] 对我是有见过这种情况的
[36:26.040 --> 36:28.040] 对就是习惯了
[36:28.040 --> 36:30.040] 其实很难生的很难生
[36:30.040 --> 36:32.040] 你说
[36:32.040 --> 36:36.040] 他们这个布局的风格主要是差别在哪里的
[36:36.040 --> 36:39.240] 我觉得可以给听众介绍一下我也不太了解
[36:39.240 --> 36:42.840] 它这个布局的风格其实还没涉及到代码的结构了
[36:42.840 --> 36:46.680] 就是比如说jango有app这个概念
[36:46.680 --> 36:49.160] 就是在一个project下有很多app
[36:49.160 --> 36:53.000] 对那你到底是每个app独立管理自己的model
[36:53.000 --> 36:55.000] tablet admin
[36:55.000 --> 36:59.800] 还是说我先有一个大的tablet收集所有的tablet
[36:59.800 --> 37:03.000] 但是在这底下再区分去管理app这种
[37:03.000 --> 37:09.000] 就是所谓的应该叫什么code layout这种代码布局
[37:09.000 --> 37:11.320] 对就是这种的调整
[37:11.320 --> 37:14.520] 所以现在的最佳实践应该是哪一种
[37:14.520 --> 37:18.120] 其实就是按照官方的这种方式来写
[37:18.120 --> 37:23.800] 就每一代的最佳实践其实就是你按照startup生成出来的那个来做
[37:23.800 --> 37:25.800] 对
[37:25.800 --> 37:30.280] 因为它官方工具提供了这个肯定是想让你都是统一的
[37:30.280 --> 37:33.080] 其实就是它的一些
[37:33.080 --> 37:37.480] 但这个其实也是比如说我们在长时间写代码的时候
[37:37.480 --> 37:39.480] 我们积累的一种经验
[37:39.480 --> 37:43.800] 然后我们把这种经验然后把它实践到某个框架里面
[37:43.800 --> 37:47.320] 我们也可以把这个理解成是搞jango的这帮人
[37:47.320 --> 37:49.320] 他们一开始在搞这种新闻网站
[37:49.320 --> 37:52.120] 就一开始比如说他一开始并不是一个框架
[37:52.120 --> 37:54.280] 那他可能就是随便什么东西
[37:54.280 --> 37:59.720] 然后这种一个简单的纯python构造成的一个能够提供web服务的东西
[37:59.720 --> 38:01.720] 那他在不断迭代过程中
[38:01.720 --> 38:04.200] 他们有一些自己的实践的东西
[38:04.200 --> 38:07.480] 比如说我们现在有人会聊的这种设计模式的东西
[38:07.480 --> 38:11.320] 那他把这个东西就你可以理解为他的这种编程的理念
[38:11.320 --> 38:13.880] 说设计理念他把它抽到这个框架里面
[38:13.880 --> 38:15.640] 然后大家都按照这个来走
[38:15.640 --> 38:17.640] 那所以其实对于他来说
[38:17.640 --> 38:23.320] 他的一个概念就是你要把这种业务上的能结合的东西就完全结合了
[38:23.320 --> 38:26.440] 你两个app之间是不需要相关的
[38:26.440 --> 38:28.440] 每个app是完全自制的
[38:28.440 --> 38:31.160] 就你可以理解我在settings里面配置一个app
[38:31.160 --> 38:34.360] 我就把这个东西热插拔进去了
[38:34.360 --> 38:36.920] 对吧我不需要的话就把它干掉就好了
[38:36.920 --> 38:41.720] 对这种逻辑会就是我们从设计上理解会更简单一点
[38:43.000 --> 38:45.720] 我其实比较喜欢这种app的设计
[38:45.720 --> 38:49.480] 就是我刚开始入门了解这个时候其实我还没有意识到
[38:49.480 --> 38:51.480] 但是后来我意识到就是
[38:51.480 --> 38:58.200] 其实相比于就是很多公司就是前段几年前微服务特别火吧
[38:58.200 --> 39:05.400] 对会看到很多小型公司创业公司可能一上来就要搞微服务架构
[39:05.400 --> 39:10.280] 对我会觉得相比于微服务架构还是
[39:10.280 --> 39:16.280] 你像Jungle框架的这种设计你能够提供一个monolith这种大的项目
[39:16.280 --> 39:20.440] 然后里面能细分很多app其实就能满足大部分人的需求了
[39:22.040 --> 39:24.280] 其实Jungle里面有很多先进的概念
[39:24.280 --> 39:27.720] 其实我觉得那个OM你只写你自己的class
[39:27.720 --> 39:33.480] 然后Jungle帮你去figure out怎么把SQL去迁移到最新的这个
[39:33.480 --> 39:36.440] 我觉得这是现在很流行的那个声明式
[39:36.440 --> 39:40.680] 你说那个make migration那个是吗
[39:40.680 --> 39:41.480] 对的对的
[39:41.480 --> 39:45.800] 那个其实最早是就1.3里面其实没有的嘛
[39:45.800 --> 39:49.320] 1.4还是1.6里面引入的
[39:49.320 --> 39:51.800] 1.3的时候它应该是一个Jungle的插件吧
[39:51.800 --> 39:53.480] 它不是一个官方自带的
[39:53.480 --> 39:55.240] 对叫Jungle source的一个东西
[39:55.240 --> 39:59.800] 你们说的1.3其实我不知道我最开始的是1.8
[39:59.800 --> 40:04.280] 好年轻好年轻
[40:06.600 --> 40:09.880] 然后其实比如说我们还是说到这个布局的有两种布局方式嘛
[40:11.080 --> 40:17.000] 就是第一种就是我app1就是比如说我这个第一个业务组织
[40:17.000 --> 40:19.000] 然后呢我把它封装成一个app
[40:19.000 --> 40:23.000] 然后这个app里面包含了我们定义的mvc对吧
[40:23.000 --> 40:24.600] 所有mvc文件都放在这个里面
[40:24.600 --> 40:26.280] 然后另外一种模式就是
[40:26.280 --> 40:29.880] ok我model是一个独立的package
[40:29.880 --> 40:32.680] 这个package里面有比如说app1的代码
[40:32.680 --> 40:33.960] app2的代码app3的代码
[40:33.960 --> 40:37.320] 然后呢我view里面有app1的代码
[40:37.320 --> 40:38.680] app2的代码app3的代码
[40:38.680 --> 40:41.640] 那这两种对比的话其实你会发现
[40:41.640 --> 40:46.120] 我当我去维护app1的比如维护它的view
[40:46.120 --> 40:47.400] 去维护它的model的时候
[40:47.400 --> 40:52.360] 其实你压根不需要关注这个app2的或app3的任何东西
[40:52.360 --> 40:54.280] 那所以这种这种场景下
[40:54.280 --> 40:57.960] 其实你把它放到一个package里面是更合适的
[40:57.960 --> 41:01.160] 因为你需要的信息量就完全在这个package里面已经呈现了
[41:01.160 --> 41:04.520] 对这是两种不一样的方式
[41:04.520 --> 41:10.440] 你的意思就是说更好的那种是把它们分开放的吧
[41:10.440 --> 41:12.280] 就是分两个app
[41:12.280 --> 41:14.280] 对按照两个app就是其实我们在
[41:14.280 --> 41:19.640] 比如我们在写这个就改代码的时候
[41:19.640 --> 41:22.440] 我们经常会要求会有一个原则
[41:22.440 --> 41:27.240] 原则就是让它你改的东西它的影响最小对吧
[41:27.240 --> 41:29.080] 你怎么让它影响最小
[41:29.080 --> 41:30.600] open close principle
[41:30.600 --> 41:31.720] 你怎么影响最小呢
[41:31.720 --> 41:36.200] 其实就是你所改的那个函数它足够小
[41:36.200 --> 41:38.280] 那你所以你影响的就是这个函数
[41:38.280 --> 41:42.360] 就让它的一个影响范围限定到这个里面
[41:42.360 --> 41:46.360] 当你把这个业务比如rmvc的东西完全放到这个package里面
[41:46.360 --> 41:48.920] 你所需要关注的点就在这个package里面
[41:48.920 --> 41:50.920] 你不需要去关注其他的
[41:50.920 --> 41:52.920] 这样你也不会去影响其他的
[41:52.920 --> 41:54.520] 那这里就有一个问题了
[41:54.520 --> 42:00.600] 既然你已经把它分开到了不同的这种app里面
[42:00.600 --> 42:01.880] 然后它们互不影响
[42:01.880 --> 42:06.360] 那为什么我不直接创建两个这样的site呢
[42:06.360 --> 42:07.240] 对吧
[42:07.240 --> 42:09.240] 两个site
[42:09.240 --> 42:11.880] 它有可能有可能两个app是有交互的
[42:11.880 --> 42:13.320] 是这样吗
[42:13.320 --> 42:14.120] 对
[42:14.120 --> 42:18.200] 对的就是两个app之间可以互相import
[42:18.200 --> 42:20.360] 对就比如说你有一个app
[42:20.360 --> 42:22.680] 你可能就是一个很大的用户系统
[42:22.680 --> 42:27.800] 对另外一个app就是基于这个用户系统之上构建的更具体的业务系统
[42:30.600 --> 42:32.920] 其实app里面应该有一个
[42:32.920 --> 42:37.240] 就是他们那个app里面有演绎文件
[42:37.240 --> 42:39.320] 其实它对另一个app来说
[42:39.320 --> 42:44.200] 就是一个那个package吧
[42:44.200 --> 42:45.560] 就是你可以import进来
[42:45.560 --> 42:47.160] 但既然他们有交互的话
[42:47.160 --> 42:49.800] 也没有办法完全的隔离对吧
[42:49.800 --> 42:54.760] 对就是其实还是那个原则
[42:54.760 --> 42:56.040] 就是让它高内聚
[42:56.040 --> 42:59.800] 就是让它特别相关的东西完全放到一个package里面
[42:59.800 --> 43:01.480] 然后两个package打交道的话
[43:01.480 --> 43:03.560] 就是外部的方式
[43:03.560 --> 43:05.560] 其实我觉得对新手来说
[43:05.560 --> 43:08.360] 怎么分那个app是比较难的一个问题
[43:08.360 --> 43:09.560] 就我刚开始写jungle的时候
[43:09.560 --> 43:11.560] 我就把所有东西写到一个app里面去
[43:11.560 --> 43:15.720] 我觉得分app这个问题其实本身就是很难的
[43:15.720 --> 43:18.120] 不是新手还是老手的问题
[43:18.120 --> 43:21.080] 对就是如果你需求是确认的话还好
[43:21.080 --> 43:23.880] 但是如果你在做一个互联网公司的产品
[43:23.880 --> 43:26.759] 这个需求就会跟着你产品走
[43:26.759 --> 43:27.960] 可能你分好了app
[43:27.960 --> 43:29.240] 然后你迭代迭代
[43:29.240 --> 43:31.240] 这个app就不合适了
[43:31.240 --> 43:37.960] 对然后这也是后来我有一段时间
[43:37.960 --> 43:39.400] 我抛弃了app这个概念
[43:39.400 --> 43:41.000] 我可能会选择按照
[43:41.000 --> 43:43.880] 就如果拿jungle举例子的话
[43:43.880 --> 43:45.960] 就按照mtv的来分
[43:45.960 --> 43:50.920] 对就是这样来分之后
[43:50.920 --> 43:52.760] 你其实会有层次
[43:52.760 --> 43:55.560] 对mtv其实它会有一个依赖的层次
[43:55.560 --> 43:58.040] 对然后往下来引用
[43:58.040 --> 44:02.440] 对但是缺点就是它不就不带这些app这种热插拔了
[44:02.440 --> 44:05.960] 对就比如说我们公司有好几个站点
[44:05.960 --> 44:09.640] 对我没法把那个app直接拔下来插到这边了
[44:09.640 --> 44:11.640] 其实最关键的就是
[44:11.640 --> 44:13.960] 往往我们在做调整的时候
[44:13.960 --> 44:16.040] 或者代码或加新的feature的时候
[44:16.040 --> 44:17.240] 我们改的是一条线对吧
[44:17.240 --> 44:21.800] 就是从template到view到model这条线
[44:21.800 --> 44:24.680] 那这条线最好是在一个package里面
[44:24.680 --> 44:26.280] 这样的话你改起来就
[44:26.280 --> 44:28.280] 对比如说我们现在的逻辑
[44:28.280 --> 44:31.080] 你在m里面你有十几个文件
[44:31.080 --> 44:33.560] 你每次都要下拉一下左侧那个菜单
[44:33.560 --> 44:35.080] 你找到你对应要改的文件
[44:35.080 --> 44:37.240] 然后改完m之后你去改view
[44:37.240 --> 44:39.080] view里面也有十几个文件
[44:39.080 --> 44:40.920] 你去把它里面下拉
[44:40.920 --> 44:42.920] 找到你对应的代码你去改
[44:42.920 --> 44:44.920] 这样其实是不太
[44:44.920 --> 44:46.920] 就写起来其实不太爽
[44:46.920 --> 44:48.920] 是
[44:48.920 --> 44:50.920] 嗯
[44:50.920 --> 44:52.920] 可以理解
[44:52.920 --> 44:54.920] 前端好像不光前端
[44:54.920 --> 44:56.920] 现在好像很多框架都是这么分层的
[44:56.920 --> 44:58.920] 但比如说其实现在这种
[44:58.920 --> 45:00.920] 这个能说是jungle开创的吗
[45:00.920 --> 45:02.920] 呃不算jungle开创的吧
[45:02.920 --> 45:04.920] 不太清楚
[45:04.920 --> 45:06.920] 呃
[45:06.920 --> 45:08.920] Spring好像也有这种概念吧
[45:08.920 --> 45:10.920] 就一个应用一个应用的
[45:10.920 --> 45:12.920] bundle
[45:12.920 --> 45:14.920] 呃
[45:14.920 --> 45:16.920] 对前端的那个
[45:16.920 --> 45:18.920] 其实前端比如说现在很多组件的这种概念
[45:18.920 --> 45:20.920] 其实我是觉得有点类似的
[45:20.920 --> 45:22.920] 就是他会把这种
[45:22.920 --> 45:24.920] 一套强相关的逻辑
[45:24.920 --> 45:26.920] 完全封装到一个组件里面
[45:26.920 --> 45:28.920] 这样的话它的附庸性
[45:28.920 --> 45:30.920] 以及它的可维护性会更好
[45:32.920 --> 45:34.920] 嗯组件就是component
[45:34.920 --> 45:36.920] 对component
[45:36.920 --> 45:38.920] 是jungle
[45:38.920 --> 45:40.920] 我理解
[45:42.920 --> 45:44.920] 另外
[45:44.920 --> 45:46.920] 另外一点就是我们还聊jungle的话
[45:46.920 --> 45:48.920] 其实jungle有一个特别好的
[45:48.920 --> 45:50.920] 点在于什么呢
[45:50.920 --> 45:52.920] 就是比如说我们给新手推荐jungle的话
[45:52.920 --> 45:54.920] jungle的资料会非常丰富
[45:54.920 --> 45:56.920] 就虽然在中文
[45:56.920 --> 45:58.920] 圈里他没有那么丰富
[45:58.920 --> 46:00.920] 但是在这个英文的世界里面
[46:00.920 --> 46:02.920] 或者如果你去看
[46:02.920 --> 46:04.920] 那个youtube上的视频类的东西的话
[46:04.920 --> 46:06.920] 其实jungle是非常多的
[46:06.920 --> 46:08.920] 包括
[46:08.920 --> 46:10.920] 对包括jungle他每因为他有个基金会
[46:10.920 --> 46:12.920] 他每年都会去
[46:12.920 --> 46:14.920] 组织这个大会
[46:14.920 --> 46:16.920] 类似于PIcon这样的大会
[46:16.920 --> 46:18.920] 那其实这是一个
[46:18.920 --> 46:22.920] 你可以理解是一个特别成熟的社区
[46:22.920 --> 46:24.920] 所以在这个环境下
[46:24.920 --> 46:26.920] 其实你会更有归属感
[46:26.920 --> 46:28.920] 是的
[46:28.920 --> 46:30.920] 比如你找了一个小的框架
[46:30.920 --> 46:32.920] 我们拿这个bottle来说
[46:32.920 --> 46:34.920] 你去找小框架
[46:34.920 --> 46:36.920] 那用bottle的人基本上都是
[46:36.920 --> 46:38.920] 比较高阶的人
[46:38.920 --> 46:40.920] 其实他其实
[46:40.920 --> 46:42.920] 很少说我要去归属到这个
[46:42.920 --> 46:44.920] 这个社区里面
[46:44.920 --> 46:46.920] 因为他选择用bottle就是因为
[46:46.920 --> 46:48.920] 这个东西足够小我可以有足够的空间
[46:48.920 --> 46:50.920] 让我自己按照我的想法去搞什么东西
[46:50.920 --> 46:52.920] 对
[46:52.920 --> 46:54.920] 我觉得选择一个框架
[46:54.920 --> 46:56.920] 包括语言就是社区是很重要的吧
[46:56.920 --> 46:58.920] 就是社区和生态
[46:58.920 --> 47:00.920] 因为这个东西决定了
[47:00.920 --> 47:02.920] 你遇到问题的时候能获得多少帮助
[47:02.920 --> 47:04.920] 所以还是挺重要的
[47:04.920 --> 47:08.920] 而且Jungle在国内应该也算是资源最多的框架了
[47:08.920 --> 47:10.920] 我觉得应该算吧
[47:10.920 --> 47:12.920] 像胡杨老师写了这么多书对吧
[47:12.920 --> 47:14.920] 只有他和Flask比较突出
[47:14.920 --> 47:18.920] 然后Jungle的中文资料
[47:18.920 --> 47:22.920] 就是中文资料里Jungle应该也算比较多的
[47:22.920 --> 47:24.920] 对比较多
[47:24.920 --> 47:26.920] 但是其实你浏览发现
[47:26.920 --> 47:28.920] 就因为我后面的一段时间
[47:28.920 --> 47:30.920] 因为我其实写博客会比较早
[47:30.920 --> 47:32.920] 包括写Jungle写Python比较早
[47:32.920 --> 47:34.920] 后面的一段时间
[47:34.920 --> 47:36.920] 我其实不太写一些这种
[47:36.920 --> 47:38.920] 网上都有的这种文章
[47:38.920 --> 47:40.920] 并且我觉得
[47:40.920 --> 47:42.920] 大家都是在重复你写的东西
[47:42.920 --> 47:44.920] 就特别没有意思
[47:44.920 --> 47:46.920] 所以这是也是一个问题
[47:46.920 --> 47:48.920] 就是你发现这种低水平
[47:48.920 --> 47:50.920] 也不能说低水平
[47:50.920 --> 47:52.920] 就是比较浅显的东西特别多
[47:52.920 --> 47:54.920] 所以你就去写书了
[47:54.920 --> 47:56.920] 对所以
[47:56.920 --> 47:58.920] 对就是我还是
[47:58.920 --> 48:00.920] 因为我最近几年
[48:00.920 --> 48:02.920] 其实想做的事情
[48:02.920 --> 48:06.920] 就是把一个东西写的足够的系统
[48:06.920 --> 48:08.920] 这样的话它是一个立体的
[48:08.920 --> 48:10.920] 不然的话你写一篇文章
[48:10.920 --> 48:12.920] 每篇文章都是一个独立的点
[48:12.920 --> 48:14.920] 这东西
[48:14.920 --> 48:16.920] 他其实第一天看到你的文章
[48:16.920 --> 48:18.920] 第二天看到别人的文章
[48:18.920 --> 48:20.920] 跟你的文章可能稍微有一点差异
[48:20.920 --> 48:22.920] 但是他的信息量没有那么多
[48:22.920 --> 48:24.920] 他对于Jungle的了解
[48:24.920 --> 48:26.920] 或对于某个技术了解
[48:26.920 --> 48:28.920] 他不够立体
[48:28.920 --> 48:30.920] 我觉得写书的问题
[48:30.920 --> 48:32.920] 我们可以就是后面再聊
[48:32.920 --> 48:34.920] 然后这里其实我有个问题
[48:34.920 --> 48:36.920] 就是因为我发现有一些
[48:36.920 --> 48:40.920] 比较新的像Python的外部框架
[48:40.920 --> 48:44.920] 包括我们之前介绍过的Ubicorn
[48:44.920 --> 48:48.920] 它好像采用的那种接口
[48:48.920 --> 48:50.920] 都是Flask式的那种
[48:50.920 --> 48:52.920] 就是非常像Flask
[48:52.920 --> 48:54.920] 然后不知道你们怎么看这个问题
[48:54.920 --> 48:56.920] 我就等等我纠正一下
[48:56.920 --> 48:58.920] Ubicorn不是一个框架
[48:58.920 --> 49:00.920] 它是一个server
[49:00.920 --> 49:02.920] 类似UViskey只不过它是ASGI的server
[49:02.920 --> 49:04.920] 那是那个
[49:04.920 --> 49:06.920] 所以那个框架是叫什么
[49:06.920 --> 49:08.920] Starlet是吧
[49:08.920 --> 49:10.920] Sonic吗
[49:10.920 --> 49:12.920] 也包括Sonic吧
[49:12.920 --> 49:14.920] 他们就都很像Flask
[49:14.920 --> 49:18.920] 所以是不是就是说Flask的接口
[49:18.920 --> 49:22.920] 更新手友好一点
[49:22.920 --> 49:26.920] 我觉得像Django很难吧
[49:26.920 --> 49:28.920] 工作量巨大
[49:28.920 --> 49:30.920] 对对对
[49:30.920 --> 49:32.920] 这个是个特别重要的点
[49:32.920 --> 49:34.920] 没看到哪个框架一上来说
[49:34.920 --> 49:36.920] 我是一个Django-like
[49:36.920 --> 49:38.920] 然后和Django做对比
[49:38.920 --> 49:40.920] 对大家都是说我是一个Flask-like
[49:40.920 --> 49:42.920] 然后我的轻量级
[49:42.920 --> 49:44.920] 我的性能是什么样的
[49:44.920 --> 49:46.920] 对对对
[49:46.920 --> 49:50.920] 我觉得Flask-like最重要的一个特征
[49:50.920 --> 49:54.920] 他们会把那个Router和View写在一起
[49:54.920 --> 49:56.920] 就是用一个Decorator那样来写
[49:56.920 --> 49:58.920] 那浑然老师你怎么看这些轻量化的框架
[49:58.920 --> 50:00.920] 觉得就是Rubbish是吗
[50:00.920 --> 50:04.920] 不太懂它适应的场景
[50:04.920 --> 50:08.920] 因为其实我之前有一次经历就是
[50:08.920 --> 50:14.920] 我想要帮一个朋友去用Django搞一个特别简单的接口
[50:14.920 --> 50:16.920] 我发现我还要去把这个项目创建出来
[50:16.920 --> 50:18.920] 然后去配置各种各样的东西
[50:18.920 --> 50:22.920] 这个接口可能就需要十几行代码就完事了
[50:22.920 --> 50:24.920] 那这种情况下其实你用Flask反而会更快
[50:24.920 --> 50:28.920] 对它就是它没有模板代码
[50:28.920 --> 50:30.920] 就是一个派文件就可以了
[50:30.920 --> 50:32.920] 对当你在做一个特别薄的事的时候
[50:32.920 --> 50:34.920] 就比如你只需要一层
[50:34.920 --> 50:36.920] 就把这个东西搞定的时候
[50:36.920 --> 50:38.920] 其实用这种轻量级的框架会非常爽
[50:38.920 --> 50:42.920] 就是因为它本身的这种结构也非常的灵活
[50:42.920 --> 50:44.920] 但是当你这个层数变多之后
[50:44.920 --> 50:46.920] 如果你自己写还好
[50:46.920 --> 50:48.920] 或者说团队写的话
[50:48.920 --> 50:50.920] 你就得考虑它的可维护性
[50:50.920 --> 50:52.920] 以及它的这个模式是不是通用
[50:52.920 --> 50:58.920] 对就是Django比较适合写一些有一定复杂度的业务吧
[50:58.920 --> 51:00.920] 可以这样说
[51:00.920 --> 51:02.920] 对对
[51:02.920 --> 51:05.920] 它也比较适合这个团队协作
[51:05.920 --> 51:07.920] 这个确实挺重要的一点
[51:07.920 --> 51:08.920] 就是复杂度高的时候
[51:08.920 --> 51:10.920] 其实Django能减少一些复杂度
[51:10.920 --> 51:12.920] 因为大家是有共识的嘛
[51:12.920 --> 51:14.920] 在框架上
[51:14.920 --> 51:16.920] 这个共识就是Django的一些标准
[51:16.920 --> 51:18.920] 因为它东西也足够多嘛
[51:18.920 --> 51:22.920] 它这个框架本身涵盖的所有的web的组件也足够多
[51:22.920 --> 51:24.920] 其实当你用的越多
[51:24.920 --> 51:26.920] 你就会越轻松
[51:26.920 --> 51:28.920] 对吧你用的越少你就会越累
[51:28.920 --> 51:30.920] 因为这个东西框机就全都拍给你了
[51:30.920 --> 51:32.920] 你发现你只需要用到其中的一点
[51:32.920 --> 51:34.920] 你就觉得特别不爽
[51:34.920 --> 51:36.920] 确实
[51:36.920 --> 51:39.920] 如果你只写一个几行的代码
[51:39.920 --> 51:41.920] 先起一个protect
[51:41.920 --> 51:43.920] 再起一个app
[51:43.920 --> 51:45.920] 然后再配置一下
[51:45.920 --> 51:47.920] 所以我问一下
[51:47.920 --> 51:49.920] 就是比如说
[51:49.920 --> 51:51.920] 那个
[51:51.920 --> 51:53.920] 用Django写blog的两位同学
[51:53.920 --> 51:55.920] 你们的blog是什么版本
[51:55.920 --> 51:57.920] Django是什么版本
[51:57.920 --> 51:59.920] 我是一开始是1.4
[51:59.920 --> 52:01.920] 后来升级成1.8就没再升级了
[52:01.920 --> 52:03.920] 然后我其实应该再升级一下的
[52:03.920 --> 52:07.920] 你是1.4直接升到1.8了吗
[52:07.920 --> 52:11.920] 我忘了是1.6升到1.8还是1.4升到1.8
[52:11.920 --> 52:13.920] 反正升级的过程还蛮顺利的
[52:13.920 --> 52:15.920] 比我想的要顺利一些
[52:17.920 --> 52:19.920] 1.6吧
[52:19.920 --> 52:21.920] 因为1.4到1.6是个大跨度
[52:21.920 --> 52:23.920] 我印象中
[52:23.920 --> 52:27.920] 对他要结构上调整
[52:27.920 --> 52:29.920] 他那个官网上有一个升级的
[52:29.920 --> 52:31.920] 升级的帮助
[52:31.920 --> 52:34.920] 就是说你升级不能跨版本
[52:34.920 --> 52:35.920] 你要比如说1.3升到1.8
[52:35.920 --> 52:38.920] 你要升到1.4再升到1.5
[52:38.920 --> 52:39.920] 这样来升
[52:39.920 --> 52:41.920] 反正我当然就照那个
[52:41.920 --> 52:43.920] 对我觉得django这方面也是非常人性化的
[52:43.920 --> 52:45.920] 都给你写的很清楚
[52:45.920 --> 52:47.920] 那个谁呢赖心汤呢
[52:47.920 --> 52:49.920] 我是wordpress写的
[52:49.920 --> 52:51.920] 但是我django我之前
[52:51.920 --> 52:53.920] 第一次写的时候是1.8
[52:53.920 --> 52:54.920] 但是我没升级过
[52:54.920 --> 52:55.920] 我后来是
[52:55.920 --> 52:58.920] 后来一个项目就开始用2.0了
[52:58.920 --> 53:02.920] 然后2.0好像升到最新的
[53:02.920 --> 53:03.920] 现在应该是2.2对吧
[53:03.920 --> 53:07.920] 那我应该经历过一次2.0到2.1的升级
[53:07.920 --> 53:10.920] 然后我现在有一个side project是用2.2写的
[53:10.920 --> 53:11.920] 就clog
[53:11.920 --> 53:15.920] 所以最新版本是2点几现在2.2
[53:15.920 --> 53:19.920] 2.2最新版本是2.2
[53:22.920 --> 53:25.920] 2点多就不支持python2了是吗
[53:25.920 --> 53:27.920] 就是2.x都不支持
[53:27.920 --> 53:31.920] 对2.02.0开始就不支持python2了
[53:31.920 --> 53:36.920] 2.0到2.1好像我遇到了一个
[53:36.920 --> 53:37.920] 不兼容的
[53:37.920 --> 53:41.920] 但是当时是因为我们django没锁死版本
[53:41.920 --> 53:42.920] 就是我非常信赖django
[53:42.920 --> 53:44.920] 后来他就一次部署
[53:44.920 --> 53:45.920] 他就把2.0升到2.1了
[53:45.920 --> 53:48.920] 然后发现了一个小地方是不兼容的
[53:48.920 --> 53:50.920] 但是我现在想不起来了
[53:51.920 --> 53:53.920] 其实django这块我觉得
[53:53.920 --> 53:55.920] 就我不了解其他的
[53:55.920 --> 53:57.920] 就没有研究过其他的这种版本管理的方式
[53:57.920 --> 53:59.920] 就是比如发版
[53:59.920 --> 54:03.920] 比如我们用1.3 1.4 1.5 1.6这样升级上去
[54:03.920 --> 54:07.920] 你们对于版本的变化有个预期吗
[54:07.920 --> 54:09.920] 比如说从1.3到1.4
[54:09.920 --> 54:10.920] 他可能会有什么问题
[54:10.920 --> 54:12.920] 看那个release notes
[54:12.920 --> 54:15.920] 对我是没有什么surprise的
[54:15.920 --> 54:16.920] 我看release notes
[54:16.920 --> 54:18.920] 我把那个breaking change如果涉及到我的
[54:18.920 --> 54:19.920] 我改一下
[54:19.920 --> 54:21.920] 然后升过去基本上都可以的
[54:21.920 --> 54:24.920] 其实他会就是django这个惯例
[54:24.920 --> 54:28.920] 就是会隔一个版本去淘汰一些这种feature
[54:28.920 --> 54:29.920] 就是老的feature
[54:29.920 --> 54:30.920] 但是他对
[54:30.920 --> 54:32.920] 但是你如果你项目里面遇到了
[54:32.920 --> 54:35.920] 比如说一开始有一个protection warning
[54:35.920 --> 54:37.920] 这个单词是这么读吗
[54:37.920 --> 54:39.920] 就是如果有这种提示的话
[54:39.920 --> 54:41.920] 你在跨版本升级的时候就要注意
[54:41.920 --> 54:44.920] 因为这个可能已经被淘汰了
[54:44.920 --> 54:47.920] 对所以这就是django为什么就推荐
[54:47.920 --> 54:50.920] 我们去一个一个版本升级吗
[54:50.920 --> 54:51.920] 这样你升级到一个版本
[54:51.920 --> 54:52.920] 你跑一段时间
[54:52.920 --> 54:57.920] 你要把所有的过期的警告全都给搞掉
[54:57.920 --> 54:59.920] 然后你再升下一个版本
[54:59.920 --> 55:02.920] 然后你再去搞那些过期警告
[55:03.920 --> 55:06.920] 对就比如说他django其实从2.0开始
[55:06.920 --> 55:09.920] 他就之前比如1.1 1.2 1.3
[55:09.920 --> 55:11.920] 这种都是小版本后面的对吧
[55:11.920 --> 55:15.920] 1.3 1.3.x的版本肯定是完全兼容的对吧
[55:15.920 --> 55:18.920] 然后等他到2.0之后
[55:18.920 --> 55:21.920] 他的版本规则就会变成2.0 2.1 2.2
[55:21.920 --> 55:24.920] 然后3.0 3.1 3.2这样的规则
[55:24.920 --> 55:26.920] 那这种情况下你在2.0里面
[55:26.920 --> 55:31.920] 所有的没有这个即将就被warning的这种feature
[55:31.920 --> 55:33.920] 在2.0里面是完全兼容的
[55:34.920 --> 55:38.920] 但是2.0的版本2.0这个版本的一些feature
[55:38.920 --> 55:41.920] 到3里面就是可能会被淘汰
[55:43.920 --> 55:45.920] 对他其实有一个文档在讲
[55:45.920 --> 55:47.920] 他的这个版本的版本管理方式
[55:47.920 --> 55:51.920] 其实我觉得这是对于在用django或者任何框架吧
[55:51.920 --> 55:55.920] 在用这个框架的人会有一个特别明明确的预期
[55:55.920 --> 55:57.920] 就是你现在版本是什么
[55:57.920 --> 56:00.920] 然后如果你想升到这个新的版本的话
[56:00.920 --> 56:02.920] 对常规来说我们会去看release对吧
[56:02.920 --> 56:05.920] 但是可以形成一个共识的
[56:05.920 --> 56:07.920] 就是如果你要做跨版本升级
[56:07.920 --> 56:10.920] 那他一定会有一些feature去做会被淘汰掉
[56:11.920 --> 56:13.920] 对就是django的这个版本升级
[56:13.920 --> 56:14.920] 我觉得是比较做的比较好的
[56:14.920 --> 56:16.920] 因为一个很有意思的地方就是
[56:16.920 --> 56:18.920] 那个django的原代码你点进去
[56:18.920 --> 56:20.920] 看他那个top1的contributor
[56:20.920 --> 56:21.920] Tim Graham
[56:21.920 --> 56:23.920] 然后你再看到他的博客
[56:23.920 --> 56:25.920] 他的博客上就一句话说
[56:25.920 --> 56:28.920] 他提供对公司的python2到python3的升级支持
[56:28.920 --> 56:31.920] 以及django的跨版本升级支持
[56:31.920 --> 56:32.920] 就是他个人提供的一个服务
[56:32.920 --> 56:34.920] 所以django这方面做的肯定特别好
[56:36.920 --> 56:38.920] 做的很好为什么还要他支持
[56:39.920 --> 56:40.920] 因为他本身就是一个
[56:41.920 --> 56:42.920] 就是这方面的专家
[56:42.920 --> 56:44.920] 我印象中django还有一点就是
[56:44.920 --> 56:46.920] 对这种不兼容变更
[56:46.920 --> 56:50.920] 其实就是他会在文档里注明说
[56:50.920 --> 56:51.920] 一旦他们有废弃计划
[56:51.920 --> 56:53.920] 就会在文档里注明说
[56:53.920 --> 56:55.920] 这个fetch什么时候会被下载
[56:55.920 --> 56:56.920] 什么版本会被下载
[56:56.920 --> 56:57.920] 所以说不推荐使用
[56:57.920 --> 57:00.920] 建议你去使用fetch这种
[57:00.920 --> 57:04.920] 对就是即使你比如说你现在已经是
[57:04.920 --> 57:06.920] 我假设现在是1.8了
[57:06.920 --> 57:07.920] 你还在看1.6的文档
[57:07.920 --> 57:09.920] 但是你也会看到说上面提示说
[57:09.920 --> 57:11.920] 这个东西你最好不要用
[57:11.920 --> 57:12.920] 对不建议你使用
[57:12.920 --> 57:13.920] 你应该怎么用这种
[57:13.920 --> 57:15.920] 对对对这个很好
[57:15.920 --> 57:16.920] 这个非常好
[57:18.920 --> 57:20.920] 对所以这个点其实我们可以聊到
[57:20.920 --> 57:22.920] 刚才那个一些新的框架上
[57:22.920 --> 57:24.920] 比如说你用这个asyncio
[57:24.920 --> 57:25.920] 不是async
[57:25.920 --> 57:27.920] 有一个什么框架
[57:27.920 --> 57:28.920] Sonic还有什么
[57:28.920 --> 57:29.920] Starlight
[57:30.920 --> 57:31.920] 这种新的框架
[57:31.920 --> 57:34.920] 他在没有一个成熟的这种
[57:34.920 --> 57:35.920] 比如说feature
[57:35.920 --> 57:37.920] 迭代演进的过程的场景下
[57:37.920 --> 57:39.920] 其实你很容易就遇到一个
[57:39.920 --> 57:41.920] 你也不知道为什么就会出现的坑
[57:42.920 --> 57:44.920] 就是你完全不可预期
[57:44.920 --> 57:46.920] 他下一个版本会出现什么样的变更
[57:46.920 --> 57:47.920] 什么样调整
[57:47.920 --> 57:49.920] 对就是你没发正式版之前
[57:49.920 --> 57:51.920] 真的会有时候大版本不兼容升级
[57:51.920 --> 57:52.920] 你就很尴尬
[57:53.920 --> 57:55.920] 对所以好处是像Starlight
[57:55.920 --> 57:58.920] 他版本他那个代码特别特别小
[57:58.920 --> 57:59.920] 所以我用这个东西的时候
[57:59.920 --> 58:01.920] 我基本上不去看文档
[58:01.920 --> 58:04.920] 我直接跳进去看原代码的那个
[58:04.920 --> 58:06.920] 寒竹声明跟视线
[58:06.920 --> 58:07.920] 真的是非常小
[58:07.920 --> 58:09.920] 他做的事情也很简单
[58:09.920 --> 58:11.920] 所以其实这里面可以对比一下
[58:11.920 --> 58:13.920] 比如说同样是一部框架
[58:13.920 --> 58:15.920] Sonic或者Tornado
[58:15.920 --> 58:16.920] 他这种这种逻辑
[58:16.920 --> 58:20.920] 其实Tornado会更加的成熟一点
[58:21.920 --> 58:22.920] 这个怎么讲
[58:23.920 --> 58:25.920] 就是他的这个
[58:26.920 --> 58:28.920] 我们说构建的时间足够长
[58:28.920 --> 58:31.920] 然后被踩的坑足够多
[58:31.920 --> 58:33.920] 虽然他也一样的很简陋
[58:33.920 --> 58:35.920] 但是他至少是成熟的
[58:35.920 --> 58:38.920] 而不是我开发一个就是某个开发者
[58:38.920 --> 58:41.920] 我去开发一个特别先进的feature
[58:41.920 --> 58:43.920] 他性能秒杀任何东西
[58:43.920 --> 58:46.920] 但是这个东西其实只是一个人单方面的
[58:46.920 --> 58:48.920] 或者说几个人单方面的
[58:48.920 --> 58:50.920] 对这个框架的一个评测
[58:50.920 --> 58:52.920] 他没有在一个生产的环境下
[58:52.920 --> 58:54.920] 被大范围的验证过
[58:54.920 --> 58:56.920] 对对对所以这个就是说
[58:56.920 --> 58:57.920] 为什么声太很重要
[58:57.920 --> 59:00.920] 一个东西用的人多踩的坑太多
[59:00.920 --> 59:01.920] 对就这样
[59:01.920 --> 59:05.920] Tornado给我最大的感觉就是
[59:05.920 --> 59:07.920] 没有太大变化
[59:07.920 --> 59:12.920] 虽然一直在4.0 4.5 5.0这种声
[59:12.920 --> 59:14.920] 但是你会觉得
[59:14.920 --> 59:18.920] Tornado其实是有一些变化的
[59:18.920 --> 59:20.920] 就是他一开始
[59:20.920 --> 59:22.920] 比如我忘了那个版本
[59:22.920 --> 59:24.920] 就一开始他没有那种
[59:24.920 --> 59:27.920] 那个叫coroutine的装饰器
[59:27.920 --> 59:29.920] 那你要写的时候
[59:29.920 --> 59:30.920] 你要手动的要的对吧
[59:30.920 --> 59:32.920] 特别的就写起来会
[59:32.920 --> 59:35.920] 对对对那种方式就特别繁琐
[59:35.920 --> 59:37.920] 对但是你有了这种coroutine装饰器
[59:37.920 --> 59:39.920] 就会好很多
[59:39.920 --> 59:43.920] 好像是有的对我也写过一段时间
[59:43.920 --> 59:48.920] 不过说回来那个好像应该
[59:48.920 --> 59:51.920] 就是自从python引入了
[59:51.920 --> 59:53.920] 语言层面支持的async之后
[59:53.920 --> 59:55.920] Tornado应该也是
[59:55.920 --> 59:57.920] 把他以前用eo的实现那些东西
[59:57.920 --> 01:00:01.920] 全都用就原生的async来重写了一遍吧
[01:00:01.920 --> 01:00:05.920] 对他是有一个
[01:00:05.920 --> 01:00:06.920] 有一个实现
[01:00:06.920 --> 01:00:08.920] 现在应该是默认实现
[01:00:08.920 --> 01:00:10.920] 默认的实现是用
[01:00:10.920 --> 01:00:12.920] 在3里面默认的实现是用async
[01:00:12.920 --> 01:00:14.920] 因为他有几个
[01:00:14.920 --> 01:00:18.920] 我可以我截个图发到这个文档上
[01:00:18.920 --> 01:00:21.920] 其实他有不同平台的实现
[01:00:24.920 --> 01:00:27.920] 就说他相当于你如果是用python2.7的话
[01:00:27.920 --> 01:00:30.920] 他实现就还是原来那套用eo的
[01:00:30.920 --> 01:00:32.920] 实现的东西
[01:00:32.920 --> 01:00:34.920] 成熟的框架会做的特别好
[01:00:34.920 --> 01:00:36.920] 就包括我们说的
[01:00:36.920 --> 01:00:38.920] jango的编程的原则里面的这种一致性
[01:00:38.920 --> 01:00:41.920] 他会对于不同的
[01:00:41.920 --> 01:00:44.920] 后端会做一个这种
[01:00:44.920 --> 01:00:46.920] 提供一个一致的接口
[01:00:46.920 --> 01:00:48.920] 然后把后端的差异性给包起来
[01:00:48.920 --> 01:00:52.920] 这其实是在整体的软件设计里面
[01:00:52.920 --> 01:00:54.920] 是一个非常重要的概念
[01:00:54.920 --> 01:00:56.920] 但是其实我一直有一个疑问
[01:00:56.920 --> 01:00:59.920] 我觉得你比如说你用jango
[01:00:59.920 --> 01:01:01.920] 但我肯定只用一种数据库
[01:01:01.920 --> 01:01:03.920] 比如说我要么选择mysql
[01:01:03.920 --> 01:01:04.920] 要么选择postgres
[01:01:04.920 --> 01:01:06.920] 这样对jango来说
[01:01:06.920 --> 01:01:07.920] 他可以扩大自己的用户群
[01:01:07.920 --> 01:01:10.920] 但是对于我一个mysql用户来说
[01:01:10.920 --> 01:01:14.920] 我没法用到只存在于mysql的特性
[01:01:14.920 --> 01:01:17.920] 也没办法用到只存在于postgres的特性
[01:01:17.920 --> 01:01:20.920] 而且我发现现在像sqlacademy这种
[01:01:20.920 --> 01:01:21.920] 其他的OIM
[01:01:21.920 --> 01:01:24.920] 他们都是去兼容很多数据库的
[01:01:24.920 --> 01:01:25.920] 为什么要这样做
[01:01:25.920 --> 01:01:28.920] 为什么不单独做一个针对一种数据库
[01:01:28.920 --> 01:01:31.920] 然后发挥下所有feature的这么一个OIM
[01:01:31.920 --> 01:01:34.920] 对是个好问题
[01:01:34.920 --> 01:01:36.920] 你OIM需要什么特殊的feature
[01:01:36.920 --> 01:01:38.920] 你能举个例子吗
[01:01:38.920 --> 01:01:44.920] 比如说那个postgres支持一个json字单
[01:01:44.920 --> 01:01:47.920] 就是你可以把json存到一个数据库的column里面
[01:01:47.920 --> 01:01:48.920] 但是mysql不支持
[01:01:48.920 --> 01:01:51.920] mysql5.7也支持json
[01:01:51.920 --> 01:01:53.920] 好吧这个我不知道
[01:01:53.920 --> 01:01:54.920] 但是如果
[01:01:54.920 --> 01:01:57.920] 这其实是另外的问题
[01:01:57.920 --> 01:01:58.920] 这其实是另外的问题
[01:01:58.920 --> 01:02:01.920] 但是你如果用5.6的
[01:02:01.920 --> 01:02:06.920] jungle的OIM好像里面没有这种jsonfile的吧
[01:02:06.920 --> 01:02:10.920] 就是我之前用jungle的话
[01:02:10.920 --> 01:02:12.920] 你如果要在数据库里面存json
[01:02:12.920 --> 01:02:14.920] 你要用一个第三方的包jsonfile的
[01:02:14.920 --> 01:02:16.920] 然后这个包去包装了
[01:02:16.920 --> 01:02:21.920] 对jungle对mysql对postgres的封装
[01:02:21.920 --> 01:02:25.920] 就是还是要通过插件来实现是吧
[01:02:25.920 --> 01:02:26.920] 是的
[01:02:26.920 --> 01:02:29.920] 我觉得用插件也还好吧
[01:02:29.920 --> 01:02:30.920] 嗯
[01:02:30.920 --> 01:02:33.920] 也不知道现在jungle有没有这种jsonfile的
[01:02:33.920 --> 01:02:35.920] 有可能也可以有吧
[01:02:35.920 --> 01:02:38.920] 最近的feature我没有跟啊
[01:02:38.920 --> 01:02:42.920] 但是我说到这个概念会特别好
[01:02:42.920 --> 01:02:43.920] 这个问题会特别好
[01:02:43.920 --> 01:02:47.920] 就是为什么不是一个针对于某一个
[01:02:47.920 --> 01:02:51.920] 比如某一个基础组件的这种完全覆盖的这样一个功能
[01:02:51.920 --> 01:02:54.920] 这其实就是涉及到它的通用性嘛
[01:02:54.920 --> 01:02:59.920] 它通用性里面其实就会让你损失了你的这些特性
[01:02:59.920 --> 01:03:01.920] 对但是其实对于jungle来说
[01:03:01.920 --> 01:03:03.920] 比如我发的那个截图
[01:03:03.920 --> 01:03:06.920] 它对于每一种backend的实现
[01:03:06.920 --> 01:03:07.920] 它会有一个feature
[01:03:07.920 --> 01:03:09.920] feature的这样一个文件
[01:03:09.920 --> 01:03:11.920] 这个文件里面就描述了
[01:03:11.920 --> 01:03:12.920] 嗯
[01:03:12.920 --> 01:03:15.920] 这个feature在这个数据库上能不能支持
[01:03:15.920 --> 01:03:18.920] 所以其实它在一定程度上是做了一个
[01:03:18.920 --> 01:03:21.920] 你可以理解比较好的这种
[01:03:21.920 --> 01:03:24.920] 对于这个feature特性的一个发挥
[01:03:24.920 --> 01:03:30.920] 就是它有针对某一种数据库开启的那种feature
[01:03:30.920 --> 01:03:31.920] 对吧
[01:03:31.920 --> 01:03:32.920] 对
[01:03:32.920 --> 01:03:34.920] 我正在看他的文档
[01:03:34.920 --> 01:03:37.920] 他就是有那个
[01:03:37.920 --> 01:03:41.920] 有一个页面就是叫那个postgres
[01:03:41.920 --> 01:03:43.920] postgreSQL
[01:03:43.920 --> 01:03:45.920] specific model fields
[01:03:45.920 --> 01:03:46.920] 然后就有json field
[01:03:46.920 --> 01:03:49.920] 所以其实信涛说的那个是已经有了的
[01:03:49.920 --> 01:03:53.920] 就是针对某一个数据库的特性
[01:03:53.920 --> 01:03:54.920] 嗯那我懂了
[01:03:54.920 --> 01:03:56.920] 可能就是我之前只用mySQL
[01:03:56.920 --> 01:04:00.920] 所以就只能通过第三方的插件来实现
[01:04:00.920 --> 01:04:02.920] 嗯这些其实在国内的话
[01:04:02.920 --> 01:04:04.920] 大家其实mySQL比较多嘛
[01:04:04.920 --> 01:04:07.920] 但是jungle其实推荐的是用postgreSQL来做
[01:04:07.920 --> 01:04:08.920] 对
[01:04:08.920 --> 01:04:09.920] 对
[01:04:09.920 --> 01:04:11.920] 我也更喜欢postgreSQL强一点
[01:04:11.920 --> 01:04:13.920] 但你习惯了mySQL之后
[01:04:13.920 --> 01:04:15.920] postgreSQL用起来有点怪怪的
[01:04:15.920 --> 01:04:17.920] 不知道你们有没有这种感觉
[01:04:17.920 --> 01:04:22.920] 你是指的是命令行的非SQL的那些命令
[01:04:22.920 --> 01:04:27.920] 他是个全局的这种命令行操作的方式
[01:04:27.920 --> 01:04:30.920] 我觉得就是CLI会有些区别嘛
[01:04:30.920 --> 01:04:33.920] 对对CLI对我最大的影响
[01:04:33.920 --> 01:04:36.920] 其实反而是比如说你真正跑一些查询
[01:04:36.920 --> 01:04:38.920] 其实差别不大
[01:04:38.920 --> 01:04:40.920] 就是你如果想平时查询的话
[01:04:40.920 --> 01:04:43.920] 你可以不用CQL的CLI
[01:04:43.920 --> 01:04:45.920] 用jungle的management shell
[01:04:45.920 --> 01:04:48.920] 让所有东西都在jungle里面查
[01:04:48.920 --> 01:04:49.920] 对对
[01:04:49.920 --> 01:04:52.920] 我以前写jungle的时候就特别喜欢用那个查
[01:04:52.920 --> 01:04:56.920] 但是jungle的objects all是吧
[01:04:56.920 --> 01:04:57.920] 对
[01:04:57.920 --> 01:04:59.920] 然后就会卡2秒
[01:04:59.920 --> 01:05:01.920] jungle shell的问题在于
[01:05:01.920 --> 01:05:03.920] 每次你要写一个新的command
[01:05:03.920 --> 01:05:04.920] 你都要去把它的代码
[01:05:04.920 --> 01:05:06.920] 就找一个模板去拷一遍
[01:05:06.920 --> 01:05:09.920] 我觉得这个是可以再人性化一点的
[01:05:09.920 --> 01:05:12.920] 然后我们可以继续聊jungle的杀手锏
[01:05:12.920 --> 01:05:15.920] 你觉得jungle的杀手锏是什么
[01:05:15.920 --> 01:05:17.920] jungle的杀手锏
[01:05:17.920 --> 01:05:18.920] 哎小鱼
[01:05:18.920 --> 01:05:20.920] 我觉得哎我先说吧
[01:05:20.920 --> 01:05:22.920] 我觉得肯定是jungle的me
[01:05:22.920 --> 01:05:25.920] 我跟很多人聊过嘛
[01:05:25.920 --> 01:05:28.920] 然后大家都觉得就是jungle一句话
[01:05:28.920 --> 01:05:32.920] 然后可以出来一个就是自动对OM管理的后端
[01:05:32.920 --> 01:05:33.920] 然后可以有登录系统
[01:05:33.920 --> 01:05:34.920] 我觉得很神奇
[01:05:34.920 --> 01:05:35.920] 就一句话
[01:05:35.920 --> 01:05:36.920] 对其实这个
[01:05:36.920 --> 01:05:39.920] 比如说我们我们现在这种场景
[01:05:39.920 --> 01:05:43.920] 我们用tornado哪怕就开发一个简单的
[01:05:43.920 --> 01:05:44.920] CLOD的操作
[01:05:44.920 --> 01:05:48.920] 你可以想象一下你需要写多少代码
[01:05:48.920 --> 01:05:49.920] 对吧
[01:05:49.920 --> 01:05:52.920] 你如果你如果不用这种OM的库的话
[01:05:52.920 --> 01:05:54.920] 你要怎么来抽象
[01:05:54.920 --> 01:05:56.920] 你的这个circle的定义
[01:05:56.920 --> 01:05:57.920] 你用OM的库的话
[01:05:57.920 --> 01:05:59.920] 你要怎么去定义你的
[01:05:59.920 --> 01:06:01.920] 比如你用circle alchemy
[01:06:01.920 --> 01:06:03.920] 你定义你的circle alchemy的这种
[01:06:03.920 --> 01:06:06.920] 这种OM的这一层
[01:06:06.920 --> 01:06:07.920] 这个model这一层
[01:06:07.920 --> 01:06:09.920] 然后你要去写对应的这个它的查询
[01:06:09.920 --> 01:06:13.920] 因为circle alchemy的查询还不像jungle那样简单
[01:06:13.920 --> 01:06:16.920] 它其实它有些底层的东西也会暴露给你
[01:06:16.920 --> 01:06:18.920] 那你写完之后
[01:06:18.920 --> 01:06:20.920] 你要去写你的这个view
[01:06:20.920 --> 01:06:23.920] 你要去写你的对应的这个页面的代码
[01:06:23.920 --> 01:06:25.920] 你想一下这套东西下来
[01:06:25.920 --> 01:06:27.920] 其实的功用量是非常大的
[01:06:31.920 --> 01:06:34.920] 对并且它还是不是没有统一的最佳实践
[01:06:34.920 --> 01:06:36.920] 会造成一些困扰
[01:06:36.920 --> 01:06:38.920] 对
[01:06:39.920 --> 01:06:43.920] 就是每个人写的都会不一样
[01:06:44.920 --> 01:06:46.920] 关键是我的mean实在是太方便了
[01:06:46.920 --> 01:06:49.920] 就是你描述一下你想展示什么
[01:06:49.920 --> 01:06:52.920] 对想展示的格式是什么
[01:06:52.920 --> 01:06:55.920] 对然后你就有了一个管理系统
[01:06:57.920 --> 01:07:01.920] 我现在的博客就是直接用jungle我的mean的
[01:07:02.920 --> 01:07:04.920] 对我也是一样的
[01:07:04.920 --> 01:07:09.920] 其实它的之后的这个应该2.0之后的哪个版本忘了
[01:07:10.920 --> 01:07:13.920] 它其实admin是支持了这个mobile端的
[01:07:14.920 --> 01:07:16.920] 这个是一个特别好
[01:07:16.920 --> 01:07:18.920] 就对我来说会特别好
[01:07:18.920 --> 01:07:23.920] 我就可以直接在手机上去做一些博客的东西的管理
[01:07:23.920 --> 01:07:24.920] 就特别方便
[01:07:24.920 --> 01:07:26.920] 你竟然有这种需求
[01:07:26.920 --> 01:07:27.920] 随时随地
[01:07:27.920 --> 01:07:30.920] 而且我觉得jungle的mean的那个模板
[01:07:30.920 --> 01:07:32.920] 就是它的那个UIL组织
[01:07:32.920 --> 01:07:35.920] 还有一些什么分页排序的功能
[01:07:35.920 --> 01:07:38.920] 我觉得比大多数的后台系统做的都很优秀
[01:07:38.920 --> 01:07:40.920] 它这种感觉会让你觉得很成熟
[01:07:40.920 --> 01:07:46.920] 比如说我们现在我去用这个tomato加sql-admin
[01:07:46.920 --> 01:07:48.920] 我去写一个这样的分页逻辑
[01:07:48.920 --> 01:07:49.920] 你就会写的特别原始
[01:07:49.920 --> 01:07:52.920] 就你特别渴望有那样的一个组件
[01:07:52.920 --> 01:07:54.920] 让你用这种纯片向对象
[01:07:54.920 --> 01:07:58.920] 语义化更好的方式去调你的去调去获取你的数据
[01:07:58.920 --> 01:08:01.920] 并且能够比较方便的翻页获取数据
[01:08:01.920 --> 01:08:03.920] 其实很难做到
[01:08:04.920 --> 01:08:07.920] 而且那个的自定义其实也很方便
[01:08:07.920 --> 01:08:09.920] 就是你不喜欢它的order by之类的
[01:08:09.920 --> 01:08:12.920] 其实你可以很容易的就扩展一套自己的规则
[01:08:14.920 --> 01:08:15.920] 对
[01:08:15.920 --> 01:08:19.920] 对而且还支持filter之类的东西
[01:08:19.920 --> 01:08:23.920] 基本上后台系统所需要的东西它都有了
[01:08:23.920 --> 01:08:27.920] 所以它对于这个内容型的管理系统来说
[01:08:27.920 --> 01:08:29.920] 或者这种业务来说
[01:08:29.920 --> 01:08:31.920] 它就是一个极大的一个大杀器
[01:08:31.920 --> 01:08:33.920] 就是特别快
[01:08:33.920 --> 01:08:37.920] 做这种简单的或者做一个比较基础的定制的话
[01:08:37.920 --> 01:08:40.920] 真的可以特别快的帮你完成这个需求
[01:08:40.920 --> 01:08:42.920] 而且就是其实比如说
[01:08:43.920 --> 01:08:45.920] 有的时候你没有特殊的需求的时候
[01:08:45.920 --> 01:08:47.920] 我也倾向于会自己来搞一个的命
[01:08:47.920 --> 01:08:49.920] 就是有有这样个的命
[01:08:49.920 --> 01:08:52.920] 我倾向于我自己就不看数据库了
[01:08:54.920 --> 01:08:55.920] 对因为
[01:08:55.920 --> 01:08:58.920] 因为就是我的
[01:08:58.920 --> 01:09:00.920] 我觉得主要的优势在于
[01:09:00.920 --> 01:09:04.920] 其实你的model的组织和你真实的数据组织
[01:09:04.920 --> 01:09:05.920] 可能是有差异的
[01:09:06.920 --> 01:09:09.920] 对就是可能你会均衡到性能啊
[01:09:09.920 --> 01:09:10.920] 或者是扩展性啊
[01:09:10.920 --> 01:09:11.920] 或者是场景啊
[01:09:11.920 --> 01:09:13.920] 你甚至一个model的数据
[01:09:13.920 --> 01:09:15.920] 你可能会存在很多地方
[01:09:15.920 --> 01:09:20.920] 然后你最后来想办法拼成一个实际上业务的model的数据
[01:09:20.920 --> 01:09:23.920] 以及这些数据可能还会服务于别的model
[01:09:23.920 --> 01:09:24.920] 对
[01:09:24.920 --> 01:09:28.920] 然后你看数据库其实是很麻烦的
[01:09:28.920 --> 01:09:30.920] 因为你可能你要找好几个表
[01:09:30.920 --> 01:09:32.920] 用一个ID各种查询
[01:09:32.920 --> 01:09:33.920] 你终于找到了说
[01:09:33.920 --> 01:09:34.920] 这个数据是我想看的
[01:09:34.920 --> 01:09:37.920] 但是你在jungle上组织好这个规则之后
[01:09:37.920 --> 01:09:39.920] 你可以一眼看到所有的东西
[01:09:40.920 --> 01:09:42.920] 而且还可以点点点来回跳
[01:09:43.920 --> 01:09:44.920] 对这个特别关键
[01:09:44.920 --> 01:09:47.920] 这是他的一个极大的优势
[01:09:47.920 --> 01:09:50.920] 但是其实也也有对应的缺点
[01:09:50.920 --> 01:09:51.920] 就是比如说
[01:09:51.920 --> 01:09:54.920] 尤其是对于不熟的人来说
[01:09:54.920 --> 01:09:58.920] 如果你没有看过这个jungle admin的这些逻辑
[01:09:58.920 --> 01:10:02.920] 因为他的这个第一是他的文档相对少
[01:10:02.920 --> 01:10:05.920] 就虽然我们说jungle文档写的特别好
[01:10:05.920 --> 01:10:07.920] 但是他这块的文档写的真的是很少
[01:10:07.920 --> 01:10:10.920] 就你想做一些定制
[01:10:10.920 --> 01:10:11.920] 或者你想做一些优化工作的时候
[01:10:11.920 --> 01:10:12.920] 没有办法
[01:10:12.920 --> 01:10:15.920] 你只能只能去看他的源码
[01:10:15.920 --> 01:10:17.920] 然后去看他源码里面什么方法
[01:10:17.920 --> 01:10:18.920] 什么方法
[01:10:18.920 --> 01:10:19.920] 你去实现对应的方法
[01:10:19.920 --> 01:10:21.920] 去他对他做一些改造
[01:10:21.920 --> 01:10:25.920] 这个可能是一个一个缺点
[01:10:25.920 --> 01:10:27.920] 你就上手有难度
[01:10:31.920 --> 01:10:34.920] 但是我觉得相比于缺点
[01:10:34.920 --> 01:10:37.920] 还是优点带来的收益更大一些
[01:10:38.920 --> 01:10:42.920] 对对对其实主要还是生产力
[01:10:42.920 --> 01:10:44.920] 对节省了很多生产力
[01:10:46.920 --> 01:10:48.920] 另外其实我们也可以聊的
[01:10:48.920 --> 01:10:50.920] OEM的部分
[01:10:50.920 --> 01:10:52.920] 不知道这个LectureM和赖清涛
[01:10:52.920 --> 01:10:56.920] 你们现在用的这种OEM的工具是什么
[01:10:57.920 --> 01:11:00.920] 我都不搞外部开发
[01:11:02.920 --> 01:11:05.920] 我是就用原生的manage.py的功能
[01:11:05.920 --> 01:11:07.920] 就make migrations跟migrate
[01:11:09.920 --> 01:11:10.920] 你还是用jungle的是吧
[01:11:10.920 --> 01:11:13.920] 比如你在平常eo开发中
[01:11:13.920 --> 01:11:18.920] 你用的这个OEM是什么
[01:11:18.920 --> 01:11:21.920] 我们这边是用java的
[01:11:21.920 --> 01:11:25.920] 所以会用hypernet那些东西
[01:11:28.920 --> 01:11:31.920] 然后我自己的话就只用jungle
[01:11:31.920 --> 01:11:32.920] 这里面其实有个点
[01:11:32.920 --> 01:11:34.920] 我们可以可以讨论一下
[01:11:34.920 --> 01:11:38.920] 比如说你是不是要用用OEM来定义
[01:11:38.920 --> 01:11:42.920] 你的整个数据数据获取的逻辑
[01:11:42.920 --> 01:11:44.920] 因为比如说我们用circle alchemy的话
[01:11:44.920 --> 01:11:46.920] 其实你也可以不用OEM对吧
[01:11:46.920 --> 01:11:48.920] 你可以用它的card api
[01:11:48.920 --> 01:11:52.920] 就是虽然也不是这个写circle对吧
[01:11:52.920 --> 01:11:53.920] 你不是写circle
[01:11:53.920 --> 01:11:58.920] 你只是用python的代码来生成对应的circle来执行
[01:11:58.920 --> 01:11:59.920] 那但是这种场景下
[01:11:59.920 --> 01:12:04.920] 其实尤其是像小斌说的这种
[01:12:04.920 --> 01:12:07.920] 你要去频繁查看这个数据库的这种场景
[01:12:07.920 --> 01:12:09.920] 但这个是数据场景
[01:12:09.920 --> 01:12:13.920] 另一方面是你要去看这个对应的表的结构是什么
[01:12:13.920 --> 01:12:14.920] 那这种场景下
[01:12:14.920 --> 01:12:18.920] 其实如果你不用OEM的情况下
[01:12:18.920 --> 01:12:20.920] 你自己去拼接circle
[01:12:20.920 --> 01:12:24.920] 其实你很难在你的应用中去发现
[01:12:24.920 --> 01:12:28.920] 或者去认识到你这个整个model层
[01:12:28.920 --> 01:12:29.920] 你要操作的这个对象
[01:12:29.920 --> 01:12:30.920] 或者操作这个表
[01:12:30.920 --> 01:12:32.920] 它有哪些字段是可以用的
[01:12:32.920 --> 01:12:34.920] 它的类型是什么
[01:12:34.920 --> 01:12:36.920] 其实是很难发现的
[01:12:36.920 --> 01:12:39.920] 这东西就是当我们把它抽象成一个
[01:12:39.920 --> 01:12:41.920] OEM的一个model的定义之后
[01:12:41.920 --> 01:12:47.920] 其实它一定程度上是代表了你数据库里面表的结构
[01:12:47.920 --> 01:12:47.920] 对吧
[01:12:47.920 --> 01:12:48.920] 它类型是什么
[01:12:48.920 --> 01:12:50.920] 你都基本上都有了
[01:12:50.920 --> 01:12:52.920] 所以你在整个应用里面
[01:12:52.920 --> 01:12:53.920] 我们从信息上来说
[01:12:53.920 --> 01:12:56.920] 这个应用里面所需要信息是完备的
[01:12:56.920 --> 01:12:59.920] 你不需要它借助于比如mycircle
[01:12:59.920 --> 01:13:00.920] 你找一个mycircle的客户端工具
[01:13:00.920 --> 01:13:02.920] 或者找一个web端的管理工具
[01:13:02.920 --> 01:13:04.920] 你去查看这里面有什么东西
[01:13:04.920 --> 01:13:09.920] 对其实对不让你们对这个有什么经验或者看法
[01:13:09.920 --> 01:13:12.920] 我有一个观点不知道你们同不同意
[01:13:12.920 --> 01:13:14.920] 就是我OEM用的虽然不多
[01:13:14.920 --> 01:13:20.920] 但是我就是因为我们我也做过一些数据库的migration
[01:13:20.920 --> 01:13:22.920] 像那个xintang和adam都知道
[01:13:22.920 --> 01:13:24.920] 以前之前我们讨论了一下
[01:13:24.920 --> 01:13:31.920] 然后就是我做这个schema的数据库schemachange的时候
[01:13:31.920 --> 01:13:32.920] 遇到了一个很大的问题
[01:13:32.920 --> 01:13:36.920] 就是说我的代码里面的很多逻辑
[01:13:36.920 --> 01:13:41.920] 是和这个数据库的数据偶合的非常紧
[01:13:41.920 --> 01:13:43.920] 那么比如说对应
[01:13:43.920 --> 01:13:45.920] 如果是用OEM的概念来说的话
[01:13:45.920 --> 01:13:49.920] 就可能是比如说我会直接访问OEM的某个field
[01:13:49.920 --> 01:13:53.920] 但是就比如说我之后数据库里
[01:13:53.920 --> 01:13:55.920] 我就把这个field给去掉了
[01:13:55.920 --> 01:14:00.920] 或者我就直接就比如说又就是变了一个类型或者怎么样
[01:14:00.920 --> 01:14:07.920] 那么我的所有用到相关这个field的代码全部都要改
[01:14:07.920 --> 01:14:10.920] 那就非常的非常麻烦
[01:14:10.920 --> 01:14:14.920] 然后我就想到了一个可以讨论的点
[01:14:14.920 --> 01:14:22.920] 就是说这种偶合是不是可以通过再加一层抽象来进行一个结偶呢
[01:14:22.920 --> 01:14:27.920] 就比如说我再用一个类把这个OEM或者是我的例子里
[01:14:27.920 --> 01:14:31.920] 就是那个protocol buffer来包一层
[01:14:31.920 --> 01:14:33.920] 那么就相当于你的代码里面
[01:14:33.920 --> 01:14:37.920] 虽然也是访问底层的数据库里面的一些数据
[01:14:37.920 --> 01:14:41.920] 但它并不会直接去接触到那个column
[01:14:41.920 --> 01:14:42.920] 对
[01:14:42.920 --> 01:14:44.920] 然后这样的话
[01:14:44.920 --> 01:14:47.920] 你比如说你数据库就算我的schema改了
[01:14:47.920 --> 01:14:50.920] 那么我也可以通过它的reperclass
[01:14:50.920 --> 01:14:55.920] 然后来修改到就是让我的代码所有的逻辑都不用变
[01:14:55.920 --> 01:14:57.920] 然后这样修改就会非常方便
[01:14:57.920 --> 01:15:01.920] 我不知道你怎么看这样一个问题
[01:15:01.920 --> 01:15:03.920] 这个问题非常好
[01:15:03.920 --> 01:15:08.920] 就是没有什么东西是不能通过分层解决的
[01:15:08.920 --> 01:15:10.920] 如果有的话那就多分几层
[01:15:10.920 --> 01:15:12.920] 对吧就这个概念
[01:15:12.920 --> 01:15:13.920] 其实本质上来说
[01:15:13.920 --> 01:15:18.920] 我们的OEM就是我们应用跟数据库之间的一层抽象
[01:15:18.920 --> 01:15:19.920] 对吧
[01:15:19.920 --> 01:15:21.920] 但是这个问题在于
[01:15:21.920 --> 01:15:25.920] django里面不知道能不能做这样的事情
[01:15:25.920 --> 01:15:27.920] 比如说django其实
[01:15:27.920 --> 01:15:30.920] 你的column就是你mySQL里面的column名称
[01:15:30.920 --> 01:15:32.920] 比如说你叫file1
[01:15:32.920 --> 01:15:35.920] 那后来因为你的这个变更
[01:15:35.920 --> 01:15:35.920] 对吧
[01:15:35.920 --> 01:15:38.920] 你把这个file1改成file2了
[01:15:38.920 --> 01:15:40.920] 那在django里面你还是叫file1
[01:15:40.920 --> 01:15:41.920] 你整个应用里面
[01:15:41.920 --> 01:15:44.920] 假设你的应用所有的依赖非常多
[01:15:44.920 --> 01:15:45.920] 它都叫file1
[01:15:45.920 --> 01:15:46.920] 那这种场景下
[01:15:46.920 --> 01:15:50.920] 其实你去改它model指定的这个名字就好了
[01:15:50.920 --> 01:15:51.920] 比如file1
[01:15:51.920 --> 01:15:53.920] 你把映射成file2也是可以的
[01:15:53.920 --> 01:15:55.920] 那这种情况下就是你刚才说的那种
[01:15:55.920 --> 01:15:57.920] 等于是中间多了一层
[01:15:57.920 --> 01:15:58.920] 然后帮你做了一个映射
[01:15:58.920 --> 01:16:00.920] 直接用model来做这个事情
[01:16:00.920 --> 01:16:01.920] 对
[01:16:01.920 --> 01:16:04.920] 其实你的整个逻辑完全是不用变的
[01:16:04.920 --> 01:16:05.920] 因为这种变的话
[01:16:05.920 --> 01:16:07.920] 你可以想象是一条线下来的
[01:16:07.920 --> 01:16:10.920] 你从最上层使用的端到最下层数据端
[01:16:10.920 --> 01:16:12.920] 其实完全变了
[01:16:12.920 --> 01:16:12.920] 对
[01:16:12.920 --> 01:16:16.920] 其实就是model这种抽象的作用
[01:16:16.920 --> 01:16:17.920] 不过我遇到的那个问题是
[01:16:17.920 --> 01:16:20.920] 它的变化不仅仅是重命名这样
[01:16:20.920 --> 01:16:23.920] 而是说整个表的结构都变了
[01:16:24.920 --> 01:16:27.920] 那可能是一开始没有设计好
[01:16:27.920 --> 01:16:29.920] 对一开始确实没设计好
[01:16:29.920 --> 01:16:30.920] 这个场景应该是极低的
[01:16:30.920 --> 01:16:33.920] 就这个场景应该还是极低的
[01:16:33.920 --> 01:16:35.920] 就包括其实我们在用
[01:16:35.920 --> 01:16:38.920] 我们在用这个比如jungle的migration的时候
[01:16:38.920 --> 01:16:43.920] 其实你发现如果你真的把这个表全部都重新改了
[01:16:43.920 --> 01:16:46.920] 你的migration就没有什么价值了
[01:16:46.920 --> 01:16:49.920] 它migration就是一个版本一个版本的这种迭代
[01:16:49.920 --> 01:16:50.920] 我们可以这么理解
[01:16:50.920 --> 01:16:52.920] 但你突然出现一个新的版本
[01:16:52.920 --> 01:16:55.920] 这个东西跟之前完全不一样了
[01:16:55.920 --> 01:16:59.920] 你就没有追踪这个differ的意义了
[01:17:00.920 --> 01:17:02.920] 是的这种情况下我感觉
[01:17:03.920 --> 01:17:05.920] 这种情况下我是觉得先建一个model
[01:17:05.920 --> 01:17:07.920] 然后你再写一个migration
[01:17:07.920 --> 01:17:12.920] 把旧的model的数据全都手动去写一个逻辑copy过去
[01:17:12.920 --> 01:17:14.920] 然后你再写一个migration把旧的model删掉
[01:17:14.920 --> 01:17:17.920] 这样可能比较平滑一点
[01:17:17.920 --> 01:17:19.920] 对就是like9m刚才提到那个问题
[01:17:19.920 --> 01:17:21.920] 我可能有一些不同的看法
[01:17:21.920 --> 01:17:23.920] 我不太倾向于加一层封装
[01:17:24.920 --> 01:17:28.920] 对因为我觉得这个事情就是软件工程里面
[01:17:28.920 --> 01:17:32.920] 经常会遇到的就是所谓的breaking changes
[01:17:32.920 --> 01:17:35.920] 对然后就是你迁移的时候遇到了这个问题
[01:17:35.920 --> 01:17:38.920] 那你就针对这个问题做一个平滑迁移就好
[01:17:39.920 --> 01:17:42.920] 听起来加一层的话
[01:17:42.920 --> 01:17:45.920] 其实是可以解决说未来都不需要更多的成本
[01:17:45.920 --> 01:17:48.920] 但是其实这个场景确实出现的比较少见
[01:17:49.920 --> 01:17:53.920] 对就是我们其实也不会说经常去做这种变更
[01:17:54.920 --> 01:17:57.920] 嗯那倒是对但是一旦要做就非常的痛苦
[01:17:57.920 --> 01:17:59.920] 对就做的时候确实很痛苦
[01:17:59.920 --> 01:18:02.920] 但是你说你预置一个方案说来避免这个情况
[01:18:02.920 --> 01:18:06.920] 我觉得那这个方案可能大部分时候都没有用处
[01:18:07.920 --> 01:18:10.920] 嗯对我完全同意小斌的这个观点
[01:18:10.920 --> 01:18:16.920] 就是其实对就model可能还是已经是一层一定的封装了
[01:18:16.920 --> 01:18:20.920] 但我们那个场景连orm都没有就对吧
[01:18:20.920 --> 01:18:24.920] 就是很那个对但其实这个还有一个很关键的点
[01:18:24.920 --> 01:18:31.920] 就是就你这个封装完成之后的这一层会让你的上层应用会变得特别别扭
[01:18:31.920 --> 01:18:33.920] 就会变得特别难以理解嘛
[01:18:33.920 --> 01:18:35.920] 其实这是一个很关键的问题
[01:18:35.920 --> 01:18:39.920] 就比如说你把一个本来是这个shuffle的类型
[01:18:39.920 --> 01:18:40.920] 你改成int了
[01:18:40.920 --> 01:18:44.920] 但是呢你在这个model层或者在应用里面为了兼容
[01:18:44.920 --> 01:18:46.920] 你还让它是一个shuffle的类型
[01:18:46.920 --> 01:18:49.920] 那这种情况下你在应用里面用的人
[01:18:49.920 --> 01:18:53.920] 就会跟你处于库里面这个产生一个比较就特别大的歧义
[01:18:53.920 --> 01:18:58.920] 对对对这倒是这是一个对这是非常这个确实是非常关键的
[01:18:58.920 --> 01:19:00.920] 就是决定了你要不要去做这个封装
[01:19:00.920 --> 01:19:02.920] 就是你做了一个封装之后会导致
[01:19:02.920 --> 01:19:04.920] 但所有的人维护这个代码
[01:19:04.920 --> 01:19:06.920] 所有人都会有一个认知上的偏差
[01:19:06.920 --> 01:19:09.920] 就他完全不知道就分裂了
[01:19:11.920 --> 01:19:13.920] 我觉得你这个点说的非常好
[01:19:15.920 --> 01:19:16.920] 好啊
[01:19:16.920 --> 01:19:23.920] 那我们接下来来聊一些jungle的一些推荐的插件也好
[01:19:23.920 --> 01:19:24.920] 实践也好
[01:19:24.920 --> 01:19:26.920] 然后来做个收尾
[01:19:26.920 --> 01:19:30.920] 插件的话其实用的比较多的
[01:19:30.920 --> 01:19:33.920] 就是知道在之前的工作中用的比较多的
[01:19:33.920 --> 01:19:35.920] 其实就是一个就是比较重的
[01:19:35.920 --> 01:19:37.920] 就是jungle x admin
[01:19:38.920 --> 01:19:42.920] 但是呢这个东西就包括我在书里面我也写了
[01:19:42.920 --> 01:19:44.920] 就是其实我在推荐这个东西呢
[01:19:44.920 --> 01:19:45.920] 我会特别犹豫
[01:19:45.920 --> 01:19:52.920] 因为x admin他新的版本已经完全改成纯前端的一个东西了
[01:19:52.920 --> 01:19:54.920] 所以就会有点尴尬
[01:19:56.920 --> 01:19:59.920] 对让其他的就是他变成了一个更好的样式了是吗
[01:19:59.920 --> 01:20:01.920] 不是他是更通用了
[01:20:01.920 --> 01:20:03.920] 就他已经不是python写的了
[01:20:03.920 --> 01:20:05.920] 也不是jungle写的了
[01:20:05.920 --> 01:20:07.920] 他是变成一个纯前端东西了
[01:20:08.920 --> 01:20:12.920] 哦我懂懂你就是相当于是一个admin的项目
[01:20:12.920 --> 01:20:14.920] 但是一个前端的admin的项目
[01:20:14.920 --> 01:20:18.920] 对对你可以把它跟untd来对比这样的
[01:20:18.920 --> 01:20:21.920] 那他为什么还叫jungle admin呢
[01:20:21.920 --> 01:20:24.920] 他现在还叫jungle x admin吗
[01:20:24.920 --> 01:20:29.920] 不他他后来改他后来改成叫叫x admin了
[01:20:29.920 --> 01:20:32.920] 哦就是专门做各种管理的一个框架
[01:20:32.920 --> 01:20:34.920] 对然后呢
[01:20:34.920 --> 01:20:38.920] 另外的插件其实就是比如说还有
[01:20:38.920 --> 01:20:40.920] jungle里面非常著名的对吧
[01:20:40.920 --> 01:20:41.920] jungle debug toolbar
[01:20:43.920 --> 01:20:45.920] 对这个其实还是一个挺好的插件
[01:20:45.920 --> 01:20:47.920] 对我这个插件非常好
[01:20:47.920 --> 01:20:50.920] 就是不仅是你在使用的时候
[01:20:50.920 --> 01:20:53.920] 就不仅是在使用jungle框架的时候
[01:20:53.920 --> 01:20:54.920] 你在使用其他框架的时候
[01:20:54.920 --> 01:20:55.920] 其实也可以去借鉴
[01:20:55.920 --> 01:20:57.920] 就是你在做一些调教工作的时候
[01:20:57.920 --> 01:21:00.920] 你要是做这种全链路的监控
[01:21:00.920 --> 01:21:02.920] 对每个点的监控
[01:21:02.920 --> 01:21:04.920] 其实你可以参考他的这个逻辑
[01:21:04.920 --> 01:21:07.920] 另外一个叫jungle silk
[01:21:07.920 --> 01:21:09.920] 两个类似差不多
[01:21:09.920 --> 01:21:12.920] 但一个是实时的一个是非实时的
[01:21:14.920 --> 01:21:19.920] 但是debug toolbar这种其实也有一些局限性吧
[01:21:19.920 --> 01:21:21.920] 就是你能稳定的付现的情况下
[01:21:21.920 --> 01:21:23.920] 对吧对对是这样
[01:21:23.920 --> 01:21:25.920] 不然的话你可能还是找不到
[01:21:25.920 --> 01:21:27.920] 为什么会变慢
[01:21:27.920 --> 01:21:30.920] 你们有什么推荐吗
[01:21:30.920 --> 01:21:31.920] 也可以
[01:21:31.920 --> 01:21:33.920] 我没什么推荐
[01:21:33.920 --> 01:21:34.920] 你们说好了
[01:21:34.920 --> 01:21:36.920] 新涛你有什么推荐吗
[01:21:36.920 --> 01:21:39.920] 我给大家推荐一个最佳实践
[01:21:39.920 --> 01:21:41.920] 就是jungle的我们不同的项目
[01:21:41.920 --> 01:21:43.920] 会有不同的setting文件
[01:21:43.920 --> 01:21:46.920] 然后比如说dev会用一个setting
[01:21:46.920 --> 01:21:49.920] 然后test会有一个testing
[01:21:49.920 --> 01:21:51.920] 然后生产环境会有一个
[01:21:51.920 --> 01:21:52.920] 另一个setting
[01:21:52.920 --> 01:21:55.920] 这些setting里面数据库的地址
[01:21:55.920 --> 01:21:57.920] 还有一些其他的配置可能不一样
[01:21:57.920 --> 01:21:59.920] 然后这个的话
[01:21:59.920 --> 01:22:02.920] 可以在目录下面建一个settings package
[01:22:02.920 --> 01:22:05.920] 然后这个变量通常是可以设置的
[01:22:05.920 --> 01:22:06.920] 对吧
[01:22:06.920 --> 01:22:08.920] 就是我们可以指定jungle用哪一个settings
[01:22:08.920 --> 01:22:11.920] 然后在项目引用的时候
[01:22:11.920 --> 01:22:15.920] 我之前的做法是根据一个环境变量
[01:22:15.920 --> 01:22:17.920] 然后根据这个变量的不同去判断
[01:22:17.920 --> 01:22:20.920] 我应该去import developer还是import testing
[01:22:20.920 --> 01:22:22.920] 后来我发现你可以直接
[01:22:22.920 --> 01:22:25.920] 从jungle.conf import settings
[01:22:25.920 --> 01:22:28.920] 你从这里import的话
[01:22:28.920 --> 01:22:29.920] 你就不用自己判断变量
[01:22:29.920 --> 01:22:31.920] 它会自动给你figure out
[01:22:31.920 --> 01:22:35.920] 现在我这个项目运行的environment是什么
[01:22:35.920 --> 01:22:38.920] 然后自动给你导入你想要的settings
[01:22:38.920 --> 01:22:40.920] 它怎么自动figure out
[01:22:40.920 --> 01:22:41.920] 这个是
[01:22:43.920 --> 01:22:45.920] 你jungle运行的时候
[01:22:45.920 --> 01:22:47.920] 你本来你要告诉它一个环境变量
[01:22:47.920 --> 01:22:49.920] 就jungle settings等于什么
[01:22:49.920 --> 01:22:50.920] 对吧
[01:22:50.920 --> 01:22:53.920] 是一个linux的环境变量
[01:22:53.920 --> 01:22:56.920] 然后我之前是自己去读出来
[01:22:56.920 --> 01:22:57.920] 这个环境变量去判断
[01:22:59.920 --> 01:23:00.920] 但是其实你不用这么做
[01:23:00.920 --> 01:23:02.920] 你只要写一行就可以了
[01:23:02.920 --> 01:23:04.920] 就是from jungle.conf import settings
[01:23:05.920 --> 01:23:08.920] 因为我记得我以前好像也遇到这个问题
[01:23:09.920 --> 01:23:10.920] 对
[01:23:10.920 --> 01:23:12.920] 其实它jungle里面自己有包装一个
[01:23:12.920 --> 01:23:13.920] 读环境变量的操作
[01:23:13.920 --> 01:23:15.920] 就我们不用自己写了
[01:23:15.920 --> 01:23:16.920] 对
[01:23:16.920 --> 01:23:19.920] 然后像jungle有一个
[01:23:19.920 --> 01:23:21.920] 除了jungle.conf
[01:23:21.920 --> 01:23:24.920] 还有jungle有一个地方在utils里面
[01:23:24.920 --> 01:23:28.920] 很多函数都是我们项目里面可以用的
[01:23:28.920 --> 01:23:30.920] 可能我们就重复的封装一些操作
[01:23:30.920 --> 01:23:31.920] jungle里面已经封装了
[01:23:31.920 --> 01:23:32.920] 对
[01:23:32.920 --> 01:23:33.920] 比如说时间的
[01:23:33.920 --> 01:23:36.920] 离现在已经过了多少小时的这种东西
[01:23:36.920 --> 01:23:37.920] 对
[01:23:38.920 --> 01:23:39.920] 对
[01:23:39.920 --> 01:23:42.920] 所以utils的代码是非常值得一读的
[01:23:42.920 --> 01:23:43.920] 胡杨
[01:23:43.920 --> 01:23:49.920] 你有什么推荐的jungle的实践吗
[01:23:52.920 --> 01:23:53.920] 如果学习jungle的实践
[01:23:53.920 --> 01:23:54.920] 如果学习jungle实践
[01:23:54.920 --> 01:23:58.920] 其实最快的方式就是
[01:23:58.920 --> 01:24:01.920] 你去把tutorials看一遍
[01:24:01.920 --> 01:24:03.920] 然后呢
[01:24:03.920 --> 01:24:05.920] 去把对应的模块就看一遍
[01:24:05.920 --> 01:24:07.920] 然后把里面的项目实践
[01:24:07.920 --> 01:24:08.920] 就实践完成
[01:24:08.920 --> 01:24:11.920] 并且去把它部署到线上
[01:24:11.920 --> 01:24:13.920] 这是一个特别快的方式
[01:24:13.920 --> 01:24:15.920] 之后你再去
[01:24:15.920 --> 01:24:17.920] 比如说你去看view
[01:24:17.920 --> 01:24:19.920] 然后你再去看model
[01:24:19.920 --> 01:24:21.920] 就这个路径会特别高效
[01:24:21.920 --> 01:24:23.920] 而不是
[01:24:23.920 --> 01:24:25.920] 而不是你找各种各样的资料
[01:24:25.920 --> 01:24:26.920] 然后堆过来去看
[01:24:26.920 --> 01:24:30.920] 就是你只要完全按照它文档的来走就好了
[01:24:34.920 --> 01:24:38.920] 然后可以看一下jungle企业开发实战
[01:24:38.920 --> 01:24:40.920] 嘻嘻嘻嘻
[01:24:40.920 --> 01:24:42.920] 对然后就就看这本书
[01:24:42.920 --> 01:24:43.920] 就这本书的逻辑
[01:24:43.920 --> 01:24:46.920] 其实也是也是按照我刚才说的那个逻辑在做的
[01:24:46.920 --> 01:24:47.920] 就是你先去
[01:24:47.920 --> 01:24:49.920] 就是比如搞一个demo
[01:24:49.920 --> 01:24:50.920] ok demo搞好了
[01:24:50.920 --> 01:24:51.920] 找一个需求
[01:24:51.920 --> 01:24:52.920] 然后把这需求做了
[01:24:52.920 --> 01:24:54.920] 把它做上线
[01:24:54.920 --> 01:24:57.920] 其实这这整套这个路子走下来之后
[01:24:57.920 --> 01:24:59.920] 你就会遇到各种各样的问题
[01:24:59.920 --> 01:25:01.920] 当你把这种问题解决了之后
[01:25:01.920 --> 01:25:04.920] 其实你就基本上能够掌握
[01:25:04.920 --> 01:25:06.920] 如何接到一个需求
[01:25:06.920 --> 01:25:08.920] 用用jungle把它开发完成
[01:25:08.920 --> 01:25:09.920] 并把它部署上线
[01:25:09.920 --> 01:25:12.920] 这种过程其实就就会掌握掌握了
[01:25:12.920 --> 01:25:13.920] 对
[01:25:13.920 --> 01:25:15.920] 那我们也再来推荐一下这本书
[01:25:15.920 --> 01:25:20.920] 如果有想学习jungle或正在学习jungle的同学
[01:25:20.920 --> 01:25:22.920] 可以买一本看看
[01:25:22.920 --> 01:25:24.920] jungle企业开发实战
[01:25:24.920 --> 01:25:26.920] 我们要不要从听众里面
[01:25:26.920 --> 01:25:29.920] 从听众里面抽几个幸运观众来送一下这个书
[01:25:29.920 --> 01:25:30.920] 可以啊
[01:25:30.920 --> 01:25:32.920] 可以我可以来安排
[01:25:32.920 --> 01:25:34.920] 你们来你们来负责抽就可以了
[01:25:34.920 --> 01:25:35.920] 我负责安排
[01:25:35.920 --> 01:25:36.920] 好啊
[01:25:36.920 --> 01:25:38.920] 我们抽几个抽5本
[01:25:38.920 --> 01:25:40.920] 可以啊
[01:25:40.920 --> 01:25:41.920] 那抽5本吧
[01:25:41.920 --> 01:25:42.920] 好
[01:25:42.920 --> 01:25:43.920] OK
[01:25:43.920 --> 01:25:45.920] 那有这么愉快的决定了
[01:25:45.920 --> 01:25:48.920] 然后其实我可以再补充一点
[01:25:48.920 --> 01:25:50.920] 就是这本书的一个
[01:25:50.920 --> 01:25:53.920] 有个比较前置的动机是什么
[01:25:53.920 --> 01:25:55.920] 前置动机就是我其实在我们最早聊的时候
[01:25:55.920 --> 01:25:56.920] 其实我说了
[01:25:56.920 --> 01:26:00.920] 就是我一开始就进到jungle这个盒子里面了
[01:26:00.920 --> 01:26:02.920] 我其实不知道外面什么样子的
[01:26:02.920 --> 01:26:04.920] 并且最重要一点就是
[01:26:04.920 --> 01:26:06.920] 当时跟你一起工作的人
[01:26:06.920 --> 01:26:08.920] 他们也不知道这个外面是什么样子的
[01:26:08.920 --> 01:26:11.920] 所以导致你写了一年jungle之后
[01:26:11.920 --> 01:26:13.920] 发现跟没写没什么太大差别
[01:26:13.920 --> 01:26:18.920] 所以其实这本书就会有一个比较完整的路线
[01:26:18.920 --> 01:26:20.920] 让你从外面
[01:26:20.920 --> 01:26:22.920] 然后让你通过实践
[01:26:22.920 --> 01:26:25.920] 然后来看整体的一个
[01:26:25.920 --> 01:26:28.920] 就有哪些点是需要你补足的
[01:26:28.920 --> 01:26:30.920] 或者你有没有的这样的一个东西
[01:26:30.920 --> 01:26:31.920] 对
[01:26:31.920 --> 01:26:34.920] 那它为什么叫企业开发实战呢
[01:26:34.920 --> 01:26:36.920] 就是企业两个字体现在哪里
[01:26:38.920 --> 01:26:44.920] 对这个名字就是我之前会担心被很多人吐槽
[01:26:44.920 --> 01:26:45.920] 但其实也会很多人吐槽
[01:26:45.920 --> 01:26:47.920] 就是你写个博客你也叫企业
[01:26:47.920 --> 01:26:50.920] 你对就是很夸张
[01:26:50.920 --> 01:26:51.920] 对吧
[01:26:51.920 --> 01:26:53.920] 但其实这个重点其实在于
[01:26:53.920 --> 01:26:57.920] 我一开始的想法是把这种更实际的做法
[01:26:57.920 --> 01:27:01.920] 更实际的这种场景通过一个博客
[01:27:01.920 --> 01:27:04.920] 然后把它给带出来
[01:27:04.920 --> 01:27:08.920] 而不是说我们就完全比如我们去开发一个商城
[01:27:08.920 --> 01:27:09.920] 对于我们来说
[01:27:09.920 --> 01:27:10.920] 我们去学习的时候
[01:27:10.920 --> 01:27:11.920] 我们开发一个商城
[01:27:11.920 --> 01:27:13.920] 你还是只是自己一个demo
[01:27:13.920 --> 01:27:15.920] 它算不上是企业东西
[01:27:15.920 --> 01:27:16.920] 那对于企业中来说
[01:27:16.920 --> 01:27:19.920] 其实它就是需要用到了什么东西
[01:27:19.920 --> 01:27:21.920] 比如说jango的一些基础的功能
[01:27:21.920 --> 01:27:22.920] 它的基础点
[01:27:22.920 --> 01:27:26.920] 然后你用到了这个对业务的分析
[01:27:26.920 --> 01:27:28.920] 然后对项目的部署
[01:27:28.920 --> 01:27:28.920] 对吧
[01:27:28.920 --> 01:27:31.920] 对这个线上性能的调优
[01:27:31.920 --> 01:27:31.920] 对吧
[01:27:31.920 --> 01:27:34.920] 其实这是跟企业相关的
[01:27:34.920 --> 01:27:36.920] 至于你说我是写一个博客
[01:27:36.920 --> 01:27:37.920] 我是写一个新网站
[01:27:37.920 --> 01:27:41.920] 或者我写一个这种这种电商平台
[01:27:41.920 --> 01:27:43.920] 其实对你来说还是个demo
[01:27:43.920 --> 01:27:45.920] 因为它并不能真正的上线
[01:27:45.920 --> 01:27:47.920] 但博客的话有好处就是
[01:27:47.920 --> 01:27:49.920] 它确实能够真正上线
[01:27:49.920 --> 01:27:51.920] 并且你需要对这个东西
[01:27:51.920 --> 01:27:53.920] 就是你会对这个东西有一个责任感
[01:27:53.920 --> 01:27:55.920] 因为你博客挂了
[01:27:55.920 --> 01:27:57.920] 其实对吧
[01:27:57.920 --> 01:27:58.920] 你作为一个程序员
[01:27:58.920 --> 01:27:59.920] 你自己的博客挂了
[01:27:59.920 --> 01:28:01.920] 脸上其实是挂不住的
[01:28:01.920 --> 01:28:04.920] 对我很同意你说这点
[01:28:04.920 --> 01:28:09.920] 其实这本书听起来是一个生产环境的tutorial
[01:28:09.920 --> 01:28:11.920] 基于jango
[01:28:11.920 --> 01:28:14.920] 对就会介绍更多的
[01:28:14.920 --> 01:28:18.920] 我们在企业中会怎么来使用jango的这样的一些东西
[01:28:18.920 --> 01:28:20.920] 我觉得相当于就是用一个
[01:28:20.920 --> 01:28:24.920] 就是用一种企业里面开发的思路
[01:28:24.920 --> 01:28:27.920] 包括现在最新的一些生产里面的工具
[01:28:27.920 --> 01:28:30.920] 来开发一个个人可以实际部署的项目
[01:28:30.920 --> 01:28:32.920] 对吧对这样子
[01:28:32.920 --> 01:28:33.920] 对是这样的
[01:28:33.920 --> 01:28:37.920] 并且你可以去对它做后续的迭代
[01:28:37.920 --> 01:28:38.920] 就比如说我们版本升级对吧
[01:28:38.920 --> 01:28:40.920] 如果你企业中用的1.3
[01:28:40.920 --> 01:28:42.920] 那你其实在企业中
[01:28:42.920 --> 01:28:44.920] 你没有机会升级到2.0的
[01:28:44.920 --> 01:28:46.920] 因为这个跨度太大了
[01:28:46.920 --> 01:28:49.920] 是但你自己是完全可以去做这种上线的
[01:28:49.920 --> 01:28:51.920] 就是我们讲
[01:28:51.920 --> 01:28:55.920] 就是你的技术站要超脱于你企业的技术站才行
[01:28:55.920 --> 01:28:58.920] 这样的话你才能不至于被业界淘汰
[01:28:58.920 --> 01:29:01.920] 对吧要不然你企业里面还用的1.3
[01:29:01.920 --> 01:29:03.920] 那其实人家都已经用2.2了
[01:29:03.920 --> 01:29:05.920] 最新版本或者再过一年之后
[01:29:05.920 --> 01:29:07.920] 大家都已经用3.0了
[01:29:07.920 --> 01:29:09.920] 你怎么出去跟人家交流
[01:29:09.920 --> 01:29:11.920] 对吧这是很大的问题
[01:29:11.920 --> 01:29:14.920] 好我们再次推荐一下这本书
[01:29:14.920 --> 01:29:17.920] 对吧jango企业开发实战
[01:29:17.920 --> 01:29:22.920] 好又到了最后结尾的一些相关资料推荐环节了
[01:29:22.920 --> 01:29:27.920] 对我们先请胡杨来推荐一些他觉得
[01:29:27.920 --> 01:29:30.920] 不错的酷组件框架或资料吧
[01:29:30.920 --> 01:29:34.920] 我就推荐一个吧就是fn.py
[01:29:34.920 --> 01:29:36.920] 这个东西接触的场景是什么
[01:29:36.920 --> 01:29:40.920] 就是其实有一段时间我是在那个
[01:29:40.920 --> 01:29:42.920] 就是专注在javascript上
[01:29:42.920 --> 01:29:44.920] 然后他里面有一些这种
[01:29:44.920 --> 01:29:47.920] 函数式编程的理念
[01:29:47.920 --> 01:29:49.920] 那这个时候其实我找了
[01:29:49.920 --> 01:29:50.920] python里面这种东西
[01:29:50.920 --> 01:29:52.920] 发现python里面有这样的一个东西
[01:29:52.920 --> 01:29:55.920] 那他的一个理念就是我们简单来说
[01:29:55.920 --> 01:29:58.920] 比如说我们定义了一个
[01:29:58.920 --> 01:30:01.920] 比如我们要去执行一个公式
[01:30:01.920 --> 01:30:03.920] 对吧这个公式是
[01:30:03.920 --> 01:30:07.920] 这个公式是比如说x加1
[01:30:07.920 --> 01:30:09.920] 然后乘上100
[01:30:09.920 --> 01:30:12.920] 我们有一个这样的公式
[01:30:12.920 --> 01:30:15.920] 那你在python里面怎么去
[01:30:15.920 --> 01:30:18.920] 比较这个更贴近这种
[01:30:18.920 --> 01:30:21.920] 这种函数式的方式去实现呢
[01:30:21.920 --> 01:30:24.920] 对吧其实x加1乘上100
[01:30:24.920 --> 01:30:26.920] 你可以把它变成两个组合函数
[01:30:26.920 --> 01:30:30.920] 第一个函数是执行x加1
[01:30:30.920 --> 01:30:33.920] 第二个函数是执行一个对应的值
[01:30:33.920 --> 01:30:35.920] 去对应编量乘上100
[01:30:35.920 --> 01:30:38.920] 那这样的场景下就是你可以用
[01:30:38.920 --> 01:30:40.920] 比如你定义了一个add的方法
[01:30:40.920 --> 01:30:43.920] 定义了一个乘的方法
[01:30:43.920 --> 01:30:45.920] 那这两个方法你把它合起来
[01:30:45.920 --> 01:30:49.920] 那这就是函数式编成里面的这种
[01:30:49.920 --> 01:30:51.920] 复合函数或者叫高阶函数
[01:30:51.920 --> 01:30:53.920] 你把这两个函数合起来
[01:30:53.920 --> 01:30:55.920] 并不是说你去执行一函数
[01:30:55.920 --> 01:30:56.920] 执行二函数
[01:30:56.920 --> 01:30:58.920] 而是把两个函数合并成一个函数
[01:30:58.920 --> 01:31:00.920] 然后传一个参数就可以把这个
[01:31:00.920 --> 01:31:04.920] 两个函数的这个方法都执行了
[01:31:04.920 --> 01:31:05.920] 得到你最终想要的结果
[01:31:05.920 --> 01:31:09.920] 就跟你执行了一个公式是一样的
[01:31:09.920 --> 01:31:11.920] 我这么描述不知道你们能不能听得懂
[01:31:11.920 --> 01:31:13.920] 就它里面其实python里面有个内置库
[01:31:13.920 --> 01:31:16.920] 有个内置库叫parcel的东西
[01:31:16.920 --> 01:31:19.920] 然后在函数式编成上
[01:31:19.920 --> 01:31:21.920] 对在函数式编成上有一个叫颗粒化的东西
[01:31:21.920 --> 01:31:23.920] carry的一个东西
[01:31:23.920 --> 01:31:27.920] 那这种东西的它的作用就是
[01:31:27.920 --> 01:31:30.920] 比如说我们定义了一个函数
[01:31:30.920 --> 01:31:32.920] 一个底层的函数
[01:31:32.920 --> 01:31:33.920] 然后它有一个类型
[01:31:33.920 --> 01:31:34.920] 除了类型之外
[01:31:34.920 --> 01:31:37.920] 比如说它有一个有一个id
[01:31:37.920 --> 01:31:40.920] 比如我们常用的比如说这个content的id
[01:31:40.920 --> 01:31:41.920] 然后有个类型
[01:31:41.920 --> 01:31:46.920] 这类型比如说是这个分类
[01:31:46.920 --> 01:31:48.920] 然后是文章
[01:31:48.920 --> 01:31:49.920] 然后是标签
[01:31:49.920 --> 01:31:51.920] 对吧这三种类型分别是123
[01:31:51.920 --> 01:31:53.920] 那这种情况下我们在上层用的时候
[01:31:53.920 --> 01:31:54.920] 你怎么用呢
[01:31:54.920 --> 01:32:01.920] 你是比如get content by id and type
[01:32:01.920 --> 01:32:02.920] 这是一个方法名称
[01:32:02.920 --> 01:32:04.920] 然后里面对应两个参数
[01:32:04.920 --> 01:32:05.920] 还是说你在
[01:32:05.920 --> 01:32:07.920] 比如我们这个是写在c层的
[01:32:07.920 --> 01:32:09.920] 然后我们把它定义成一个
[01:32:09.920 --> 01:32:12.920] 就除了这个基础的定义
[01:32:12.920 --> 01:32:16.920] 就get by就get content by id and type之外
[01:32:16.920 --> 01:32:20.920] 我会在这上面通过partial再封装出来三个函数
[01:32:20.920 --> 01:32:23.920] 一个函数就叫get比如说category
[01:32:23.920 --> 01:32:25.920] 一个函数叫get post
[01:32:25.920 --> 01:32:28.920] 然后通过partial把最后的那个那个变量
[01:32:28.920 --> 01:32:31.920] 就content type给指定死
[01:32:31.920 --> 01:32:32.920] 那这样的话
[01:32:32.920 --> 01:32:36.920] 其实我在这一层可以封装出来一个语意化更好的
[01:32:36.920 --> 01:32:38.920] 在上层调用是完全没有歧义
[01:32:38.920 --> 01:32:41.920] 并且上层是不需要知道我有一个
[01:32:41.920 --> 01:32:43.920] 就不需要知道我content id
[01:32:43.920 --> 01:32:47.920] 就content type定义的这样的一个东西
[01:32:47.920 --> 01:32:49.920] 对这是他的一个
[01:32:49.920 --> 01:32:52.920] 特别实际的一个用处
[01:32:52.920 --> 01:32:54.920] OK感谢火羊的分享
[01:32:54.920 --> 01:32:56.920] 我们今天的节目到此结束
[01:32:56.920 --> 01:32:58.920] 结束之前插播一条广告
[01:32:58.920 --> 01:33:02.920] 补舌者说将会在PyCon2019上海站布置展位
[01:33:02.920 --> 01:33:06.920] Like9M和赖信涛也将在PyCon上进行分享
[01:33:06.920 --> 01:33:10.920] 所以Like9M打算分享的主题是什么呢
[01:33:10.920 --> 01:33:17.920] 对就是PyCon这次PyCon2019上海站
[01:33:17.920 --> 01:33:22.920] 然后我和信涛都会就我们分别各有一个talk吧
[01:33:22.920 --> 01:33:27.920] 然后我的那个演讲是讲关于Python调试的新思路
[01:33:27.920 --> 01:33:30.920] 然后我希望是能回顾一下
[01:33:30.920 --> 01:33:33.920] 就是以往Python调试的一些历史
[01:33:33.920 --> 01:33:37.920] 然后结合我最近做的一个项目来
[01:33:37.920 --> 01:33:44.920] 就是谈一下一些可能的不一样的更好的调试思路吧
[01:33:44.920 --> 01:33:47.920] 希望我能把这个项目做出来
[01:33:47.920 --> 01:33:49.920] 信涛你呢你会讲什么
[01:33:49.920 --> 01:33:53.920] 我的主题是Jungle的OM
[01:33:53.920 --> 01:33:55.920] 其实主要是migration原理
[01:33:55.920 --> 01:34:01.920] 就是讲model的迁移怎么是落实到数据库的迁移的
[01:34:01.920 --> 01:34:04.920] 然后以及相关的一些最佳实践
[01:34:04.920 --> 01:34:09.920] 希望把这个事情讲的比较浅显明白一点
[01:34:09.920 --> 01:34:14.920] 然后争取让没有接触过Jungle的同学也能理解
[01:34:14.920 --> 01:34:18.920] 就是这么做的一些好处以及它的原理
[01:34:18.920 --> 01:34:25.920] OK我们将在Pycom期待大家的到来
