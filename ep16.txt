[00:30.000 --> 00:32.600] 欢迎大家收听捕蛇者说
[00:32.600 --> 00:35.400] 本期节目我们将邀请到陈征
[00:35.400 --> 00:37.400] 和我们一起来聊一聊Python3
[00:37.400 --> 00:39.400] 以及Python3迁移的话题
[00:39.400 --> 00:42.000] 首先我们有请我们的嘉宾陈征
[00:42.000 --> 00:44.400] 陈征先来自我介绍一下吧
[00:44.400 --> 00:46.400] OK 大家好
[00:46.400 --> 00:48.400] 我叫陈征
[00:48.400 --> 00:50.400] 在大学毕业之后
[00:50.400 --> 00:52.400] 我的主要工作经历都在知乎
[00:52.400 --> 00:54.400] 也曾经在多抓鱼工作
[00:54.400 --> 00:56.400] 在工作经历里面
[00:56.400 --> 00:58.400] 我的大部分时间都是
[00:58.400 --> 01:01.400] 在使用Python作为我主要的编程语言
[01:01.400 --> 01:04.400] 除了Python以外也写过一段时间的Go
[01:04.400 --> 01:07.400] 好 以及欢迎我们另外两位常驻主持人
[01:07.400 --> 01:09.400] 曼珠萨卡和蓝星涛
[01:09.400 --> 01:11.400] 大家好 我是蓝星涛
[01:11.400 --> 01:14.400] 曼珠萨卡和大家打一声招呼吧
[01:14.400 --> 01:16.400] 哈喽 大家好 我是曼珠萨卡
[01:16.400 --> 01:18.400] 最近修福报修得比较爽
[01:18.400 --> 01:20.400] 所以说一直没有来跟大家做节目
[01:20.400 --> 01:23.400] 今天终于暂时来做了一些
[01:23.400 --> 01:25.400] 然后做完之后我又要去修福报了
[01:25.400 --> 01:27.400] 大家一定不要来修福报
[01:27.400 --> 01:30.400] 好 那我们就开始聊我们的主题
[01:30.400 --> 01:32.400] 我们今天主要会围绕着
[01:32.400 --> 01:36.400] 和Python3相关的特性 优势 缺点
[01:36.400 --> 01:39.400] 包括一些迁移来聊一聊
[01:39.400 --> 01:41.400] 对 那说到Python3
[01:41.400 --> 01:44.400] 其实我们昨天应该是迎来了
[01:44.400 --> 01:46.400] Python2的最后一个版本
[01:46.400 --> 01:47.400] Python2.7.18
[01:47.400 --> 01:50.400] 然后之后Python2就不会再更新了
[01:50.400 --> 01:53.400] 那Python3引入的一些特性里面
[01:53.400 --> 01:56.400] 大家会有什么觉得比较喜欢的
[01:56.400 --> 01:58.400] 或者用的比较爽的吗
[01:58.400 --> 01:59.400] 陈德伟先来
[01:59.400 --> 02:01.400] 那我先来吧
[02:01.400 --> 02:04.400] 在现在的工作里面我也在用Python3
[02:04.400 --> 02:07.400] 然后我觉得一个比较爽的是
[02:07.400 --> 02:09.400] 一个叫Data Class的装饰器
[02:09.400 --> 02:12.400] 然后用它来装饰你的类之后
[02:12.400 --> 02:16.400] 你就可以直接去写你需要的属性了
[02:16.400 --> 02:18.400] 然后你再也不需要init的函数了
[02:18.400 --> 02:20.400] 然后还有一个比较爽的地方是
[02:20.400 --> 02:23.400] Data Class提供了一个叫Frozen的Leg
[02:23.400 --> 02:25.400] 当你去把它设置成True的时候
[02:25.400 --> 02:28.400] 你这个实例它就是一个只读的
[02:28.400 --> 02:30.400] 就不会被修改了
[02:30.400 --> 02:33.400] 这个特性好像还挺有趣的
[02:33.400 --> 02:35.400] 我之前没有接触过Data Class
[02:35.400 --> 02:38.400] 但是它就相当于是我们可以生成之后
[02:38.400 --> 02:40.400] 就可以被保护起来是吗
[02:40.400 --> 02:41.400] Read Only
[02:41.400 --> 02:44.400] 对 是因为我们现在的工作里面
[02:44.400 --> 02:46.400] 目前的代码是偏O的风格
[02:46.400 --> 02:50.400] 所以其实会有特别多的这种类的定义
[02:50.400 --> 02:51.400] 这个其实挺有意思
[02:51.400 --> 02:53.400] 就是我之前看过
[02:53.400 --> 02:56.400] Python里面其实是没有不可变的这个东西
[02:56.400 --> 02:57.400] 你其实没法实现
[02:57.400 --> 03:00.400] 任何东西最终都是可以改变的
[03:00.400 --> 03:03.400] 然后就有人用一些很神奇的方式
[03:03.400 --> 03:04.400] 实现了一些Const
[03:04.400 --> 03:08.400] 我觉得这个Frozen应该也可以拿来
[03:08.400 --> 03:11.400] 就是搞一个那个吧 对吧
[03:11.400 --> 03:12.400] 替换掉对吧
[03:12.400 --> 03:13.400] 就是你如果掉的话
[03:13.400 --> 03:15.400] 我就直接给你泡一场
[03:15.400 --> 03:17.400] 它的实现其实就是应该是
[03:17.400 --> 03:20.400] 把你的setHB的那个方法
[03:20.400 --> 03:23.400] 给从某方式给禁用掉了
[03:23.400 --> 03:26.400] 对 它其实是setHB
[03:26.400 --> 03:28.400] 它应该是描述符
[03:28.400 --> 03:29.400] 如果没猜错的话
[03:29.400 --> 03:30.400] 它这种Python里面
[03:30.400 --> 03:32.400] 你那里面常见的那个东西都应该是
[03:32.400 --> 03:35.400] 可能会是用描述符来hook
[03:35.400 --> 03:37.400] 对 其实就是你的那个property
[03:37.400 --> 03:39.400] 比如说你class里面的property对吧
[03:39.400 --> 03:41.400] 然后它其实本质上也是
[03:41.400 --> 03:43.400] 就是通过描述符来hook
[03:43.400 --> 03:44.400] 对 property是描述符
[03:44.400 --> 03:46.400] 但是有一些也不是
[03:46.400 --> 03:48.400] 我觉得这个我们可以再确认一下
[03:48.400 --> 03:50.400] 到时候看一下它的PP
[03:50.400 --> 03:51.400] 对 我们可以看一下
[03:51.400 --> 03:54.400] 因为data class我也没怎么用过
[03:54.400 --> 03:55.400] 说实话
[03:55.400 --> 03:58.400] 我有一个点比较好奇啊 陈征
[03:58.400 --> 04:00.400] 就是刚才有描述说
[04:00.400 --> 04:03.400] 我们在很多地方就使用OO这种概念
[04:03.400 --> 04:05.400] 然后会用到data class
[04:05.400 --> 04:06.400] 我想知道比如说一般
[04:06.400 --> 04:10.400] 什么场景会选择用frozen这个flag呢
[04:10.400 --> 04:12.400] 就当你创建好你的实例
[04:12.400 --> 04:14.400] 你就不希望它被修改的时候
[04:14.400 --> 04:16.399] 或者能确定它不会被修改
[04:16.399 --> 04:18.399] 也不容易去
[04:18.399 --> 04:20.399] 修改它的实例之后
[04:20.399 --> 04:21.399] 你就可以加一个
[04:21.399 --> 04:23.400] 然后上来做了一个保险
[04:23.400 --> 04:24.400] 你可能知道你自己不会去修改
[04:24.400 --> 04:25.400] 但是你加上之后
[04:25.400 --> 04:28.400] 你就能知道它一定不会被修改了
[04:28.400 --> 04:31.400] 那是不是 我不太确认啊
[04:31.400 --> 04:34.400] 是不是比如说我们假设做一个core a
[04:34.400 --> 04:36.400] 那它对外暴露的API所返回的对象
[04:36.400 --> 04:38.400] 我都可以frozen一把
[04:38.400 --> 04:40.400] 我觉得是可以的
[04:40.400 --> 04:41.400] 我觉得也是可以
[04:41.400 --> 04:43.400] 我觉得其实这样也是
[04:43.400 --> 04:44.400] 感觉是挺推荐的
[04:44.400 --> 04:45.400] 我不确认
[04:45.400 --> 04:48.400] 也许这也是一个不好的事件
[04:48.400 --> 04:50.400] 对 因为我之前没有用过
[04:50.400 --> 04:53.400] 但是我觉得frozen这个flag确实
[04:53.400 --> 04:55.400] 好像会比较有趣一些
[04:55.400 --> 04:58.400] 比如说像pattern request的那个core
[04:58.400 --> 04:59.400] 就可以把那个response
[04:59.400 --> 05:00.400] 设成frozen的对吧
[05:00.400 --> 05:03.400] 这个我还没听过
[05:03.400 --> 05:05.400] 对 因为听起来
[05:05.400 --> 05:07.400] 大家不应该去修改这个response
[05:07.400 --> 05:08.400] 如果真的有需要
[05:08.400 --> 05:10.400] 应该把里面的数据导出来
[05:10.400 --> 05:12.400] 然后自己去做操作
[05:12.400 --> 05:13.400] 是的
[05:13.400 --> 05:15.400] 刚才还提到说Data Class
[05:15.400 --> 05:16.400] 有另外一个好处是
[05:16.400 --> 05:18.400] 不需要自己手动写init是吗
[05:18.400 --> 05:20.400] 这个地方我有个问题
[05:20.400 --> 05:21.400] 就是我可以
[05:21.400 --> 05:24.400] 因为Data Class的PPP我看过
[05:24.400 --> 05:26.400] 它就是说你写了那个class
[05:26.400 --> 05:27.400] 然后你在下面写上
[05:27.400 --> 05:28.400] 它所有的那个属性
[05:28.400 --> 05:33.400] 比如说name,string,age,int
[05:33.400 --> 05:36.400] 然后你后面的都不用写了
[05:36.400 --> 05:39.400] 它就会帮你根据你写的那个属性
[05:39.400 --> 05:42.400] 帮你生成init,eq,hash这些东西
[05:42.400 --> 05:43.400] 当然你也可以控制
[05:43.400 --> 05:44.400] 它们不要生成eq,hash
[05:44.400 --> 05:47.400] 就之前你如果第一class的属性
[05:47.400 --> 05:49.400] 全都得写到init的方法里面
[05:49.400 --> 05:51.400] 这对其他语言的程序来说
[05:51.400 --> 05:53.400] 可能看起来比较奇怪
[05:53.400 --> 05:54.400] 因为你就相当于
[05:54.400 --> 05:56.400] 那个class里面什么都没有
[05:56.400 --> 05:58.400] 然后你在init里面规定了
[05:58.400 --> 05:59.400] 它有什么属性
[05:59.400 --> 06:02.400] 而且还是一个相当于是动态生成的
[06:02.400 --> 06:04.400] 对吧 如果你init里有if的话
[06:04.400 --> 06:05.400] 对
[06:05.400 --> 06:07.400] 你同一个class的属性
[06:07.400 --> 06:08.400] 都是不一样的
[06:08.400 --> 06:09.400] 对对对
[06:09.400 --> 06:11.400] 但是我这个地方
[06:11.400 --> 06:12.400] 其实一直有一个问题
[06:12.400 --> 06:15.400] 因为我就是看PVP实际写代码的时候
[06:15.400 --> 06:16.400] 我用的很少
[06:16.400 --> 06:17.400] 所以我想问一下陈生
[06:17.400 --> 06:19.400] 就是你们有没有遇到过这种情况
[06:19.400 --> 06:21.400] 就是比如说init里面
[06:21.400 --> 06:25.400] 有一些值想给它默认变量
[06:25.400 --> 06:27.400] 比如说你先建一个connection
[06:27.400 --> 06:28.400] 我默认的端口
[06:28.400 --> 06:29.400] 如果你不填的话
[06:29.400 --> 06:31.400] 可能是6379这样子
[06:31.400 --> 06:34.400] 但是如果你在那个class下面的属性
[06:34.400 --> 06:35.400] 加一个等号
[06:35.400 --> 06:37.400] 然后给它复一个默认值的话
[06:37.400 --> 06:38.400] 那这个属性如果按照
[06:38.400 --> 06:40.400] 我看的PVP的时候的印象的话
[06:40.400 --> 06:43.400] 它应该直接就被提升成一个class的attribute
[06:43.400 --> 06:45.400] 就不是对象的了
[06:45.400 --> 06:47.400] 因为你那个是就是你class本身啊
[06:47.400 --> 06:50.400] 你它其实本身就是classattribute嘛
[06:50.400 --> 06:51.400] 不知道是不是这样子
[06:51.400 --> 06:55.400] 就是你不能给那个属性复一个默认值
[06:55.400 --> 06:56.400] 它如果有默认值的话
[06:56.400 --> 06:58.400] 它就变成一个class的属性
[06:58.400 --> 06:59.400] 不是对象的属性了
[06:59.400 --> 07:02.400] 听起来变class的属性比较合理
[07:02.400 --> 07:05.400] 比较符合Python的定义
[07:05.400 --> 07:09.400] 它是通过那个inspect来hook掉里面的东西的吗
[07:09.400 --> 07:11.400] 我还真没有太看过它的实现
[07:11.400 --> 07:12.400] 对对
[07:12.400 --> 07:14.400] 因为之前没有data class的时候
[07:14.400 --> 07:15.400] 我们就是这么写的嘛
[07:15.400 --> 07:15.400] 对吧
[07:15.400 --> 07:16.400] class里面的对
[07:16.400 --> 07:17.400] 演绎的上面的东西
[07:17.400 --> 07:20.400] 就是那个class层级的东西
[07:20.400 --> 07:21.400] 所以好像没有什么办法
[07:21.400 --> 07:24.400] 你在那个data class里面
[07:24.400 --> 07:27.400] 给这些class定义默认值
[07:27.400 --> 07:29.400] 我不太确认
[07:29.400 --> 07:32.400] 就是这个是就是会被提升吗
[07:32.400 --> 07:33.400] 因为我刚才看了一下
[07:33.400 --> 07:35.400] 这个data class的文档
[07:35.400 --> 07:39.400] 但是好像没有明确的体现这个事情
[07:39.400 --> 07:40.400] 我看这个文档上面写着
[07:40.400 --> 07:42.400] 如果你写一个值等于0的话
[07:42.400 --> 07:44.400] 这个值就是在init的时候
[07:44.400 --> 07:45.400] 会变成一个默认值
[07:45.400 --> 07:47.400] 啊我想起来了
[07:47.400 --> 07:48.400] 实现不是很重要
[07:48.400 --> 07:49.400] 我现在明白了
[07:49.400 --> 07:50.400] 我再跟你们讲一下
[07:50.400 --> 07:51.400] 我刚刚讲错了
[07:51.400 --> 07:54.400] 就是说没有data class的时候
[07:54.400 --> 07:56.400] 你在class里面写一个a等于0
[07:56.400 --> 07:58.400] 那这个a就是class的属性
[07:58.400 --> 07:58.400] 对吧
[07:58.400 --> 08:00.400] 它是它的值是0
[08:00.400 --> 08:02.400] 但如果你那个class被装饰了
[08:02.400 --> 08:03.400] 把data class装饰了
[08:03.400 --> 08:05.400] 你写一个a等于0
[08:05.400 --> 08:07.400] 然后你生成init的方法的时候
[08:07.400 --> 08:09.400] 这个init的方法的那个
[08:09.400 --> 08:12.400] 那个声明里面就有一个a等于0
[08:12.400 --> 08:15.400] 就是说这个a是一个入参
[08:15.400 --> 08:17.400] 但是它有一个默认值是0
[08:17.400 --> 08:21.400] 这个a依然是一个对象的属性
[08:21.400 --> 08:22.400] 不是一个class的属性
[08:22.400 --> 08:24.400] 啊我看到了
[08:24.400 --> 08:25.400] 我看到文档里确实是
[08:25.400 --> 08:28.400] 如果你付了值的话
[08:28.400 --> 08:30.400] 它是class attribute
[08:30.400 --> 08:33.400] 文档里说的class attribute的意思是
[08:33.400 --> 08:35.400] 在我没有实际化的时候
[08:35.400 --> 08:37.400] 我可以通过直接
[08:37.400 --> 08:40.400] 点这个attribute拿到这个属性吗
[08:40.400 --> 08:42.400] 对对是这样
[08:42.400 --> 08:43.400] 你这个地方说错了
[08:43.400 --> 08:44.400] 它其实是哪个都存的
[08:44.400 --> 08:46.400] 因为你a等于0之后
[08:46.400 --> 08:48.400] 然后你cf.a等于它
[08:48.400 --> 08:50.400] 实际上是你在你的instance的dict里面
[08:50.400 --> 08:51.400] 新建的一个变量
[08:51.400 --> 08:54.400] 而你class的attribute是一直存在的
[08:54.400 --> 08:56.400] 只是说你的查找规则
[08:56.400 --> 08:57.400] 在第一步查找的时候
[08:57.400 --> 08:59.400] 就给你返回了
[08:59.400 --> 09:02.400] 就是两个其实都会声明是吗
[09:02.400 --> 09:04.400] 你class attribute是肯定还存在的
[09:04.400 --> 09:07.400] 然后只是说我后面在initial的时候
[09:07.400 --> 09:08.400] 然后initial的时候
[09:08.400 --> 09:09.400] 我给你那个一个
[09:09.400 --> 09:11.400] 就是说是创建了一个instance变量
[09:11.400 --> 09:13.400] 然后你后面的话
[09:13.400 --> 09:14.400] 就因为查找规则
[09:14.400 --> 09:16.400] 查找规则一般情况下默认的行为
[09:16.400 --> 09:19.400] 是你在查到instance的变量之后
[09:19.400 --> 09:22.400] 我就不再继续向上查找
[09:22.400 --> 09:23.400] 所以说这个地方的话
[09:23.400 --> 09:25.400] 就是只是说做了这样一个操作而已
[09:25.400 --> 09:28.400] 但是它本质上还是会变成
[09:28.400 --> 09:30.400] 一个class attribute
[09:30.400 --> 09:32.400] 就是ManyShaka说的那个
[09:32.400 --> 09:33.400] 我还是不太明白
[09:33.400 --> 09:36.400] 就是这个值你的意思是
[09:36.400 --> 09:38.400] 它会同时变成class的属性
[09:38.400 --> 09:40.400] 以及对象的属性吗
[09:40.400 --> 09:42.400] 听起来是这样的
[09:42.400 --> 09:43.400] 因为如果不这样的话
[09:43.400 --> 09:46.400] 它确实是要去修改inspect的行为
[09:46.400 --> 09:47.400] 对两个都
[09:47.400 --> 09:50.400] 如果是按照新淘说的
[09:50.400 --> 09:51.400] 因为我觉得挺没用
[09:51.400 --> 09:52.400] 如果按照新淘说的
[09:52.400 --> 09:54.400] 它会在那个initial的时候
[09:54.400 --> 09:55.400] 生成一个默认变量
[09:55.400 --> 09:56.400] 然后创建进去
[09:56.400 --> 09:58.400] 然后复制给instance的话
[09:58.400 --> 10:00.400] 那么这个东西毫无疑问就两个了
[10:00.400 --> 10:03.400] 好像确实会这样
[10:03.400 --> 10:05.400] 对是的
[10:05.400 --> 10:07.400] 那还是我第一次说的
[10:07.400 --> 10:08.400] 那个问题是对的
[10:08.400 --> 10:10.400] 就是你假如说给一个值
[10:10.400 --> 10:11.400] 复制成默认值的话
[10:11.400 --> 10:14.400] 那这个变量就会变成一个class的属性
[10:14.400 --> 10:16.400] 因为本身你本身就是
[10:16.400 --> 10:18.400] 这个是符合常理的
[10:18.400 --> 10:21.400] 然后就说是你其实相当于说
[10:21.400 --> 10:23.400] 你其实相当于说
[10:23.400 --> 10:25.400] 我就是只是做了一个
[10:25.400 --> 10:28.400] 那个就instance复制的操作
[10:28.400 --> 10:31.400] 然后你class的HTML是不受影响的
[10:31.400 --> 10:33.400] 然后你instance
[10:33.400 --> 10:35.400] 然后复制之后就其实相当于说
[10:35.400 --> 10:36.400] 我查找的时候
[10:36.400 --> 10:38.400] 我就只查找了instance这一层
[10:38.400 --> 10:41.400] 其余的时候我不上传就行了
[10:41.400 --> 10:43.400] 对
[10:43.400 --> 10:44.400] 对是的
[10:44.400 --> 10:46.400] 这样的话
[10:46.400 --> 10:48.400] 其实这个类的属性里面
[10:48.400 --> 10:50.400] 有一个这样的名字的变量
[10:50.400 --> 10:52.400] 然后实体化出来的对象
[10:52.400 --> 10:53.400] 也会有一个这样的变量
[10:53.400 --> 10:56.400] 但是我们因为我们总是通过
[10:56.400 --> 10:58.400] 那个实例来调用的
[10:58.400 --> 11:02.400] 所以类上那个变量相当于是没有用的
[11:02.400 --> 11:03.400] 是的
[11:03.400 --> 11:06.400] 实际上你复制成class属性
[11:06.400 --> 11:07.400] 一般情况下没什么问题
[11:07.400 --> 11:12.400] 因为你那个你data class都是基于instance级别的
[11:12.400 --> 11:14.400] 所以说你基本上不太可能说我直接类去调用
[11:14.400 --> 11:18.400] 它的那个data class应该是不生效的
[11:18.400 --> 11:19.400] 对
[11:19.400 --> 11:21.400] 来要不我们换一个问题
[11:21.400 --> 11:23.400] 好我们刚刚聊到哪了
[11:23.400 --> 11:24.400] data class
[11:24.400 --> 11:28.400] 然后我们就这data class进行了深入的讨论
[11:28.400 --> 11:30.400] 但是我觉得data class很方便
[11:30.400 --> 11:34.400] 就是其实大部分时候我们的init
[11:34.400 --> 11:36.400] 往往就是为了设置一些初始变量
[11:36.400 --> 11:40.400] 就很少会说在里面设置一些行为之类的
[11:40.400 --> 11:42.400] 当然我有看到一些代码init的时候
[11:42.400 --> 11:45.400] 会调用函数去做一些行为
[11:45.400 --> 11:48.400] 但是更多的就是设置这些值
[11:48.400 --> 11:49.400] 对的确是
[11:49.400 --> 11:51.400] 但是像比如说有些的确很常
[11:51.400 --> 11:53.400] 其实在init里面去设置值
[11:53.400 --> 11:55.400] 其实也是挺常见的
[11:55.400 --> 11:57.400] 诶诶陈真我还有一个问题啊
[11:57.400 --> 12:01.400] 就是data class因为它其实提供了默认的init方法
[12:01.400 --> 12:01.400] 对吧
[12:01.400 --> 12:05.400] 那我能不能比如说它有没有什么提供一个特殊的方法
[12:05.400 --> 12:09.400] 我可以自己写init的时候调到data class的init
[12:09.400 --> 12:11.400] 这样我就相当于是我可以把keywords
[12:11.400 --> 12:13.400] 整体的先传给它的init
[12:13.400 --> 12:16.400] 让它帮我init所有的变量
[12:16.400 --> 12:18.400] 然后如果真的有行为的话
[12:18.400 --> 12:21.400] 我再之后我再追加我自己想要的行为
[12:21.400 --> 12:24.400] 好像是就是你在里面不是定义init了
[12:24.400 --> 12:27.400] 你好像可以写一个叫其他名字的方法
[12:27.400 --> 12:30.400] 然后它写的那个init会调用你
[12:30.400 --> 12:32.400] 嗯啊它会调用我是吗
[12:32.400 --> 12:34.400] 就是我注册一下相当于是
[12:34.400 --> 12:37.400] 对但是我不确定我看一下
[12:37.400 --> 12:41.400] 它里面是有个post的init processing
[12:41.400 --> 12:43.400] 对对对post的init
[12:43.400 --> 12:45.400] 这个名字就叫post的init
[12:45.400 --> 12:47.400] 然后也是一个data method
[12:47.400 --> 12:48.400] 对对对
[12:48.400 --> 12:50.400] 我觉得这样还
[12:50.400 --> 12:53.400] 我了解到这个之后
[12:53.400 --> 12:55.400] 我觉得我还挺喜欢这种方式的
[12:55.400 --> 12:56.400] 就是我的
[12:56.400 --> 12:59.400] 将于是我的我就可以定义
[12:59.400 --> 13:00.400] 我的对象属性是什么
[13:00.400 --> 13:02.400] 就是显示的来声明定义
[13:02.400 --> 13:04.400] 对生成完之后如果有追加行为
[13:04.400 --> 13:07.400] 那其实就有点像各种构造方法里面
[13:07.400 --> 13:11.400] 我最后再去再去执行一下
[13:11.400 --> 13:13.400] 对那个post的init
[13:13.400 --> 13:15.400] 就是相当于完全执行完的init在执行里
[13:15.400 --> 13:18.400] 比如说你这个class里面有a跟b
[13:18.400 --> 13:22.400] 然后你可以在post的init里面写self.c
[13:22.400 --> 13:24.400] 等于self.a加self.b
[13:24.400 --> 13:25.400] 学习到了
[13:25.400 --> 13:29.400] 我觉得是一个比较比较新的方式
[13:29.400 --> 13:32.400] 可以来做一些这种对象的操作
[13:32.400 --> 13:33.400] 是的啊
[13:33.400 --> 13:35.400] 我觉得反正是我觉得data class
[13:35.400 --> 13:37.400] 听今天我刚才看一下
[13:37.400 --> 13:39.400] 我觉得以后感觉可以用起来了
[13:39.400 --> 13:41.400] 实际上我现在也不怎么写python
[13:41.400 --> 13:44.400] 可以为了data class开始写python
[13:44.400 --> 13:48.400] 我现在也就一些sales project
[13:48.400 --> 13:51.400] 或者说我自己的一些在做一些写quantum
[13:51.400 --> 13:52.400] 写SDK的时候
[13:52.400 --> 13:54.400] 我自己比如说我最近在做
[13:54.400 --> 13:58.400] 那个一个工作室在做那个siggroup
[13:58.400 --> 14:01.400] Linux下面siggroup的那个python SDK
[14:01.400 --> 14:03.400] 之前我试图想促成
[14:03.400 --> 14:06.400] 因为我当时的background是这样
[14:06.400 --> 14:10.400] 就是比如说大家在这种在一起服务的时候
[14:10.400 --> 14:12.400] 一般就比如说g-unico那种形式
[14:12.400 --> 14:16.400] 你会从multiprocessing
[14:16.400 --> 14:18.400] 或是os里面去引入CPU count
[14:18.400 --> 14:20.400] 就是查看他的CPU count对吧
[14:20.400 --> 14:22.400] 但是在默认的情况下
[14:22.400 --> 14:24.400] 容器你比如说你在容器里面的时候
[14:24.400 --> 14:27.400] 你的CPU count是你的物理机的规格
[14:27.400 --> 14:30.400] 就是说你的宿主机的实际上的CPU count
[14:30.400 --> 14:32.400] 而不是你容器里面的limit
[14:32.400 --> 14:33.400] 所以说这个时候
[14:33.400 --> 14:35.400] 当你在容器里面受到一些
[14:35.400 --> 14:37.400] 有CPU一些count的一些limit的时候
[14:37.400 --> 14:39.400] 你的这个时候在用宿主机的limit
[14:39.400 --> 14:41.400] 就会比较受到一些缺陷
[14:41.400 --> 14:43.400] 而且包括还有它的memory usage
[14:43.400 --> 14:46.400] 就是memory limit这种东西一套
[14:46.400 --> 14:48.400] 其实上这个东西就衍生出来另外一个问题
[14:48.400 --> 14:51.400] 就是说python目前还是没有一套比较OK了
[14:51.400 --> 14:55.400] 对于cgroup这套操作的一个SDK
[14:55.400 --> 14:58.400] 让大家可以去管理查看它相关的信息
[15:00.400 --> 15:01.400] 我觉得有点跑题
[15:01.400 --> 15:03.400] 但是我还是想问一下
[15:03.400 --> 15:06.400] 就是python其实还是有场景的
[15:06.400 --> 15:07.400] 但是我觉得比较少
[15:07.400 --> 15:09.400] 因为python有必要获取
[15:09.400 --> 15:11.400] 这个机器有多少个核吗
[15:12.400 --> 15:16.400] 对因为一般不是我的意思是
[15:16.400 --> 15:19.400] 就是代码本身执行代码本身
[15:19.400 --> 15:21.400] 有必要知道自己有多少核吗
[15:21.400 --> 15:24.400] 因为它其实可以通过web来控制多进程模型
[15:25.400 --> 15:27.400] 对它和golang还是有一些区别
[15:27.400 --> 15:29.400] 就golang我可能要起n个golang
[15:29.400 --> 15:31.400] 然后我可以直接来多核
[15:31.400 --> 15:32.400] 但是python比如说多核
[15:32.400 --> 15:34.400] 其实就是多进程模型
[15:35.400 --> 15:36.400] 对那多进程模型
[15:36.400 --> 15:39.400] 比如说我们说gunicorn这种的话
[15:39.400 --> 15:41.400] 当然gunicorn也是python写的
[15:42.400 --> 15:45.400] 但是其实就在gunicorn层面
[15:45.400 --> 15:50.400] 它其实就通过进程和这个就可以来做这个事
[15:51.400 --> 15:53.400] 对你其实本身还有一些代码
[15:53.400 --> 15:56.400] 是本身就是说是要去获取它内部的
[15:56.400 --> 15:58.400] 就比如说你LPS或者说状态的
[15:58.400 --> 16:00.400] 你要去获取它的内部的CPU核数
[16:00.400 --> 16:02.400] 或者说是它内存的限制
[16:02.400 --> 16:05.400] 这个问题就并不仅仅限于说
[16:05.400 --> 16:07.400] 我是内存的核数对吧
[16:07.400 --> 16:09.400] 就比如说我举个例子
[16:10.400 --> 16:11.400] 我起了一个服务
[16:12.400 --> 16:14.400] 我容器里面有一个就是健康脚本
[16:14.400 --> 16:15.400] 就是我起了一个服务
[16:15.400 --> 16:17.400] 一个主服务一个健康脚本
[16:17.400 --> 16:20.400] 然后我健康脚本需要检查我容器里面
[16:20.400 --> 16:26.400] 我整体的内存现在使用和内存限制之间的状况
[16:26.400 --> 16:28.400] 对然后这个时候就是一些
[16:28.400 --> 16:32.400] 比较偏需要去暴露底层信息的场景
[16:32.400 --> 16:34.400] 这种就不太OK了
[16:34.400 --> 16:36.400] 好我们把话题拉回来
[16:38.400 --> 16:40.400] 对拉回来
[16:40.400 --> 16:44.400] 我先说一句Data Class我们刚才聊完了吗
[16:45.400 --> 16:46.400] 算聊完了吧
[16:46.400 --> 16:48.400] 新涛你觉得有什么
[16:48.400 --> 16:51.400] 派磁3比较吸引人的新特性吗
[16:51.400 --> 16:53.400] 陈老师刚刚还想
[16:53.400 --> 16:54.400] 还有没说完吧
[16:54.400 --> 16:56.400] 除了这个Data Class
[16:56.400 --> 16:58.400] 我知道一个是有序的字典
[16:58.400 --> 16:59.400] 这算是一个
[16:59.400 --> 17:02.400] 但是目前好像还没有用到过
[17:02.400 --> 17:05.400] 你们之前在工作中有会去到
[17:05.400 --> 17:06.400] 就是又想说个字典
[17:06.400 --> 17:09.400] 但又想要保持某种有序吗
[17:10.400 --> 17:13.400] 这个我先说一个吧
[17:13.400 --> 17:15.400] 就是但是其实没有用到
[17:15.400 --> 17:16.400] 但是我能想到一个例子
[17:16.400 --> 17:18.400] 就是比如说Jungle的RM
[17:18.400 --> 17:20.400] 你如果写那个choice
[17:20.400 --> 17:22.400] 就是之前你们写过吗
[17:22.400 --> 17:23.400] 就是Jungle的choice
[17:23.400 --> 17:24.400] 有
[17:24.400 --> 17:26.400] 这个数据库的属性只能选这个
[17:26.400 --> 17:28.400] 比如说要么是性别
[17:28.400 --> 17:29.400] 要么是男
[17:29.400 --> 17:30.400] 要么是女
[17:30.400 --> 17:31.400] 要么是不想透露
[17:31.400 --> 17:32.400] 这三个选项
[17:32.400 --> 17:33.400] 你就把它写到一个choice里面
[17:33.400 --> 17:34.400] 这个choice要怎么写呢
[17:34.400 --> 17:36.400] 要一个list
[17:36.400 --> 17:38.400] 然后里面有三个tuple
[17:38.400 --> 17:40.400] 每一个tuple都是一个
[17:40.400 --> 17:42.400] 比如说female
[17:42.400 --> 17:44.400] 然后逗号女生
[17:44.400 --> 17:46.400] 然后这个女生就是用来显示的
[17:46.400 --> 17:47.400] 然后这个female
[17:47.400 --> 17:50.400] 这个就是用来存放到数据库里面去的
[17:50.400 --> 17:51.400] 然后你们想一下
[17:51.400 --> 17:52.400] 为什么要写成一个list
[17:52.400 --> 17:53.400] 里面有三个tuple
[17:53.400 --> 17:55.400] 这个有点复杂的结构呢
[17:55.400 --> 17:56.400] 就是因为
[17:56.400 --> 17:57.400] 如果像
[17:57.400 --> 18:00.400] 如果你要保证它的顺序
[18:00.400 --> 18:01.400] 如果你不这么写的话
[18:01.400 --> 18:02.400] 对吧
[18:02.400 --> 18:03.400] 你写一个字典
[18:03.400 --> 18:05.400] 这放在之前的pattern里面
[18:05.400 --> 18:07.400] 你每一次根据这个class
[18:07.400 --> 18:09.400] 来生成你的migration的时候
[18:09.400 --> 18:11.400] 你跑十次
[18:11.400 --> 18:12.400] 可能会生成
[18:12.400 --> 18:14.400] 就是四五次migration的file
[18:14.400 --> 18:16.400] 但其实里面什么都没做
[18:16.400 --> 18:17.400] 为什么会生成四五次
[18:17.400 --> 18:18.400] 就是因为
[18:18.400 --> 18:20.400] 它每次生成的这个choice
[18:20.400 --> 18:21.400] Jungle认为是不一样的
[18:21.400 --> 18:23.400] 因为字典是没有顺序的
[18:23.400 --> 18:25.400] 所以它就要在一个
[18:25.400 --> 18:27.400] 用一个list里面放一个
[18:27.400 --> 18:30.400] 一对一对的pair这样的数据来放这个
[18:30.400 --> 18:31.400] 有点
[18:31.400 --> 18:32.400] 有点
[18:32.400 --> 18:34.400] 不是很直观嘛
[18:34.400 --> 18:35.400] 但如果字典是有序的
[18:35.400 --> 18:38.400] 那你就可以直接用字典来放这个choice
[18:38.400 --> 18:40.400] 就非常明了
[18:40.400 --> 18:41.400] 你这个话
[18:41.400 --> 18:43.400] 其实之前是有两种情况
[18:43.400 --> 18:45.400] 第一种情况是在pattern2和pattern3之间的隔离
[18:45.400 --> 18:46.400] 其实因为
[18:46.400 --> 18:50.400] 因为它之前所有字典默认的行为是
[18:50.400 --> 18:52.400] 默认行为说我根据那个
[18:52.400 --> 18:55.400] 它的hash值存放的槽来的
[18:55.400 --> 18:56.400] 然后在pattern2时期
[18:56.400 --> 18:58.400] 它所有的那个
[18:58.400 --> 18:59.400] hash值
[18:59.400 --> 19:01.400] 它的就是说是都是都会是一样的
[19:01.400 --> 19:05.400] 因为它的随机数种子是默认是固定的
[19:05.400 --> 19:07.400] 然后在pattern3的时候就不一样
[19:07.400 --> 19:08.400] 我的另外
[19:08.400 --> 19:09.400] 我举个另外一个场景吧
[19:09.400 --> 19:10.400] 它是这样
[19:10.400 --> 19:12.400] 就是金融验签的场合
[19:12.400 --> 19:14.400] 就是有一些金融公司
[19:14.400 --> 19:15.400] 就比如说你去调支付
[19:15.400 --> 19:17.400] 或者其他接口的时候存在验签
[19:17.400 --> 19:18.400] 验签的时候
[19:18.400 --> 19:20.400] 它有一些会很奇葩的
[19:20.400 --> 19:22.400] 对于它里面的参数顺序有要求
[19:22.400 --> 19:25.400] 然后你需要去把它生成的那个接色
[19:25.400 --> 19:27.400] 再做一次md5之类的
[19:27.400 --> 19:30.400] 那么这个时候order的dict就非常有用了
[19:30.400 --> 19:32.400] 你说的是微信是吧
[19:32.400 --> 19:35.400] 其实不仅是微信
[19:35.400 --> 19:37.400] 我就举个很简单的例子
[19:37.400 --> 19:40.400] 因为是它一般情况下支付的时候
[19:40.400 --> 19:41.400] 它会给你下发一个密钥
[19:41.400 --> 19:43.400] 它会给你下发一个密钥之后
[19:43.400 --> 19:45.400] 你的签名是基于这个密钥来做的
[19:45.400 --> 19:47.400] 就是说是验证你的独一无二的身份
[19:47.400 --> 19:49.400] 然后这个时候你的签名的本体
[19:49.400 --> 19:51.400] 是你的一段信息
[19:51.400 --> 19:55.400] 那么你需要保证你的服务端和你的客户端
[19:55.400 --> 19:57.400] 然后就是说是你们之间的信息
[19:57.400 --> 20:00.400] 在对于同一组数据生成的信息
[20:00.400 --> 20:02.400] 是一定是要有一个order的
[20:02.400 --> 20:04.400] 这个时候是怎么办呢
[20:04.400 --> 20:06.400] 最简单的就是说是基于字典序的一个接色
[20:06.400 --> 20:09.400] 对就基于key的一个字典序的接色
[20:09.400 --> 20:11.400] 不然的话比如说我python默认是有序的
[20:11.400 --> 20:13.400] 我加瓦牌是默认是无序的
[20:13.400 --> 20:15.400] 我直接接色拿过去之后
[20:15.400 --> 20:17.400] 我直接序列画质
[20:17.400 --> 20:19.400] 对懂我意思了吧
[20:19.400 --> 20:21.400] 就是一个设计的很蠢的API
[20:21.400 --> 20:23.400] 对对对
[20:23.400 --> 20:25.400] 其实这个东西的话也是我觉得
[20:25.400 --> 20:28.400] 如果说仔细想一想的话也是make sense的
[20:28.400 --> 20:30.400] 因为就是说是你自己要去
[20:30.400 --> 20:32.400] 因为你是要保证数据一致嘛
[20:32.400 --> 20:34.400] 你两边数据是一致的对吧
[20:34.400 --> 20:38.400] 对他就是相当于验证你的请求的时候
[20:38.400 --> 20:39.400] 把Jason sort一下
[20:39.400 --> 20:40.400] 然后再进行
[20:40.400 --> 20:42.400] 我刚刚说的地方就是可能跟你不一样
[20:42.400 --> 20:44.400] 我觉得把Jason就是sort一下
[20:44.400 --> 20:46.400] 然后再进行加密是比较合理的
[20:46.400 --> 20:47.400] 然后微信的支付
[20:47.400 --> 20:49.400] 微信的API里面
[20:49.400 --> 20:52.400] 他要求URL的那个参数也是顺序的
[20:52.400 --> 20:53.400] 比如说对我
[20:53.400 --> 20:55.400] 我想说的是他这个地方就比较恶心
[20:55.400 --> 20:58.400] 这个很多HTC锐库根本就不会考虑这个
[20:58.400 --> 21:00.400] 对吧就没有人要求这个
[21:00.400 --> 21:02.400] 你像很多网关
[21:02.400 --> 21:04.400] 就比如说万一我们公司的网关是
[21:04.400 --> 21:07.400] 就是统一请求的那个服务器会把它拆开
[21:07.400 --> 21:09.400] 然后再验证一下再发出去
[21:09.400 --> 21:12.400] 那他又不会去保证这个顺序对吧
[21:12.400 --> 21:15.400] 中间很多层可能都不会去保证这个顺序
[21:15.400 --> 21:17.400] 好先喷到这个地方来
[21:17.400 --> 21:19.400] 反正是做支付再吐槽一句
[21:19.400 --> 21:21.400] 做对接支付真的是一件很恶心的事
[21:21.400 --> 21:23.400] 不仅是微信已经算好的了
[21:23.400 --> 21:25.400] 你对接其他支付你就知道了
[21:25.400 --> 21:26.400] 微信已经算业界良心了
[21:26.400 --> 21:28.400] 特别是还有很多国标加密的
[21:28.400 --> 21:33.400] 然后还有比如说是那个其他奇奇怪怪的接口的
[21:33.400 --> 21:35.400] 我擦真的不吐槽了
[21:35.400 --> 21:39.400] 你见过把body放在
[21:39.400 --> 21:42.400] 把body放在那个header
[21:42.400 --> 21:46.400] 把铺头的就是把body放在header里面的请求吗
[21:46.400 --> 21:49.400] 我见过我就不吐槽了
[21:49.400 --> 21:50.400] 我就不吐槽了
[21:50.400 --> 21:52.400] 因为这个东西我就不吐槽了
[21:52.400 --> 21:54.400] 为了避免律师汉我就不吐槽了
[21:54.400 --> 21:55.400] 我就只问你去
[21:55.400 --> 21:57.400] 你见过把body放在header里面
[21:57.400 --> 21:59.400] 要求把body放在header里面的请求吗
[21:59.400 --> 22:01.400] 我见过把header放到body里面的
[22:01.400 --> 22:03.400] 那是小意思的
[22:03.400 --> 22:05.400] 好好好我们继续继续
[22:05.400 --> 22:07.400] 我们不然今天就要变成吐槽大会了
[22:07.400 --> 22:08.400] 继续
[22:08.400 --> 22:09.400] 好啊
[22:09.400 --> 22:11.400] 我其实会遇到很多类似的场景吧
[22:11.400 --> 22:12.400] 就是什么场景呢
[22:12.400 --> 22:14.400] 就是你有一批数据
[22:14.400 --> 22:15.400] 你的业务场景
[22:15.400 --> 22:16.400] 它是需要它有序的
[22:16.400 --> 22:17.400] 以及呢
[22:17.400 --> 22:19.400] 你在这个函数里
[22:19.400 --> 22:23.400] 你可能还要在这个这批数据里做快速查找操作
[22:23.400 --> 22:26.400] 比如说过滤数据啊巴拉巴拉的这种
[22:26.400 --> 22:28.400] 对那你没有有序字典之前
[22:28.400 --> 22:31.400] 要不然你选择用第三方的有序字典
[22:31.400 --> 22:33.400] 要不然你就选择自己维持两个结构吧
[22:33.400 --> 22:35.400] 一个就是有序的list
[22:35.400 --> 22:37.400] 一个就是你自己再搞一个dict
[22:37.400 --> 22:39.400] 然后dict用来做查询
[22:39.400 --> 22:42.400] list用来做最后的结果的输出
[22:42.400 --> 22:45.400] 比如说过滤啊修改啊调整啊之类的就特别烦
[22:45.400 --> 22:47.400] 就是如果你本身就是一个有序的
[22:47.400 --> 22:49.400] 但是你要有查找场景
[22:49.400 --> 22:52.400] 其实就很适合用有序字典嘛
[22:52.400 --> 22:55.400] 但是我觉得微信那个真的我不太懂啊
[22:55.400 --> 22:59.400] 我觉得是有什么安全因素吗
[22:59.400 --> 23:02.400] 不然的话其实是应该他们自己来抽参数
[23:02.400 --> 23:05.400] 然后做顺序和校验
[23:05.400 --> 23:07.400] 我们第一个聊的比较久了
[23:07.400 --> 23:10.400] 然后要不我接着再来说一下吧
[23:10.400 --> 23:11.400] 好啊
[23:11.400 --> 23:13.400] Panasonic里面我觉得用的比较爽的就是
[23:13.400 --> 23:14.400] Fstream
[23:14.400 --> 23:18.400] 然后我其实去参与了一个开源项目嘛
[23:18.400 --> 23:22.400] 就PTC-LI是那个Postgres的那个命令行工具
[23:22.400 --> 23:24.400] 然后我去的第一件事就是把
[23:24.400 --> 23:28.400] 2.7 3.3 3.4 3.5全都给放弃支持掉了
[23:28.400 --> 23:30.400] 然后我就可以开始用Fstream下下发了
[23:30.400 --> 23:34.400] 你觉得这个比较爽的点是什么对你来说
[23:34.400 --> 23:38.400] 就Python里面的Fstream是直接可以引用
[23:38.400 --> 23:40.400] 就是我当今可用的那个变量的对吧
[23:40.400 --> 23:41.400] 其他的你得
[23:41.400 --> 23:45.400] 其他的像之前的Python或者Java或者其他的
[23:45.400 --> 23:46.400] 你都得用模板
[23:46.400 --> 23:48.400] 然后加站位服务来拼那个
[23:48.400 --> 23:50.400] 就不是很直观嘛
[23:50.400 --> 23:51.400] 嗯
[23:51.400 --> 23:56.400] 然后现在的Python的那个Fstream甚至还支持
[23:56.400 --> 23:59.400] 就是你的中括号里面写一个Fold等于号
[23:59.400 --> 24:00.400] 然后就没了
[24:00.400 --> 24:01.400] 外面是个大括号嘛
[24:01.400 --> 24:03.400] 然后他打印的时候会自动打出来
[24:03.400 --> 24:05.400] 这个Fold等于
[24:05.400 --> 24:07.400] 然后是跟着他实际的变样
[24:07.400 --> 24:09.400] 他实际上是可以写那个啊
[24:09.400 --> 24:11.400] 就是说是Dual Function Method之类的
[24:11.400 --> 24:13.400] 其他一些的东西都可以
[24:13.400 --> 24:15.400] 嗯不是我是说他后来新加了这个
[24:15.400 --> 24:17.400] 他可以把那个用等于号来
[24:17.400 --> 24:19.400] 来表示出就是什么等于什么
[24:19.400 --> 24:20.400] OK
[24:20.400 --> 24:22.400] 就是这个调调试起来特别方便
[24:22.400 --> 24:23.400] 嗯
[24:23.400 --> 24:24.400] 你能懂我的意思吧
[24:24.400 --> 24:26.400] 就是能对
[24:26.400 --> 24:27.400] 我纠正你一点
[24:27.400 --> 24:29.400] 其实这个其他很多语言都有
[24:29.400 --> 24:31.400] 像比如说我现在就写的很爽的
[24:31.400 --> 24:33.400] 他也是还有C-Shape之类的都是有的
[24:33.400 --> 24:34.400] 哦
[24:34.400 --> 24:35.400] C-Shape也有
[24:35.400 --> 24:36.400] Kotlin现在有很多特性
[24:36.400 --> 24:37.400] 其实挺好的
[24:37.400 --> 24:39.400] 他这个语言比较新嘛
[24:39.400 --> 24:41.400] 对Kotlin他许多很多Design我很喜欢
[24:41.400 --> 24:42.400] 嗯
[24:42.400 --> 24:45.400] 我也是我看过稍微看过了解过几篇
[24:45.400 --> 24:46.400] Kotlin的
[24:46.400 --> 24:47.400] 然后
[24:47.400 --> 24:48.400] 嗯
[24:48.400 --> 24:51.400] 我想吐槽Fstream的一点就是
[24:51.400 --> 24:53.400] 如果让我来设计这个Fstream的话
[24:53.400 --> 24:54.400] 我会把那个
[24:54.400 --> 24:55.400] F前缀嘛
[24:55.400 --> 24:57.400] 放在那个双引号的后面
[24:57.400 --> 24:58.400] 因为
[24:58.400 --> 24:59.400] 因为我比如说
[24:59.400 --> 25:01.400] logger.info的时候
[25:01.400 --> 25:04.400] 我经常就是打了第一个引号
[25:04.400 --> 25:06.400] 然后后面打打打打
[25:06.400 --> 25:07.400] 写了一行字
[25:07.400 --> 25:09.400] 然后我想把某个变量打出来
[25:09.400 --> 25:10.400] 然后我开始写这个括号
[25:10.400 --> 25:12.400] 发现我这个Stream其实没有加F
[25:12.400 --> 25:14.400] 然后我就把光标跳到前面去加F
[25:14.400 --> 25:15.400] 对吧
[25:15.400 --> 25:17.400] 然后我跳到原来的位置写了这个变量
[25:17.400 --> 25:19.400] 然后打另一个引号
[25:19.400 --> 25:20.400] 然后括号
[25:20.400 --> 25:22.400] 这样一行日志这个代码我就写完了
[25:22.400 --> 25:24.400] 但是如果我这个F可以加在后面的话
[25:24.400 --> 25:25.400] 我就可以直接写代码
[25:25.400 --> 25:26.400] 然后中间
[25:26.400 --> 25:28.400] 无论他是一个纯的字符串
[25:28.400 --> 25:29.400] 还是一个
[25:29.400 --> 25:31.400] 要引用变量的字符串
[25:31.400 --> 25:34.400] 我其实都可以在最后的时候再决定
[25:34.400 --> 25:35.400] 要不要加这个F
[25:36.400 --> 25:37.400] 其实他就是
[25:37.400 --> 25:40.400] 他其实是为了简化那个编译器那边的
[25:40.400 --> 25:41.400] 实现难度嘛
[25:41.400 --> 25:43.400] 就是说你在那个语法解析的时候
[25:43.400 --> 25:44.400] 对
[25:44.400 --> 25:45.400] 可以理解
[25:45.400 --> 25:47.400] 对他其实做了个tradeoff嘛
[25:47.400 --> 25:49.400] 我觉得对于阅读代码也是更好的
[25:49.400 --> 25:50.400] 对对
[25:50.400 --> 25:52.400] 对我觉得是对对对阅读代码
[25:52.400 --> 25:53.400] 其实也是更好的
[25:53.400 --> 25:54.400] 对
[25:54.400 --> 25:56.400] 你如果看一些代码
[25:56.400 --> 25:57.400] 然后你看这一行太长了
[25:57.400 --> 25:58.400] 你不会看
[25:58.400 --> 26:00.400] 然后你想不到后面还有个F对吧
[26:00.400 --> 26:01.400] 确实有这种问题
[26:02.400 --> 26:03.400] OK
[26:03.400 --> 26:05.400] 然后我最喜欢的其实就是type hint了
[26:05.400 --> 26:06.400] 对
[26:06.400 --> 26:07.400] 我最喜欢的就是type hint
[26:07.400 --> 26:09.400] 我现在在leak code上面刷旗
[26:09.400 --> 26:12.400] 我现在旗手都是from typing import xxx
[26:12.400 --> 26:13.400] 然后我先
[26:13.400 --> 26:14.400] 我先做
[26:14.400 --> 26:15.400] 我现在打周赛的时候
[26:15.400 --> 26:16.400] 我也是
[26:16.400 --> 26:17.400] 我先不会写正式代码
[26:17.400 --> 26:19.400] 然后我会先把他的那个
[26:19.400 --> 26:21.400] 比如说他有些Rx数之类的
[26:21.400 --> 26:23.400] 然后我会先把他的那个节点
[26:23.400 --> 26:25.400] 节点的type hint全部不齐
[26:25.400 --> 26:27.400] 比如说有些他没有用optional的
[26:27.400 --> 26:29.400] 我会先把optional给他补齐
[26:29.400 --> 26:30.400] 然后其他的东西
[26:30.400 --> 26:32.400] 我先把type hint给他补齐了之后
[26:32.400 --> 26:33.400] 我才开始写代码
[26:33.400 --> 26:37.400] 你做leak code的时候会用type hint
[26:37.400 --> 26:38.400] 你主要是
[26:38.400 --> 26:40.400] 主要是觉得优质是啥呢
[26:40.400 --> 26:43.400] 就是他可以帮你去做一些检查是吗
[26:43.400 --> 26:44.400] 对啊ID有好
[26:44.400 --> 26:46.400] 然后我可以在CI里面去支撑他
[26:46.400 --> 26:48.400] 你就是稍微大一点的项目
[26:48.400 --> 26:49.400] 用这个比较好
[26:49.400 --> 26:51.400] leak code有点夸张了
[26:53.400 --> 26:54.400] 我习惯了嘛
[26:54.400 --> 26:57.400] 现在我就先起手就type hint了嘛
[26:57.400 --> 27:00.400] leak code有很多人以写代码词短为荣
[27:00.400 --> 27:02.400] 你这样不是很不占优势吗
[27:02.400 --> 27:03.400] 我不喜欢
[27:03.400 --> 27:06.400] 你看到我之前在博客里面
[27:06.400 --> 27:09.400] 秀的代码都是全部是全type hint的
[27:09.400 --> 27:12.400] 我现在都把type hint做成了一个模板了
[27:12.400 --> 27:15.400] from typing import新建一个文体
[27:15.400 --> 27:17.400] 先from typing import了
[27:17.400 --> 27:20.400] 我觉得更多的好处应该是刚刚提到的
[27:20.400 --> 27:22.400] 在CI里面应该是可以做一些工作的
[27:22.400 --> 27:24.400] 这方面的经验
[27:24.400 --> 27:26.400] 我不知道可以再多介绍一下
[27:26.400 --> 27:28.400] 是的
[27:29.400 --> 27:31.400] 其实是两方面的花样
[27:31.400 --> 27:32.400] 第一个是依赖注入嘛
[27:32.400 --> 27:33.400] 就是说是第一个
[27:33.400 --> 27:35.400] 我是可以根据type hint
[27:35.400 --> 27:37.400] 去获取一些额外的信息
[27:37.400 --> 27:39.400] 我去获取一些额外的信息之后
[27:39.400 --> 27:41.400] 我举个例子像fastAPI里面的一个模式是
[27:41.400 --> 27:44.400] 我可以将我的response序列化之后
[27:44.400 --> 27:47.400] 不是我进来的时候是个阶层字符串对吧
[27:47.400 --> 27:49.400] 我进来的时候是个阶层字符串
[27:49.400 --> 27:51.400] 然后我可能会定义一些sigma对吧
[27:51.400 --> 27:52.400] 定义了一些sigma之后
[27:52.400 --> 27:54.400] 这就是一个model
[27:54.400 --> 27:56.400] 那么这个model里面就可能据说是我可以
[27:56.400 --> 27:57.400] 把我序列
[27:57.400 --> 27:59.400] 把我的原本的阶层信息
[27:59.400 --> 28:02.400] 就是说是序列化成这样一个model对吧
[28:02.400 --> 28:04.400] 对然后就然后这个时候
[28:04.400 --> 28:07.400] 在比如说在我一些场景的情况下
[28:07.400 --> 28:11.400] 我可以直接根据它接口所写的参数
[28:11.400 --> 28:13.400] 我app root路由之后
[28:13.400 --> 28:15.400] 对有个处理函数对吧
[28:15.400 --> 28:16.400] 有个处理函数之后
[28:16.400 --> 28:18.400] 那么我路由先进来的时候
[28:18.400 --> 28:19.400] 到了这个函数的时候
[28:19.400 --> 28:23.400] 我先根据它的函数的那个类型
[28:23.400 --> 28:25.400] 就是函数它参数的类型
[28:25.400 --> 28:27.400] 去获取到我是用哪个model
[28:27.400 --> 28:30.400] 然后我去把它里面阶层数据给序列化之后
[28:30.400 --> 28:31.400] 就是说是做
[28:31.400 --> 28:33.400] 然后序列化成这个model之后
[28:33.400 --> 28:34.400] 给它注入进去
[28:34.400 --> 28:36.400] 这个东西的话就说是我
[28:36.400 --> 28:39.400] 根据type hint可以做很多extra的
[28:39.400 --> 28:42.400] 就是说是但是很有用的一些操作
[28:42.400 --> 28:43.400] 第二个的话
[28:43.400 --> 28:46.400] 其实就是在那个生产上面
[28:46.400 --> 28:48.400] 你去生产上面
[28:48.400 --> 28:50.400] 就是你第一个写代码的时候
[28:50.400 --> 28:51.400] 你是id-friendly的
[28:51.400 --> 28:53.400] 就是说是用现在比较流行的话
[28:53.400 --> 28:54.400] 就是说id-friendly
[28:54.400 --> 28:55.400] 不管你是在VS code
[28:55.400 --> 28:57.400] 还是在那个PyCharm上面
[28:57.400 --> 29:00.400] 你都能够很好地得到代码提示
[29:00.400 --> 29:02.400] 第二个你是可以开mypy
[29:02.400 --> 29:04.400] 或者说是谷歌的pytype
[29:04.400 --> 29:08.400] 就是说是如果是你中间类型出现错误
[29:08.400 --> 29:11.400] 那么它是会给你就直接塞挂掉了
[29:11.400 --> 29:14.400] 我觉得这两个东西对于
[29:14.400 --> 29:16.400] 普通人来说还是很有用的
[29:16.400 --> 29:18.400] 我没有用过
[29:18.400 --> 29:19.400] 我想问一下
[29:19.400 --> 29:22.400] 就是如果真是真的在用CI的话
[29:22.400 --> 29:24.400] 就是你去修CI的时间多
[29:24.400 --> 29:27.400] 还是CI帮你修bug的时间多
[29:27.400 --> 29:32.400] 一般情况下我想想怎么说
[29:32.400 --> 29:34.400] 如果说是用IDE的话
[29:34.400 --> 29:36.400] 一般情况下很多低级的bug
[29:36.400 --> 29:38.400] 就是说是在加上type hint之后
[29:38.400 --> 29:39.400] 比如说低级的类型错误的bug
[29:39.400 --> 29:41.400] 其实在IDE中就能发现
[29:41.400 --> 29:43.400] CI就只是说加一个backup
[29:43.400 --> 29:45.400] 然后我之前在leak code上面
[29:45.400 --> 29:47.400] 还有一些我自己的代码
[29:47.400 --> 29:49.400] 的确是当时type hint写错了
[29:49.400 --> 29:51.400] 然后我的类型也写错了
[29:51.400 --> 29:53.400] 然后在mypy的时候就给我
[29:53.400 --> 29:55.400] 就这么报错了
[29:55.400 --> 29:58.400] 然后我觉得整体的话体验还是体感非常好
[29:58.400 --> 30:00.400] 对这是我的一点小经验
[30:00.400 --> 30:02.400] 好那有什么让你们不爽的地方吗
[30:02.400 --> 30:03.400] Path3
[30:03.400 --> 30:04.400] 对吧
[30:04.400 --> 30:07.400] 毕竟是breaking changes对吧
[30:07.400 --> 30:09.400] 572
[30:09.400 --> 30:11.400] 572你会用吗关键是
[30:11.400 --> 30:12.400] 我不会用啊
[30:12.400 --> 30:13.400] 但是我就只是
[30:13.400 --> 30:15.400] 觉得它很不爽而已啊
[30:17.400 --> 30:21.400] 我们还是和听众也解释一下572吧
[30:21.400 --> 30:23.400] 就是Assignment Expression
[30:23.400 --> 30:24.400] 海象操作服
[30:24.400 --> 30:27.400] 对这个我们之前其实也有聊过
[30:27.400 --> 30:31.400] 对然后大家也可以再去看一下那个PPP
[30:31.400 --> 30:32.400] 为什么觉得不爽呢
[30:32.400 --> 30:34.400] 我就觉得看着很不爽
[30:34.400 --> 30:35.400] 看着不爽是吗
[30:35.400 --> 30:36.400] 对我就单纯看着很不爽
[30:36.400 --> 30:37.400] 就是虽然我不用它
[30:37.400 --> 30:38.400] 我也不想用它
[30:38.400 --> 30:40.400] 但是就是会让你觉得很不爽是吗
[30:40.400 --> 30:41.400] 是是是
[30:41.400 --> 30:44.400] 没有它对我很重要对吧
[30:44.400 --> 30:46.400] 也许你去写一下勾就好了
[30:46.400 --> 30:47.400] 泉舟你呢
[30:47.400 --> 30:49.400] 这个没准备我想一下
[30:49.400 --> 30:50.400] 可以心跳心跳
[30:50.400 --> 30:53.400] 我没有吧
[30:53.400 --> 30:54.400] 没有没有
[30:54.400 --> 30:55.400] 好评如潮
[30:55.400 --> 30:59.400] 那我可以说整个不仅是Path3的我想吐槽的吗
[30:59.400 --> 31:00.400] 比如呢
[31:00.400 --> 31:02.400] 调试工具线上调试工具太缺乏了
[31:02.400 --> 31:04.400] 这个确实
[31:04.400 --> 31:06.400] 你是和Java对比是吗
[31:06.400 --> 31:10.400] 对就是包括和勾浪对比也不行啊
[31:10.400 --> 31:12.400] 你勾浪内置的Profile
[31:12.400 --> 31:14.400] 其实是能做很多的工作了
[31:14.400 --> 31:16.400] 就比如说你的某一些
[31:16.400 --> 31:18.400] 就是说是你内置的Mutix
[31:18.400 --> 31:19.400] 一直没有释放
[31:19.400 --> 31:21.400] 你在Profile上面是能看出来的
[31:21.400 --> 31:23.400] 然后比如说你内部的对象
[31:23.400 --> 31:24.400] 有多少对象
[31:24.400 --> 31:26.400] 然后它的内存构建是什么样的
[31:26.400 --> 31:27.400] 然后你目前的整个东西
[31:27.400 --> 31:29.400] 它调试工具太缺乏了
[31:29.400 --> 31:31.400] 我举两个很简单的
[31:31.400 --> 31:34.400] 我举两个很简单的例子
[31:34.400 --> 31:36.400] 就是说是一个吧
[31:36.400 --> 31:37.400] 就我之前在调试
[31:37.400 --> 31:40.400] 我们之前有个场景是
[31:40.400 --> 31:42.400] 有个情况是我们某一个服务
[31:42.400 --> 31:43.400] 有一段时间
[31:43.400 --> 31:46.400] 它是会内存急剧上升
[31:46.400 --> 31:47.400] 然后会比如说
[31:47.400 --> 31:49.400] 从直接40%的水位
[31:49.400 --> 31:51.400] 然后到80%的水位上
[31:51.400 --> 31:52.400] 然后这个时候毫无疑问
[31:52.400 --> 31:55.400] 就基本上可以断定为内存泄露了
[31:55.400 --> 31:56.400] 然后这个时候的话
[31:56.400 --> 31:57.400] 我们去首先check代码
[31:57.400 --> 32:00.400] 如果说没有内存泄露的逻辑情况下
[32:00.400 --> 32:03.400] 这个时候我就会去查一下
[32:03.400 --> 32:05.400] 看下它线上有没有什么其他的问题
[32:05.400 --> 32:06.400] 那么这个时候
[32:06.400 --> 32:08.400] 我就还需要去看它内存的分布
[32:08.400 --> 32:10.400] 然后我要去看它GC情况
[32:10.400 --> 32:11.400] 然后包括我要去
[32:11.400 --> 32:13.400] 到这个线程然后去
[32:13.400 --> 32:15.400] 那么这个时候就很恶心
[32:15.400 --> 32:16.400] 就说比如说我要去
[32:16.400 --> 32:18.400] 获取它内存信息
[32:18.400 --> 32:19.400] 对端信息之类的
[32:19.400 --> 32:21.400] 然后另外一个就在
[32:21.400 --> 32:23.400] 大家可能知道Python的
[32:23.400 --> 32:25.400] 一个性能工具分析工具之前
[32:25.400 --> 32:27.400] 我们也有推荐叫PyFrame
[32:27.400 --> 32:30.400] 是Uber还是哪个公司出的
[32:30.400 --> 32:31.400] Uber协调
[32:31.400 --> 32:35.400] 然后对在这个工具出来之前
[32:35.400 --> 32:38.400] 你其实是没有很好的办法
[32:38.400 --> 32:40.400] 去就是说是去trace你
[32:40.400 --> 32:41.400] 整个里面的函数调控站
[32:41.400 --> 32:43.400] 或者是其他的情况
[32:43.400 --> 32:45.400] 我觉得整体的调试工具和调试手段
[32:45.400 --> 32:47.400] 来说我还是
[32:47.400 --> 32:48.400] 准确说是有手段
[32:48.400 --> 32:49.400] 比如说我要去
[32:49.400 --> 32:51.400] 和他一起进行一个进程
[32:51.400 --> 32:52.400] 好简单
[32:52.400 --> 32:53.400] GDP进去
[32:53.400 --> 32:56.400] 然后再用其他的骚操作搞
[32:56.400 --> 32:57.400] 可以是可以
[32:57.400 --> 32:59.400] 但是太不友好了
[32:59.400 --> 33:00.400] 对这就是我的觉得
[33:00.400 --> 33:03.400] 我觉得它就是调试工具来讲的话
[33:03.400 --> 33:05.400] 太缺乏太不友好了
[33:05.400 --> 33:07.400] 而且就是说是整体
[33:07.400 --> 33:08.400] 你看像go
[33:08.400 --> 33:11.400] 其实你看像go那套东西simple
[33:11.400 --> 33:12.400] 但是好用
[33:12.400 --> 33:14.400] 你很简单的
[33:14.400 --> 33:16.400] 你既可以在你的测试线上
[33:16.400 --> 33:17.400] 比如说做开关
[33:17.400 --> 33:19.400] 把这些profile的接口调试出来
[33:19.400 --> 33:21.400] 然后你直接在线上去查看
[33:21.400 --> 33:22.400] 你线上服务的
[33:22.400 --> 33:23.400] 就是说是情况
[33:23.400 --> 33:25.400] 你也可以直接用profile
[33:25.400 --> 33:27.400] go profile的命令去和他一起进行
[33:27.400 --> 33:28.400] go进程
[33:28.400 --> 33:29.400] 他会进程
[33:29.400 --> 33:30.400] 他会帮你就是说是搞定
[33:30.400 --> 33:33.400] 就是说是最终抓取到这些信息
[33:33.400 --> 33:34.400] 你当下来
[33:34.400 --> 33:35.400] 然后进行以web
[33:35.400 --> 33:37.400] 或是其他的方式进行显示
[33:37.400 --> 33:38.400] 我觉得他的profile工具
[33:38.400 --> 33:40.400] 其实就是说是简单的
[33:40.400 --> 33:41.400] 是足够好用
[33:41.400 --> 33:42.400] 而python
[33:42.400 --> 33:44.400] 没有
[33:44.400 --> 33:46.400] 西涛你刚想说啥
[33:46.400 --> 33:48.400] 我刚想说我想到一点不爽的是
[33:48.400 --> 33:49.400] 我到现在都不知道
[33:49.400 --> 33:51.400] 三除以二的结果是什么
[33:51.400 --> 33:54.400] 然后我每次用到都要去打开一个中文测试进行
[33:54.400 --> 33:56.400] 好像跟python2变了
[33:56.400 --> 33:58.400] 然后但是python2我也不知道
[33:58.400 --> 33:59.400] 三除以二等于多少
[33:59.400 --> 34:01.400] 所以我一直就记不清
[34:01.400 --> 34:02.400] python2是1
[34:02.400 --> 34:04.400] python3是1.5
[34:04.400 --> 34:08.400] 所以我经常会选择三除以二
[34:08.400 --> 34:12.400] 不要让自己去考虑这些问题
[34:14.400 --> 34:15.400] 或者三点零除二
[34:15.400 --> 34:16.400] 啊
[34:16.400 --> 34:18.400] good point
[34:18.400 --> 34:19.400] 就跟那个l
[34:20.400 --> 34:22.400] 对就跟那个ln-s建立链接一样
[34:22.400 --> 34:24.400] 我老是分不清
[34:24.400 --> 34:26.400] source跟dest是什么
[34:26.400 --> 34:29.400] 然后docker的那个-v
[34:29.400 --> 34:31.400] 我也不知道语言跟目的
[34:31.400 --> 34:33.400] 哪一个在前哪一个在后
[34:33.400 --> 34:35.400] 这些我每次都要去查
[34:35.400 --> 34:37.400] 所以你会容易迷糊
[34:37.400 --> 34:40.400] 那我给陈老板有什么想吐槽的没有
[34:40.400 --> 34:42.400] 我刚刚想到一个就是排序
[34:42.400 --> 34:43.400] sort这个方法
[34:43.400 --> 34:46.400] 它去掉了CMP这个参数
[34:46.400 --> 34:50.400] 也就是说我现在没有办法去给它写一个
[34:50.400 --> 34:51.400] 比较函数了
[34:51.400 --> 34:52.400] 啊
[34:52.400 --> 34:53.400] 对
[34:53.400 --> 34:56.400] 但是他那个不是推荐了一个写法吗
[34:56.400 --> 35:01.400] 就是你可以在那个啥eq外面包一个CMP
[35:01.400 --> 35:04.400] 我知道有一个workaround的方法是
[35:04.400 --> 35:07.400] 他的found tools里面提供了一个叫做
[35:07.400 --> 35:09.400] CMP2key的一个方法
[35:09.400 --> 35:10.400] 你说的是同一个吗
[35:10.400 --> 35:11.400] 对对对
[35:11.400 --> 35:12.400] 对应该是这个
[35:12.400 --> 35:16.400] 我就是在他的那个文档里面看到一个
[35:16.400 --> 35:18.400] 迁移的workaround的方法
[35:18.400 --> 35:19.400] 应该就是这个
[35:19.400 --> 35:21.400] 这个有什么问题吗
[35:21.400 --> 35:22.400] 就是不爽
[35:22.400 --> 35:25.400] 然后如果你用你之前的代码在迁移过程中
[35:25.400 --> 35:26.400] 你从二迁到三的时候
[35:26.400 --> 35:28.400] 你就必须要用这个包一下
[35:28.400 --> 35:29.400] 嗯
[35:29.400 --> 35:31.400] 我想起Python还有很不爽的地方
[35:31.400 --> 35:33.400] 就是它还是很简陋
[35:33.400 --> 35:34.400] 我举个例子
[35:34.400 --> 35:35.400] 就是现在云服务厂商
[35:35.400 --> 35:37.400] 它很多监控的服务
[35:37.400 --> 35:39.400] 它会提供一个探针
[35:39.400 --> 35:40.400] 比如说是
[35:40.400 --> 35:42.400] 然后其他语言是可以通过一些agent的手段
[35:42.400 --> 35:44.400] 就是说是加载进去
[35:44.400 --> 35:47.400] 然后agent的手段就是会hook到你里面具体方法
[35:47.400 --> 35:49.400] 或者是某些指定的东西
[35:49.400 --> 35:51.400] 然后把对应的确诊信息输出出来
[35:51.400 --> 35:53.400] 输出到云厂商的监控服务里面去
[35:53.400 --> 35:57.400] Python至少对于现在这块是没有比较好的方法
[35:57.400 --> 36:00.400] 我觉得你这吐槽的就是Python之后
[36:00.400 --> 36:03.400] 二还是三其实没有什么太大的影响
[36:03.400 --> 36:06.400] 实际上也是Python三
[36:06.400 --> 36:10.400] 其实我现在对于Python三比较诟病的一点就是说
[36:10.400 --> 36:11.400] 大家都在去搞语法堂了
[36:11.400 --> 36:15.400] 但是对于就是说是一个生产上的公司
[36:15.400 --> 36:20.400] 大家比较concern的就是说是性能调试工具
[36:20.400 --> 36:22.400] 然后这两方面来讲
[36:22.400 --> 36:26.400] 其实做的努力其实是相对不算太大的
[36:26.400 --> 36:27.400] 说实话
[36:27.400 --> 36:29.400] 这是我自己的一个小开发
[36:29.400 --> 36:31.400] 因为我觉得就像比如说
[36:31.400 --> 36:33.400] 你会为了sync
[36:33.400 --> 36:34.400] sync还好
[36:34.400 --> 36:37.400] sync的确很多人会为了sync去签
[36:37.400 --> 36:39.400] 你会为了P1P572
[36:39.400 --> 36:43.400] 然后去把你的代码库从3.6签到3.7吗
[36:43.400 --> 36:45.400] 然后你会为了是机型做一个签译吗
[36:45.400 --> 36:47.400] 我觉得可能说是吸引人
[36:47.400 --> 36:51.400] 更多人来用Python用Python三加XXX
[36:51.400 --> 36:53.400] 它更多原因是良好的性能
[36:53.400 --> 36:56.400] 然后就是说是贴切的语法堂
[36:56.400 --> 36:57.400] 再加上方便的工具
[36:57.400 --> 36:58.400] OK
[36:58.400 --> 36:59.400] 这是我的一点小看法
[36:59.400 --> 37:00.400] 没了
[37:00.400 --> 37:01.400] 刚刚是不是有个口误
[37:01.400 --> 37:03.400] 是3.7还是3.8
[37:03.400 --> 37:04.400] 572吗
[37:04.400 --> 37:06.400] 好像3.8还是3.7
[37:06.400 --> 37:08.400] 我忘了572是哪个接收的了
[37:08.400 --> 37:09.400] 3.8
[37:09.400 --> 37:10.400] OK
[37:10.400 --> 37:13.400] 其实我们都没提到一个点
[37:13.400 --> 37:14.400] 其实应该就是签译
[37:14.400 --> 37:16.400] 签译应该是最大的槽点
[37:16.400 --> 37:17.400] 对吧
[37:17.400 --> 37:18.400] 就这样
[37:18.400 --> 37:19.400] 是的
[37:19.400 --> 37:22.400] 陈正不是从Python2签Python3
[37:22.400 --> 37:24.400] 签了有一段时间了
[37:24.400 --> 37:25.400] 能给我们聊一些
[37:25.400 --> 37:28.400] 比如说这种签译中遇到的槽点吗
[37:28.400 --> 37:30.400] 可以
[37:30.400 --> 37:33.400] 我们要直接从签译的
[37:33.400 --> 37:35.400] 我们直接聊一下签译的一些
[37:35.400 --> 37:37.400] 整体的一些情况
[37:37.400 --> 37:40.400] 再来去聊一下具体的一些槽点吧
[37:40.400 --> 37:42.400] 对因为其实
[37:42.400 --> 37:44.400] 新濤应该也是做过Python3的签译
[37:44.400 --> 37:48.400] 然后我前段时间也一个人去做了一下
[37:48.400 --> 37:51.400] 整个公司的Codebase的签译
[37:51.400 --> 37:54.400] 我们先可以先聊一下签译的方式
[37:54.400 --> 37:56.400] 我不知道新濤之前说签一个东西
[37:56.400 --> 37:59.400] 说两周还是一周就把它签完了
[37:59.400 --> 38:01.400] 是因为你们是一个比较小的库呢
[38:01.400 --> 38:04.400] 还是一个整个的应用
[38:04.400 --> 38:07.400] 我觉得是比较小吧
[38:07.400 --> 38:10.400] 因为我们之前是搞爬虫
[38:10.400 --> 38:12.400] 其实我没有参与那个签译的工作
[38:12.400 --> 38:14.400] 其他两位同事做的
[38:14.400 --> 38:15.400] 因为他们做得很快
[38:15.400 --> 38:18.400] 而且据我所知之后应该也没有什么太大的问题
[38:18.400 --> 38:20.400] 应该就是用了那个223
[38:20.400 --> 38:22.400] 然后在手动修改一些东西
[38:22.400 --> 38:25.400] 可能也是因为代码量的一个原因
[38:25.400 --> 38:28.400] 来会影响你的签译的方式吧
[38:28.400 --> 38:30.400] 那么据我了解到的
[38:30.400 --> 38:33.400] 例如Instagram他们其实就做过一个分享
[38:33.400 --> 38:35.400] 在2017年的Python上面
[38:35.400 --> 38:37.400] 然后他们提到了几种签译的方式
[38:37.400 --> 38:40.400] 例如按照你的入口
[38:40.400 --> 38:42.400] 比如说你的入口
[38:42.400 --> 38:43.400] 如果你是一个web server的话
[38:43.400 --> 38:46.400] 那就按你的入口来去切分就好了
[38:46.400 --> 38:48.400] 我一个一个入口来签
[38:48.400 --> 38:50.400] 但这种方式其实是会有问题的
[38:50.400 --> 38:52.400] 因为你不同入口
[38:52.400 --> 38:54.400] 其实会有很多共同的代码
[38:54.400 --> 38:55.400] 这部分怎么做呢
[38:55.400 --> 38:57.400] 其实很不好去划分出一个清晰的
[38:57.400 --> 39:00.400] 一个隔离的方法
[39:00.400 --> 39:03.400] 然后Instagram他们实际上做的方法
[39:03.400 --> 39:05.400] 其实是按fixed来去做
[39:05.400 --> 39:08.400] 他们就是相当于一个一个语法来去做
[39:08.400 --> 39:10.400] 然后每做完一个语法之后
[39:10.400 --> 39:13.400] 就通过工具能够保证
[39:13.400 --> 39:15.400] 你不会再写一些不接用的代码了
[39:15.400 --> 39:16.400] 这样一个隔离去签
[39:16.400 --> 39:20.400] 所以他们是签完某一个语法
[39:20.400 --> 39:23.400] 就把这个东西加到另一个检查里是吗
[39:23.400 --> 39:25.400] 就不再允许老的语法的使用了
[39:25.400 --> 39:26.400] 对
[39:26.400 --> 39:29.400] 那你这个只能通过代码分析来保证
[39:29.400 --> 39:31.400] 你还是没办法测试
[39:31.400 --> 39:34.400] 这个东西是不是到底在Python3里面能跑
[39:34.400 --> 39:38.400] 刚刚提的只是说你实际上改
[39:38.400 --> 39:40.400] 兼容代码这部分是怎么做
[39:40.400 --> 39:43.400] 其实我们忽略了一个比较重要的问题
[39:43.400 --> 39:46.400] 就是在你实际上在去签语之前
[39:46.400 --> 39:49.400] 你其实会有非常大量的工作
[39:49.400 --> 39:50.400] 其实在补你的测试
[39:50.400 --> 39:53.400] 因为对于Python这样的一个编程语言来说
[39:53.400 --> 39:57.400] 测试是非常重要的一部分
[39:57.400 --> 40:00.400] 尤其是涉及到这么大量的改动的过程中
[40:00.400 --> 40:01.400] 同意
[40:01.400 --> 40:02.400] 我之前的话是花了
[40:02.400 --> 40:03.400] 先花了一个多月来
[40:03.400 --> 40:06.400] 我就当时签一个主服务
[40:06.400 --> 40:08.400] 然后其实是花了一个月来不测试
[40:08.400 --> 40:11.400] 包括进单元测试和集成测试
[40:11.400 --> 40:13.400] 所以在你开始签语之前
[40:13.400 --> 40:17.400] 你先保证你的测试覆盖率是足够的高
[40:17.400 --> 40:18.400] 这个足够高
[40:18.400 --> 40:20.400] 那就看你们是怎么定义了
[40:20.400 --> 40:21.400] 对
[40:21.400 --> 40:22.400] 我们之前的话
[40:22.400 --> 40:24.400] 我们之前测试覆盖率是没什么要求
[40:24.400 --> 40:25.400] 但是后面的话
[40:25.400 --> 40:27.400] 我还是尽可能做到95以上
[40:27.400 --> 40:28.400] 那相当的高
[40:28.400 --> 40:29.400] 对
[40:29.400 --> 40:32.400] 因为主要就是说是各种MonkeyPy
[40:32.400 --> 40:34.400] 就是说是能派起的地方就派起了
[40:34.400 --> 40:36.400] 就是说保证它行为一致
[40:36.400 --> 40:39.400] 然后但是我觉得它可能说按入口
[40:39.400 --> 40:42.400] 按入口或者说是按其他的
[40:42.400 --> 40:43.400] 也有其他的问题
[40:43.400 --> 40:45.400] 就比如说像我们之前的一个
[40:45.400 --> 40:46.400] 重型网关的东西
[40:46.400 --> 40:50.400] 它一个入口可能和其他入口有关联的关系
[40:50.400 --> 40:52.400] 就是说你一个就是说是
[40:52.400 --> 40:54.400] 如果说你一个地方签一个
[40:54.400 --> 40:56.400] 就是你一个服务之间
[40:56.400 --> 40:57.400] 它当时结构设计有问题
[40:57.400 --> 40:59.400] 就是说整体盲拍之间的
[40:59.400 --> 41:00.400] 和比较有关系
[41:00.400 --> 41:01.400] 严重
[41:01.400 --> 41:04.400] 所以最后我选择的策略是
[41:04.400 --> 41:06.400] 一次性起个新的东西
[41:06.400 --> 41:08.400] 然后全部把它签完了之后
[41:08.400 --> 41:10.400] 全部把它签完了之后
[41:10.400 --> 41:12.400] 然后来做就是说是回度
[41:12.400 --> 41:13.400] 然后慢慢测
[41:14.400 --> 41:17.400] 陈钊就是你刚刚说的那个测试
[41:18.400 --> 41:20.400] 就是怎么在Python3里面测呢
[41:20.400 --> 41:22.400] 就是因为你的整一套测试
[41:22.400 --> 41:24.400] 肯定是在Python3里面跑不过的
[41:24.400 --> 41:26.400] 假如说你只签了一个语法
[41:26.400 --> 41:31.400] 这个其实可以先说一下
[41:31.400 --> 41:34.400] 我们是怎么去做签译的
[41:34.400 --> 41:36.400] 我们按照的区分方式
[41:36.400 --> 41:38.400] 其实是按目录结构来的
[41:38.400 --> 41:39.400] 也就是说按不同的模块
[41:39.400 --> 41:42.400] 我们先把某一个目录下的文件
[41:42.400 --> 41:43.400] 给先做了
[41:43.400 --> 41:44.400] 那么其实我们测的时候
[41:44.400 --> 41:46.400] 可能就是先做
[41:46.400 --> 41:47.400] 其实我们不能说按目录
[41:47.400 --> 41:48.400] 其实我们按层了
[41:48.400 --> 41:49.400] 可能分不同的model层
[41:49.400 --> 41:50.400] control的层
[41:50.400 --> 41:51.400] 或者handle的这一层
[41:51.400 --> 41:52.400] 这样来去做切分
[41:52.400 --> 41:54.400] 所以其实这时候测试来说
[41:54.400 --> 41:55.400] 为什么选这样的方式
[41:55.400 --> 41:57.400] 其实也是为了测试的时候
[41:57.400 --> 41:58.400] 会更好去测说
[41:58.400 --> 42:00.400] 哪些已经ready了
[42:00.400 --> 42:02.400] 你就可以去通过linter和你的测试
[42:02.400 --> 42:03.400] 能保证这部分
[42:03.400 --> 42:04.400] 其实是能够保证
[42:04.400 --> 42:05.400] 能正常工作的
[42:05.400 --> 42:06.400] 刚刚Mentosacker
[42:06.400 --> 42:08.400] 其实提到的那个方法
[42:08.400 --> 42:11.400] 其实在Instagram的分享里面
[42:11.400 --> 42:12.400] 其实提到了他们
[42:12.400 --> 42:13.400] 这也是一种方法
[42:13.400 --> 42:16.400] 如果你的checkout出来的
[42:16.400 --> 42:17.400] 一个branch
[42:17.400 --> 42:19.400] 能够非常快的能够去盖栏
[42:19.400 --> 42:21.400] 并且能够模拟回去的话
[42:21.400 --> 42:22.400] 那这样方式其实是非常好的
[42:22.400 --> 42:25.400] 因为你就是直接一把就搞定了
[42:25.400 --> 42:26.400] 你不会有
[42:26.400 --> 42:28.400] 但这个前提其实是你的
[42:28.400 --> 42:30.400] 你要时间足够的短
[42:30.400 --> 42:32.400] 这样才不会做你其他的开发
[42:32.400 --> 42:35.400] 我当时是全职来做QIANYI
[42:35.400 --> 42:38.400] 我当时是花了两个多月
[42:38.400 --> 42:39.400] 接近三个月时间吧
[42:39.400 --> 42:42.400] 然后全年老服务全部下掉
[42:42.400 --> 42:43.400] 那你这个过程中
[42:43.400 --> 42:45.400] 你不会有新的需求和新的
[42:45.400 --> 42:47.400] 会有些新的需求
[42:47.400 --> 42:49.400] 但是不是基于这个服务的
[42:49.400 --> 42:53.400] 这个服务当时的需求我是全部停了
[42:53.400 --> 42:55.400] 对所以就是这是一个问题
[42:55.400 --> 42:57.400] 就是你必须把它的新的开发
[42:57.400 --> 42:58.400] 都停掉了
[42:58.400 --> 42:59.400] 全员全员来做这个东西
[42:59.400 --> 43:00.400] 不然你是没有把保证
[43:00.400 --> 43:02.400] 你能够merge回去的
[43:02.400 --> 43:03.400] 因为是因为我们当时
[43:03.400 --> 43:05.400] 其实是一个众服务
[43:05.400 --> 43:06.400] 众服务的话
[43:06.400 --> 43:07.400] 你一个个接口签
[43:07.400 --> 43:08.400] 其实说实话
[43:08.400 --> 43:10.400] 你的code你一个接口签
[43:10.400 --> 43:12.400] 因为你按照你的接口签的规度
[43:12.400 --> 43:13.400] 其他的流程
[43:13.400 --> 43:15.400] 因为我们当时infra
[43:15.400 --> 43:16.400] 其实并不完善
[43:16.400 --> 43:18.400] 因为infra并不完善
[43:18.400 --> 43:20.400] 一个后果就是说是你对于细
[43:20.400 --> 43:23.400] 就是说是非常细的接口的力度的灰度
[43:23.400 --> 43:26.400] 其实是做那个做的并不太好
[43:26.400 --> 43:27.400] 而你如果说一个接口
[43:27.400 --> 43:28.400] 一个接口的签的话
[43:28.400 --> 43:30.400] 其实是需要你对于
[43:30.400 --> 43:33.400] 就是说是比较细力度的进行控制
[43:33.400 --> 43:35.400] 对就是说是百分比或其他的
[43:35.400 --> 43:37.400] 就是灰度测试的时候
[43:37.400 --> 43:39.400] 但是我们当时没有这么完善infra
[43:39.400 --> 43:41.400] 因为我们是以整个一个服务
[43:41.400 --> 43:43.400] 就是说是一个进行聚合点
[43:43.400 --> 43:45.400] 进行的那个上游的一个就是转发
[43:45.400 --> 43:47.400] 那么这个时候也没办法
[43:47.400 --> 43:49.400] 就只能说我们一次性的整体打包迁移
[43:49.400 --> 43:52.400] 那陈导你们分层迁移的话是
[43:52.400 --> 43:54.400] 将这一层迁移到Python3
[43:54.400 --> 43:57.400] 然后添加上Ci
[43:57.400 --> 43:59.400] 在Python3里面就加上这一层的测试吗
[43:59.400 --> 44:01.400] 然后其他层还是只跑Python3
[44:01.400 --> 44:02.400] 是的
[44:02.400 --> 44:05.400] 但是会在Ci那层用Python3来跑吗
[44:05.400 --> 44:06.400] 还是
[44:06.400 --> 44:09.400] 但解释器替换感觉内部风险还挺大的
[44:09.400 --> 44:10.400] 就是线上放量是吗
[44:10.400 --> 44:11.400] 还是怎么说呢
[44:11.400 --> 44:14.400] 其实他并不是说直接就写成Python3的语法
[44:14.400 --> 44:18.400] 其实迁移的过程其实是做一个所谓的兼容的过程
[44:18.400 --> 44:21.400] 因为你代码其实还是用Python2来跑的
[44:21.400 --> 44:24.400] 线上实际上解释器还是Python2
[44:24.400 --> 44:27.400] 但是Ci会Python2,Python3都跑
[44:27.400 --> 44:28.400] 对测试
[44:28.400 --> 44:32.400] 然后你们直到把所有的层Python3都跑过了
[44:32.400 --> 44:35.400] 然后再把解释器逐渐替换成Python3
[44:35.400 --> 44:37.400] 对大概过程是这样子的
[44:37.400 --> 44:39.400] 切到Python3就不需要再测Python2了吧
[44:39.400 --> 44:41.400] 就如果线上已经是Python3了
[44:41.400 --> 44:44.400] 那我理解就是大家都从Python3开始走了
[44:44.400 --> 44:47.400] 对还是会有一个绘度的一个过程
[44:47.400 --> 44:48.400] 因为在那个过程中
[44:48.400 --> 44:51.400] 其实你还是会发现你在之前的测试
[44:51.400 --> 44:53.400] 或者Lint那部分没有发现的问题
[44:53.400 --> 44:55.400] 然后你还是去改
[44:55.400 --> 44:57.400] 包括还会有一些一些Running这些东西
[44:57.400 --> 44:59.400] 你也可能会去把它给fix掉
[44:59.400 --> 45:03.400] 然后迁移到就是假如说是线上
[45:03.400 --> 45:06.400] 所有的解释器都变成Python3了
[45:06.400 --> 45:08.400] 然后你们写的代码是直接
[45:08.400 --> 45:11.400] 就是你们CI是直接测Python3了呢
[45:11.400 --> 45:14.400] 还是说2跟3都会同时测一段时间
[45:14.400 --> 45:16.400] 我没明白你的问题
[45:16.400 --> 45:20.400] 就是首先就每一层都用Python2跟Python3同时测了嘛
[45:20.400 --> 45:22.400] 然后下一步是线上的服务器
[45:22.400 --> 45:24.400] 从Python2切换到Python3对吧
[45:24.400 --> 45:27.400] 然后这一步是完全切换到Python3
[45:27.400 --> 45:31.400] 然后这个时候你们接下来写的代码里面
[45:31.400 --> 45:34.400] 还会在CI里面同时测两个Python吗
[45:34.400 --> 45:37.400] 你是说老服务还没有全部下调的时候吗
[45:37.400 --> 45:40.400] 对,我的问题就是这个
[45:40.400 --> 45:44.400] 我不知道要不要写继续兼容两个Python的代码
[45:44.400 --> 45:45.400] 然后测两个
[45:45.400 --> 45:47.400] 我认为什么时候可以去切
[45:47.400 --> 45:50.400] 就是说你的测试不用在Python3来跑
[45:50.400 --> 45:53.400] 其实只有当你确定你不会再去
[45:53.400 --> 45:55.400] rollback到Python2的情况下
[45:55.400 --> 45:57.400] 你就可以去不支持了
[45:57.400 --> 46:01.400] 那这个时间段还是不是很长的对吧
[46:01.400 --> 46:03.400] 就可能线上跑一个星期
[46:03.400 --> 46:05.400] 你们就可以放心的
[46:05.400 --> 46:08.400] 但是我是觉得这种就和Python无关
[46:08.400 --> 46:10.400] 就是你灰度一般都是灰度
[46:10.400 --> 46:12.400] 即使灰到全部的百分百
[46:12.400 --> 46:15.400] 然后就会设置一个时间点
[46:15.400 --> 46:17.400] 比如说我们在上面观察一天
[46:17.400 --> 46:19.400] 观察一周,观察一个月
[46:19.400 --> 46:20.400] 好,没有问题
[46:20.400 --> 46:22.400] 就宣告老的彻底被放弃了
[46:22.400 --> 46:24.400] 我认为是这样的
[46:24.400 --> 46:28.400] 我觉得有个背景没有补充进去
[46:28.400 --> 46:30.400] 就是其实我做的这部分
[46:30.400 --> 46:34.400] 其实只到了大概就是灰度放量这一段
[46:34.400 --> 46:37.400] 后面就因为各种原因没有进行下去了
[46:37.400 --> 46:38.400] 然后现在有没有人去接
[46:38.400 --> 46:40.400] 或者是一个什么样的情况
[46:40.400 --> 46:41.400] 其实不太了解了
[46:41.400 --> 46:43.400] 这个可能前天同步的时候
[46:43.400 --> 46:45.400] 没有跟你提到过
[46:45.400 --> 46:47.400] 就是你这边的工作
[46:47.400 --> 46:50.400] 就是做到灰度逐渐放量的这个地方
[46:50.400 --> 46:54.400] 可以停需求是一个很幸福的事情
[46:54.400 --> 46:58.400] 其实就是两边派在同时兼容的时候
[46:58.400 --> 47:00.400] 你写兼容二跟三个代码
[47:00.400 --> 47:01.400] 还是比较恶心的
[47:01.400 --> 47:02.400] 是的
[47:02.400 --> 47:04.400] 我们之前也是我们之前是星期两服务
[47:04.400 --> 47:06.400] 其实是新建了一个服务
[47:06.400 --> 47:09.400] 然后1% 10%
[47:09.400 --> 47:10.400] 然后50%
[47:10.400 --> 47:12.400] 然后我灰度
[47:12.400 --> 47:14.400] 我记得当时是两个多星期时间
[47:14.400 --> 47:15.400] 两个多星期时间之后
[47:15.400 --> 47:17.400] 如果说是灰度彻底没有问题之后
[47:17.400 --> 47:20.400] 包括日志和其他的都没有问题
[47:20.400 --> 47:21.400] 那么最后这一块的话
[47:21.400 --> 47:24.400] 其实就直接老服务就下掉了
[47:24.400 --> 47:26.400] 后面新需求就全部积于三了
[47:26.400 --> 47:28.400] 所以说那段时间我把新的需求停了
[47:28.400 --> 47:31.400] 但是对应的是
[47:31.400 --> 47:33.400] 我在其他方面我得满足他们的需求
[47:33.400 --> 47:35.400] 所以说那段时间压力很大
[47:35.400 --> 47:38.400] 就是说我准确说需求不能停
[47:38.400 --> 47:40.400] 准确说需求是不能停的
[47:40.400 --> 47:43.400] 就比如说他要因为我们当时是网关类型的操作
[47:43.400 --> 47:45.400] 他的需求是不能停的
[47:45.400 --> 47:47.400] 然后但是我这个服务我又要签
[47:47.400 --> 47:48.400] 因为我们这是个大服务
[47:48.400 --> 47:50.400] 又只能一次性签
[47:50.400 --> 47:51.400] 怎么办呢
[47:51.400 --> 47:53.400] 我就只能用其他方法
[47:53.400 --> 47:54.400] 让他能满足他的需求
[47:54.400 --> 47:55.400] 但是不改这个地方
[47:55.400 --> 47:58.400] 所以说只是停了在这个codebase上的需求
[47:58.400 --> 48:01.400] 但是实际上他本身上的需求
[48:01.400 --> 48:04.400] 是我通过另外一些方法给他满足
[48:04.400 --> 48:05.400] 所以说这个还是很恶心
[48:05.400 --> 48:07.400] 我刚想说前两年
[48:07.400 --> 48:09.400] 其实很多公司面试的时候都喜欢问你
[48:09.400 --> 48:12.400] 判断三跟判断二的代码怎么同时兼容
[48:12.400 --> 48:14.400] 现在已经不问了
[48:14.400 --> 48:15.400] 我觉得
[48:15.400 --> 48:18.400] 要不然能升就升
[48:18.400 --> 48:19.400] 升不了的就留在那了
[48:19.400 --> 48:20.400] 是吧
[48:20.400 --> 48:22.400] 对要么就直接切到判断三来去写了
[48:22.400 --> 48:24.400] 我之前对这种面试的时候
[48:24.400 --> 48:26.400] 问你判断三有什么新特性
[48:26.400 --> 48:29.400] 怎么同时兼容判断三的代码
[48:29.400 --> 48:31.400] 这种问题比较头疼
[48:31.400 --> 48:33.400] 判断三一直在开发对吧
[48:33.400 --> 48:34.400] 就加了那么多
[48:34.400 --> 48:35.400] 怎么能记得住呢
[48:35.400 --> 48:37.400] 对其实我觉得除了要停止维护以外
[48:37.400 --> 48:39.400] 判断三的话
[48:39.400 --> 48:41.400] 除了type hint和要停止维护两个原因以外
[48:41.400 --> 48:43.400] 我觉得判断三
[48:43.400 --> 48:46.400] 判断二三要找能让公司
[48:46.400 --> 48:49.400] 公司去迁移他那么庞大的codebase的动力
[48:49.400 --> 48:50.400] 还真的会很少
[48:50.400 --> 48:53.400] 而且巨多的函数名字都不一样了
[48:53.400 --> 48:54.400] 不过这个还好
[48:54.400 --> 48:57.400] 就写一个文件兼容一下import
[48:57.400 --> 48:58.400] 一句话就是说
[48:58.400 --> 49:00.400] 你不要用任何判断三的新特性
[49:00.400 --> 49:04.400] 虽然会有一些特性会backup到2.7里面去
[49:04.400 --> 49:06.400] 但是的话
[49:06.400 --> 49:08.400] 但是那个也是很老的事情了
[49:08.400 --> 49:09.400] 很久的事情了
[49:09.400 --> 49:13.400] 所以说有些codebase还在2.5、2.6的
[49:13.400 --> 49:14.400] 那种情况
[49:14.400 --> 49:16.400] 你就只能说
[49:16.400 --> 49:19.400] 我不用任何判断三的新特性
[49:19.400 --> 49:21.400] 然后升级到2.7
[49:21.400 --> 49:24.400] 前段时间有一个那个Macro
[49:24.400 --> 49:26.400] 迁移的那个文章巨长
[49:26.400 --> 49:27.400] 不知道你没有看
[49:27.400 --> 49:29.400] 没有可以分享一下
[49:29.400 --> 49:31.400] 我们贴到博客的那个里
[49:31.400 --> 49:32.400] 可以
[49:32.400 --> 49:33.400] 对对
[49:33.400 --> 49:35.400] 我可以简单说几点
[49:35.400 --> 49:36.400] 就是那个
[49:36.400 --> 49:38.400] 其实那个人的博客挺好的
[49:38.400 --> 49:39.400] 我看了挺多
[49:39.400 --> 49:41.400] 那个人就是其实也是那个拍
[49:41.400 --> 49:43.400] OxyDizer的那个作者
[49:43.400 --> 49:44.400] 哇
[49:44.400 --> 49:47.400] 那个他写他们半年基本上就任何事情
[49:47.400 --> 49:48.400] 没做
[49:48.400 --> 49:50.400] 只从判断二迁移到判断三
[49:50.400 --> 49:53.400] 但其实这个迁移并没有给他们带来任何
[49:53.400 --> 49:55.400] 基本上没有带来任何好处
[49:55.400 --> 49:56.400] 然后我看那些文章
[49:56.400 --> 49:58.400] 我靠我都看哭了快了
[49:58.400 --> 50:00.400] 简直太惨了
[50:00.400 --> 50:04.400] 就是他们在内部表示字符串
[50:04.400 --> 50:05.400] 都是用Unicode表示的
[50:05.400 --> 50:07.400] 然后对判断二
[50:07.400 --> 50:09.400] 前面的三他们有一个特别
[50:09.400 --> 50:11.400] 特别麻烦的地方
[50:11.400 --> 50:14.400] 就是他们要把内部的表示
[50:14.400 --> 50:17.400] 同Unicode改成String好像是
[50:17.400 --> 50:19.400] 然后有一些方案
[50:19.400 --> 50:21.400] 然后他列举的方案就特别复杂
[50:21.400 --> 50:23.400] 就比如说用批量替换
[50:23.400 --> 50:25.400] 把所有的那个前缀U给去掉
[50:25.400 --> 50:27.400] 但是这样会带来别的问题
[50:27.400 --> 50:29.400] 就反正写的非常那个
[50:29.400 --> 50:31.400] 然后那篇文章值得非常值得一看
[50:31.400 --> 50:33.400] 他那个应该是迁移到比较低的Python3吧
[50:33.400 --> 50:35.400] 我记得Python3.4之后
[50:35.400 --> 50:37.400] Python2里面的Unicode是和Batman
[50:37.400 --> 50:39.400] 和前缀符是重新做了
[50:39.400 --> 50:42.400] 在Python3里面做了向上减容
[50:42.400 --> 50:45.400] 是在3.4里面是哪个PPP我得找一下
[50:45.400 --> 50:47.400] 那他们好惨啊
[50:47.400 --> 50:49.400] 好不容易花了大力气搞完之后
[50:49.400 --> 50:53.400] 然后发现其实最新版本不需要搞
[50:53.400 --> 50:56.400] 他们应该是先到3.3或者是哪个版本了
[50:56.400 --> 50:59.400] 就是他们有一些很想
[50:59.400 --> 51:01.400] 就是不那个的地方
[51:01.400 --> 51:03.400] 比如说你改了所有的那个
[51:03.400 --> 51:05.400] 前缀嘛
[51:05.400 --> 51:08.400] 你的所有文件的那个Commit的历史
[51:08.400 --> 51:10.400] 全都没了对吧
[51:10.400 --> 51:11.400] 你如果Blame的话
[51:11.400 --> 51:13.400] 你根本就找不到那个人了
[51:13.400 --> 51:14.400] 就Git会变得很乱
[51:14.400 --> 51:18.400] 虽然Git有一些东西可以让你
[51:18.400 --> 51:21.400] 就是忽略掉这次Commit的Blame
[51:21.400 --> 51:24.400] 这个好像他在博客里面也说过
[51:24.400 --> 51:27.400] 所以这篇比较值得一读的
[51:27.400 --> 51:30.400] 然后后来他们的方案是搞了个模块
[51:30.400 --> 51:32.400] 就是相当于是hack了一下
[51:32.400 --> 51:35.400] 这个文件虽然用的有一些U的前缀
[51:35.400 --> 51:37.400] 但是我可以就是
[51:37.400 --> 51:40.400] 相当于我自己去解释这个文件
[51:40.400 --> 51:43.400] 把这些把这些代码给处理掉了一次
[51:43.400 --> 51:45.400] 比如说你可以保留这个U
[51:45.400 --> 51:48.400] 我找到了是那个PEP
[51:48.400 --> 51:53.400] 那个2012年的PEP414重新引入U
[51:53.400 --> 51:56.400] 然后PEP461是重新引入B
[51:56.400 --> 51:59.400] 然后就是在那个就是在3.5里面
[51:59.400 --> 52:03.400] 他应该是迁到了3.3之前的版本
[52:03.400 --> 52:05.400] 但我知道有一个不支持的是UR
[52:05.400 --> 52:08.400] 也就是说同时是UNIQLO以及RAW
[52:08.400 --> 52:10.400] 那么这时候到排名单里面就
[52:10.400 --> 52:12.400] 那个好像是
[52:12.400 --> 52:15.400] 对应该他们也有这个问题吧
[52:15.400 --> 52:19.400] 我之前看的印象不是特别深吗
[52:19.400 --> 52:21.400] 我觉得我觉得那是真的
[52:21.400 --> 52:24.400] 反正我觉得Python3这个东西说实话
[52:24.400 --> 52:26.400] 我觉得我觉得现在的还是搞得一地鸡毛
[52:26.400 --> 52:29.400] Python3第一个版本是什么时候
[52:29.400 --> 52:32.400] 2006年是PEP3000正式提出
[52:32.400 --> 52:35.400] 然后是2009年
[52:35.400 --> 52:39.400] 准确时间是2009年的2月14号
[52:39.400 --> 52:42.400] 现在已经接近11年了
[52:42.400 --> 52:43.400] 11年多了
[52:43.400 --> 52:49.400] 中间还发布了好几个breaking changes的Python3.x
[52:49.400 --> 52:53.400] 是当时其实当时社区也是扯皮了
[52:53.400 --> 52:54.400] 扯了很久了
[52:54.400 --> 52:56.400] 说实话当时是2006年几月
[52:56.400 --> 52:58.400] 那个PEP3K正式提出
[52:58.400 --> 53:00.400] 其实当时很多的设想到现在来看
[53:00.400 --> 53:01.400] 都是没有实现
[53:01.400 --> 53:03.400] 就社区反抗力度太大
[53:03.400 --> 53:05.400] 我想到一个刚刚在
[53:05.400 --> 53:07.400] 讲验证相关的时候没有提到的
[53:07.400 --> 53:09.400] 就是我们刚刚其实在说
[53:09.400 --> 53:12.400] 怎么去让你的代码能够通过你的测试
[53:12.400 --> 53:14.400] 或者说通过linter的方式
[53:14.400 --> 53:16.400] 能够保证你代码能word
[53:16.400 --> 53:20.400] 但其实验证除了我们说通过方向验证以外
[53:20.400 --> 53:24.400] 其实还涉及到一些跟其他的服务也好
[53:24.400 --> 53:25.400] 数据库也好
[53:25.400 --> 53:27.400] 或者说跟用户对联接也好
[53:27.400 --> 53:31.400] 其实你还是得通过手工的方式
[53:31.400 --> 53:32.400] 还是看一下了
[53:32.400 --> 53:33.400] 比如说你同时两个版本看
[53:33.400 --> 53:35.400] 同时Python3跑着的时候
[53:35.400 --> 53:38.400] 其实你可能会涉及到比如最简单的
[53:38.400 --> 53:40.400] 序列化相关的两个版本之间
[53:40.400 --> 53:42.400] 它们序列化能不能互相的去
[53:42.400 --> 53:43.400] 有没有问题
[53:43.400 --> 53:44.400] 有没有兼容的问题
[53:44.400 --> 53:46.400] 你说的序列化是指的是
[53:46.400 --> 53:48.400] 跟语言无关的序列化吗
[53:48.400 --> 53:49.400] 嗯 应该是这样的
[53:49.400 --> 53:51.400] 比如你去
[53:51.400 --> 53:53.400] 你序列化放到任务对类里面
[53:53.400 --> 53:55.400] 那里面你Python3里面再拿出来
[53:55.400 --> 53:57.400] 因为其实你是用到别的库了嘛
[53:57.400 --> 53:59.400] 那其实你不知道这些库
[53:59.400 --> 54:01.400] 在不同版本上的行为是不一样的
[54:01.400 --> 54:06.400] 你们实际发现兼容的
[54:06.400 --> 54:10.400] 就是这种兼容率高吗
[54:10.400 --> 54:11.400] Python2跟Python3
[54:11.400 --> 54:13.400] 这点我们没有遇到问题
[54:13.400 --> 54:15.400] 那还挺神奇的
[54:15.400 --> 54:17.400] 因为Pico它们文档
[54:17.400 --> 54:19.400] 这种就是明确说
[54:19.400 --> 54:22.400] 版本之间不会兼容
[54:22.400 --> 54:24.400] 但我们没有Pico这样的序列化
[54:24.400 --> 54:27.400] 我指的应该是我们的服务器的调用
[54:27.400 --> 54:31.400] 包括任务对类这种
[54:31.400 --> 54:32.400] 是这种
[54:32.400 --> 54:36.400] 那你们的IPC用的是什么样的序列化
[54:36.400 --> 54:39.400] IPC这个我们这边还没有
[54:39.400 --> 54:42.400] 我们还是走HTTP的
[54:42.400 --> 54:45.400] 如果是跟语言无关的
[54:45.400 --> 54:47.400] 对 如果是跟语言无关的
[54:47.400 --> 54:49.400] 那种序列化的方式的话
[54:49.400 --> 54:51.400] 应该会问题比较少
[54:51.400 --> 54:53.400] 其实也不一定
[54:53.400 --> 54:55.400] 然后就说是
[54:55.400 --> 54:57.400] 123之间其实它每一个版本
[54:57.400 --> 54:59.400] 每个版本的很多小细节
[54:59.400 --> 55:01.400] 小细节都会发生变化
[55:01.400 --> 55:04.400] 如果说你之前代码用了太多的非标操作
[55:04.400 --> 55:06.400] 这个时候就会很恶心
[55:06.400 --> 55:08.400] 哪些算非标操作呢
[55:08.400 --> 55:10.400] 比如说上次我上次政策表达室
[55:10.400 --> 55:12.400] 我和他们的互分政策表达室
[55:12.400 --> 55:13.400] 然后他们说
[55:13.400 --> 55:16.400] 然后我就直接用那个RE
[55:16.400 --> 55:17.400] RE.find
[55:17.400 --> 55:20.400] 然后我不需要预编译政策表达室
[55:20.400 --> 55:21.400] 他的理由就是说
[55:21.400 --> 55:25.400] 他底层是给你做了cake的
[55:25.400 --> 55:27.400] 然后说你不需要再去预编译了
[55:27.400 --> 55:29.400] 这种东西就算非标操作
[55:29.400 --> 55:31.400] 对吧 你每个大版本的
[55:31.400 --> 55:33.400] 你每个大版本的行为都在发生变化的
[55:33.400 --> 55:35.400] 然后还有你可能小版本行为
[55:35.400 --> 55:37.400] 都可能在发生变化的这种非标操作
[55:37.400 --> 55:39.400] 还有一些比如说我直接去
[55:39.400 --> 55:42.400] 用它模块里面的某一些
[55:42.400 --> 55:43.400] 前面加了双下发线的
[55:43.400 --> 55:45.400] 一些影视的东西
[55:45.400 --> 55:47.400] 这种也是非标操作
[55:47.400 --> 55:50.400] 其实23里面这种采用的可能也挺多的
[55:50.400 --> 55:51.400] 我觉得在23这种里面
[55:51.400 --> 55:55.400] 其实很大精力放在了字符串的处理上
[55:55.400 --> 55:58.400] 我想起一个遇到的一个坑
[55:58.400 --> 56:02.400] 是一个关于register key的一个问题
[56:02.400 --> 56:05.400] 是因为我们在生成这个key的时候
[56:05.400 --> 56:10.400] 把一个byte放到一个string里面去format了
[56:10.400 --> 56:12.400] 所以format出来的那个
[56:12.400 --> 56:14.400] format出来在pattern3的时候
[56:14.400 --> 56:16.400] 它就会把这个b也会带到
[56:16.400 --> 56:19.400] 这个生成好的字符串里面去
[56:19.400 --> 56:21.400] 所以这次key其实就换了一个key了
[56:21.400 --> 56:23.400] 这个我感觉跟redispy有关系
[56:23.400 --> 56:27.400] 它那个默认给你的response进行decode的这种行为
[56:27.400 --> 56:29.400] 很容易踩坑
[56:29.400 --> 56:31.400] 你那个其实是另外一个问题
[56:31.400 --> 56:32.400] 这个key其实并不是
[56:32.400 --> 56:34.400] 这个key是我们自己生成的
[56:34.400 --> 56:35.400] 但不知道怎么
[56:35.400 --> 56:37.400] 它就是一个byte
[56:37.400 --> 56:39.400] 结果在pattern2里面的时候
[56:39.400 --> 56:40.400] 你去format的时候
[56:40.400 --> 56:45.400] 其实你是你byte和str都是正常的key夹
[56:45.400 --> 56:47.400] 你就叫一个full
[56:47.400 --> 56:48.400] 那么你得到就是full
[56:48.400 --> 56:50.400] 但如果是变成pattern3里面
[56:50.400 --> 56:51.400] 如果是一个byte
[56:51.400 --> 56:52.400] 然后再去format的时候
[56:52.400 --> 56:55.400] 就变成一个很冷心的就是b
[56:55.400 --> 56:57.400] 然后在引号再去full
[56:57.400 --> 56:59.400] 这样的一个字符串
[56:59.400 --> 57:01.400] 那如果
[57:01.400 --> 57:02.400] 我比较好奇
[57:02.400 --> 57:04.400] 这个是你们一上线就发现了
[57:04.400 --> 57:05.400] 还是跑了一段时间就发
[57:05.400 --> 57:06.400] 他发现了
[57:06.400 --> 57:07.400] 因为比如说你一上线
[57:07.400 --> 57:08.400] 刚刚写入的数据
[57:08.400 --> 57:10.400] 其实是能读到的
[57:10.400 --> 57:14.400] 我觉得应该在测试方面就已经被发现了
[57:14.400 --> 57:15.400] 我记得是
[57:15.400 --> 57:17.400] 那还比较好
[57:17.400 --> 57:20.400] 就没有等到线上
[57:20.400 --> 57:23.400] 但如果你没有刚好没有被覆盖到
[57:23.400 --> 57:25.400] 那有可能真的在后面你才会发现
[57:25.400 --> 57:27.400] 如果发现在缓存上面
[57:27.400 --> 57:28.400] 你可能更难查
[57:28.400 --> 57:31.400] 对我觉得这种其实就是很多非标操作
[57:31.400 --> 57:32.400] 很多非标的操作
[57:32.400 --> 57:34.400] 然后的话就导致就是说你
[57:34.400 --> 57:35.400] 你迁移的时候
[57:35.400 --> 57:38.400] 你永远不知道会有什么坑在等着你
[57:38.400 --> 57:39.400] 对所以聊到这个问题
[57:39.400 --> 57:42.400] 其实可以再聊一下关于unicode
[57:42.400 --> 57:43.400] 说实话
[57:43.400 --> 57:46.400] 我的unicode其实了解并不是很太深
[57:46.400 --> 57:48.400] 来陈老板现在给我们科普科普
[57:48.400 --> 57:50.400] unicode就是字符集
[57:50.400 --> 57:53.400] 然后Python里面我们经常在Python上写的时候
[57:53.400 --> 57:56.400] 其实可能在最开始就会写一下什么
[57:56.400 --> 57:58.400] 去写一下code.utf8
[57:58.400 --> 58:02.400] 那utf8其实就是所谓的编码方式
[58:02.400 --> 58:03.400] 就它其实是表对
[58:03.400 --> 58:05.400] 其实什么叫字符集呢
[58:05.400 --> 58:07.400] 其实就是unicode是字符集吧
[58:07.400 --> 58:10.400] 对我担心我讲错了
[58:10.400 --> 58:12.400] 是unicode是字符集
[58:12.400 --> 58:15.400] utf8是具体的编码方式
[58:15.400 --> 58:18.400] 对那就相当于字符集是什么
[58:18.400 --> 58:21.400] 就是我们不同的字符都会有
[58:21.400 --> 58:24.400] 它独一无二的一个表述方式
[58:24.400 --> 58:26.400] 然后也可以叫做码点
[58:26.400 --> 58:27.400] 那么字符集呢
[58:27.400 --> 58:29.400] 就是这样的一个码点
[58:29.400 --> 58:33.400] 它具体的一个在不同的字符集里面
[58:33.400 --> 58:35.400] 所表示的一种方式
[58:35.400 --> 58:37.400] 我之前和大家举例子
[58:37.400 --> 58:42.400] 我觉得用ask码字符集会比较容易举例子
[58:42.400 --> 58:46.400] 就是说就是字符集ask码字符集
[58:46.400 --> 58:48.400] 就规定了我有多少个字符嘛
[58:48.400 --> 58:49.400] 对它们就是字符集
[58:49.400 --> 58:51.400] 以及它们的码点就是64 65 66
[58:51.400 --> 58:52.400] 这种就是码点
[58:52.400 --> 58:54.400] 它是人为规定的
[58:54.400 --> 58:56.400] 哪一个码点对应哪个字符
[58:56.400 --> 58:58.400] 对unicode也是一样
[58:58.400 --> 59:01.400] 对只是unicode超级多
[59:01.400 --> 59:03.400] 对他们有社区有委员会来
[59:03.400 --> 59:05.400] 专门定这些东西
[59:05.400 --> 59:06.400] 对然后
[59:06.400 --> 59:08.400] 然后因为这些码点有值
[59:08.400 --> 59:11.400] 有值就要涉及到存储与传输
[59:11.400 --> 59:13.400] 然后就会有编码方式
[59:13.400 --> 59:14.400] 就是incoding
[59:14.400 --> 59:18.400] 就是什么utf8 utf16 utf32
[59:18.400 --> 59:19.400] 对
[59:19.400 --> 59:20.400] 我来说一下
[59:20.400 --> 59:22.400] 你们看我这样理解没有问题
[59:22.400 --> 59:26.400] 比如说第2万个字符是你好的你
[59:26.400 --> 59:28.400] 然后所有的浏览器
[59:28.400 --> 59:29.400] 所有的程序都知道
[59:29.400 --> 59:32.400] 这第2万个字符是这个汉字
[59:32.400 --> 59:34.400] 然后我们在传输的时候
[59:34.400 --> 59:35.400] 会把它编码成bios嘛
[59:35.400 --> 59:38.400] 就是把这个2万这个东西
[59:38.400 --> 59:41.400] 编译成bios对吧
[59:41.400 --> 59:44.400] 然后2万我通过utf8编译成bios
[59:44.400 --> 59:46.400] 它可能因为有一些压缩
[59:46.400 --> 59:48.400] 或者什么的编译成bios之后
[59:48.400 --> 59:51.400] 它的值是123
[59:51.400 --> 59:53.400] 然后我传到另一个地方
[59:53.400 --> 59:55.400] 传到给另一个地方
[59:55.400 --> 59:56.400] 然后他再把这个123
[59:56.400 --> 59:58.400] 按照utf8给decode出来
[59:58.400 --> 59:59.400] 他就知道是2万
[59:59.400 --> 01:00:02.400] 然后对应出来这个你好的你
[01:00:02.400 --> 01:00:04.400] 然后假如说我把这个2万
[01:00:04.400 --> 01:00:06.400] 用utf8 encode
[01:00:06.400 --> 01:00:08.400] 然后编成bios之后是123
[01:00:08.400 --> 01:00:13.400] 然后对方误认为这个是gbk
[01:00:13.400 --> 01:00:15.400] 然后他用gbk给decode出来
[01:00:15.400 --> 01:00:19.400] 发现这个123按照gbk的方法
[01:00:19.400 --> 01:00:22.400] decode出来之后是2万5000
[01:00:22.400 --> 01:00:24.400] 然后就发现这个东西
[01:00:24.400 --> 01:00:25.400] decode出来是一个字
[01:00:25.400 --> 01:00:27.400] 就是遇到了编码问题
[01:00:27.400 --> 01:00:29.400] 对这就是你们小时候玩游戏
[01:00:29.400 --> 01:00:31.400] 会遇到乱码问题吗
[01:00:31.400 --> 01:00:33.400] 对这个其实就是问题的根源
[01:00:33.400 --> 01:00:35.400] 就是我们小时候玩的游戏
[01:00:35.400 --> 01:00:37.400] 全都是台湾产的
[01:00:37.400 --> 01:00:40.400] 对然后台湾的编码
[01:00:40.400 --> 01:00:41.400] 他们的编码
[01:00:41.400 --> 01:00:43.400] 他们的字符集和编码方式
[01:00:43.400 --> 01:00:45.400] 叫big5
[01:00:45.400 --> 01:00:48.400] 对我们叫我们当时叫啥
[01:00:48.400 --> 01:00:50.400] 我不确定我们当时是不是gbk
[01:00:50.400 --> 01:00:52.400] 我忘记了反正就是从一个数值
[01:00:52.400 --> 01:00:54.400] 对应的汉字到编码方式
[01:00:54.400 --> 01:00:55.400] 都是不一致的
[01:00:55.400 --> 01:00:57.400] 但是大家用的那个码点
[01:00:57.400 --> 01:00:58.400] 其实都是统一的对吧
[01:00:58.400 --> 01:01:00.400] 只不过找的这个
[01:01:00.400 --> 01:01:03.400] 不统一码点也是不统一的
[01:01:03.400 --> 01:01:05.400] 大家各自定义自己的码点
[01:01:05.400 --> 01:01:07.400] 这个对就是编码方式
[01:01:07.400 --> 01:01:09.400] 也不同于码点也不同
[01:01:09.400 --> 01:01:13.400] 对那这个问题更难更复杂了
[01:01:13.400 --> 01:01:15.400] 对所以才会有unicode出现
[01:01:15.400 --> 01:01:17.400] 他要解决的就是在互联网之前
[01:01:17.400 --> 01:01:19.400] 其实都是各个国家定义
[01:01:19.400 --> 01:01:21.400] 各个国家自己的一套规范
[01:01:21.400 --> 01:01:23.400] 当时就觉得自己国家能用就行
[01:01:23.400 --> 01:01:26.400] 对然后比如说中文的这些字
[01:01:26.400 --> 01:01:27.400] 其他的国家
[01:01:27.400 --> 01:01:29.400] 他的字符集里都没有定义
[01:01:29.400 --> 01:01:30.400] 因为他们也不需要
[01:01:30.400 --> 01:01:32.400] 对但是后来就满足不了了
[01:01:32.400 --> 01:01:35.400] 对然后就会有通用字符集
[01:01:35.400 --> 01:01:36.400] 这个概念
[01:01:36.400 --> 01:01:38.400] OK我觉得科普的差不多了
[01:01:38.400 --> 01:01:41.400] 我觉得现在听众应该都比较好
[01:01:41.400 --> 01:01:42.400] 区分编码方式
[01:01:42.400 --> 01:01:44.400] 干嘛点这些东西了
[01:01:44.400 --> 01:01:47.400] 对其实关于unicode和关于Tiff
[01:01:47.400 --> 01:01:49.400] 其实我记得我看过一个
[01:01:49.400 --> 01:01:50.400] 非常好的一个资料
[01:01:50.400 --> 01:01:52.400] 一个slides
[01:01:52.400 --> 01:01:54.400] 我回头可以分享出来
[01:01:54.400 --> 01:01:56.400] 然后这里面其实会
[01:01:56.400 --> 01:01:58.400] 非常详细去解释这是什么概念
[01:01:58.400 --> 01:02:00.400] 然后在这个分享里面
[01:02:00.400 --> 01:02:01.400] 我记得他提到一个概念
[01:02:01.400 --> 01:02:03.400] 叫做unicode sandwich
[01:02:03.400 --> 01:02:05.400] 其实就是他提到一个概念
[01:02:05.400 --> 01:02:07.400] 其实就是在外面你用byte
[01:02:07.400 --> 01:02:10.400] 但是在你的应用程序内部
[01:02:10.400 --> 01:02:11.400] 你就去用unicode
[01:02:11.400 --> 01:02:14.400] 这个我也看过这是写的挺好
[01:02:14.400 --> 01:02:17.400] 我不确认我没有看过了
[01:02:17.400 --> 01:02:19.400] 是说就是所有的字符处理
[01:02:19.400 --> 01:02:20.400] 都应该是先decode
[01:02:20.400 --> 01:02:23.400] 然后处理完再encode对吧
[01:02:23.400 --> 01:02:25.400] 对对对对对
[01:02:25.400 --> 01:02:27.400] 我有点忘记那个文章
[01:02:27.400 --> 01:02:29.400] 或者是一个排框的分享
[01:02:29.400 --> 01:02:30.400] 叫做什么了
[01:02:30.400 --> 01:02:33.400] 但是那个slide是个正方形的
[01:02:33.400 --> 01:02:34.400] 然后底是白色的
[01:02:34.400 --> 01:02:36.400] 你涂成黄色的吗
[01:02:36.400 --> 01:02:38.400] 哈哈哈哈
[01:02:38.400 --> 01:02:39.400] 我们可以找一找
[01:02:39.400 --> 01:02:41.400] 然后分享给听众
[01:02:41.400 --> 01:02:42.400] ok
[01:02:42.400 --> 01:02:44.400] 对反正提起这个unicode问题
[01:02:44.400 --> 01:02:45.400] 其实是因为
[01:02:45.400 --> 01:02:47.400] 我们在Python2里面
[01:02:47.400 --> 01:02:48.400] 其实是很
[01:02:48.400 --> 01:02:50.400] 大家是不注意去区分
[01:02:50.400 --> 01:02:53.400] 所谓的str和unicode
[01:02:53.400 --> 01:02:55.400] 所以在这一点上面看起来
[01:02:55.400 --> 01:02:57.400] 其实我觉得在Python2里面
[01:02:57.400 --> 01:03:00.400] 它的行为其实就是有点像
[01:03:00.400 --> 01:03:01.400] 弱类型一样
[01:03:01.400 --> 01:03:03.400] 比如说str加unicode
[01:03:03.400 --> 01:03:06.400] 它其实会被自动转成unicode
[01:03:06.400 --> 01:03:08.400] 它会把str给decode
[01:03:08.400 --> 01:03:09.400] 它其实就是说
[01:03:09.400 --> 01:03:11.400] 你那str其实是跟unicode
[01:03:11.400 --> 01:03:12.400] 是可以相加的
[01:03:12.400 --> 01:03:14.400] 然后在Python2里面
[01:03:14.400 --> 01:03:17.400] 然后之后就会被转成unicode
[01:03:17.400 --> 01:03:18.400] 有类似的行为
[01:03:18.400 --> 01:03:19.400] 其实会埋坑
[01:03:19.400 --> 01:03:20.400] 是不是这样
[01:03:20.400 --> 01:03:22.400] 就是那个str是一个
[01:03:22.400 --> 01:03:23.400] encode之后的
[01:03:23.400 --> 01:03:24.400] 比如说200
[01:03:24.400 --> 01:03:26.400] 然后那个unicode是一个码点
[01:03:26.400 --> 01:03:27.400] 比如说200
[01:03:27.400 --> 01:03:29.400] 这个200可以跟200相加
[01:03:29.400 --> 01:03:30.400] 对
[01:03:30.400 --> 01:03:31.400] 我想起来了
[01:03:31.400 --> 01:03:33.400] 这个确实很恶心
[01:03:33.400 --> 01:03:35.400] 然后这样你一旦相加起来
[01:03:35.400 --> 01:03:37.400] 传出去交给别人就
[01:03:37.400 --> 01:03:38.400] 非常非常难解决
[01:03:38.400 --> 01:03:41.400] 因为它既不是一个
[01:03:41.400 --> 01:03:43.400] encode之后的那个bios
[01:03:43.400 --> 01:03:45.400] 又不是一个unicode
[01:03:45.400 --> 01:03:46.400] 它两部分都有
[01:03:46.400 --> 01:03:48.400] 我收到过这种东西
[01:03:48.400 --> 01:03:51.400] 我在ACI里面见过这种东西
[01:03:51.400 --> 01:03:53.400] 我觉得这个
[01:03:53.400 --> 01:03:56.400] 这个就是好像就是所有的
[01:03:56.400 --> 01:03:58.400] 课程也好教材也好
[01:03:58.400 --> 01:04:00.400] 只教你啥是字符串
[01:04:00.400 --> 01:04:03.400] 什么是string
[01:04:03.400 --> 01:04:05.400] 但是一旦涉及到具体的文字
[01:04:05.400 --> 01:04:07.400] 这里面涉及的东西就很多
[01:04:07.400 --> 01:04:10.400] 其实这让我想起来
[01:04:10.400 --> 01:04:11.400] 其实对
[01:04:11.400 --> 01:04:12.400] 我确实在
[01:04:12.400 --> 01:04:13.400] 我是在迁移过程中
[01:04:13.400 --> 01:04:14.400] 才知道的一个
[01:04:14.400 --> 01:04:17.400] 就是当我去编立一个byte的时候
[01:04:17.400 --> 01:04:18.400] 例如我就是byte
[01:04:18.400 --> 01:04:20.400] 就是abcd的一个byte
[01:04:20.400 --> 01:04:21.400] 那么我去编立的时候
[01:04:21.400 --> 01:04:23.400] 我用一个for去print里面
[01:04:23.400 --> 01:04:24.400] 这个足够print出来的时候
[01:04:24.400 --> 01:04:26.400] 其实你得到就是97 98 99
[01:04:26.400 --> 01:04:28.400] 这个你们可以在pattern3里面去试一下
[01:04:28.400 --> 01:04:29.400] 但起码在pattern3里面
[01:04:29.400 --> 01:04:31.400] 你知道这是一个byte
[01:04:31.400 --> 01:04:32.400] 但是在pattern2里面
[01:04:32.400 --> 01:04:34.400] 就是确实它没有
[01:04:34.400 --> 01:04:35.400] 清晰地给你指出来的时候
[01:04:35.400 --> 01:04:37.400] 其实它是都有可能
[01:04:37.400 --> 01:04:40.400] 对当时在没有明确引入ub
[01:04:40.400 --> 01:04:41.400] 这两个概念
[01:04:41.400 --> 01:04:43.400] 就是说是大家在盲写的时候
[01:04:43.400 --> 01:04:44.400] 就可能GG
[01:04:44.400 --> 01:04:46.400] 但是不是不是
[01:04:46.400 --> 01:04:47.400] 就是这个
[01:04:47.400 --> 01:04:48.400] 怎么不是
[01:04:48.400 --> 01:04:50.400] 我觉得我们可以再讨论一把
[01:04:50.400 --> 01:04:51.400] 你abcd的话
[01:04:51.400 --> 01:04:53.400] 比如说你一个就你什么前
[01:04:53.400 --> 01:04:54.400] 前罪都不加的abcd
[01:04:54.400 --> 01:04:55.400] 它既可能是byte
[01:04:55.400 --> 01:04:57.400] 也有可能是其他
[01:04:57.400 --> 01:04:58.400] 就是你不强制声明
[01:04:58.400 --> 01:04:59.400] 就是它的值
[01:04:59.400 --> 01:05:01.400] 是可以代表很多含义的
[01:05:01.400 --> 01:05:02.400] 是二一系
[01:05:02.400 --> 01:05:04.400] 对它是这个东西的话
[01:05:04.400 --> 01:05:05.400] 其实也是个经典的
[01:05:05.400 --> 01:05:07.400] 可能如果说你之前
[01:05:07.400 --> 01:05:09.400] 就是说是没有正确的使用的话
[01:05:09.400 --> 01:05:11.400] 也是会让你觉得
[01:05:11.400 --> 01:05:13.400] 在欢声笑语中打出GG的
[01:05:13.400 --> 01:05:14.400] 在迁移的时候
[01:05:14.400 --> 01:05:16.400] 听众朋友们可能不太知道
[01:05:16.400 --> 01:05:18.400] 我们刚才一下在讨论什么
[01:05:18.400 --> 01:05:20.400] 我这个给大家讲一下
[01:05:20.400 --> 01:05:23.400] 就是比如说你一个abcd的
[01:05:23.400 --> 01:05:24.400] abcd的字符串
[01:05:24.400 --> 01:05:26.400] 你一个abcd的字符串
[01:05:26.400 --> 01:05:27.400] 然后的话就是双引号
[01:05:27.400 --> 01:05:28.400] 在python2里面
[01:05:28.400 --> 01:05:30.400] 然后你前面什么前罪
[01:05:30.400 --> 01:05:31.400] 不管是ubr也好
[01:05:31.400 --> 01:05:33.400] 你什么前罪都不加
[01:05:33.400 --> 01:05:34.400] 这个时候呢
[01:05:34.400 --> 01:05:36.400] 如果说你要去
[01:05:36.400 --> 01:05:37.400] 我们就来问一下
[01:05:37.400 --> 01:05:40.400] 你这段代码可能是代表了什么含义
[01:05:40.400 --> 01:05:41.400] 实际上是有两种
[01:05:41.400 --> 01:05:44.400] 第一种就是你包含abcd
[01:05:44.400 --> 01:05:47.400] 三个四个字符串
[01:05:47.400 --> 01:05:49.400] 第二个是分别代表
[01:05:49.400 --> 01:05:51.400] 第二个是分别代表
[01:05:51.400 --> 01:05:55.400] 97 98 99和100的字节数据
[01:05:55.400 --> 01:05:56.400] 所以说这个地方的话
[01:05:56.400 --> 01:05:58.400] 就是它的字节数据和字符串
[01:05:58.400 --> 01:05:59.400] 混合语义上的
[01:05:59.400 --> 01:06:00.400] 就算是二一性
[01:06:00.400 --> 01:06:02.400] 会导致你在写代码
[01:06:02.400 --> 01:06:05.400] 或者说之后迁移的过程之中
[01:06:05.400 --> 01:06:06.400] 出现很大的问题
[01:06:06.400 --> 01:06:08.400] 对是这样
[01:06:08.400 --> 01:06:11.400] 所以其实这也算python3的改进之一
[01:06:11.400 --> 01:06:13.400] 对对对
[01:06:13.400 --> 01:06:15.400] 对我之前写过一个python3之路
[01:06:15.400 --> 01:06:17.400] 我去年做的一个分享就是python3之路
[01:06:17.400 --> 01:06:21.400] 就分享python2到python3之间的一些改进和优化
[01:06:21.400 --> 01:06:22.400] 对golang这边
[01:06:22.400 --> 01:06:25.400] 其实可能会做的比python3好
[01:06:25.400 --> 01:06:26.400] 比python整体都要好吧
[01:06:26.400 --> 01:06:30.400] 就是对byte,ruin,stream
[01:06:30.400 --> 01:06:32.400] 它都会有一个清晰的区分
[01:06:32.400 --> 01:06:34.400] 然后来让大家来了解
[01:06:34.400 --> 01:06:36.400] 对它有一个比较好的概念是ruin
[01:06:36.400 --> 01:06:38.400] 对其实对大家做一些字符串呀
[01:06:38.400 --> 01:06:39.400] 或者文本的处理
[01:06:39.400 --> 01:06:41.400] 其实会清晰一些
[01:06:41.400 --> 01:06:42.400] 是我再举个例子
[01:06:42.400 --> 01:06:44.400] 其实python2之前更还是挺多的
[01:06:44.400 --> 01:06:47.400] 就比如说早期版本python是没有
[01:06:47.400 --> 01:06:50.400] generator或者是iterator这种概念的
[01:06:50.400 --> 01:06:52.400] 所以说比如说你直接
[01:06:52.400 --> 01:06:54.400] 你要去比如说我们
[01:06:54.400 --> 01:06:55.400] 字里点key字
[01:06:55.400 --> 01:06:58.400] 然后是获取它里面所有的key对吧
[01:06:58.400 --> 01:07:00.400] 它默认的情况下是直接
[01:07:00.400 --> 01:07:03.400] 那个默认情况下是生成的一个
[01:07:03.400 --> 01:07:04.400] 就说是list嘛
[01:07:04.400 --> 01:07:07.400] 但是如果说你内存里面就key太多
[01:07:07.400 --> 01:07:08.400] 你内存肯定要炸对吧
[01:07:08.400 --> 01:07:10.400] 然后你后面引入
[01:07:10.400 --> 01:07:13.400] 你再引入那个生成器的概念之后
[01:07:13.400 --> 01:07:15.400] 你就有了x
[01:07:15.400 --> 01:07:17.400] 那个就说是iterkey
[01:07:17.400 --> 01:07:19.400] itervalue
[01:07:19.400 --> 01:07:21.400] 就是那个我没记错的话是
[01:07:21.400 --> 01:07:22.400] 对iteritems
[01:07:22.400 --> 01:07:23.400] iterkeys
[01:07:23.400 --> 01:07:25.400] itervalue这种东西
[01:07:25.400 --> 01:07:29.400] 就会导致整体的那个API设计很割裂
[01:07:29.400 --> 01:07:32.400] 因为它要向前兼容以前的行为嘛
[01:07:32.400 --> 01:07:35.400] 但是之前的命名和接口都已经给出去了
[01:07:35.400 --> 01:07:36.400] 那它只能
[01:07:36.400 --> 01:07:39.400] 对对就是它向前兼容
[01:07:39.400 --> 01:07:40.400] 它最开始设计失误
[01:07:40.400 --> 01:07:42.400] 导致它向前兼容的时候
[01:07:42.400 --> 01:07:44.400] 就是说是我补上这个设计失误
[01:07:44.400 --> 01:07:46.400] 但是突然发现一大堆人用我设计失误
[01:07:46.400 --> 01:07:47.400] 用我开新
[01:07:47.400 --> 01:07:49.400] 然后就导致它就要向前兼容
[01:07:49.400 --> 01:07:52.400] 然后它就整体的API就很分裂了
[01:07:52.400 --> 01:07:56.400] 但是我觉得社区在这个上面
[01:07:56.400 --> 01:07:57.400] 风格并不是统一的呀
[01:07:57.400 --> 01:07:58.400] 就我举个例子
[01:07:58.400 --> 01:07:59.400] 就比如说Range
[01:07:59.400 --> 01:08:00.400] X-Range
[01:08:00.400 --> 01:08:01.400] Range对吧
[01:08:01.400 --> 01:08:04.400] 对就是它经历了这种
[01:08:04.400 --> 01:08:06.400] 先是提供了一个新的
[01:08:06.400 --> 01:08:09.400] 然后又去改老的这种情况
[01:08:09.400 --> 01:08:11.400] 对它是先提供新的
[01:08:11.400 --> 01:08:15.400] 但是你Python3是直接把老的语音也发生了变化
[01:08:15.400 --> 01:08:16.399] 就是你这个
[01:08:16.399 --> 01:08:17.399] 对对版本割裂嘛
[01:08:17.399 --> 01:08:19.399] 所以这个部分很多时候
[01:08:19.399 --> 01:08:23.399] Python2的时期的API设计的割裂
[01:08:23.399 --> 01:08:25.399] 会导致你在签Python3的时候
[01:08:25.399 --> 01:08:27.399] 因为它重新一统了嘛
[01:08:27.399 --> 01:08:30.399] 会导致你签译的时候还是有很多坑
[01:08:30.399 --> 01:08:33.399] 这个我之前还看Video说过
[01:08:33.399 --> 01:08:35.399] Python3的一个错误
[01:08:35.399 --> 01:08:37.399] 就是把CX作为一个三方库
[01:08:37.399 --> 01:08:40.399] 如果能重新就是搞这个Python3的话
[01:08:40.399 --> 01:08:42.399] 就把它放到标定页里面
[01:08:42.399 --> 01:08:43.399] 诶陈征
[01:08:43.399 --> 01:08:45.399] 陈征我把话题拉回来
[01:08:45.399 --> 01:08:47.399] 我想问就比如说
[01:08:47.399 --> 01:08:50.399] 其实刚才也聊了一些Python3的那个
[01:08:50.399 --> 01:08:52.399] 签译的一些过程啊
[01:08:52.399 --> 01:08:53.399] 包括踩的坑啊
[01:08:53.399 --> 01:08:55.399] 然后一些经验啊
[01:08:55.399 --> 01:08:57.399] 对啊就是如果说
[01:08:57.399 --> 01:08:59.399] 比如说现在还是有一些公司没有签译的话
[01:08:59.399 --> 01:09:01.399] 你会有什么建议吗
[01:09:01.399 --> 01:09:02.399] 对包括一些经验也好
[01:09:02.399 --> 01:09:05.399] 或者一些资料也好来指导大家
[01:09:05.399 --> 01:09:07.399] 对包括新濤和NZSAKA
[01:09:07.399 --> 01:09:08.399] 大家会有什么建议吗
[01:09:08.399 --> 01:09:11.399] 嗯其实我觉得我的建议是
[01:09:11.399 --> 01:09:13.399] 我们刚才其实提到了
[01:09:13.399 --> 01:09:14.399] 都已经覆盖到了
[01:09:14.399 --> 01:09:18.399] 例如我建议尽可能的去提高你的覆盖率
[01:09:18.399 --> 01:09:20.399] 因为在签译过程中
[01:09:20.399 --> 01:09:21.399] 对测试的覆盖率
[01:09:21.399 --> 01:09:24.399] 其实在签译过程中通过测试
[01:09:24.399 --> 01:09:26.399] 能够暴露非常非常多的问题
[01:09:26.399 --> 01:09:29.399] 这一点是极大的减少了线上的失误
[01:09:29.399 --> 01:09:32.399] 然后刚刚也提到另外一点是
[01:09:32.399 --> 01:09:33.399] 关于Unicode的问题
[01:09:33.399 --> 01:09:35.399] 我觉得处理好
[01:09:35.399 --> 01:09:38.399] STL和Unicode的这一点上面
[01:09:38.399 --> 01:09:39.399] 也是可以去做很多文章的
[01:09:39.399 --> 01:09:41.399] 那么我的建议是
[01:09:41.399 --> 01:09:44.399] 对于这种字符串的处理
[01:09:44.399 --> 01:09:45.399] 要多加小心
[01:09:45.399 --> 01:09:47.399] 例如你在Pattern 2里面
[01:09:47.399 --> 01:09:50.399] 去手动去Encode了UTF-8
[01:09:50.399 --> 01:09:53.399] 那这样的怠慢就多看一下
[01:09:53.399 --> 01:09:55.400] 因为如果没有特殊要求的话
[01:09:55.400 --> 01:09:58.400] 你就最好不要手动的去Encode
[01:09:58.400 --> 01:10:00.400] 然后在签译的过程中
[01:10:00.400 --> 01:10:03.400] 我觉得SIG这样一个库是非常好用的
[01:10:03.400 --> 01:10:05.400] 比如刚才提到的
[01:10:05.400 --> 01:10:06.400] 关于对字符串的处理
[01:10:06.400 --> 01:10:10.400] 它其实提供了几个很好用的一个函数
[01:10:10.400 --> 01:10:12.400] 分别是insure binary
[01:10:12.400 --> 01:10:13.400] insure str
[01:10:13.400 --> 01:10:15.400] insure text
[01:10:15.400 --> 01:10:17.400] 这几个地方其实都能够
[01:10:17.400 --> 01:10:19.400] 针对不同的输入
[01:10:19.400 --> 01:10:21.400] 在R3里面去保证
[01:10:21.400 --> 01:10:24.400] 它的输出是你想要的
[01:10:24.400 --> 01:10:27.400] SIG是个相当好用的库
[01:10:27.400 --> 01:10:29.400] 你在做那个
[01:10:29.400 --> 01:10:33.400] 在做就是你特别是有些是SDK
[01:10:33.400 --> 01:10:35.400] 你要兼容R3的时候就很麻烦
[01:10:35.400 --> 01:10:37.400] SIG就是必备
[01:10:37.400 --> 01:10:39.400] 有很多库如果他们支持R3的话
[01:10:39.400 --> 01:10:44.400] 其实他们自己也在大量的去使用SIG来去做兼容
[01:10:44.400 --> 01:10:45.400] 对,是
[01:10:45.400 --> 01:10:48.400] SIG是你兼容R3
[01:10:48.400 --> 01:10:51.400] 如果说你个SDK兼容R3是逃不了的
[01:10:51.400 --> 01:10:53.400] 还有什么推荐吗?陈征
[01:10:53.400 --> 01:10:56.400] 暂时没有了
[01:10:56.400 --> 01:10:57.400] 那就看你呢
[01:10:57.400 --> 01:11:00.400] 你有什么推荐给大家的经验和建议吗?
[01:11:00.400 --> 01:11:03.400] 其实我觉得最好是在签之前
[01:11:03.400 --> 01:11:06.400] 首先要确保你所有的东西都是R3兼容的
[01:11:06.400 --> 01:11:07.400] 你的依赖
[01:11:07.400 --> 01:11:08.400] 我觉得这个很重要
[01:11:08.400 --> 01:11:11.400] 我觉得你不要看2020年
[01:11:11.400 --> 01:11:13.400] 然后但是你不知道你前任用的什么库
[01:11:13.400 --> 01:11:15.400] 他就没有做R3兼容
[01:11:15.400 --> 01:11:17.400] 对,就我觉得这个是个很重要的一件事
[01:11:17.400 --> 01:11:21.400] 就是因为其实在做签语之前需要有个checklist
[01:11:21.400 --> 01:11:24.400] 你需要去就是说是checklist
[01:11:24.400 --> 01:11:28.400] 就是第一个就是你就准备个checklist
[01:11:28.400 --> 01:11:30.400] 就是说是我觉得就是说你准备个时间表
[01:11:30.400 --> 01:11:33.400] 在某一个阶段之前要做好什么事情
[01:11:33.400 --> 01:11:35.400] 然后按照就是说这个checklist来
[01:11:35.400 --> 01:11:38.400] 第二个的话就是说是你需要去逐一比对
[01:11:38.400 --> 01:11:40.400] 就比如说第一步不测试
[01:11:40.400 --> 01:11:42.400] 你的测试哪些关键点是有测试覆盖的
[01:11:42.400 --> 01:11:44.400] 哪些关键点没有测试覆盖
[01:11:44.400 --> 01:11:46.400] 哪些关键点一定要有测试覆盖
[01:11:46.400 --> 01:11:49.400] 然后第二个就比如说你的那个你周边的库
[01:11:49.400 --> 01:11:51.400] 然后你周边会像我走之前
[01:11:51.400 --> 01:11:52.400] 我老东家还有几个服务
[01:11:52.400 --> 01:11:55.400] 没有签python3是因为它是模型内的库
[01:11:55.400 --> 01:11:57.400] 然后它依赖XGBoost的
[01:11:57.400 --> 01:11:58.400] XGBoost的有几个版本
[01:11:58.400 --> 01:11:59.400] 就是说是兼容3的版本
[01:11:59.400 --> 01:12:02.400] 它和2之间它的那个训练出来的模型效果
[01:12:02.400 --> 01:12:04.400] 会有比较大的变化
[01:12:04.400 --> 01:12:05.400] 这个时候你就没办法签
[01:12:05.400 --> 01:12:08.400] 所以说你需要去签去
[01:12:08.400 --> 01:12:10.400] 主要是double check和triple check
[01:12:10.400 --> 01:12:11.400] 就是说你的依赖
[01:12:11.400 --> 01:12:13.400] 然后你一定要跟业务方
[01:12:13.400 --> 01:12:14.400] 如果说是你是info2方的话
[01:12:14.400 --> 01:12:16.400] 你一定要去跟业务方确认
[01:12:16.400 --> 01:12:19.400] 你这个库升级之后不会影响到他们的东西
[01:12:19.400 --> 01:12:21.400] 然后你这个库是兼容23的
[01:12:21.400 --> 01:12:23.400] 然后这一套东西就很
[01:12:23.400 --> 01:12:25.400] 然后就其实是个挺恶心的账户
[01:12:25.400 --> 01:12:27.400] 但是是不得不做的账户
[01:12:27.400 --> 01:12:28.400] 这个东西一定要做
[01:12:28.400 --> 01:12:33.400] 你千万不要以为你所有的库都能签到python3
[01:12:33.400 --> 01:12:35.400] 虽然现在是02 020
[01:12:35.400 --> 01:12:36.400] 具体怎么检查
[01:12:36.400 --> 01:12:39.400] 其实用一个叫做can I use python3的库
[01:12:39.400 --> 01:12:40.400] 3是数字的3
[01:12:40.400 --> 01:12:43.400] 是这个有些基础的东西
[01:12:43.400 --> 01:12:44.400] 但是就像我刚才说了
[01:12:44.400 --> 01:12:45.400] 就是说是我们有库
[01:12:45.400 --> 01:12:46.400] 它是能签到3的
[01:12:46.400 --> 01:12:48.400] 它有3的版本
[01:12:48.400 --> 01:12:50.400] 但是你签了3的版本之后
[01:12:50.400 --> 01:12:51.400] 你的业务数据
[01:12:51.400 --> 01:12:53.400] 它会导致你行为发生变化
[01:12:53.400 --> 01:12:55.400] 对你这个就行为的测试了
[01:12:55.400 --> 01:12:56.400] 对对对
[01:12:56.400 --> 01:12:59.400] 说实话就是说是你triple check就一定要去和
[01:12:59.400 --> 01:13:01.400] 就是说是你的业务方
[01:13:01.400 --> 01:13:03.400] 业务方保证你的东西
[01:13:03.400 --> 01:13:05.400] 就是说是你签1到23之后
[01:13:05.400 --> 01:13:06.400] 说这也是灰度嘛
[01:13:06.400 --> 01:13:08.400] 一定要签1这些东西
[01:13:08.400 --> 01:13:09.400] 特别是有些不
[01:13:10.400 --> 01:13:12.400] 所以我理解是不是这样的呀
[01:13:12.400 --> 01:13:14.400] 就是你签1python3
[01:13:14.400 --> 01:13:16.400] 除了你自己叠代代码
[01:13:16.400 --> 01:13:17.400] 还有一部分工作是
[01:13:17.400 --> 01:13:21.400] 你发现你的依赖不适配python3
[01:13:21.400 --> 01:13:23.400] 那你就要去升级到支持python3的
[01:13:23.400 --> 01:13:26.400] 但是这中间它的升级又不是说
[01:13:26.400 --> 01:13:30.400] 它给你提供了一个行为没有变化的python3版本
[01:13:30.400 --> 01:13:32.400] 而是它本身也有版本升级
[01:13:32.400 --> 01:13:35.400] 那你升级之后可能还要再去做
[01:13:35.400 --> 01:13:36.400] 这个你依赖的兼容啊
[01:13:36.400 --> 01:13:37.400] 适配啊
[01:13:37.400 --> 01:13:40.400] 是的没错100%
[01:13:40.400 --> 01:13:41.400] 是的没错
[01:13:41.400 --> 01:13:42.400] 对因为你要升级它
[01:13:42.400 --> 01:13:44.400] 它可能会引入break and change
[01:13:44.400 --> 01:13:47.400] 是的它可能会引入break and change
[01:13:47.400 --> 01:13:48.400] 然后的话
[01:13:48.400 --> 01:13:50.400] 而且因为你一般情况下
[01:13:50.400 --> 01:13:51.400] 可能你还会用你
[01:13:51.400 --> 01:13:53.400] 你签1的时候可能就说是
[01:13:53.400 --> 01:13:55.400] 一般情况下会有一个owner
[01:13:55.400 --> 01:13:56.400] 你做一个owner去签1
[01:13:56.400 --> 01:13:59.400] 你签1的时候可能会去覆盖到别人代码
[01:13:59.400 --> 01:14:00.400] 这个时候别人用了什么依赖
[01:14:00.400 --> 01:14:02.400] 大家一定要double check或triple check
[01:14:02.400 --> 01:14:03.400] 千万不要想当然
[01:14:03.400 --> 01:14:05.400] 我觉得这个升级没问题
[01:14:05.400 --> 01:14:06.400] 你觉得没问题的时候
[01:14:06.400 --> 01:14:07.400] 升级一般都会出过
[01:14:07.400 --> 01:14:10.400] 这是切身之痛啊我擦
[01:14:10.400 --> 01:14:11.400] 好吧
[01:14:11.400 --> 01:14:15.400] 新涛你呢你有什么经验可以和大家分享的吗
[01:14:15.400 --> 01:14:16.400] 我其实经验比较少
[01:14:16.400 --> 01:14:18.400] 但有一点可以分享的是那个
[01:14:18.400 --> 01:14:22.400] coverage.py在3.8是有问题的
[01:14:22.400 --> 01:14:24.400] 4.5之前是有问题的
[01:14:24.400 --> 01:14:27.400] 然后就是这个问题比较难排查
[01:14:27.400 --> 01:14:29.400] 就是假如说你发现你签1
[01:14:29.400 --> 01:14:30.400] pattern的时候
[01:14:30.400 --> 01:14:33.400] 签1过后代码的覆盖率下
[01:14:33.400 --> 01:14:34.400] 严重下降了
[01:14:34.400 --> 01:14:36.400] 你可以先尝试升级一下
[01:14:36.400 --> 01:14:37.400] 那个coverage.py
[01:14:37.400 --> 01:14:39.400] 其实我后来想了一下这个问题
[01:14:39.400 --> 01:14:42.400] coverage.py是没法做的向前兼容的
[01:14:42.400 --> 01:14:44.400] 然后老的版本
[01:14:44.400 --> 01:14:48.400] 他又不知道我这个未来的判断代码会改变什么东西
[01:14:48.400 --> 01:14:51.400] 所以遇到这种覆盖率下降的问题的时候
[01:14:51.400 --> 01:14:53.400] 你看不到任何提示
[01:14:53.400 --> 01:14:56.400] 也排查起来会比较麻烦吧
[01:14:56.400 --> 01:14:58.400] 因为他给不出你任何提示
[01:14:58.400 --> 01:14:59.400] 也不会报什么错
[01:14:59.400 --> 01:15:01.400] 覆盖率下就是下降了
[01:15:01.400 --> 01:15:02.400] 对吧
[01:15:02.400 --> 01:15:03.400] 对了
[01:15:02.400 --> 01:15:05.400] 我觉得就是你check的一个重点
[01:15:05.400 --> 01:15:06.400] 还是就是去check你的
[01:15:06.400 --> 01:15:07.400] 你可能会
[01:15:07.400 --> 01:15:10.400] 比如说有些公司会自己做一些c extension
[01:15:10.400 --> 01:15:13.400] 这个时候你一定要去check你应用的相关c API的变化
[01:15:13.400 --> 01:15:14.400] 这个很重要
[01:15:14.400 --> 01:15:18.400] 因为二三之间的c API变化其实是相当大的
[01:15:18.400 --> 01:15:19.400] 但是这个如果有ci的话
[01:15:19.400 --> 01:15:21.400] 应该是能跑出来的
[01:15:21.400 --> 01:15:22.400] 是能跑出来
[01:15:22.400 --> 01:15:23.400] 是能跑出来
[01:15:22.400 --> 01:15:26.400] 但是你就说是需要去check你哪些extension是自研的
[01:15:26.400 --> 01:15:28.400] 然后你哪些c extension是哪些
[01:15:28.400 --> 01:15:30.400] 就是说是外部的
[01:15:30.400 --> 01:15:31.400] 然后他做了二三兼容的
[01:15:31.400 --> 01:15:33.400] 有些哪些是没做的
[01:15:33.400 --> 01:15:36.400] 然后你这个东西就还是要做一个double
[01:15:36.400 --> 01:15:37.400] triple check
[01:15:37.400 --> 01:15:39.400] 我觉得我们还没有聊那个一部相关的
[01:15:39.400 --> 01:15:42.400] 我觉得很多人去用Python 3
[01:15:42.400 --> 01:15:43.400] 也有可能是因为
[01:15:43.400 --> 01:15:47.400] 他的一部好像变得更加好用了
[01:15:47.400 --> 01:15:49.400] 我其实很好奇
[01:15:49.400 --> 01:15:52.400] 因为我知道在3.4 3.5的时候
[01:15:52.400 --> 01:15:55.400] 其实他是一直有各种变化的
[01:15:55.400 --> 01:15:57.400] 我没有了解过他背后的历史
[01:15:57.400 --> 01:15:59.400] 包括他的实现
[01:15:59.400 --> 01:16:01.400] 他整个过程是什么样子的
[01:16:01.400 --> 01:16:04.400] 我觉得可以聊一聊这一块
[01:16:04.400 --> 01:16:05.400] 我不是特别说
[01:16:05.400 --> 01:16:07.400] 因为我知道他是从3.4
[01:16:07.400 --> 01:16:09.400] 从you from然后到3.5的时候
[01:16:09.400 --> 01:16:12.400] 就忽然有了async await这样的关键字
[01:16:12.400 --> 01:16:15.400] 关于这块还挺感兴趣的
[01:16:15.400 --> 01:16:17.400] 我觉得一部现在整体来讲
[01:16:17.400 --> 01:16:18.400] 还是相当不成熟
[01:16:18.400 --> 01:16:20.400] 他本身上其实就是
[01:16:20.400 --> 01:16:23.400] 他其实对于后面3.5的async await来讲
[01:16:23.400 --> 01:16:25.400] 他其实本身来讲
[01:16:25.400 --> 01:16:27.400] 他还是一个语法堂
[01:16:27.400 --> 01:16:29.400] 就是说你不用去手动限制
[01:16:29.400 --> 01:16:32.400] 就是手动去写yield from
[01:16:32.400 --> 01:16:34.400] 因为他其实在最开始的版本里面
[01:16:34.400 --> 01:16:36.400] 你async await
[01:16:36.400 --> 01:16:37.400] 其实和yield from
[01:16:37.400 --> 01:16:38.400] 其实是没什么区别
[01:16:38.400 --> 01:16:39.400] 而在3.4版本里面
[01:16:39.400 --> 01:16:41.400] 你yield from的东西
[01:16:41.400 --> 01:16:44.400] 是可以用他async io.croutine的装置器
[01:16:44.400 --> 01:16:45.400] 包裹一下就ok的
[01:16:45.400 --> 01:16:46.400] 成为一个feature
[01:16:46.400 --> 01:16:48.400] 然后你后续的语法堂
[01:16:48.400 --> 01:16:49.400] 衍生出来的东西
[01:16:49.400 --> 01:16:50.400] 就是你可以去做
[01:16:50.400 --> 01:16:52.400] 比如说异步的上下文管理器
[01:16:52.400 --> 01:16:54.400] 比如说你在上下文管理器里面
[01:16:54.400 --> 01:16:55.400] 你有些io操作
[01:16:55.400 --> 01:16:57.400] 那么这个时候你也是可以async await
[01:16:57.400 --> 01:16:59.400] 还有其他的一些小东西
[01:16:59.400 --> 01:17:00.400] 他本质上来讲
[01:17:00.400 --> 01:17:02.400] Python现在的3.5
[01:17:02.400 --> 01:17:04.400] 不是3.5是Python的async io
[01:17:04.400 --> 01:17:06.400] async这一套体系
[01:17:06.400 --> 01:17:08.400] 他还是基于Python原本的
[01:17:08.400 --> 01:17:10.400] 在P2XXX
[01:17:10.400 --> 01:17:12.400] 那个就是generator和那个
[01:17:12.400 --> 01:17:14.400] 就是说是3.4.2还是哪个
[01:17:14.400 --> 01:17:15.400] 忘了
[01:17:15.400 --> 01:17:17.400] 然后就是他一套的
[01:17:17.400 --> 01:17:19.400] 就是生成器的体系改过来
[01:17:19.400 --> 01:17:21.400] 因为他后面他最开始的生成器
[01:17:21.400 --> 01:17:23.400] 是没有那一套东西
[01:17:23.400 --> 01:17:25.400] 就是生成器他可以保持上下文
[01:17:25.400 --> 01:17:27.400] 但是他的数据流向是带降的
[01:17:27.400 --> 01:17:28.400] 后续加入了send
[01:17:28.400 --> 01:17:30.400] 然后但是你生成器套生成器
[01:17:30.400 --> 01:17:32.400] 然后这个时候你生成器套生成器
[01:17:32.400 --> 01:17:34.400] 然后返回直这些东西
[01:17:34.400 --> 01:17:36.400] 你需要自己去做一些dirty work
[01:17:36.400 --> 01:17:38.400] 说说后面引入了
[01:17:38.400 --> 01:17:39.400] 那个yield from
[01:17:39.400 --> 01:17:41.400] 然后你yield from之后
[01:17:41.400 --> 01:17:42.400] 你后面就显示了
[01:17:42.400 --> 01:17:43.400] 把它规定成为一个具体的
[01:17:43.400 --> 01:17:44.400] 余法行async await
[01:17:44.400 --> 01:17:46.400] 就是具体这一套
[01:17:46.400 --> 01:17:47.400] 现在来讲
[01:17:47.400 --> 01:17:48.400] 其实是他的
[01:17:48.400 --> 01:17:50.400] API在3.7以后算是
[01:17:50.400 --> 01:17:52.400] 就是说是他官方的推荐的
[01:17:52.400 --> 01:17:54.400] 就是说是世界循环库在3.7以后
[01:17:54.400 --> 01:17:56.400] 是趋于一个stable的状态
[01:17:56.400 --> 01:17:58.400] 就是说是构建相对合理了
[01:17:58.400 --> 01:17:59.400] 在3.56的时候
[01:17:59.400 --> 01:18:02.400] 其实他的问题还是不少的
[01:18:02.400 --> 01:18:04.400] 就是包括他的很多API设计不合理
[01:18:04.400 --> 01:18:06.400] 然后behavior不合理之类的
[01:18:06.400 --> 01:18:08.400] 然后在3.7 3.8这两版本里面
[01:18:08.400 --> 01:18:09.400] 是做了不少fix
[01:18:09.400 --> 01:18:11.400] 但是他其实他的问题还是不小
[01:18:11.400 --> 01:18:13.400] 因为他这种单核
[01:18:13.400 --> 01:18:15.400] 单核event loop的情况
[01:18:15.400 --> 01:18:16.400] 其实问题还是不小
[01:18:16.400 --> 01:18:18.400] 因为最常见的情况就可能说
[01:18:18.400 --> 01:18:20.400] 你某一个地方阻塞
[01:18:20.400 --> 01:18:21.400] 就比如说你某一天
[01:18:21.400 --> 01:18:23.400] 一个大请求进来了
[01:18:23.400 --> 01:18:25.400] 然后你在json序列化的时候
[01:18:25.400 --> 01:18:26.400] 反序列化的时候
[01:18:26.400 --> 01:18:27.400] 你某一个地方大阻塞
[01:18:27.400 --> 01:18:30.400] 你会block住整个event loop
[01:18:30.400 --> 01:18:31.400] 或者说我们之前采过一个坑
[01:18:31.400 --> 01:18:33.400] 包括gevent其实也是存在这样的坑
[01:18:33.400 --> 01:18:35.400] 比如说我们之前采过一个坑
[01:18:35.400 --> 01:18:37.400] 就是说我们某一个节点
[01:18:37.400 --> 01:18:40.400] 他的那个在获取DNS的时候
[01:18:40.400 --> 01:18:42.400] 就是说你发起HTTP之前
[01:18:42.400 --> 01:18:43.400] 你需要走DNS
[01:18:43.400 --> 01:18:45.400] 他DNS是没有patch到
[01:18:45.400 --> 01:18:47.400] 当时像我们当时的DNS出现问题了
[01:18:47.400 --> 01:18:52.400] 然后就某一处代码就block在DNS那个地方
[01:18:52.400 --> 01:18:54.400] 就导致整个event loop block
[01:18:54.400 --> 01:18:56.400] 所以我觉得这条缺陷的话
[01:18:56.400 --> 01:18:57.400] 其实还是挺多的
[01:18:57.400 --> 01:18:59.400] 对他目前这种单核
[01:18:59.400 --> 01:19:01.400] 然后event loop的情况
[01:19:01.400 --> 01:19:04.400] 而不是说因为GIL的限制
[01:19:04.400 --> 01:19:06.400] GIL限制其实你调度到多个系统之上
[01:19:06.400 --> 01:19:08.400] 反而还不可控
[01:19:08.400 --> 01:19:11.400] 然后你单核单性程的一个event loop的话
[01:19:11.400 --> 01:19:13.400] 我觉得其实现在来讲
[01:19:13.400 --> 01:19:14.400] 其实问题还是不少
[01:19:14.400 --> 01:19:15.400] 而且缺陷挺大
[01:19:15.400 --> 01:19:18.400] 我觉得有几个点吧
[01:19:18.400 --> 01:19:20.400] 就是我会觉得你刚才提到的
[01:19:20.400 --> 01:19:22.400] 比如说某一个阻塞block的问题
[01:19:22.400 --> 01:19:25.400] 我觉得其实不是python写程的问题
[01:19:25.400 --> 01:19:27.400] 是python本身GIL的问题
[01:19:27.400 --> 01:19:30.400] 因为他只有单核
[01:19:30.400 --> 01:19:35.400] 就是这个和你写程的模型可能关系不大
[01:19:35.400 --> 01:19:39.400] 会更多取决的是你这个运行的这个
[01:19:39.400 --> 01:19:40.400] 对我就说嘛
[01:19:40.400 --> 01:19:45.400] 就说是你本身的就是语言的限制
[01:19:45.400 --> 01:19:47.400] 然后你本身的语言限制
[01:19:47.400 --> 01:19:49.400] 但是导致了你写程就出现这样的问题
[01:19:49.400 --> 01:19:53.400] 你这个不是编程模式的问题吗
[01:19:53.400 --> 01:19:56.400] 你假如说用go你给block掉
[01:19:56.400 --> 01:19:58.400] 你不是也一样的吗
[01:19:58.400 --> 01:19:59.400] 或者用c用别的
[01:19:59.400 --> 01:20:03.400] 你go是多个线程之间不同调度啊
[01:20:03.400 --> 01:20:06.400] 但是就是他的一个json
[01:20:06.400 --> 01:20:08.400] 你用任何语言不都会block吗
[01:20:08.400 --> 01:20:09.400] 假如说用go的话
[01:20:09.400 --> 01:20:12.400] 但是你也只会block出一个线程啊
[01:20:12.400 --> 01:20:13.400] 你其他的地方是会
[01:20:13.400 --> 01:20:17.400] 其他线程上跑的grouting是正常跑的呀
[01:20:17.400 --> 01:20:19.400] 那python你也可以
[01:20:19.400 --> 01:20:21.400] 比如说开四个线程
[01:20:21.400 --> 01:20:22.400] 每一个都开一个实例吧
[01:20:22.400 --> 01:20:23.400] 你每个开一个实例
[01:20:23.400 --> 01:20:25.400] 但是你的就是这样
[01:20:25.400 --> 01:20:27.400] 因为他go的话是同一个event loop
[01:20:27.400 --> 01:20:28.400] 同一个event loop
[01:20:28.400 --> 01:20:30.400] 你都在线程上调度吗
[01:20:30.400 --> 01:20:33.400] 假如四个线程的话
[01:20:33.400 --> 01:20:35.400] 你要解析同时解析四个大bjson
[01:20:35.400 --> 01:20:38.400] 然后才会同时block掉对吧
[01:20:38.400 --> 01:20:40.400] 是这样你是这样
[01:20:40.400 --> 01:20:41.400] 我一个线程里面
[01:20:41.400 --> 01:20:43.400] 我是这样我一个线程里面
[01:20:43.400 --> 01:20:44.400] 我因为现在是这样
[01:20:44.400 --> 01:20:45.400] 我们一个进程
[01:20:45.400 --> 01:20:46.400] 我们现在是多进程部署吧
[01:20:46.400 --> 01:20:47.400] 多进程
[01:20:47.400 --> 01:20:48.400] 然后多进程
[01:20:48.400 --> 01:20:49.400] 多进程单线程
[01:20:49.400 --> 01:20:51.400] 然后每个线程一个event loop
[01:20:51.400 --> 01:20:52.400] 然后你之前
[01:20:52.400 --> 01:20:54.400] 然后现在是你之前承担的
[01:20:54.400 --> 01:20:56.400] 就是说是你这个event loop
[01:20:56.400 --> 01:20:57.400] 你这个线程上面
[01:20:57.400 --> 01:20:58.400] 你这个线程上面
[01:20:58.400 --> 01:21:00.400] 就是说是承担了很多个请求
[01:21:00.400 --> 01:21:01.400] 就很多个请求
[01:21:01.400 --> 01:21:04.400] 你把一个请求的大的json来了
[01:21:04.400 --> 01:21:05.400] 然后你把它block住了
[01:21:05.400 --> 01:21:06.400] block住了之后
[01:21:06.400 --> 01:21:07.400] 然后你其他的
[01:21:07.400 --> 01:21:09.400] 这个线程上面的event loop
[01:21:09.400 --> 01:21:11.400] 就全部就就阻塞了
[01:21:11.400 --> 01:21:13.400] 你其他的请求就没法正常调度
[01:21:13.400 --> 01:21:14.400] 而在go上面的话
[01:21:14.400 --> 01:21:16.400] 他是可以就是说是把你的go routing
[01:21:16.400 --> 01:21:18.400] 调度到其他线程上继续执行
[01:21:18.400 --> 01:21:20.400] 那python不也可以开四个线程
[01:21:20.400 --> 01:21:22.400] 然后有四个event loop吗
[01:21:22.400 --> 01:21:23.400] 你四个线程
[01:21:23.400 --> 01:21:24.400] 你四个线程
[01:21:24.400 --> 01:21:27.400] 那个你event loop是基于一个单线程的模式的
[01:21:27.400 --> 01:21:28.400] 对
[01:21:28.400 --> 01:21:29.400] 就我知道这个意思
[01:21:29.400 --> 01:21:32.400] 但是我觉得其他语言也会有这个问题
[01:21:32.400 --> 01:21:34.400] 我知道python肯定会有这个
[01:21:34.400 --> 01:21:36.400] 你其他的语言是你一个
[01:21:36.400 --> 01:21:39.400] 你是一个event loop在多个线程上调度
[01:21:39.400 --> 01:21:41.400] 但是你python如果我没记错的话
[01:21:41.400 --> 01:21:44.400] event loop它始终是作用于单线程的一个情况
[01:21:44.400 --> 01:21:46.400] 它的核心的调度
[01:21:46.400 --> 01:21:48.400] 对我能理解这个问题
[01:21:48.400 --> 01:21:51.400] 就如果只有一个线程是有这个问题
[01:21:51.400 --> 01:21:55.400] 对因为你除非说我自己在上面再去封装一个
[01:21:55.400 --> 01:21:57.400] 我在event loop
[01:21:57.400 --> 01:21:59.400] 在sync l上面再去封装一套体系
[01:21:59.400 --> 01:22:01.400] 就是说我跨线程进行调度
[01:22:01.400 --> 01:22:02.400] 但是我刚才也说了
[01:22:02.400 --> 01:22:04.400] 你在python里面你跨线程进行调度
[01:22:04.400 --> 01:22:06.400] 其实你在线程切换的时候
[01:22:06.400 --> 01:22:08.400] 反而还会引出其余的
[01:22:08.400 --> 01:22:10.400] 就是不可控的问题
[01:22:10.400 --> 01:22:12.400] 就是先让你不要纠结
[01:22:12.400 --> 01:22:13.400] 这开几个线程
[01:22:13.400 --> 01:22:15.400] 你就想象如果只有一个线程的话
[01:22:15.400 --> 01:22:17.400] 为什么是跨线程
[01:22:17.400 --> 01:22:21.400] 我觉得这个事情其实本质就是python的这种单线程
[01:22:21.400 --> 01:22:24.400] 绑定cpu gil导致的
[01:22:24.400 --> 01:22:28.400] 就是这个事情其实我觉得更多的和调度模型
[01:22:28.400 --> 01:22:30.400] 其实关系不是那么大
[01:22:30.400 --> 01:22:31.400] 对就是如果某一个语言
[01:22:31.400 --> 01:22:33.400] 你限制它只有一个线程
[01:22:33.400 --> 01:22:37.400] 那它的这个写程的切换也会退化到这个模型上
[01:22:37.400 --> 01:22:38.400] 是的我同意
[01:22:38.400 --> 01:22:40.400] 对但是我就只是说
[01:22:40.400 --> 01:22:43.400] 因为它的原因就是造成了其实python的
[01:22:43.400 --> 01:22:46.400] 因为它本身语言的问题造成了python
[01:22:46.400 --> 01:22:49.400] 它的coding其实是有不少缺陷的
[01:22:49.400 --> 01:22:51.400] 对这是我的一个逻辑
[01:22:51.400 --> 01:22:54.400] 然后的话其实生态这两年还好
[01:22:54.400 --> 01:22:55.400] 但是还在完善
[01:22:55.400 --> 01:22:59.400] 但是说实话完善的程度真的挺一般的
[01:22:59.400 --> 01:23:02.400] 现在比如说现在
[01:23:02.400 --> 01:23:05.400] Mysql都没有一个能打的原生支持
[01:23:05.400 --> 01:23:10.400] AsyncVette的driver
[01:23:10.400 --> 01:23:12.400] 现在还没有
[01:23:12.400 --> 01:23:13.400] 现在是还没有的
[01:23:13.400 --> 01:23:18.400] 它有一个AIOMysql基于pyMysql的
[01:23:18.400 --> 01:23:20.400] 但是那个bug太多了
[01:23:20.400 --> 01:23:22.400] 而且现在基本上是没人管的三不管了
[01:23:22.400 --> 01:23:24.400] 那个叫什么组织来说
[01:23:24.400 --> 01:23:26.400] 他们是一直在维护着各种
[01:23:26.400 --> 01:23:28.400] AIOLibs是吗
[01:23:28.400 --> 01:23:29.400] 对AIOXX那个吧
[01:23:29.400 --> 01:23:31.400] 但是实际上很多户都是没有
[01:23:31.400 --> 01:23:33.400] 就是三不管问津的状态
[01:23:33.400 --> 01:23:36.400] 这点的痛苦我在两三年前有体会
[01:23:36.400 --> 01:23:40.400] 但我不确定现在是到一个什么样的情况
[01:23:40.400 --> 01:23:43.400] 对因为你就相当于是都要
[01:23:43.400 --> 01:23:46.400] 就是之前这种很多都是官方自己实现了
[01:23:46.400 --> 01:23:49.400] 某个语言的特定的这个driver
[01:23:49.400 --> 01:23:51.400] 对现在就变成了说我不只要实现
[01:23:51.400 --> 01:23:52.400] 这个driver协议
[01:23:52.400 --> 01:23:55.400] 我还要提供一个这个
[01:23:55.400 --> 01:23:56.400] Async版本的
[01:23:56.400 --> 01:23:58.400] AsyncIO能适配的
[01:23:58.400 --> 01:24:00.400] 现在的那个IOlib
[01:24:00.400 --> 01:24:05.400] 还是都用那个官方提供的AsyncIO吗
[01:24:05.400 --> 01:24:08.400] 是的而且就是说是你作为一些基础的
[01:24:08.400 --> 01:24:10.400] 比如说数据库或者radius之类的
[01:24:10.400 --> 01:24:12.400] 你要做到productivity
[01:24:12.400 --> 01:24:14.400] 就是生产可用的
[01:24:14.400 --> 01:24:17.400] 就是说是我觉得是个很困难的
[01:24:17.400 --> 01:24:22.400] 对这一套的设计是什么样子的
[01:24:22.400 --> 01:24:25.400] 还是一样该缺的
[01:24:25.400 --> 01:24:28.400] 该缺的那个驱动还是缺
[01:24:28.400 --> 01:24:30.400] 现在整体上还是
[01:24:30.400 --> 01:24:32.400] 我就说是整体的API设计
[01:24:32.400 --> 01:24:34.400] 都是用了那个官方的AsyncIO
[01:24:34.400 --> 01:24:37.400] AsyncIO的话它可以替换你底下的运行loop
[01:24:37.400 --> 01:24:39.400] 所以说后面现在的UA loop
[01:24:39.400 --> 01:24:43.400] 或者是其他的东西都还是挺有挺火的
[01:24:43.400 --> 01:24:45.400] 所以说但是整个
[01:24:45.400 --> 01:24:47.400] 因为问题其实并不在于你官方怎么发展
[01:24:47.400 --> 01:24:50.400] 因为最主要还是就是说你生态
[01:24:50.400 --> 01:24:51.400] 是的
[01:24:51.400 --> 01:24:54.400] 就是说你很多东西是需要从上上下的
[01:24:54.400 --> 01:24:56.400] 你需要去从上上下的
[01:24:56.400 --> 01:24:58.400] 就比如说我推了AsyncIO
[01:24:58.400 --> 01:25:00.400] 那么你是不是该去推一个
[01:25:00.400 --> 01:25:04.400] 就是说具体的某一些样板的driver出来
[01:25:04.400 --> 01:25:06.400] 就是比如说你官方在背后支持
[01:25:06.400 --> 01:25:07.400] 或者是其他的
[01:25:07.400 --> 01:25:10.400] 而据我所知目前这块是很少的
[01:25:10.400 --> 01:25:11.400] Web Framework呢
[01:25:11.400 --> 01:25:14.400] 有什么新的Web Framework
[01:25:14.400 --> 01:25:16.400] Web Framework的话倒是挺多的
[01:25:16.400 --> 01:25:20.400] 然后就是说是比如说早一点的Sync
[01:25:20.400 --> 01:25:21.400] 然后后一点的
[01:25:21.400 --> 01:25:23.400] 然后API Star
[01:25:23.400 --> 01:25:25.400] 后面退化为StarLabel
[01:25:25.400 --> 01:25:28.400] 然后再近一点的
[01:25:28.400 --> 01:25:29.400] 然后中间有几个
[01:25:29.400 --> 01:25:33.400] 比如说Facebook的那个
[01:25:33.400 --> 01:25:35.400] 之前还是挺好的一个
[01:25:35.400 --> 01:25:36.400] 然后框架
[01:25:36.400 --> 01:25:39.400] 然后在后面的话Jungle
[01:25:39.400 --> 01:25:42.400] Jungle也是有支持Async了
[01:25:42.400 --> 01:25:45.400] 现在就是后面ORM的部分
[01:25:45.400 --> 01:25:47.400] 再往后的话就FastAPI什么的
[01:25:47.400 --> 01:25:49.400] 然后Flask据说有在支持Async
[01:25:49.400 --> 01:25:51.400] ASGI那套东西
[01:25:51.400 --> 01:25:53.400] 但是进度还不知道
[01:25:53.400 --> 01:25:56.400] 这样听起来还是多了蛮多
[01:25:56.400 --> 01:26:02.400] 对说实话我觉得这套东西是需要钱和人一起扎进去的
[01:26:02.400 --> 01:26:04.400] 其实上层支持的还挺多的吧
[01:26:04.400 --> 01:26:08.400] 就是Web Framework这层
[01:26:08.400 --> 01:26:10.400] 而且他们应该会简单一些
[01:26:10.400 --> 01:26:14.400] 但是比如说他依赖的一些东西
[01:26:14.400 --> 01:26:18.400] 对就是说Web Framework一直都是挺多的
[01:26:18.400 --> 01:26:20.400] 但是最关键就是说
[01:26:20.400 --> 01:26:26.400] 我们用谁又是只用Web Framework
[01:26:26.400 --> 01:26:28.400] 就比如说现在很火的GRPC
[01:26:28.400 --> 01:26:30.400] 它好像也没有原生的Async模式
[01:26:30.400 --> 01:26:34.400] GRPC应该是有提供一个异步机制的
[01:26:34.400 --> 01:26:38.400] 但是应该不是AsyncIO的那种
[01:26:38.400 --> 01:26:43.400] 它应该就提供了一个Future的这种实现
[01:26:43.400 --> 01:26:46.400] 对吧所以说虽然你可以去通过
[01:26:46.400 --> 01:26:48.400] 你可以通过那个比如说我包裹一个线程
[01:26:48.400 --> 01:26:50.400] 因为AsyncIO支持线程的调度
[01:26:50.400 --> 01:26:53.400] 你用一个线程去裹一下
[01:26:53.400 --> 01:26:58.400] 但是我觉得这种东西就还是一句话
[01:26:58.400 --> 01:27:00.400] 配套的实施太少了
[01:27:00.400 --> 01:27:02.400] 当然这个东西又是老黑重谈了
[01:27:02.400 --> 01:27:04.400] 我每天都在黑它
[01:27:04.400 --> 01:27:06.400] 然后每天都是这几个理由
[01:27:06.400 --> 01:27:08.400] 人家说你能不能换点新的理由
[01:27:08.400 --> 01:27:10.400] 但是我听人说你也没有新的变化
[01:27:10.400 --> 01:27:13.400] 所以现在看来大家升级到Panel 3之后
[01:27:13.400 --> 01:27:17.400] 其实很有可能是并不会去引入这种
[01:27:17.400 --> 01:27:21.400] 异步相关的关键字或者去融到相关的Feature
[01:27:21.400 --> 01:27:25.400] 我不确认就是如果是一个大项目的话
[01:27:25.400 --> 01:27:26.400] 我觉得很难
[01:27:26.400 --> 01:27:29.400] 特别是如果那个大项目之前就在用GEvent
[01:27:29.400 --> 01:27:33.400] 那对他来说可能他会付出很大的成本
[01:27:33.400 --> 01:27:36.400] 但是可能不会有太多的收益
[01:27:36.400 --> 01:27:40.400] 就是其实我听起来比如说
[01:27:40.400 --> 01:27:42.400] 一个项目规模越大
[01:27:42.400 --> 01:27:45.400] 他要切成AsyncIO的成本其实是越高的
[01:27:45.400 --> 01:27:50.400] 对那对以及其实我不太
[01:27:50.400 --> 01:27:51.400] 我没有了解过
[01:27:51.400 --> 01:27:53.400] 我觉得我事后可以去了解一下
[01:27:53.400 --> 01:27:59.400] 就是这种切换到底会带来多大的性能的提升
[01:27:59.400 --> 01:28:01.400] 这个我之后可能会去
[01:28:01.400 --> 01:28:03.400] 也会之后想去了解一下
[01:28:03.400 --> 01:28:07.400] 我们是从Async退回到了GEvent
[01:28:07.400 --> 01:28:08.400] 是的没错
[01:28:08.400 --> 01:28:11.400] 然后我们最后我们迁移到了Async之后
[01:28:11.400 --> 01:28:13.400] 然后又从Async退回到了GEvent
[01:28:13.400 --> 01:28:14.400] 问题太多了
[01:28:14.400 --> 01:28:16.400] 提升挺大的
[01:28:16.400 --> 01:28:18.400] 提升说实话是挺大的
[01:28:18.400 --> 01:28:19.400] 而且说实话
[01:28:19.400 --> 01:28:22.400] 如果你不去用Async的一些特性的话
[01:28:22.400 --> 01:28:24.400] 你从2.7切到Python3
[01:28:24.400 --> 01:28:26.400] 实际上你的性能还是会下降的
[01:28:26.400 --> 01:28:27.400] 你敢信
[01:28:27.400 --> 01:28:32.400] 对就说是从Python3的几个版本
[01:28:32.400 --> 01:28:34.400] 我记得是直到Python3.6
[01:28:34.400 --> 01:28:37.400] 然后性能才和Python2.7打平
[01:28:37.400 --> 01:28:40.400] 之前的版本性能是一直低于Python2.7的
[01:28:40.400 --> 01:28:42.400] 对所以说我觉得这个时候
[01:28:42.400 --> 01:28:46.400] 也是对于Python觉得恨铁不成钢
[01:28:46.400 --> 01:28:49.400] 当然很多人会直接来吐槽说
[01:28:49.400 --> 01:28:50.400] 你都用Python了
[01:28:50.400 --> 01:28:52.400] 你还考虑什么性能啊
[01:28:52.400 --> 01:28:55.400] 唉来要不要今天我们的正事
[01:28:55.400 --> 01:28:56.400] 就先讨论这么多
[01:28:56.400 --> 01:28:58.400] 来我们开始进入推荐环节
[01:28:58.400 --> 01:28:59.400] 还是对
[01:28:59.400 --> 01:29:03.400] 然后让陈老板再推荐个酷和推荐Ten的书之类的吧
[01:29:03.400 --> 01:29:07.400] 酷的话Six算是我一个推荐了吧
[01:29:07.400 --> 01:29:08.400] 如果是书的话
[01:29:08.400 --> 01:29:10.400] 我最近在看一本书叫做
[01:29:10.400 --> 01:29:13.400] Philosophy of Software Design
[01:29:13.400 --> 01:29:15.400] 软件设计的哲学
[01:29:15.400 --> 01:29:19.400] 强烈推荐大家去看一下陈征推荐的这本书
[01:29:19.400 --> 01:29:21.400] 对
[01:29:21.400 --> 01:29:23.400] 作者是一个老爷爷
[01:29:23.400 --> 01:29:26.400] 这个是不是在你们之前已经有人推荐过了
[01:29:26.400 --> 01:29:28.400] 作者是TikTok的作者
[01:29:28.400 --> 01:29:29.400] 我看了他一个演讲
[01:29:29.400 --> 01:29:30.400] 他在Google的一个演讲
[01:29:30.400 --> 01:29:32.400] 哇那个演讲特别好
[01:29:32.400 --> 01:29:33.400] 特别特别好
[01:29:33.400 --> 01:29:34.400] 我看了两遍
[01:29:34.400 --> 01:29:35.400] 陈老师你也看过吗
[01:29:35.400 --> 01:29:37.400] 嗯然后他
[01:29:37.400 --> 01:29:41.400] 那个演讲应该是这本书里面的一些总结了吧
[01:29:41.400 --> 01:29:42.400] 对对
[01:29:42.400 --> 01:29:43.400] 嗯
[01:29:43.400 --> 01:29:46.400] 然后他这里面其实就无非就是围绕着一个话题
[01:29:46.400 --> 01:29:49.400] 就是怎么去降低软件的复杂度
[01:29:49.400 --> 01:29:52.400] 他其实从你的流你的函数
[01:29:52.400 --> 01:29:54.400] 你的类怎么去设计怎么去写
[01:29:54.400 --> 01:29:55.400] 怎么去实现
[01:29:55.400 --> 01:29:57.400] 到你呃
[01:29:57.400 --> 01:29:59.400] 例如comment你的注释怎么去写
[01:29:59.400 --> 01:30:02.400] 他都给你去做了很
[01:30:02.400 --> 01:30:03.400] 从各方面去做了一些分析
[01:30:03.400 --> 01:30:06.400] 然后作者的语言也非常的直白
[01:30:06.400 --> 01:30:07.400] 然后这本书其实也非常薄
[01:30:07.400 --> 01:30:08.400] 只有100多页
[01:30:08.400 --> 01:30:11.400] 所以其实是非常推荐去看一下的
[01:30:11.400 --> 01:30:13.400] 然后看完书之后再去结合一下
[01:30:13.400 --> 01:30:15.400] 在YouTube上面那个在Google的分享
[01:30:15.400 --> 01:30:19.400] 这个分这个书在之前有嘉宾或你们有推荐过吗
[01:30:19.400 --> 01:30:25.400] 呃有感觉这已经是我们第四次或第五次强烈推荐了
[01:30:25.400 --> 01:30:28.400] 大家一定要去看一下
[01:30:28.400 --> 01:30:30.400] 三四次吧
[01:30:30.400 --> 01:30:32.400] 应该还没到第五次
[01:30:32.400 --> 01:30:33.400] 曼德萨卡你有什么推荐吗
[01:30:33.400 --> 01:30:35.400] 呃我最近推荐两本书吧
[01:30:35.400 --> 01:30:39.400] 一本是那个呃MacSource Pattern
[01:30:39.400 --> 01:30:43.400] 然后是中中国好像有引进版
[01:30:43.400 --> 01:30:48.400] 是叫做微服务设计设计模式还是什么的
[01:30:48.400 --> 01:30:51.400] 然后就是里面讲的微服务的一些设计的精要
[01:30:51.400 --> 01:30:54.400] 或者说是一些就最基本的中文中性的principle
[01:30:54.400 --> 01:30:56.400] 然后这本书质量还不错
[01:30:56.400 --> 01:30:59.400] 呃我觉得是最近新书算是一本新书吧
[01:30:59.400 --> 01:31:02.400] 然后我就挺挺挺推荐的
[01:31:02.400 --> 01:31:06.400] 另外一本是推荐一本老呃推荐一本老书吧
[01:31:06.400 --> 01:31:08.400] 然后我最近在重修网络
[01:31:08.400 --> 01:31:10.400] 所以说我就在看TCPIP详解
[01:31:10.400 --> 01:31:13.400] 然后关于协议的部分
[01:31:13.400 --> 01:31:15.400] 然后这里面其实讲的是很详细的
[01:31:15.400 --> 01:31:17.400] 但是中文版的质量说实话一般说
[01:31:17.400 --> 01:31:20.400] 我建议大家可以去看一下他的那个英文版
[01:31:20.400 --> 01:31:21.400] 是Orally出的
[01:31:21.400 --> 01:31:23.400] 然后是可以在线看的
[01:31:23.400 --> 01:31:25.400] 新涛你呢
[01:31:25.400 --> 01:31:27.400] 呃我来推荐一个Vim插件吧
[01:31:27.400 --> 01:31:28.400] 叫Vim-HK
[01:31:28.400 --> 01:31:29.400] 呃VHK
[01:31:29.400 --> 01:31:31.400] VH就是哪一个
[01:31:31.400 --> 01:31:33.400] 我们知道在Vim里面
[01:31:33.400 --> 01:31:35.400] 你们你可以map KK这样
[01:31:35.400 --> 01:31:38.400] 比如说呃你的layer K是多好
[01:31:38.400 --> 01:31:40.400] 你可以多好AB干一件事
[01:31:40.400 --> 01:31:42.400] 然后多好A也可以干一件事
[01:31:42.400 --> 01:31:45.400] 但是显然这个直觉上这两个mapping是冲突的嘛
[01:31:45.400 --> 01:31:47.400] Vim是这样来处理的
[01:31:47.400 --> 01:31:49.400] 就是你按下多好A
[01:31:49.400 --> 01:31:51.400] 他发现这个多好A后面还可以再接一个B
[01:31:51.400 --> 01:31:54.400] 所以多好AB他会执行多好AB的事
[01:31:54.400 --> 01:31:56.400] 如果多好A你停断一段时间的话
[01:31:56.400 --> 01:31:58.400] 他就会认为你按的是多好A
[01:31:58.400 --> 01:32:02.400] 然后就会执行呃多好A所干的事情
[01:32:02.400 --> 01:32:03.400] 所以这个比较恶心的是
[01:32:03.400 --> 01:32:05.400] 假如说你有这样的mapping的话
[01:32:05.400 --> 01:32:08.400] 你每次执行多好A需要隔一段时间
[01:32:08.400 --> 01:32:10.400] 他才会真正的生效
[01:32:10.400 --> 01:32:13.400] 因为Vim要等你看你要不要再按一下B嘛
[01:32:13.400 --> 01:32:16.400] 然后Vim-HK就是利用这样的一个机制
[01:32:16.400 --> 01:32:19.400] 呃你把那个多好的mapping
[01:32:19.400 --> 01:32:24.400] 呃你的所有的K的mapping的第一个按下的键都是layer K嘛
[01:32:24.400 --> 01:32:27.400] 然后你把layer K mapping到这个Vim-HK
[01:32:27.400 --> 01:32:29.400] 然后你每次如果忘记了什么K的时候
[01:32:29.400 --> 01:32:31.400] 你就按下多好
[01:32:31.400 --> 01:32:33.400] 这个时候你停断了一段时间之后
[01:32:33.400 --> 01:32:36.400] Vim认为你执行的是这个多好键嘛
[01:32:36.400 --> 01:32:38.400] 他就会给你打开一个面板
[01:32:38.400 --> 01:32:40.400] 这个面板上面就显示你所有的mapping
[01:32:40.400 --> 01:32:42.400] 比如说多好AB是干什么的
[01:32:42.400 --> 01:32:43.400] 多好A是干什么的
[01:32:43.400 --> 01:32:45.400] 然后你接着可以按AB
[01:32:45.400 --> 01:32:47.400] 也就是说他完全不侵入你已有的mapping
[01:32:47.400 --> 01:32:50.400] 但是他可以在你停顿的时候给你提示
[01:32:50.400 --> 01:32:52.400] 嗯应该比较好理解他的工作原理吧
[01:32:52.400 --> 01:32:53.400] 我这样解释
[01:32:53.400 --> 01:32:56.400] 嗯我觉得他就是没有改变你的任何习惯
[01:32:56.400 --> 01:32:57.400] 没有break任何东西
[01:32:57.400 --> 01:32:59.400] 然后给你这样的一个提示
[01:32:59.400 --> 01:33:00.400] 应该挺好的
[01:33:00.400 --> 01:33:03.400] 而且你这样的话会越来越熟悉你的K
[01:33:03.400 --> 01:33:05.400] 然后你知道你哪些mapping是没有用的
[01:33:05.400 --> 01:33:07.400] 在你映射新的ID的时候
[01:33:07.400 --> 01:33:10.400] 会可以帮助你做出一些选择吗
[01:33:11.400 --> 01:33:14.400] 那我简单的推荐一个我最近在看的资料吧
[01:33:14.400 --> 01:33:19.400] 就是我最近在看那个卡普卡的文档
[01:33:19.400 --> 01:33:22.400] 对然后这里面最推荐的就是
[01:33:22.400 --> 01:33:26.400] 我其实我觉得大家可以跳过很多这种
[01:33:26.400 --> 01:33:28.400] 先跳过很多实现啊
[01:33:28.400 --> 01:33:31.400] 然后介绍啊去看他里面专门有一张
[01:33:31.400 --> 01:33:32.400] 叫design
[01:33:33.400 --> 01:33:37.400] 对就是我甚至推荐所有其他都可以先不
[01:33:37.400 --> 01:33:39.400] 看先看这部分design
[01:33:39.400 --> 01:33:42.400] 他详细的讲了一下就是卡卡设计的动机
[01:33:42.400 --> 01:33:43.400] 是什么
[01:33:43.400 --> 01:33:47.400] 然后持久化的方案策略是和其他的
[01:33:47.400 --> 01:33:48.400] 现行的市面做比较
[01:33:48.400 --> 01:33:49.400] 然后都有哪一些
[01:33:49.400 --> 01:33:51.400] 他们是怎么选择的
[01:33:51.400 --> 01:33:54.400] 对然后他们的producer consumer是
[01:33:54.400 --> 01:33:55.400] 是什么策略对
[01:33:55.400 --> 01:33:58.400] 以及他们的这个replica为什么要这么做
[01:33:58.400 --> 01:34:04.400] 对就是感觉就是一篇长的技术技术
[01:34:04.400 --> 01:34:08.400] 或者说这种架构设计的这种博客的感觉
[01:34:08.400 --> 01:34:13.400] 对其实还对还解决了我不少困惑
[01:34:13.400 --> 01:34:15.400] 我挺喜欢这个的
[01:34:15.400 --> 01:34:18.400] 好长我当时看了好久
[01:34:18.400 --> 01:34:19.400] 我不用卡普卡
[01:34:19.400 --> 01:34:21.400] 但我觉得看一下也挺好的
[01:34:21.400 --> 01:34:22.400] 我也会去看一下
[01:34:22.400 --> 01:34:23.400] 上次你推荐的那个
[01:34:23.400 --> 01:34:25.400] how does relational database work
[01:34:25.400 --> 01:34:27.400] 我看了两天了还没看完
[01:34:27.400 --> 01:34:30.400] 我还没有我没有我没有去追那些论文
[01:34:30.400 --> 01:34:32.400] 我就是纯往下看都看了好久
[01:34:32.400 --> 01:34:35.400] 主要是他他引用了一些论文也很好
[01:34:35.400 --> 01:34:38.400] 比如说数据库里面设计的sorting的算法
[01:34:38.400 --> 01:34:40.400] 那些论文都是其实挺入门的
[01:34:40.400 --> 01:34:43.400] 我觉得追论文是一件很麻烦的事
[01:34:43.400 --> 01:34:45.400] 我现在我之前看DDIA的时候
[01:34:45.400 --> 01:34:46.400] 我就是在追他的论文
[01:34:46.400 --> 01:34:49.400] 然后我觉得然后我最近在看论文的时候
[01:34:49.400 --> 01:34:50.400] 又发现他里面又reference
[01:34:50.400 --> 01:34:52.400] 又要去看他的reference
[01:34:52.400 --> 01:34:54.400] 好我觉得这套商量无穷无尽
[01:34:54.400 --> 01:34:56.400] 刚刚推荐的那本书
[01:34:56.400 --> 01:34:57.400] 既然大家都提到过了
[01:34:57.400 --> 01:34:59.400] 那我再补充一个
[01:34:59.400 --> 01:35:01.400] 我最近想看的那本书叫做
[01:35:01.400 --> 01:35:02.400] The Effective Engineer
[01:35:02.400 --> 01:35:05.400] 应该是关于怎么去做一个更高效的工程师
[01:35:05.400 --> 01:35:07.400] 这是一个不负责任的推荐
[01:35:07.400 --> 01:35:08.400] 因为我还没有读
[01:35:08.400 --> 01:35:09.400] 我只是想读而已
[01:35:10.400 --> 01:35:12.400] 大家好我是Like9M
[01:35:12.400 --> 01:35:15.400] 然后今天是由我来感谢一下
[01:35:15.400 --> 01:35:16.400] 给我们打赏的用户
[01:35:16.400 --> 01:35:19.400] 首先是夜宵rain同学
[01:35:19.400 --> 01:35:21.400] 感谢你给曼德萨卡买的内裤
[01:35:21.400 --> 01:35:23.400] 然后是有几位匿名的用户
[01:35:23.400 --> 01:35:24.400] 谢谢你们
[01:35:25.400 --> 01:35:27.400] 有一位用户给我们留言
[01:35:27.400 --> 01:35:32.400] 说他听了关于PIP和PIPENV相关的那期节目
[01:35:32.400 --> 01:35:34.400] 然后解决了他长期以来的一些疑惑
[01:35:35.400 --> 01:35:37.400] 很高兴你告诉我们你的想法
[01:35:37.400 --> 01:35:40.400] 然后就是这个也是我们做播客的初衷吧
[01:35:40.400 --> 01:35:43.400] 然后希望如果其他的听众
[01:35:43.400 --> 01:35:47.400] 有任何的反馈或者想法都欢迎告诉我们
[01:35:47.400 --> 01:35:49.400] 我们还是很希望听到你们的想法
[01:35:49.400 --> 01:35:53.400] 然后9.4千秋再次感谢你给曼德萨卡买的内裤
[01:35:53.400 --> 01:35:57.400] 然后林伟是我们的老听众了
[01:35:57.400 --> 01:35:58.400] 然后在群里也非常活跃
[01:35:58.400 --> 01:36:00.400] 谢谢你的打赏
[01:36:00.400 --> 01:36:02.400] 然后是XXChang
[01:36:03.400 --> 01:36:06.400] 这位同学也谢谢你给曼德萨卡买的内裤
[01:36:06.400 --> 01:36:08.400] 差不多这次就是这样
[01:36:08.400 --> 01:36:10.400] 然后有一些没有念到的朋友
[01:36:10.400 --> 01:36:12.400] 因为我们按照规矩五元的是不念的
[01:36:12.400 --> 01:36:15.400] 但是也还是非常谢谢你们的支持
[01:36:15.400 --> 01:36:17.400] 现在我们也是收到了不少打赏
[01:36:17.400 --> 01:36:21.400] 然后目前还不能cover服务器的费用
[01:36:21.400 --> 01:36:24.400] 我们是希望至少能够说
[01:36:24.400 --> 01:36:27.400] 在服务器这方面是能够用打赏来cover的
[01:36:27.400 --> 01:36:30.400] 另外就是我们最近又增加了一些麦克风的支出
[01:36:30.400 --> 01:36:32.400] 就是我们为了提升音质
[01:36:32.400 --> 01:36:35.400] 或者是会给嘉宾去寄麦克风的
[01:36:35.400 --> 01:36:36.400] 如果他没有麦克风的话
[01:36:36.400 --> 01:36:38.400] 所以这方面支出最近也增加了一些
[01:36:38.400 --> 01:36:42.400] 但是不管怎么样我们还是会继续做出更好的节目
[01:36:42.400 --> 01:36:44.400] 然后来服务听众们
[01:36:44.400 --> 01:36:45.400] 好今天差不多就这样
[01:36:45.400 --> 01:36:46.400] 谢谢大家
[01:36:46.400 --> 01:36:48.400] 好那我们今天就到这
[01:36:48.400 --> 01:36:50.400] 感谢诚中的到来与分享
[01:36:50.400 --> 01:36:52.400] 谢谢邀请我
[01:36:52.400 --> 01:36:54.400] 拜拜
[01:36:54.400 --> 01:36:57.400] 好来好辛苦大家
[01:36:57.400 --> 01:37:00.400] 好本期捕蛇者说的播客就到这里
[01:37:00.400 --> 01:37:01.400] 感谢您的收听
[01:37:01.400 --> 01:37:04.400] 本期内容中提到的资料链接都会放到我们的网站上
[01:37:04.400 --> 01:37:07.400] 我们的网址是pythonhunter.org
[01:37:07.400 --> 01:37:10.400] 由于我们主播的知乎账号被禁
[01:37:10.400 --> 01:37:13.400] 所以以后的更新都不会再发布到知乎上
[01:37:13.400 --> 01:37:14.400] 请您留意
[01:37:14.400 --> 01:37:17.400] 推荐您使用泛用型客户端订阅我们的撲克
[01:37:17.400 --> 01:37:19.400] 也欢迎您关注我们的推特
[01:37:19.400 --> 01:37:22.400] 加入我们的Telegram群组和其他听众一起聊天
[01:37:22.400 --> 01:37:26.400] 我们的推特是pythonhunter加一个下滑线
[01:37:26.400 --> 01:37:29.400] Telegram群组的链接可以在我们的网站上找到
[01:37:29.400 --> 01:37:58.400] 我们下期再见
[01:37:59.400 --> 01:38:00.400] 嗯
[01:38:29.400 --> 01:38:31.400] 嗯
