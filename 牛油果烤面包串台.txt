[00:00.000 --> 00:10.000] 在一些编程语言的排名中,Python是世界第一语言。
[00:10.000 --> 00:15.000] 2020年的今天,如果初学一门语言,那么大概率是Python。
[00:15.000 --> 00:26.000] 不仅如此,Python还在AI、数据分析、互联网业务逻辑、脚本编写等诸多方面有广泛的应用。
[00:26.000 --> 00:35.000] 这一集,我们有幸请到了Python中国社区的达人like9m来到我们的节目,聊一聊Python的方方面面。
[00:38.000 --> 00:44.000] 如果你想完成一件事情,那么最好是有且只有一种方法来做,不需要让你从多种方法中去选择。
[00:44.000 --> 00:52.000] 达人like9m也说得很清楚,就是他们一开始低估了做这样一种转换的成本。
[00:52.000 --> 01:00.000] 就他们觉得说,我们一宣布说3.0版本特别好,然后大家就马上就用上Python了,然后一下就完成了。
[01:00.000 --> 01:03.000] 但实际上这个过程花了十年还不止。
[01:08.000 --> 01:10.000] 这里是牛油果烤面包。
[01:14.000 --> 01:26.000] 大家好,我是斯特纳特。
[01:26.000 --> 01:27.000] 我是Vindy。
[01:27.000 --> 01:28.000] 我是Kat。
[01:28.000 --> 01:37.000] 今天是一期串台节目,我们的科技播客牛油果烤面包有幸请到了播客补舌者说来到我们的节目。
[01:37.000 --> 01:40.000] 大家知道补舌者说是柳宗元的散文,对吧?
[01:40.000 --> 01:44.000] 所以我们这应该是跨界请到了古文方面的播客来做客我们节目,对吧?
[01:44.000 --> 01:48.000] 大家好,我是,我是like9m,对。
[01:48.000 --> 01:51.000] 你们这个是一个古文节目,对吧?
[01:51.000 --> 01:55.000] 对,我们是个古文节目,然后顺便聊聊Python这样子,对。
[01:55.000 --> 02:05.000] 开个玩笑啊,我理解是他们这个节目补舌者说取义是要搞定一个编程语言,叫Python,就是莽舌,对吧?
[02:05.000 --> 02:11.000] 对,就是我们当时想这个补舌者说的名字,然后也是想了挺久的嘛,
[02:11.000 --> 02:17.000] 然后一开始就我们说要做一个播客,就是我们几个创始人相当于都是比较喜欢写Python吧,
[02:17.000 --> 02:22.000] 然后也是在那个Python这个圈子里面,就是在社区里面混的这么几个人,
[02:22.000 --> 02:26.000] 然后就说用一个什么名字好的,发现好像其他播客都是4个字,
[02:26.000 --> 02:32.000] 然后我们也用4个字吧,于是就补舌者说,对,Python就是莽舌的意思,
[02:32.000 --> 02:36.000] 就是今天肯定是要聊Python这本编程语言,但是他为什么,
[02:36.000 --> 02:41.000] 这本编程语言为什么以莽舌来作为名字的话,其实我也不知道。
[02:41.000 --> 02:48.000] 我们知道编程语言呢,有很多种,那么Python是一种这个世界第一的编程语言,对吧?
[02:48.000 --> 02:52.000] 某种程度上可以这么讲,对,就如同其他的所有事情一样,
[02:52.000 --> 02:59.000] 你评价一个事情可以有很多不同的标准,那从某些标准来评价Python可以说是世界第一,
[02:59.000 --> 03:05.000] 比如说有一些编程语言的排名,在其中一个排名里Python就是世界第一的,
[03:05.000 --> 03:12.000] 那他这个排名的标准是说他在Google里面搜索某种编程语言的tutorial,
[03:12.000 --> 03:18.000] 也就是教程的这个条目的数量,那他认为你某种语言的教程的条目越多,
[03:18.000 --> 03:22.000] 他这个语言排名就越靠前,因为说明就是学这个语言的人越多了,
[03:22.000 --> 03:26.000] 相当于现在是一个,现在的大家在学什么编程语言,他是这样来排的,
[03:26.000 --> 03:32.000] 那在这样的标准下Python是第一,所以你可以说他是一个非常流行的编程语言,
[03:32.000 --> 03:36.000] 还有不同的排名方式啊,比如说最著名的这个Toby index,
[03:36.000 --> 03:41.000] 他是以Python或者是C++这其他一些编程语言为关键词,
[03:41.000 --> 03:47.000] 看你这个能搜出来多少,但是前面的那个排名就是来数教程数量这个排名,
[03:47.000 --> 03:51.000] 他就说你光搜关键词这种排名方式不好,为什么呢?
[03:51.000 --> 03:56.000] 因为他说,比如说你搜一个,你搜Python吧,那他可能出来很多关于蟒蛇的东西的吧,
[03:56.000 --> 04:00.000] 那他这个跟编程语言完全没关系了,所以就不准,
[04:00.000 --> 04:03.000] 就是Toby index,呃,算是用的最多的一个排名,
[04:03.000 --> 04:07.000] 他Python是排第三的,哦,那谁还排在Python前面呢?
[04:07.000 --> 04:12.000] 呃,我看看,我记得第一好像是C,然后没记错的话,第一是C,第二是Java,
[04:12.000 --> 04:18.000] 第一是Javascript的吧,Javascript的第七,对,所以说他这个不准了,不准了,
[04:18.000 --> 04:22.000] 其实我觉得如果说Python是世界第一语言的话,
[04:22.000 --> 04:25.000] 其实还有另外一个含义,就是说对于入门者来讲,
[04:25.000 --> 04:31.000] 特别是非专业的人入门者语言总是有一种这个最著名的入门语言是吧?
[04:31.000 --> 04:35.000] 2020年最有可能是从Python学起的,对吧?这个是为什么呢?
[04:35.000 --> 04:40.000] 主要就是我觉得他的语法确实比较容易上手吧,
[04:40.000 --> 04:43.000] 不能说简单,因为因为简单这个概念,
[04:43.000 --> 04:46.000] 它是一个比较模糊的概念,所以我就说容易上手,
[04:46.000 --> 04:49.000] 或者说他用Python来写一个程序,
[04:49.000 --> 04:54.000] 需要的知识比你用CRJR或者Java等一些其他编程语言需要的知识要少,
[04:54.000 --> 04:59.000] 就对于一个没有编程背景的人来说,他确实是比较容易学的。
[04:59.000 --> 05:02.000] 还有一个说Python是世界第一语言的原因就是,
[05:02.000 --> 05:07.000] 现在是一个人工智能的时代,Python是人工智能的语言,对吧?
[05:07.000 --> 05:12.000] 对,确实是可以这样讲,就是某种程度上说,
[05:12.000 --> 05:15.000] 基本上现在搞AI这些人都在用Python,
[05:15.000 --> 05:18.000] 你也可以说它是一个事实标准或者怎么样,
[05:18.000 --> 05:20.000] 就背后肯定是有很多原因的,然后
[05:20.000 --> 05:23.000] 还有一点就是所有的程序员,不管是什么程序员,
[05:23.000 --> 05:29.000] 多多少少都得写一点Python,因为Python是最重要的脚本语言,对吧?
[05:29.000 --> 05:32.000] 对,我写脚本只会用Python。
[05:32.000 --> 05:36.000] 对,我们公司也用Django,所以也总要用一下Python。
[05:36.000 --> 05:40.000] 脚本语言是什么呢?脚本语言一般是一种非常简单的语言,
[05:40.000 --> 05:43.000] 它的调用的内容就是调用一些其他的程序,
[05:43.000 --> 05:48.000] 比如说调用程序A,如果返回值是1的话,再调用程序B,
[05:48.000 --> 05:51.000] 如果返回值是0的话,调用程序C,
[05:51.000 --> 05:56.000] Python被认为是维护性最好的一种脚本语言,
[05:56.000 --> 05:57.000] 当然这个很主观了。
[05:57.000 --> 05:59.000] 对,Python是一门比较好的胶水语言,
[05:59.000 --> 06:02.000] 它的意思就是说它可以把其他的语言串起来,
[06:02.000 --> 06:06.000] 比如说你有一个程序里面你想用各种不同的语言,
[06:06.000 --> 06:09.000] 那你可以用Python来做一个这种中间层,
[06:09.000 --> 06:12.000] 它就方便各种语言之间互相的调用。
[06:12.000 --> 06:18.000] 除此之外,是不是真的有人用Python写一些比较实际的应用呢?
[06:18.000 --> 06:21.000] 比较实际的应用吗?这个很多啊。
[06:21.000 --> 06:24.000] 对啊,YouTube就是Python写的啊,以前。
[06:24.000 --> 06:28.000] 哦,YouTube就是Python写的,我知道Instagram也是Python这个。
[06:28.000 --> 06:33.000] 对啊,Uber什么的,就很多小一点的时候都会用Python写。
[06:33.000 --> 06:37.000] 你说Python也是一个非常流行的互联网公司写业务逻辑的语言,对吧?
[06:37.000 --> 06:39.000] 对,对,对,Startup。
[06:39.000 --> 06:42.000] 我们说到了Python是著名的初学语言,
[06:42.000 --> 06:45.000] 是AI语言,是脚本语言,
[06:45.000 --> 06:48.000] 还是互联网公司写业务逻辑的语言。
[06:48.000 --> 06:51.000] 那么为什么Python这么流行呢?
[06:51.000 --> 06:54.000] 我觉得要用一个关键词来描述的话,
[06:54.000 --> 06:57.000] 我觉得就是平衡吧,Python作为编程语言的话,
[06:57.000 --> 07:00.000] 在平衡各个方面这方面掌握的比较好,
[07:00.000 --> 07:03.000] 就是首先我们刚才也提到它比较容易上手,
[07:03.000 --> 07:06.000] 其实有很多语言都很容易上手,
[07:06.000 --> 07:09.000] 但是呢,其他一些比较容易上手的语言,
[07:09.000 --> 07:12.000] 比如说甚至一些你不需要真正去写代码的语言,
[07:12.000 --> 07:14.000] 就你就是拖拽一些那个空间啊,
[07:14.000 --> 07:16.000] 它就能给你搞一个程序出来。
[07:16.000 --> 07:18.000] 说看它的初学语言logo是吧?
[07:18.000 --> 07:19.000] 啊,类似吧,对。
[07:19.000 --> 07:20.000] Scratch是吧?
[07:20.000 --> 07:22.000] Scratch,是的,是的,Scratch。
[07:22.000 --> 07:24.000] 容易上手的语言还是有一些,
[07:24.000 --> 07:26.000] 但是容易上手,
[07:26.000 --> 07:32.000] 同时又能够作为一门严肃的编程语言来构建软件应用的,
[07:32.000 --> 07:33.000] 就不是那么多了。
[07:33.000 --> 07:37.000] 所以是上得厅堂下得厨房是吧?
[07:37.000 --> 07:39.000] 对,它的平衡做的比较好,
[07:39.000 --> 07:40.000] 我觉得概括起来就是这样子,
[07:40.000 --> 07:42.000] 当然还有一些别的方面,
[07:42.000 --> 07:45.000] 然后如果我们待会设计也可以再聊一下。
[07:45.000 --> 07:46.000] 我们就这个话题聊一聊啊,
[07:46.000 --> 07:48.000] 为什么它的平衡做的比较好呢?
[07:48.000 --> 07:51.000] 为什么可以上得厅堂下得厨房呢?
[07:51.000 --> 07:54.000] 这个我觉得主要就是由语言的特点决定的吧,
[07:54.000 --> 07:57.000] 它的主要特点最好的一个概括,
[07:57.000 --> 07:59.000] 有一段描述叫The Zen of Python,
[07:59.000 --> 08:01.000] 然后中文的话可以翻译成Python之禅,
[08:01.000 --> 08:04.000] 禅就是那个禅修的那个禅,
[08:04.000 --> 08:08.000] 它相当于是Python这本语言在创立之初,
[08:08.000 --> 08:12.000] 一些负责在改进这个语言的人给Python这本语言定下了一个,
[08:12.000 --> 08:14.000] 你可以说是风格呢,
[08:14.000 --> 08:16.000] 还是说是准则一样的东西,
[08:16.000 --> 08:19.000] 比如说它其中最著名的就是叫做,
[08:19.000 --> 08:21.000] 如果你想完成一件事情,
[08:21.000 --> 08:23.000] 那么最好是有且只有一种方法来做,
[08:23.000 --> 08:26.000] 不需要让你从多种方法中去选择。
[08:26.000 --> 08:28.000] 那就是苹果的设计理念吗?
[08:28.000 --> 08:30.000] 可能很多东西都是相通的吧,
[08:30.000 --> 08:34.000] 因为你是有一个说法叫做API is a kind of user interface,
[08:34.000 --> 08:36.000] 就是API也是一种用户界面嘛,
[08:36.000 --> 08:38.000] 所以就是说当然编成语言,
[08:38.000 --> 08:40.000] 你也可以认为它是一种用户界面,
[08:40.000 --> 08:43.000] 所以这方面和就是苹果有些相通,
[08:43.000 --> 08:44.000] 我觉得也不奇怪。
[08:44.000 --> 08:46.000] 确实是禅的高度了啊,
[08:46.000 --> 08:48.000] 在Python里面有一些描述,
[08:48.000 --> 08:50.000] 就是比如说叫beautiful is better than ugly,
[08:50.000 --> 08:52.000] 就是没比丑更好,
[08:52.000 --> 08:54.000] simple is better than complex,
[08:54.000 --> 08:55.000] 就简单比复杂更好,
[08:55.000 --> 08:58.000] 就是一些很高层次的讲一些准则,
[08:58.000 --> 08:59.000] 这个还是很有意思的,
[08:59.000 --> 09:01.000] 就是它有一套哲学是吧?
[09:01.000 --> 09:02.000] 对对对,
[09:02.000 --> 09:03.000] 你可以说是Python的哲学,
[09:03.000 --> 09:04.000] 我觉得这个描述比较好,
[09:04.000 --> 09:05.000] 是的,
[09:05.000 --> 09:06.000] 所以Python的哲学就是,
[09:06.000 --> 09:08.000] 它是一种简单的语言啊,
[09:08.000 --> 09:09.000] 一种易用的语言,
[09:09.000 --> 09:10.000] 一种优美的语言,
[09:10.000 --> 09:11.000] 对吧?
[09:11.000 --> 09:13.000] 那大家同意这个观点吗?
[09:13.000 --> 09:14.000] 我肯定是同意的呀,
[09:14.000 --> 09:16.000] 我觉得这些基本还是符合的吧,
[09:16.000 --> 09:19.000] 当然现在就是说随着这个语言的发展,
[09:19.000 --> 09:21.000] 它的功能也是在越加越多,
[09:21.000 --> 09:24.000] 所以很多人就觉得就有一些违反刚才说的,
[09:24.000 --> 09:27.000] 那个做一件事情只有一种方法这个原则了嘛,
[09:27.000 --> 09:29.000] 但是这个就比较深入了,
[09:29.000 --> 09:31.000] 所以我们就不继续聊这个话题,
[09:31.000 --> 09:35.000] 我觉得从入门到熟悉到一定程度,
[09:35.000 --> 09:36.000] 这都是对的,
[09:36.000 --> 09:39.000] 但是再搞下去就开始出现有坑了,
[09:39.000 --> 09:40.000] 对对对,
[09:40.000 --> 09:41.000] 坑挺大的,
[09:41.000 --> 09:43.000] 我们现在在做的东西就是不用排放,
[09:43.000 --> 09:44.000] 改用C++写,
[09:44.000 --> 09:46.000] 我们一个很大的项目。
[09:46.000 --> 09:48.000] 我对Python最大的喜爱就是,
[09:48.000 --> 09:51.000] 它是需要敲的字符非常的少,
[09:51.000 --> 09:53.000] 因为它不需要什么括弧啊,
[09:53.000 --> 09:55.000] 什么花括弧啊,
[09:55.000 --> 09:59.000] 什么变量声明的时候要加个类型啊,
[09:59.000 --> 10:00.000] 都不用啊,
[10:00.000 --> 10:02.000] 就直接敲几个空格就行了啊,
[10:02.000 --> 10:03.000] 字符非常的少,
[10:03.000 --> 10:04.000] 非常的爽。
[10:04.000 --> 10:05.000] 再加一句,
[10:05.000 --> 10:07.000] 就可能有些不是程序员的听众,
[10:07.000 --> 10:09.000] 不太了解我们刚才在说什么,
[10:09.000 --> 10:10.000] 但是你可以想象一下,
[10:10.000 --> 10:12.000] 就是说你用Python写的程序,
[10:12.000 --> 10:14.000] 它会更像你自然的说一句话,
[10:14.000 --> 10:17.000] 就是更像你在用自然语言去描述一个事情,
[10:17.000 --> 10:19.000] 而不像说用其他语言,
[10:19.000 --> 10:22.000] 你可能要学习它的一些就是具体的写法,
[10:22.000 --> 10:23.000] 要怎么写,
[10:23.000 --> 10:26.000] 那就这个方面也是让Python更容易学吗?
[10:26.000 --> 10:27.000] 说起Python呢,
[10:27.000 --> 10:30.000] 很多人第一反应就是它特别的慢啊,
[10:30.000 --> 10:32.000] 性能非常的差啊,
[10:32.000 --> 10:33.000] 一说起性能特别差,
[10:33.000 --> 10:37.000] 一个主要原因就是说它只能有一个现成,
[10:37.000 --> 10:38.000] 现成是什么东西呢?
[10:38.000 --> 10:40.000] 现成就是你可以理解为,
[10:40.000 --> 10:43.000] 一段程序正在执行这个这个这个这个,
[10:43.000 --> 10:45.000] 它是连续执行的,
[10:45.000 --> 10:47.000] 如果只有一个现成,
[10:47.000 --> 10:50.000] 就说明不管你这台计算机有多少核啊,
[10:50.000 --> 10:52.000] 双核四核六核八核,
[10:52.000 --> 10:55.000] 那么它就只能使用一个核,
[10:55.000 --> 10:56.000] 这是真的吗?
[10:56.000 --> 10:59.000] 就首先最重要的一件事情就是说,
[10:59.000 --> 11:00.000] 有人认为Python是单现成,
[11:00.000 --> 11:01.000] 这个肯定是不对的,
[11:01.000 --> 11:03.000] 对,因为Python可以开启多现成,
[11:03.000 --> 11:06.000] 并且它的现成是操作系统的真正的现成,
[11:06.000 --> 11:09.000] 就而不是像很多其他语言一样,
[11:09.000 --> 11:12.000] 是一个比如说更高阶或者说模拟出来的东西,
[11:12.000 --> 11:16.000] 那它为什么就有人觉得说它是单现成的呢?
[11:16.000 --> 11:20.000] 因为就虽然你可以开启多个现成,
[11:20.000 --> 11:24.000] 但是它在同一个时刻执行的实际上只能有一个现成,
[11:24.000 --> 11:26.000] 这个事情可能比较绕啊,
[11:26.000 --> 11:27.000] 但是我觉得可以举一个例子,
[11:27.000 --> 11:29.000] 就比如说你想象一下有一条河,
[11:29.000 --> 11:30.000] 然后河有两岸嘛,
[11:30.000 --> 11:34.000] 你有一些人要把这个砖头从河的一边搬到河的另一边去,
[11:34.000 --> 11:35.000] 那你可能雇了四个人,
[11:35.000 --> 11:37.000] 比如说你有四个现成,
[11:37.000 --> 11:39.000] 但是呢它这个河上有一座独木桥,
[11:39.000 --> 11:41.000] 你一次只能走一个人,
[11:41.000 --> 11:44.000] 那就只能有一个人在上面去搬砖嘛,
[11:44.000 --> 11:45.000] 那就相当于虽然你有四个人,
[11:45.000 --> 11:46.000] 你确实是有四个人,
[11:46.000 --> 11:50.000] 但是你同时只能有一个人去真正的把一块砖运到另一边,
[11:50.000 --> 11:52.000] 效果就类似于这个比喻,
[11:52.000 --> 11:56.000] 因为很多时候你的现成它是会需要等待一些操作嘛,
[11:56.000 --> 11:59.000] 比如说你去下载一个从网上下载一个图片,
[11:59.000 --> 12:02.000] 它这个现成就要等那张图片下完嘛,
[12:02.000 --> 12:05.000] 然后你这个现成其实上就要等着它不能做任何事情,
[12:05.000 --> 12:06.000] 那么这个时候,
[12:06.000 --> 12:10.000] 然后python它会知道说这个现成它现在没有在做任何事情,
[12:10.000 --> 12:13.000] 那它就会把其他的现成给拉起来,
[12:13.000 --> 12:15.000] 然后去让其他现成去做事,
[12:15.000 --> 12:18.000] 并且就是说python也是支持多进程的,
[12:18.000 --> 12:21.000] 就是说如果你觉得多现成确实不能满足你的要求的话,
[12:21.000 --> 12:23.000] 你就想同时跑16个任务,
[12:23.000 --> 12:25.000] 那你可以开多进程,
[12:25.000 --> 12:27.000] 这个的支持是没有任何问题,
[12:27.000 --> 12:28.000] 关于python的性能,
[12:28.000 --> 12:30.000] 还有一个经常吐槽的槽点就是,
[12:30.000 --> 12:32.000] 不知道是不是偏见啊,
[12:32.000 --> 12:35.000] 就是有人说python是解释执行的,
[12:35.000 --> 12:37.000] 解释执行是什么意思呢?
[12:37.000 --> 12:42.000] 就是说它并没有被翻译为机器能够执行的机器语言,
[12:42.000 --> 12:43.000] 就直接运行,
[12:43.000 --> 12:48.000] 而是需要有另外一个机器语言来读这个python,
[12:48.000 --> 12:50.000] 我看到这句是什么,
[12:50.000 --> 12:51.000] 那我来执行,
[12:51.000 --> 12:54.000] 所以它不是python翻译过去自己在执行,
[12:54.000 --> 12:57.000] 而是另外一个语言在执行它,
[12:57.000 --> 12:58.000] 这是真的吗?
[12:58.000 --> 12:59.000] 对,这个是真的,
[12:59.000 --> 13:01.000] 是的,这样其实就是方便程序员了,
[13:01.000 --> 13:04.000] 就python用的是一个虚拟机嘛,
[13:04.000 --> 13:06.000] 就比如说你用苹果,
[13:06.000 --> 13:08.000] 然后苹果它的UI做的非常人性化,
[13:08.000 --> 13:11.000] 那你可以就是用一些很少的操作完成一些工作,
[13:11.000 --> 13:13.000] 但是你比如说你用linux,
[13:13.000 --> 13:14.000] 你就要打一些命令,
[13:14.000 --> 13:17.000] 然后就相当于python的这个虚拟机,
[13:17.000 --> 13:19.000] 它帮你去做了很多事情,
[13:19.000 --> 13:21.000] 然后你在它之上来做一些操作,
[13:21.000 --> 13:23.000] 就相当于更简单,
[13:23.000 --> 13:24.000] 要操心的事情更少,
[13:24.000 --> 13:26.000] 过去我们说因为是脚本语言嘛,
[13:26.000 --> 13:29.000] 所以它要解释执行是吧,
[13:29.000 --> 13:32.000] 但是从Google的V8开始,
[13:32.000 --> 13:34.000] JavaScript,一个脚本语言,
[13:34.000 --> 13:37.000] 它也做成了像这个编译执行的,
[13:37.000 --> 13:38.000] 也做得很快,
[13:38.000 --> 13:41.000] Facebook还把这个PHP改造成了叫HPHP的吧,
[13:41.000 --> 13:43.000] 还是叫HIPHOP的吧,
[13:43.000 --> 13:45.000] 也是可以将脚本语言执行得很快,
[13:45.000 --> 13:48.000] 是的,原来刚发明的时候叫做HIPHOP,
[13:48.000 --> 13:51.000] 当然也有人说其实叫HPHP,
[13:51.000 --> 13:55.000] 就是赵海平想要把自己的名字打上去,
[13:55.000 --> 13:58.000] 其实就是海平的意思,
[13:58.000 --> 13:59.000] 不知道了,
[13:59.000 --> 14:02.000] 但是后来就改名叫做HACK,
[14:02.000 --> 14:03.000] 整个语言就叫HACK,
[14:03.000 --> 14:06.000] 好像注册的域名也是HACKLANG,
[14:06.000 --> 14:08.000] 有人说和Python类似的语言,
[14:08.000 --> 14:10.000] 也可以做成像即时编译的这种类型,
[14:10.000 --> 14:12.000] 也可以运行得很快,
[14:12.000 --> 14:14.000] 那为什么Python不可以呢?
[14:14.000 --> 14:15.000] 其实是可以的,
[14:15.000 --> 14:17.000] 就是有一些库可以来做这个事情,
[14:17.000 --> 14:19.000] 对,这就涉及到另外一个问题,
[14:19.000 --> 14:20.000] 就是说语言和实现嘛,
[14:20.000 --> 14:23.000] 就语言和实现是两个概念,
[14:23.000 --> 14:25.000] 我不知道听众们能不能理解,
[14:25.000 --> 14:26.000] 就相当于语言的话,
[14:26.000 --> 14:28.000] 也用方言来比喻可能不太合适,
[14:28.000 --> 14:30.000] 但是语言它是类似一个标准,
[14:30.000 --> 14:31.000] 但是实现的话,
[14:31.000 --> 14:35.000] 它就是说相当于怎么去把你这段语言在机器上执行,
[14:35.000 --> 14:37.000] 那语言和实现是两个东西,
[14:37.000 --> 14:39.000] 就是说机器懂汉语,
[14:39.000 --> 14:40.000] 我们说的是英语是吧,
[14:40.000 --> 14:41.000] 不同的翻译,
[14:41.000 --> 14:43.000] 它翻译成的汉语它不一样对吧,
[14:43.000 --> 14:45.000] 有的好有的不好是吧,
[14:45.000 --> 14:47.000] 有的长有的短是这个意思吗?
[14:47.000 --> 14:48.000] 也不能这么说,
[14:48.000 --> 14:51.000] 就相当于我想说是我们平常指的Python,
[14:51.000 --> 14:52.000] 其实是它的,
[14:52.000 --> 14:53.000] 其实指的是CPython,
[14:53.000 --> 14:56.000] 就是它的用C写的这个实现,
[14:56.000 --> 14:59.000] 然后它是官方在维护的一种实现,
[14:59.000 --> 15:02.000] 然后它相当于说就Python这个语言,
[15:02.000 --> 15:03.000] 它都是一样的嘛,
[15:03.000 --> 15:07.000] 但是你可以有用不同的方法把它翻译成机器能够理解的语言,
[15:07.000 --> 15:10.000] 那么有一种你可以说实现也好,
[15:10.000 --> 15:11.000] 或者说一个工具也好,
[15:11.000 --> 15:13.000] 它能够把Python翻译成机器语言,
[15:13.000 --> 15:14.000] 然后去执行,
[15:14.000 --> 15:16.000] 并没有任何限制去,
[15:16.000 --> 15:18.000] 限制了Python不能翻译成机器语言,
[15:18.000 --> 15:21.000] 只是说平常大家用的这个实现,
[15:21.000 --> 15:22.000] 它是解释执行的,
[15:22.000 --> 15:25.000] 那为什么这个官方版本不做快的实现呢?
[15:25.000 --> 15:26.000] 讲一下Python历史吧,
[15:26.000 --> 15:28.000] 就刚才可能这方面没有讲,
[15:28.000 --> 15:30.000] 就Python是Grado Van Rossum,
[15:30.000 --> 15:31.000] 这个荷兰人发明的嘛,
[15:31.000 --> 15:34.000] 它和像Java这种语言不太一样,
[15:34.000 --> 15:36.000] 它一开始没有一个公司的背景,
[15:36.000 --> 15:38.000] 包括到现在也没有公司的背景,
[15:38.000 --> 15:42.000] 你可以说Python在它的很长一段时间内,
[15:42.000 --> 15:44.000] 都是Grado一个人的东西,
[15:44.000 --> 15:46.000] 它的当初的这种技术选择,
[15:46.000 --> 15:48.000] 就是说我做一个虚拟机,
[15:48.000 --> 15:50.000] 然后来解释执行Python这门语言,
[15:50.000 --> 15:51.000] 这个传统就被延续下来,
[15:51.000 --> 15:53.000] 那么后来越来越多的人,
[15:53.000 --> 15:55.000] 就是去在这门语言上工作,
[15:55.000 --> 15:59.000] 那么它自然就会围绕在说一开始的这个实现,
[15:59.000 --> 16:02.000] 或者说Grado一直在维护的这个实现上去做,
[16:02.000 --> 16:05.000] 那么后来就有人发现说,
[16:05.000 --> 16:08.000] 这个我们叫官方实现或者Cpython的实现不太好,
[16:08.000 --> 16:11.000] 那他们也去尝试了做一些其他的实现,
[16:11.000 --> 16:13.000] 然后就让Python跑得更快,
[16:13.000 --> 16:17.000] 但是大部分的这种努力后来都没有下文了,
[16:17.000 --> 16:19.000] 但是也有一些还在维护的,
[16:19.000 --> 16:20.000] 比如说PyPy,
[16:20.000 --> 16:22.000] 就可能是少数几个,
[16:22.000 --> 16:24.000] 就是说非Cpython的实现吧。
[16:24.000 --> 16:26.000] 那为什么Cpython不做呢?
[16:26.000 --> 16:30.000] 是因为他们比较遵从创始人的这个理念吗?
[16:30.000 --> 16:31.000] 你可以这样讲,
[16:31.000 --> 16:32.000] 就是说Grado这个人吧,
[16:32.000 --> 16:34.000] 我虽然不想说他坏话,
[16:34.000 --> 16:39.000] 但是他的想法一直是觉得Python不需要有特别大的性能的改进,
[16:39.000 --> 16:41.000] 就是说他觉得Python已经足够快了,
[16:41.000 --> 16:43.000] 那然后如果你觉得Python不够快,
[16:43.000 --> 16:45.000] 你就去写C扩展,
[16:45.000 --> 16:47.000] 就是Python刚才我们说了嘛,
[16:47.000 --> 16:48.000] 它是一个教学语言,
[16:48.000 --> 16:50.000] 所以将于你可以拿执行速度更快的语言,
[16:50.000 --> 16:52.000] 比如说C和C++来写一部分东西,
[16:52.000 --> 16:54.000] 然后你拿Python去调用,
[16:54.000 --> 16:56.000] 他觉得这样是OK的,
[16:56.000 --> 17:01.000] 所以他本身并没有一个很强的动力说去改进Cpython的执行速度,
[17:01.000 --> 17:04.000] 那我觉得这个可能是一个根本吧,
[17:04.000 --> 17:06.000] 然后另外一方面的话,
[17:06.000 --> 17:10.000] 就是说Python它这门语言没有一个大公司的支持,
[17:10.000 --> 17:14.000] 那么没有大公司支持带来的就是说缺钱,
[17:14.000 --> 17:18.000] 你所有的现在Python在开发Python这门语言的人都是义务工作,
[17:18.000 --> 17:20.000] 或者大部分都是义务工作,
[17:20.000 --> 17:22.000] 那你义务工作的话时间就比较少,
[17:22.000 --> 17:26.000] 你也不可能说我就全身心的在这方面去做,
[17:26.000 --> 17:30.000] 那么它能带来的改进自然也相对来讲就更少一些,
[17:30.000 --> 17:33.000] 所以的话首先是归到本身的意愿,
[17:33.000 --> 17:36.000] 然后其次是也确实缺乏一些客观条件吧,
[17:36.000 --> 17:42.000] 可能是导致了就是说近些年来大家看到Python在速度这方面的改进不太多的原因,
[17:42.000 --> 17:44.000] 刚才吐槽了很多Python的性能啊,
[17:44.000 --> 17:45.000] 说解释执行啊,
[17:45.000 --> 17:47.000] 但是解释执行真的就是那么慢吗?
[17:47.000 --> 17:50.000] 真的就比那种即时编译的要慢很多吗?
[17:50.000 --> 17:51.000] 还是慢挺多的,
[17:51.000 --> 17:52.000] 对,
[17:52.000 --> 17:53.000] 确实慢挺多,
[17:53.000 --> 17:55.000] 但是这个就是说刚才提到归陋想法吧,
[17:55.000 --> 17:57.000] 你也不能说他说的是错的,
[17:57.000 --> 18:00.000] 就是因为实际上对于大部分的应用,
[18:00.000 --> 18:01.000] 大部分的场景来看,
[18:01.000 --> 18:03.000] Python的确是不慢,
[18:03.000 --> 18:05.000] 就是说我们经常说啊,
[18:05.000 --> 18:07.000] 够能支持几十万并发,
[18:07.000 --> 18:09.000] 但是你比如说你做一个创业公司,
[18:09.000 --> 18:11.000] 你真的需要几十万并发吗?
[18:11.000 --> 18:12.000] 你不需要对吧?
[18:12.000 --> 18:13.000] 那其实也是一个意思,
[18:13.000 --> 18:16.000] 就是说对于99.9%的场景来讲,
[18:16.000 --> 18:17.000] Python是不慢的,
[18:17.000 --> 18:20.000] 因为它毕竟是一个系统编程语言,
[18:20.000 --> 18:21.000] 它是跑在你电脑上,
[18:21.000 --> 18:23.000] 那它自然就肯定不会慢到哪去吗?
[18:23.000 --> 18:25.000] 但是就是说我们说Python慢,
[18:25.000 --> 18:27.000] 也只是和更快的语言来对比,
[18:27.000 --> 18:28.000] 然后说它比较慢,
[18:28.000 --> 18:30.000] 是这样一个意思。
[18:30.000 --> 18:35.000] 我觉得从脚本语言来看和从做一个服务来看不一样吧,
[18:35.000 --> 18:36.000] 对吧?
[18:36.000 --> 18:38.000] 做服务可能真的会在乎并发,
[18:38.000 --> 18:44.000] 尤其是你不一定所有东西都可以通过horizontally scale来解决,
[18:44.000 --> 18:47.000] 有可能你就需要在单个实例上有高并发,
[18:47.000 --> 18:49.000] 但有些东西可以horizontally scale,
[18:49.000 --> 18:50.000] 那你就不管了,
[18:50.000 --> 18:51.000] 不够了就加instance,
[18:51.000 --> 18:52.000] 反正又不贵,
[18:52.000 --> 18:53.000] 对吧?
[18:53.000 --> 18:55.000] 直到你加到了非常非常烧钱为止,
[18:55.000 --> 18:57.000] 可能不同的情况不一样。
[18:57.000 --> 18:59.000] 对,就说你考虑到单机的性能的话,
[18:59.000 --> 19:03.000] Python确实是在大规模的互联网应用上是不行,
[19:03.000 --> 19:04.000] 对,这个必须要承认,
[19:04.000 --> 19:07.000] 然后但是就是说对于大部分的公司来讲,
[19:07.000 --> 19:09.000] 可能你还没有到那个程度,
[19:09.000 --> 19:11.000] 然后就是说即使你到了这个程度,
[19:11.000 --> 19:13.000] 你也有办法就是通过水平扩展来解决,
[19:13.000 --> 19:14.000] 就比如说Instagram,
[19:14.000 --> 19:16.000] 它现在的后端是Django嘛,
[19:16.000 --> 19:18.000] 然后就是Python的语言的一个框架,
[19:18.000 --> 19:20.000] 那它其实就一直是Django,
[19:20.000 --> 19:23.000] 那你说Instagram的流量它都能够支撑住,
[19:23.000 --> 19:24.000] 对吧?
[19:24.000 --> 19:25.000] 我们吐完槽了Python的性能,
[19:25.000 --> 19:29.000] 我们要不要给大家讲一讲Python这个语言到底是怎么回事,
[19:29.000 --> 19:30.000] 什么时候,
[19:30.000 --> 19:31.000] 它的历史是怎么样的?
[19:31.000 --> 19:33.000] 好,就是刚才也提到了嘛,
[19:33.000 --> 19:36.000] 然后就是Python是Gradle这个人发明的,
[19:36.000 --> 19:39.000] 它具体的时间点是在1989年的圣诞节,
[19:39.000 --> 19:43.000] 那反正就是说传说它在圣诞节的时候,
[19:43.000 --> 19:44.000] 然后放假了,
[19:44.000 --> 19:45.000] 在家里闲着没事,
[19:45.000 --> 19:47.000] 然后就搞一门语言出来玩一玩,
[19:47.000 --> 19:49.000] 没想到突然就火了,
[19:49.000 --> 19:50.000] 对吧?
[19:50.000 --> 19:51.000] 其实也不是突然火的,
[19:51.000 --> 19:54.000] 那它一开始肯定就一开始肯定也想不到嘛,
[19:54.000 --> 19:56.000] 这门语言它在创立的时候,
[19:56.000 --> 19:58.000] 它是作为另外一门语言的一个后继,
[19:58.000 --> 20:00.000] 就是叫这门语言叫ABC,
[20:00.000 --> 20:04.000] 它是说从ABC这门语言里面学习了很多东西嘛,
[20:04.000 --> 20:08.000] 那我觉得它一开始可能也就是想就是做一个就个人项目吧,
[20:08.000 --> 20:09.000] 然后玩一玩,
[20:09.000 --> 20:12.000] 因为你看现在就是很多一些大学生啊,
[20:12.000 --> 20:14.000] 就是对编程语言有一定研究,
[20:14.000 --> 20:16.000] 他们也会写自己的语言,
[20:16.000 --> 20:18.000] 那后来就是说我听到的故事啊,
[20:18.000 --> 20:21.000] 就是我在那个去年PyCon现场,
[20:21.000 --> 20:24.000] 然后听了当时几个Python的元老来讲一段故事,
[20:24.000 --> 20:27.000] 就是Gradle去美国的一个公司,
[20:27.000 --> 20:29.000] 那个公司名字我忘记了,
[20:29.000 --> 20:32.000] 好像是一个什么实验室来宣传Python这门语言嘛,
[20:32.000 --> 20:35.000] 一开始一个新语言肯定没有人知道也没人用嘛,
[20:35.000 --> 20:37.000] 然后当时那个公司的几个人,
[20:37.000 --> 20:39.000] 然后就听了就觉得诶,
[20:39.000 --> 20:40.000] 这门语言很不错,
[20:40.000 --> 20:42.000] 就是他们也也想用一用,
[20:42.000 --> 20:47.000] 然后他们就说要我们就把Gradle招募到这个公司来专门开发这门语言吧,
[20:47.000 --> 20:48.000] 后来Gradle就到美国来了,
[20:48.000 --> 20:52.000] 然后他们这个公司的一些人也开始在Python这门语言上工作,
[20:52.000 --> 20:55.000] 那他主见的就是说从一个人的项目,
[20:55.000 --> 20:57.000] 然后变成了有几个人在上面工作,
[20:57.000 --> 21:00.000] 然后他的就是社群就慢慢的越来越大,
[21:00.000 --> 21:03.000] 然后后来就到了今天这个程度,
[21:03.000 --> 21:08.000] 那就必须要提的是就是Python一开始在2000年之前吧,
[21:08.000 --> 21:10.000] 或者在2000年左右的一段时间,
[21:10.000 --> 21:14.000] 他的竞争对手Gradle给自己设定的竞争对手一直是Per,
[21:14.000 --> 21:16.000] Per是另外一门编程语言嘛,
[21:16.000 --> 21:19.000] 那就是Python一开始一直是对标Per的,
[21:19.000 --> 21:20.000] Per叫什么,
[21:20.000 --> 21:21.000] Write Only Language是吧,
[21:21.000 --> 21:22.000] 只能写的语言,
[21:22.000 --> 21:25.000] 就是任何字符串都是合法的Per语言,
[21:25.000 --> 21:29.000] 意思就是不这个没法读只能写的语言啊,
[21:29.000 --> 21:33.000] 对,反正他就是反正和Per竞争了这么一段时间之后,
[21:33.000 --> 21:35.000] 他就算是赢得了一场竞争吧,
[21:35.000 --> 21:37.000] 这是个功德无量的事啊,
[21:37.000 --> 21:39.000] 在我们程序员看来就是个功德无量的事啊,
[21:39.000 --> 21:44.000] 我如果偶尔看那些非常老的代码Per写的这些脚本,
[21:44.000 --> 21:45.000] 我在想哇,
[21:45.000 --> 21:48.000] 如果今天让我写让我写这些语言,
[21:48.000 --> 21:49.000] 我就辞职了,
[21:49.000 --> 21:50.000] 没见过,
[21:50.000 --> 21:55.000] 对,就是之前也提到说Python在机器学习方面有很多的应用嘛,
[21:55.000 --> 21:56.000] 那他这个,
[21:56.000 --> 21:58.000] 我觉得这个也属于比较偶然吧,
[21:58.000 --> 21:59.000] 或者说偶然若有必然,
[21:59.000 --> 22:04.000] 就是因为Python他能够很好的和C来交互,
[22:04.000 --> 22:07.000] 那就在Python还没有这么火的时候,
[22:07.000 --> 22:13.000] 有些人他就用Python去做一个C的wrapper来实现了一些科学计算的库,
[22:13.000 --> 22:15.000] 比如说NumPy,
[22:15.000 --> 22:16.000] 然后SciPy这样子,
[22:16.000 --> 22:19.000] 所谓的科学计算就这个要怎么解释,
[22:19.000 --> 22:20.000] 我也不知道怎么解释,
[22:20.000 --> 22:22.000] 反正就是说你可以理解为科学家用的语言,
[22:22.000 --> 22:26.000] 那么他有了这些一些底层的支持之后,
[22:26.000 --> 22:29.000] 用Python就可以很好去做科学计算嘛,
[22:29.000 --> 22:32.000] 那么到了机器学习爆发的这个时间点,
[22:32.000 --> 22:37.000] 大家发现用Python就可以去很容易的写出一些机器学习的库,
[22:37.000 --> 22:39.000] 然后大家就自然而然的开始都用Python,
[22:39.000 --> 22:41.000] 这个也有一定偶然吧,
[22:41.000 --> 22:43.000] 但是还是和他语言本身的特性有关,
[22:43.000 --> 22:44.000] 在我印象中,
[22:44.000 --> 22:47.000] 在比如深度学习的这个是吧,
[22:47.000 --> 22:48.000] 这几个语言之前,
[22:48.000 --> 22:52.000] Python就也已经比较广泛的应用于数据处理的语言了,
[22:52.000 --> 22:54.000] 当然有Metalab是一批了,
[22:54.000 --> 22:55.000] 那时候还有R啊,
[22:55.000 --> 22:59.000] 然后慢慢慢慢是越来越多的数据分析的人是用Python在写的,
[22:59.000 --> 23:05.000] 这可能确实想说的是有很多的这些科学计算的这些库有关系,
[23:05.000 --> 23:07.000] 这个是我们刚才说到了Python的转型啊,
[23:07.000 --> 23:09.000] 2000年之前是一个脚本语言啊,
[23:09.000 --> 23:11.000] 就是我说的那个啊,
[23:11.000 --> 23:12.000] 你让他去做ABC啊,
[23:12.000 --> 23:18.000] 然后之后转型为了一个更从科学计算为入口,
[23:18.000 --> 23:21.000] 今天成为了这个深度学习的语言,
[23:21.000 --> 23:23.000] 写深度学习的人都要写语言,
[23:23.000 --> 23:25.000] 我觉得也不能叫转型,
[23:25.000 --> 23:26.000] 是吧,
[23:26.000 --> 23:30.000] 因为Python一开始他就是一个叫做通用语言,
[23:30.000 --> 23:35.000] 就是说他一开始就不是一个只局限于某一个领域的语言,
[23:35.000 --> 23:36.000] 比如说啊,
[23:36.000 --> 23:38.000] 很多人都知道HTML吗?
[23:38.000 --> 23:40.000] 就是写这个网上页面的语言,
[23:40.000 --> 23:42.000] 那他你能用HTML编程吗?
[23:42.000 --> 23:43.000] 那当然不能,
[23:43.000 --> 23:44.000] 对吧?
[23:44.000 --> 23:46.000] 所以Python和HTML还是不一样的,
[23:46.000 --> 23:49.000] 他一开始就是能够去执行多种任务的一个语言,
[23:49.000 --> 23:54.000] 所以他后来在大家发现他在执行某一些任务方面比较适合,
[23:54.000 --> 23:56.000] 那他就在这个方面就比较火,
[23:56.000 --> 23:58.000] 我们从历史说到了现在啊,
[23:58.000 --> 24:01.000] 那未来Python的发展方向是什么呢?
[24:01.000 --> 24:04.000] 第一个是叫做type hints,
[24:04.000 --> 24:05.000] type hints是什么呢?
[24:05.000 --> 24:07.000] 就是就是类型是吧,
[24:07.000 --> 24:08.000] 类型标注,
[24:08.000 --> 24:10.000] 换句话就是说在Python里面,
[24:10.000 --> 24:12.000] 你比如说你定义一个函数吗?
[24:12.000 --> 24:14.000] 你可以你设定它有AB两个参数,
[24:14.000 --> 24:15.000] 但是呢,
[24:15.000 --> 24:17.000] 你其实不知道它类型是什么吗?
[24:17.000 --> 24:20.000] 或者说你可以给它传任意类型的值,
[24:20.000 --> 24:23.000] 就是说现在如果我们用Python写程序的话,
[24:23.000 --> 24:25.000] 我们可以说这是一个函数啊,
[24:25.000 --> 24:26.000] FXY对吧?
[24:26.000 --> 24:27.000] 我们什么都写,
[24:27.000 --> 24:29.000] XY是什么我们都不知道,
[24:29.000 --> 24:31.000] 但是如果我们写一个别的语言,
[24:31.000 --> 24:32.000] 比如说C++,
[24:32.000 --> 24:34.000] 我们要说这个函数FXY,
[24:34.000 --> 24:35.000] X是个整数,
[24:35.000 --> 24:37.000] Y是个无理数,
[24:37.000 --> 24:39.000] 我们返回一个数是字符串,
[24:39.000 --> 24:41.000] 我得标注它类型是什么,
[24:41.000 --> 24:43.000] 那但是Python就不用,
[24:43.000 --> 24:45.000] 那么这个类型叫什么?
[24:45.000 --> 24:46.000] 类型标注,
[24:46.000 --> 24:47.000] hint是吧?
[24:47.000 --> 24:49.000] 类型标注是什么意思呢?
[24:49.000 --> 24:51.000] 它的意思就是说你可以在这个,
[24:51.000 --> 24:53.000] 比如说你有两个参数A和B,
[24:53.000 --> 24:55.000] 然后在A后面加一个冒号,
[24:55.000 --> 24:56.000] 你写上一个int,
[24:56.000 --> 25:00.000] 然后就代表说A它是一个整数,
[25:00.000 --> 25:02.000] 就是你会传一个整数给它,
[25:02.000 --> 25:04.000] 但它实际上并不是一个强制的约束,
[25:04.000 --> 25:07.000] 就它类似于一个函数的注释吧,
[25:07.000 --> 25:08.000] 它会报错吗?
[25:08.000 --> 25:10.000] 如果你比如说你标注它是int,
[25:10.000 --> 25:11.000] 那你给它传stream,
[25:11.000 --> 25:12.000] 当然程序也是可以跑的,
[25:12.000 --> 25:15.000] 但是你如果用一些工具去检查的话,
[25:15.000 --> 25:18.000] 它可以检查说你这个地方写的是int,
[25:18.000 --> 25:19.000] 但是你传的是个stream,
[25:19.000 --> 25:21.000] 就相当于你在程序执行之前,
[25:21.000 --> 25:23.000] 你可以检查出一些错误了,
[25:23.000 --> 25:24.000] 说到这个,
[25:24.000 --> 25:26.000] 我觉得Python是一个非常棒的语言,
[25:26.000 --> 25:28.000] 就是有的语言是没有类型的,
[25:28.000 --> 25:31.000] 有的语言是说我所有的变量都要说,
[25:31.000 --> 25:32.000] 这个是个整数,
[25:32.000 --> 25:33.000] 是个字串,
[25:33.000 --> 25:34.000] 有的语言是没有类型的,
[25:34.000 --> 25:36.000] 就是说随便写,
[25:36.000 --> 25:37.000] 我写了一个整数,
[25:37.000 --> 25:39.000] 我写了一个字符串,
[25:39.000 --> 25:41.000] 我就可以把它们不用知道什么,
[25:41.000 --> 25:42.000] 就可以一起操作,
[25:42.000 --> 25:44.000] Python其实是有的对吧?
[25:44.000 --> 25:46.000] Python是个强类型的变成语言,
[25:46.000 --> 25:47.000] 它被复制之后,
[25:47.000 --> 25:49.000] 这个变量是有个类型的,
[25:49.000 --> 25:51.000] 但是我又不用写的类型是什么,
[25:51.000 --> 25:52.000] 这是个非常酷的语言,
[25:52.000 --> 25:53.000] 我觉得,
[25:53.000 --> 25:56.000] 就像斯图亚克刚才说的,
[25:56.000 --> 25:57.000] 这个一方面是很方便,
[25:57.000 --> 25:58.000] 另一方面也造成了很多问题,
[25:58.000 --> 26:01.000] 就是说你可能你想让它传一个字符串进去,
[26:01.000 --> 26:03.000] 但它传了个整数进去,
[26:03.000 --> 26:04.000] 然后你的程序就不工作了,
[26:04.000 --> 26:05.000] 直接crash了,
[26:05.000 --> 26:06.000] 对,
[26:06.000 --> 26:07.000] 然后type hints它的出现,
[26:07.000 --> 26:08.000] 我觉得是很重要,
[26:08.000 --> 26:10.000] 就是在工程化这个方面,
[26:10.000 --> 26:12.000] 帮助Python改善了很多吧,
[26:12.000 --> 26:13.000] 我觉得,
[26:13.000 --> 26:15.000] 就我其实在公司里面,
[26:15.000 --> 26:17.000] 之前短暂的写过一段Python,
[26:17.000 --> 26:18.000] 也是有这种感觉,
[26:18.000 --> 26:20.000] 就我不熟悉那段代码,
[26:20.000 --> 26:22.000] 然后根本就不知道它那些参数是什么,
[26:22.000 --> 26:24.000] 它有可能七八个参数,
[26:24.000 --> 26:25.000] 很难看,
[26:25.000 --> 26:26.000] 但是如果你有type hints的话,
[26:26.000 --> 26:29.000] 你至少知道说这些参数它都分别是什么类型,
[26:29.000 --> 26:32.000] 这就相当于帮助你在阅读代码的时候,
[26:32.000 --> 26:33.000] 节省了很多工作,
[26:33.000 --> 26:35.000] 所以我觉得type hints还是很重要,
[26:35.000 --> 26:38.000] 这是我们说的Python第一个未来发展方向,
[26:38.000 --> 26:40.000] 还有什么主要发展方向呢?
[26:40.000 --> 26:42.000] 然后第二个可能是async,
[26:42.000 --> 26:44.000] 就是asynchronous异步,
[26:44.000 --> 26:45.000] 异步是什么意思?
[26:45.000 --> 26:48.000] 就我们刚才说Python在同一个时刻,
[26:48.000 --> 26:50.000] 它只能有同一个线程在跑嘛,
[26:50.000 --> 26:51.000] 虽然它可以有多线程,
[26:51.000 --> 26:54.000] 但是同一个时刻只能有一个线程在执行,
[26:54.000 --> 26:55.000] 那么异步的话,
[26:55.000 --> 26:57.000] 它就是说就相当于是说,
[26:57.000 --> 27:00.000] 你既然同一时刻只能有一个线程在执行,
[27:00.000 --> 27:02.000] 那我为什么还要开多个线程呢?
[27:02.000 --> 27:04.000] 为什么不能让用一个线程去完成,
[27:04.000 --> 27:06.000] 我多个线程能做的事情呢?
[27:06.000 --> 27:08.000] 这可能讲起来比较抽象,
[27:08.000 --> 27:13.000] 但是它就是相当于让你用一个线程能做多件事,
[27:13.000 --> 27:15.000] 比如说你同时在做实验室,
[27:15.000 --> 27:16.000] 然后有其中的,
[27:16.000 --> 27:17.000] 其中有几个,
[27:17.000 --> 27:18.000] 几个这种任务,
[27:18.000 --> 27:20.000] 它是处于一个等待的状态,
[27:20.000 --> 27:22.000] 比如说就是你要从网上下载一个图片,
[27:22.000 --> 27:24.000] 那它就可以切到别的任务去执行,
[27:24.000 --> 27:26.000] 但它还是在同样一个线程里面,
[27:26.000 --> 27:27.000] 大概就是这么个意思,
[27:27.000 --> 27:33.000] 就是一个线程可以用多个核的计算能力来跑一个线程的工作,
[27:33.000 --> 27:34.000] 用不了多个核,
[27:35.000 --> 27:37.000] 一个线程的肯定就是一个核,
[27:37.000 --> 27:39.000] 它就是做多件事,
[27:39.000 --> 27:42.000] 相当于你可以理解为提高了一个线程的利用效率,
[27:42.000 --> 27:44.000] 那它编程的方法就不一样吗?
[27:44.000 --> 27:45.000] 比如说我们是吧,
[27:45.000 --> 27:50.000] 初学编程的人大概写程序都是会编成if,for是吧,
[27:50.000 --> 27:51.000] 如果这样怎么怎么样,
[27:51.000 --> 27:53.000] 循环从1到10怎么怎么样对吧,
[27:53.000 --> 27:56.000] 那么出现这种叫异步的这种特性之后,
[27:56.000 --> 27:59.000] 那大家写程序的方式会有改变吗?
[27:59.000 --> 28:00.000] 会有改变,
[28:00.000 --> 28:00.000] 对,
[28:00.000 --> 28:02.000] 这个其实Kat可能也比较熟,
[28:02.000 --> 28:04.000] 就是跟JavaScript里面是一样的,
[28:04.000 --> 28:07.000] 就是一个叫做async关键字,
[28:07.000 --> 28:11.000] 然后你可以用async来标记说一个函数是不是async,
[28:11.000 --> 28:12.000] 对,
[28:12.000 --> 28:15.000] 我觉得async其实就是说怎么说呢,
[28:15.000 --> 28:17.000] 还是用搬砖这个例子吧,
[28:17.000 --> 28:21.000] 就是它的意思是你搬砖有一块砖,
[28:21.000 --> 28:22.000] 如果搬到一半,
[28:22.000 --> 28:24.000] 你这块砖不能搬下去了,
[28:24.000 --> 28:26.000] 你可以把这块砖就地放下来,
[28:26.000 --> 28:27.000] 你还是一个人,
[28:27.000 --> 28:30.000] 但这个人可以跑去搬另外一块砖去了,
[28:30.000 --> 28:31.000] 对,
[28:31.000 --> 28:32.000] 这就是async的核心啊,
[28:32.000 --> 28:36.000] 所以例如说你可以所有的砖都搬到桥旁边了,
[28:36.000 --> 28:39.000] 然后就一块一块的搬过去,
[28:39.000 --> 28:42.000] 其实没有变的是你还是只有一个人,
[28:42.000 --> 28:43.000] 没有变的,
[28:43.000 --> 28:47.000] 同时还有这个桥还是只能统一时间通过一个人,
[28:47.000 --> 28:50.000] 但是你这个砖的调度变得更灵活了,
[28:50.000 --> 28:51.000] 好了,
[28:51.000 --> 28:52.000] 我们说完了异步对吧,
[28:52.000 --> 28:54.000] 我们还有什么?
[28:54.000 --> 28:57.000] 还有一个比较重要的就是,
[28:57.000 --> 29:01.000] 这个可能严格来讲不是属于python这门语言,
[29:01.000 --> 29:02.000] 就不是它语言本身,
[29:02.000 --> 29:05.000] 但是属于语言这个生态的一部分,
[29:05.000 --> 29:07.000] 比如说你写一个程序吧,
[29:07.000 --> 29:09.000] 然后我就有这么一段代码,
[29:09.000 --> 29:12.000] 那我想把它变成一个windows上的exe,
[29:12.000 --> 29:14.000] 那我要怎么做?
[29:14.000 --> 29:17.000] 就是它有一个这样的叫做packaging的过程,
[29:17.000 --> 29:23.000] 所以packaging其实就是把你写的代码变成一个别人能够去调用的库,
[29:24.000 --> 29:26.000] 或者说是一个可执行的程序,
[29:26.000 --> 29:27.000] 这样的一个过程,
[29:27.000 --> 29:31.000] 因为你肯定不可能让别人去把你这段代码复制到机器上去跑,
[29:31.000 --> 29:33.000] 就是我在windows会生成一个图标,
[29:33.000 --> 29:35.000] 一个n就可以执行了,
[29:35.000 --> 29:37.000] 所以说那么python一开始的话,
[29:37.000 --> 29:41.000] 它这方面的基础设施是非常薄弱的,
[29:41.000 --> 29:43.000] 或者说官方就没太管,
[29:43.000 --> 29:45.000] 它就你想怎么弄怎么弄,
[29:45.000 --> 29:48.000] 然后社区里就也是诞生了一些解决方案,
[29:48.000 --> 29:50.000] 但这些解决方案都不是特别好,
[29:50.000 --> 29:55.000] 那么在最近几年python这个社区就在这方面发力比较多吧,
[29:55.000 --> 29:58.000] 就是有一些官方的标准出台,
[29:58.000 --> 30:02.000] 然后有一些比较新的比较好用的工具来也是在逐渐的出来,
[30:02.000 --> 30:06.000] 然后就相当于你可以更方便的把你的程序打包成一个库,
[30:06.000 --> 30:08.000] 或者打包成一个可执行的程序,
[30:08.000 --> 30:11.000] 这方面的最近的发展是很快的,
[30:11.000 --> 30:14.000] 以后看到越来越多的windows图标,
[30:14.000 --> 30:16.000] 其实后面是python写的,
[30:16.000 --> 30:18.000] 其实其实就是我们讲packaging的时候,
[30:18.000 --> 30:19.000] packaging有两种,
[30:19.000 --> 30:21.000] 一种是打包成应用程序,
[30:21.000 --> 30:23.000] 另外一种是打包成一个库,
[30:23.000 --> 30:25.000] 就相与我在写一个python程序,
[30:25.000 --> 30:27.000] 我可以用别人写的一段程序,
[30:27.000 --> 30:31.000] 更多的时候打包是我们在说的是后面一种情况,
[30:31.000 --> 30:32.000] 就是打包成一个库,
[30:32.000 --> 30:34.000] 让别人的python程序可以调用,
[30:34.000 --> 30:37.000] 我们说了类型提示,
[30:37.000 --> 30:38.000] 异步执行,
[30:38.000 --> 30:42.000] 如何能够生成各种各样的库和可执行程序是吧,
[30:42.000 --> 30:44.000] 还有什么别的方向吗?
[30:44.000 --> 30:47.000] 然后就是老生常谈的性能问题了,
[30:47.000 --> 30:50.000] 就虽然我是一直在黑python的性能,
[30:50.000 --> 30:51.000] 说他最近没有什么改进,
[30:51.000 --> 30:54.000] 但其实一直有很多人在尝试去改进,
[30:54.000 --> 30:56.000] 只是都没有成功而已,
[30:56.000 --> 30:59.000] 就是说官方他们也还是要提高性能的,
[30:59.000 --> 30:59.000] 是吧,
[30:59.000 --> 31:01.000] 虽然虽然这么说,
[31:01.000 --> 31:02.000] 说已经很好了,
[31:02.000 --> 31:03.000] 但是我们还是要可以更好,
[31:03.000 --> 31:04.000] 是吧,
[31:04.000 --> 31:07.000] 其实那个只是gradle可能感觉比较好,
[31:07.000 --> 31:09.000] 但是也有很多人觉得不够好,
[31:09.000 --> 31:11.000] 那相当于最新的一些进展,
[31:11.000 --> 31:14.000] 必须要提的一个就是叫做multi interpreter,
[31:14.000 --> 31:15.000] 就是多解释器,
[31:15.000 --> 31:17.000] 这个东西真的是很tricky,
[31:17.000 --> 31:20.000] 就我们刚才讲到python的那个现成,
[31:20.000 --> 31:23.000] 同一时刻只能有一个一个现场在执行吧,
[31:23.000 --> 31:27.000] 那有人就说你既然他的现成是有这种限制,
[31:27.000 --> 31:30.000] 那我为什么不跑多个解释器呢?
[31:30.000 --> 31:33.000] 同时跑多个解释器不就可以同时跑多个现成了吗?
[31:33.000 --> 31:35.000] 这个听着很有道理啊,
[31:35.000 --> 31:37.000] 这就像这个CPU流水线一样,
[31:37.000 --> 31:38.000] 对吧?
[31:38.000 --> 31:40.000] 有一个人应该是叫Eric Snow,
[31:40.000 --> 31:43.000] 他在这方面工作了很多年了,
[31:43.000 --> 31:45.000] 好像从15年就开始有这个想法,
[31:45.000 --> 31:48.000] 然后最近几年一直在去推进这个事情,
[31:48.000 --> 31:52.000] 他就想把多解释器去做进Cpython里面,
[31:52.000 --> 31:54.000] 让python能够支持多解释器,
[31:54.000 --> 31:58.000] 但这个事情呢就是在社区的争议是非常大的,
[31:58.000 --> 32:01.000] 因为他可以想象这是一个比较根本的改变嘛,
[32:01.000 --> 32:04.000] 他涉及到很多很多的其他的部分,
[32:04.000 --> 32:06.000] 那可能会有一些breaking change,
[32:06.000 --> 32:11.000] 那就是说很多人也觉得说这个东西到底是不是有意义,
[32:11.000 --> 32:17.000] 就是说我们是不是应该去支持说真正的让多个现场能同时执行,
[32:17.000 --> 32:21.000] 而不是要多解释器这样一种比较hack的方式,
[32:21.000 --> 32:23.000] 就是社区的争议是很大的,
[32:23.000 --> 32:30.000] 但是这个事情呢反正是一个可能是就是最近几年有关于性能的最相关的一个议题吧,
[32:30.000 --> 32:33.000] 他最后能不能能不能合进Cpython就不知道了,
[32:33.000 --> 32:38.000] 所以大概意思就是说虽然我们不能让python并行执行我们的程序,
[32:38.000 --> 32:40.000] 但是我们执行的时候可以是并行的是吧?
[32:40.000 --> 32:42.000] 对,我们可以好多python同时,
[32:42.000 --> 32:46.000] 但是让你感觉还是用同一个python,
[32:46.000 --> 32:48.000] 就是这个听着很酷啊,
[32:48.000 --> 32:49.000] 是吧,
[32:49.000 --> 32:49.000] 对,
[32:49.000 --> 32:50.000] 听上去很酷啊,
[32:50.000 --> 32:52.000] 我还是写for if是吧,
[32:52.000 --> 32:54.000] 还是写我的普通函数,
[32:54.000 --> 32:55.000] 但是我就更快了,
[32:55.000 --> 32:57.000] 我就直接可以用多个和了,
[32:57.000 --> 32:58.000] 这个多酷呀,
[32:58.000 --> 32:58.000] 对,
[32:58.000 --> 32:59.000] 可能没有你说的那么酷,
[32:59.000 --> 33:02.000] 但是他还是就是肯定是有改进的,
[33:02.000 --> 33:03.000] 就再看,
[33:03.000 --> 33:06.000] 然后还有另外一些方面就是刚才说的不同的python实现,
[33:06.000 --> 33:09.000] 那么就有像pypy这种,
[33:09.000 --> 33:11.000] 他是叫做一个JIT,
[33:11.000 --> 33:13.000] 然后就是这个说起来又太复杂,
[33:13.000 --> 33:14.000] 然后我其实也不太懂,
[33:14.000 --> 33:16.000] 但是他总之你可以理解,
[33:16.000 --> 33:20.000] 听众们就理解成是另外一种更快的python实现就好了,
[33:20.000 --> 33:22.000] 就有一些这方面的工作,
[33:22.000 --> 33:25.000] 然后我觉得主要可能就这4个方面吧,
[33:25.000 --> 33:27.000] 好,给我们讲讲python的未来啊,
[33:27.000 --> 33:33.000] 听上去这个python的未来好像也击败不了这个java和这样的语言啊,
[33:33.000 --> 33:37.000] 没可能,除非除非那个oracle或者google哪天发神经了,
[33:37.000 --> 33:39.000] 说我们要make python great again,
[33:39.000 --> 33:41.000] 然后就就投钱就不计成本了,
[33:41.000 --> 33:42.000] 要改进python,
[33:42.000 --> 33:44.000] google以前其实做过这个事情,
[33:44.000 --> 33:45.000] 相当于零几年的时候,
[33:45.000 --> 33:48.000] 有几个google的工程师说我们要做一个更快的python,
[33:48.000 --> 33:50.000] 然后就开了一个项目,
[33:50.000 --> 33:53.000] 并且这个项目是放在那个google公司底下的,
[33:53.000 --> 33:54.000] 那大家就说哇,
[33:54.000 --> 33:56.000] google要开始就是做一个更快的python了,
[33:56.000 --> 33:58.000] 然后我们期待会发生什么,
[33:58.000 --> 34:00.000] 然后最后几年之后这个项目不了了之,
[34:00.000 --> 34:04.000] 因为这个项目根本就不是google官方想推的一个项目,
[34:04.000 --> 34:06.000] 就是那几个工程师他自己有兴趣,
[34:06.000 --> 34:07.000] 然后他就做了一个,
[34:07.000 --> 34:12.000] 所以就是说实际上到现在为止python是没有像java,
[34:12.000 --> 34:17.000] 甚至像就是c sharp这种google这种这样的语言大公司支持的,
[34:17.000 --> 34:20.000] 它就是一个社区土生土长,
[34:20.000 --> 34:22.000] 然后这样的c++也是啊,
[34:22.000 --> 34:24.000] 所以c++也很烂啊,
[34:24.000 --> 34:27.000] 我作为一个天天写c++的人,
[34:27.000 --> 34:29.000] 我不觉得c++很烂啊,
[34:29.000 --> 34:31.000] 至少在性能上吧,
[34:31.000 --> 34:32.000] 性能这个当然是,
[34:32.000 --> 34:35.000] 但是对c++的抱怨绝对是不比python少的,
[34:35.000 --> 34:38.000] c++光是constructor就有二十几种,
[34:38.000 --> 34:40.000] 所以对吧,
[34:40.000 --> 34:42.000] c++应该是历史太久远,
[34:42.000 --> 34:45.000] 以至于它很多东西不好改吧,
[34:45.000 --> 34:46.000] 其实python也是这样子,
[34:46.000 --> 34:48.000] 其实python也有类似的问题,
[34:48.000 --> 34:48.000] 呃,
[34:48.000 --> 34:50.000] 它的历史包袱是很多的,
[34:50.000 --> 34:52.000] 正好说到了c++的历史包袱,
[34:52.000 --> 34:54.000] 我们正好提到下一个话题,
[34:54.000 --> 34:56.000] 因为我们知道c++是一个标准,
[34:56.000 --> 34:58.000] 其实非常日新月异的语言呀,
[34:58.000 --> 34:59.000] 对吧,
[34:59.000 --> 35:00.000] 什么什么11,
[35:00.000 --> 35:01.000] 14,
[35:01.000 --> 35:02.000] 17,
[35:02.000 --> 35:03.000] 20什么之类的,
[35:03.000 --> 35:07.000] 它基本上都可以保持向下兼容对吧,
[35:07.000 --> 35:11.000] 基本上你拿一个c++新版本的17的语言,
[35:11.000 --> 35:13.000] 你跑一个90年代写c++,
[35:13.000 --> 35:15.000] 基本上还是都是可以编译的对吧,
[35:15.000 --> 35:17.000] 基本上不用太改就可以用,
[35:17.000 --> 35:19.000] 但是python这个语言呢,
[35:19.000 --> 35:21.000] 最近经历了一次是吧,
[35:21.000 --> 35:24.000] python版本2到版本3的更改啊,
[35:24.000 --> 35:26.000] 这个更改结果是,
[35:26.000 --> 35:29.000] 几乎所有的python程序几乎都不能运行了啊,
[35:29.000 --> 35:31.000] 并且还不是小修小改就可以运行,
[35:31.000 --> 35:35.000] 并且需要做都需要还相对比较大的改动才能运行,
[35:35.000 --> 35:36.000] 这个让大家是吧,
[35:36.000 --> 35:40.000] 是让我们这些偶尔写python的这些工程师吐槽不尽呢,
[35:40.000 --> 35:41.000] 这个是怎么回事啊,
[35:41.000 --> 35:43.000] 这个事情也是说来话长吧,
[35:43.000 --> 35:46.000] 然后反正大概是08,09年的时候,
[35:46.000 --> 35:50.000] guido就是说我们要做python的第三代,
[35:50.000 --> 35:51.000] 第三个版本,
[35:51.000 --> 35:53.000] 因为python一开始是1.0嘛,
[35:53.000 --> 35:54.000] 然后1点几,
[35:54.000 --> 35:55.000] 然后后来是2点几,
[35:55.000 --> 35:57.000] 然后他那个时候说我们要做3点几,
[35:57.000 --> 35:59.000] 那这个升级当然没什么问题,
[35:59.000 --> 36:01.000] 因为你的版本号自然就是越来越大的,
[36:01.000 --> 36:06.000] 但是当时他的决定就是说python3是不兼容python2的,
[36:06.000 --> 36:12.000] 也就是说你的一个python3是不能直接执行python2的程序,
[36:12.000 --> 36:14.000] 就是刚才像他刚才说的,
[36:14.000 --> 36:16.000] 那么这个背景的话,
[36:16.000 --> 36:20.000] 我首先要表明我不是python的核心开发者,
[36:20.000 --> 36:22.000] 所以我知道的并不深入,
[36:22.000 --> 36:25.000] 但是我查到了一篇python核心开发者的文章,
[36:25.000 --> 36:27.000] 是叫做Brad Cannon这个人写的,
[36:28.000 --> 36:31.000] 他是一个相应python很长时间的核心开发者吧,
[36:31.000 --> 36:32.000] 然后是在微软,
[36:32.000 --> 36:36.000] 他就描述了一下说为什么说python3就不能兼容python2,
[36:36.000 --> 36:39.000] 它的主要原因就是就是unicode,
[36:39.000 --> 36:41.000] 这个确实就是刚才讲到的python,
[36:41.000 --> 36:43.000] 为什么说python也有历史包袱,
[36:43.000 --> 36:44.000] python是1989年发明的,
[36:44.000 --> 36:47.000] 当时还没有unicode的这个标准,
[36:47.000 --> 36:49.000] 就是说python的诞生是早于unicode的,
[36:49.000 --> 36:51.000] 所以python一开始,
[36:51.000 --> 36:54.000] 它里面并没有unicode这个概念,
[36:54.000 --> 36:58.000] unicode就是以一种字符串的一种编码标准,
[36:58.000 --> 37:00.000] 让全世界的语言都可以编进去是吧,
[37:00.000 --> 37:03.000] 就比如说你的那些表情,
[37:03.000 --> 37:05.000] 一个笑脸或者是一个哭脸,
[37:05.000 --> 37:06.000] 它都是unicode的一部分,
[37:06.000 --> 37:07.000] 这都是unicode的标准,
[37:07.000 --> 37:10.000] 它有一个码跟它对应,
[37:10.000 --> 37:12.000] 就unicode字符也是在越增越多,
[37:12.000 --> 37:16.000] 然后大家都把一些各国的一些像汉字,
[37:16.000 --> 37:19.000] 或者说是一些符号都在逐渐往里加,
[37:19.000 --> 37:21.000] 但是就相当于python一开始,
[37:21.000 --> 37:23.000] 它早于unicode诞生的,
[37:23.000 --> 37:25.000] 那么龟斗在创作这门语言的时候,
[37:25.000 --> 37:27.000] 他就没有考虑unicode的支持,
[37:27.000 --> 37:30.000] 那所以就是说导致了很多问题,
[37:30.000 --> 37:32.000] 比如说在python2版本里,
[37:32.000 --> 37:34.000] 它的字符串和整数其实是,
[37:34.000 --> 37:37.000] 其实它字符串和整数是一个概念,
[37:37.000 --> 37:39.000] 比如说你都是ASCII,
[37:39.000 --> 37:40.000] 就是字符嘛,
[37:40.000 --> 37:42.000] 就是我们二斤智嘛,
[37:42.000 --> 37:44.000] 一个字符是有256种嘛,
[37:44.000 --> 37:45.000] 对吧,
[37:45.000 --> 37:47.000] 我们从小学电脑是吧,
[37:47.000 --> 37:49.000] 就写A呀B呀C呀,
[37:49.000 --> 37:51.000] 那个就是ASCII字符对吧,
[37:51.000 --> 37:54.000] 对你可以理解为它就是支持的不完全,
[37:54.000 --> 37:56.000] 那比如说你在python的一段代码里,
[37:56.000 --> 37:58.000] 有个中文的字符串,
[37:58.000 --> 38:00.000] 那它默认就是不能够执行的,
[38:00.000 --> 38:02.000] 你需要去就是声明,
[38:02.000 --> 38:04.000] 然后或者说加一个,
[38:04.000 --> 38:06.000] 在那个字符串前面加一个U,
[38:06.000 --> 38:08.000] 我觉得我觉得够了呀,
[38:08.000 --> 38:10.000] 去识别这个有很多人也是觉得够了,
[38:10.000 --> 38:12.000] 但它其实会造成很多问题嘛,
[38:12.000 --> 38:15.000] 就是说这样就导致python里有两种字符串,
[38:15.000 --> 38:17.000] 那一种是unicode的字符串,
[38:17.000 --> 38:19.000] 一种是非unicode的字符串,
[38:19.000 --> 38:21.000] 它在使用过程中就造成了很多的问题,
[38:21.000 --> 38:25.000] 后来就guido和其他一些核心开发者看到说,
[38:25.000 --> 38:27.000] 这个unicode的支持造成了这么多问题,
[38:27.000 --> 38:29.000] 那我们就干脆推倒重新来吧,
[38:29.000 --> 38:31.000] 然后就所有东西都是,
[38:31.000 --> 38:33.000] 现在所有字符串都是unicode了,
[38:33.000 --> 38:35.000] 那现在还可以加B吗?
[38:35.000 --> 38:37.000] B是有的,
[38:37.000 --> 38:38.000] 这个东西又太tricky了,
[38:38.000 --> 38:42.000] B其实它就是原来的那种字符串,
[38:42.000 --> 38:43.000] 不不不,
[38:43.000 --> 38:45.000] 但它现在B那个它就不叫字符串了,
[38:45.000 --> 38:47.000] 那我也可以管unicode不叫字符串,
[38:47.000 --> 38:48.000] 对,
[38:48.000 --> 38:51.000] 但反正就是说他为什么觉得说没有办法,
[38:51.000 --> 38:56.000] 没有办法实现一个向前兼容的这种python3的原因,
[38:56.000 --> 38:57.000] 我也很难讲清,
[38:57.000 --> 39:00.000] 但就是说核心开发者和guido是这么觉得,
[39:00.000 --> 39:05.000] 他们觉得旧版本的python有不可修正的弱点,
[39:05.000 --> 39:08.000] 有无法弥补的这个问题,
[39:08.000 --> 39:10.000] 就相当于你一个楼的地基造歪了,
[39:10.000 --> 39:12.000] 你可能上面怎么修你都修不好,
[39:12.000 --> 39:16.000] 反正给我们程序员带来了无尽的灾难,
[39:16.000 --> 39:20.000] 我这个在python2到3这个运动之前,
[39:20.000 --> 39:24.000] 我们并没有意识到原来我们生活中有这么多python小粉,
[39:24.000 --> 39:25.000] 我还要提一句,
[39:25.000 --> 39:29.000] 就是为什么他们做出这个不兼容python2的决定,
[39:29.000 --> 39:32.000] 这个他在那篇文章里也说得很清楚,
[39:32.000 --> 39:37.000] 就是他们一开始低估了做这样一种转换的成本,
[39:37.000 --> 39:41.000] 就他们觉得说我们一宣布说3.0版本特别好,
[39:41.000 --> 39:45.000] 然后大家就马上把python2的代码全都抛弃掉,
[39:45.000 --> 39:46.000] 或者重写掉,
[39:46.000 --> 39:47.000] 就用上python3了,
[39:47.000 --> 39:48.000] 然后一下就完成了,
[39:48.000 --> 39:51.000] 但实际上这个过程花了10年还不止,
[39:51.000 --> 39:54.000] 就他们低估了legacy code,
[39:54.000 --> 39:56.000] 或者叫也不能叫legacy code吧,
[39:56.000 --> 39:59.000] 就是叫已经存在的代码去做转换的这样一种难度,
[39:59.000 --> 40:01.000] 那比如说你很简单一个例子,
[40:01.000 --> 40:04.000] 如果说做一件事情难度很低,
[40:04.000 --> 40:05.000] 那你可能就倾向于去做了,
[40:05.000 --> 40:08.000] 我如果说买张彩票100%会中奖,
[40:08.000 --> 40:09.000] 那你当然就会买了,
[40:09.000 --> 40:12.000] 但是你说那有一亿分之一才会中奖,
[40:12.000 --> 40:13.000] 你可能就不会买了,
[40:13.000 --> 40:18.000] 但如果说他们当年预估到了这种python2升级到python3的难度和耗时的话,
[40:18.000 --> 40:21.000] 可能也会重新去思考一下当年的决定,
[40:21.000 --> 40:23.000] 我们吐槽了这个,
[40:23.000 --> 40:26.000] 我们很少见的一个语言突然就不能用了,
[40:26.000 --> 40:27.000] 这么一种事儿,
[40:27.000 --> 40:30.000] 这个事是只发生在python身上吗?
[40:30.000 --> 40:34.000] 我在好奇就有没有其他的比较popular的语言发生过类似的事情呢?
[40:34.000 --> 40:37.000] 好像per6是不兼容per5吧,
[40:37.000 --> 40:38.000] 我也不知道,
[40:38.000 --> 40:39.000] 你连这都知道,
[40:39.000 --> 40:40.000] 挺厉害的,
[40:40.000 --> 40:42.000] 我好像确实没有太听说过,
[40:42.000 --> 40:46.000] 至少的主要语言好像没有太听说过有这样的事情啊,
[40:46.000 --> 40:47.000] 比较少,
[40:47.000 --> 40:48.000] 确实比较少,
[40:48.000 --> 40:50.000] JavaScript是另外一个极端,
[40:50.000 --> 40:52.000] 任何事情都要保证兼容,
[40:52.000 --> 40:53.000] 不兼容,
[40:53.000 --> 40:56.000] 你就会破坏掉已有的浏览器的功能,
[40:56.000 --> 40:58.000] 因为还有无数人跑老版本的浏览器,
[40:58.000 --> 40:59.000] 好,
[40:59.000 --> 41:02.000] 那我们还有没有什么好玩的事情没有说过的?
[41:02.000 --> 41:03.000] 我来插一句,
[41:03.000 --> 41:07.000] 就是python2到python3的这个转换现在已经是正式完成了,
[41:07.000 --> 41:11.000] 最后一个python2的版本是在今年的4月份发布了,
[41:11.000 --> 41:14.000] 然后补轴者说也是做了一期节目,
[41:14.000 --> 41:16.000] 就像告别python2迎接python3,
[41:16.000 --> 41:18.000] 有些节目大家可以去听一下,
[41:18.000 --> 41:20.000] 但是反正就是说从现在往后,
[41:20.000 --> 41:24.000] 大家其实就可以当做python2是一个不存在的,
[41:24.000 --> 41:25.000] 死掉的语言,
[41:25.000 --> 41:27.000] 就是过去的一段噩梦,
[41:27.000 --> 41:29.000] 然后就可以对就可以把它忘掉,
[41:29.000 --> 41:31.000] 如果一个人学python开始的话,
[41:31.000 --> 41:32.000] 那应该怎么开始呢?
[41:32.000 --> 41:35.000] 这个我觉得要不就不光我来聊了吧,
[41:35.000 --> 41:37.000] 然后大家都可以去讲讲,
[41:37.000 --> 41:39.000] 那反正对我来讲的话,
[41:39.000 --> 41:43.000] 因为我学python的时候就已经有新加加的编程基础了,
[41:43.000 --> 41:47.000] 所以我是从一个叫做codecademy的网站开始学的,
[41:47.000 --> 41:50.000] 然后他其实就是一个在线编程平台,
[41:50.000 --> 41:53.000] 他就他是就左边是教程教你python语法,
[41:53.000 --> 41:54.000] 然后右边是练习,
[41:54.000 --> 41:55.000] 你就在上面写,
[41:55.000 --> 41:57.000] 然后就写完就执行,
[41:57.000 --> 41:59.000] 如果你没有编程经验的话,
[41:59.000 --> 42:02.000] 我建议你可以听一听补轴者说的第一期,
[42:02.000 --> 42:04.000] 我们的古文播客又来了啊,
[42:04.000 --> 42:06.000] 打广告开始打广告,
[42:07.000 --> 42:10.000] 我们当时第一期就聊了一下新人需要什么,
[42:10.000 --> 42:13.000] 就是一个我们的新人就指的是编程初学者,
[42:13.000 --> 42:16.000] 那么我们当时不止聊了学python,
[42:16.000 --> 42:20.000] 就包括一个比较要更普遍的说编程怎么入本,
[42:20.000 --> 42:22.000] 可以去听一听我们当时那期节目,
[42:22.000 --> 42:23.000] 好,
[42:23.000 --> 42:24.000] 广告打完了,
[42:24.000 --> 42:26.000] 你们也都来聊一聊有什么推荐的书或者方法,
[42:26.000 --> 42:27.000] 没有啊,
[42:27.000 --> 42:28.000] 我没有正式学过python啊,
[42:28.000 --> 42:29.000] 就是google嘛,
[42:29.000 --> 42:30.000] google大学嘛,
[42:30.000 --> 42:35.000] 我可能也是直接看那个tutorial或什么之类的这种学的,
[42:35.000 --> 42:37.000] 就是没有正式学过,
[42:37.000 --> 42:38.000] 抄抄别人的代码,
[42:38.000 --> 42:39.000] 对,
[42:39.000 --> 42:40.000] 对,
[42:40.000 --> 42:41.000] 因为大学里都不教嘛,
[42:41.000 --> 42:42.000] 所以那个年代,
[42:42.000 --> 42:44.000] 我不知道现在教不教,
[42:44.000 --> 42:45.000] 至少我应该教了吧,
[42:45.000 --> 42:51.000] 我是属于说以前看过一下那个什么learn python in the hard way还是什么啊,
[42:51.000 --> 42:54.000] 但是那个时候看的时候又不需要用,
[42:54.000 --> 42:56.000] 你练过了也没有用啊,
[42:56.000 --> 42:57.000] 到你现在要用的时候,
[42:57.000 --> 42:58.000] 你又不记得了,
[42:58.000 --> 43:00.000] 其实python就属于那种,
[43:00.000 --> 43:02.000] 你如果想临时用一用,
[43:02.000 --> 43:03.000] 然后你看一下教程,
[43:03.000 --> 43:04.000] 然后10分钟你就能用了,
[43:04.000 --> 43:05.000] 对,
[43:05.000 --> 43:06.000] 对,
[43:06.000 --> 43:07.000] 对,
[43:07.000 --> 43:08.000] 但如果你没有实际需求,
[43:08.000 --> 43:09.000] 不停的用,
[43:09.000 --> 43:10.000] 然后你一会就忘掉了,
[43:10.000 --> 43:12.000] 尤其是我这种写大量javascript的,
[43:12.000 --> 43:15.000] 然后突然用一下python就总会掉各种坑里,
[43:15.000 --> 43:17.000] 例如说最近就掉坑里,
[43:17.000 --> 43:19.000] 发现要访问一个jsonkey,
[43:19.000 --> 43:22.000] 就忘记要检查这个key存不存在啊之类的,
[43:22.000 --> 43:24.000] 就是不需要检查啊,
[43:24.000 --> 43:25.000] 没有就undefined啊,
[43:25.000 --> 43:28.000] 这个是javascript的问题,
[43:29.000 --> 43:30.000] 哦,
[43:30.000 --> 43:32.000] 我想起来我之前python用的多的,
[43:32.000 --> 43:35.000] 有一段时间是那个找工作刷题的时候,
[43:35.000 --> 43:37.000] 就是我发现那个比较快,
[43:37.000 --> 43:38.000] 就是你刷leetcode,
[43:38.000 --> 43:39.000] 对吧,
[43:39.000 --> 43:40.000] python比较短嘛,
[43:40.000 --> 43:41.000] 写起来比较快,
[43:41.000 --> 43:43.000] 一开始我还是用西佳佳写的,
[43:43.000 --> 43:45.000] 然后有一次面试的时候,
[43:45.000 --> 43:46.000] 就是因为那个题,
[43:46.000 --> 43:49.000] 他的那个字符串什么的这种处理太多了,
[43:49.000 --> 43:51.000] 西佳佳写这个就巨啰嗦,
[43:51.000 --> 43:52.000] 字符串太多了,
[43:52.000 --> 43:53.000] 然后面完出来,
[43:53.000 --> 43:54.000] 对对对,
[43:54.000 --> 43:55.000] 面完出来,
[43:55.000 --> 43:57.000] 那个refer我的朋友就批评我说,
[43:57.000 --> 43:58.000] 你怎么不写python呢,
[43:58.000 --> 44:00.000] 然后我回去就只刷python了,
[44:00.000 --> 44:02.000] 变成一门面试语啊,
[44:02.000 --> 44:03.000] 对对对,
[44:03.000 --> 44:07.000] 我是开algotogether的这个算法刷题学组,
[44:07.000 --> 44:08.000] Kat的广告开始了,
[44:08.000 --> 44:09.000] 然后很搞笑,
[44:09.000 --> 44:14.000] 就是有一次我们在这个学习小组的上课的期间,
[44:14.000 --> 44:16.000] 准确来说是在模拟面试的期间,
[44:16.000 --> 44:20.000] 然后我们一个老师和一个学生就在模拟面试,
[44:20.000 --> 44:22.000] 然后其他学生就在聊天窗口聊天,
[44:22.000 --> 44:23.000] 我说哇,
[44:23.000 --> 44:24.000] 这个写得好复杂啊,
[44:24.000 --> 44:26.000] 就在马上就有人回复了一句,
[44:26.000 --> 44:29.000] Life is short, use python,
[44:29.000 --> 44:30.000] 对,
[44:30.000 --> 44:31.000] 这句还挺经典的,
[44:31.000 --> 44:32.000] 对对,
[44:32.000 --> 44:34.000] 这个也是python的一个经典的口号,
[44:34.000 --> 44:35.000] 对,
[44:35.000 --> 44:37.000] 因为就是python写代码写的比较短,
[44:37.000 --> 44:38.000] 比较优雅,
[44:38.000 --> 44:39.000] 然后你就节省了你很多时间,
[44:39.000 --> 44:40.000] 所以life is short, use python,
[44:40.000 --> 44:41.000] 我有一件这个衣服,
[44:41.000 --> 44:42.000] 对,
[44:42.000 --> 44:44.000] 它上面就是写的life is short, use python,
[44:44.000 --> 44:46.000] 并且这个是有官方的中文翻译的,
[44:46.000 --> 44:47.000] 就叫人生苦短,
[44:47.000 --> 44:48.000] 我用python,
[44:48.000 --> 44:52.000] 这是那个python社区里面一个很著名的人叫大妈翻译的,
[44:52.000 --> 44:56.000] 我当时面google也是用python刷题,
[44:56.000 --> 44:57.000] 用python面试,
[44:57.000 --> 45:00.000] 我还专门问了一下hr能不能用python,
[45:00.000 --> 45:01.000] 然后她说可以,
[45:01.000 --> 45:02.000] 那还有什么想的就用python,
[45:02.000 --> 45:05.000] 自从用了之后就再也不用别的语言做面试题了,
[45:07.000 --> 45:12.000] 我们说了这种就是初学或者说是完全初学编程用python,
[45:12.000 --> 45:14.000] 要听我们补舌者说对吧,
[45:14.000 --> 45:18.000] 我们这些已经有编程基础的工程师偶尔用python,
[45:18.000 --> 45:21.000] 就是用这个code academy这个网站是吧,
[45:21.000 --> 45:25.000] 那么如果说你要成为一个优秀的专业python程序员呢,
[45:25.000 --> 45:26.000] 有没有什么推荐呢?
[45:26.000 --> 45:29.000] 其实python的书籍和学习的网站真的有特别多,
[45:29.000 --> 45:32.000] 就是大家也不用局限于就我们刚才提到的,
[45:32.000 --> 45:35.000] 这个现在网上资源真的真的太多了,
[45:35.000 --> 45:39.000] 包括python它官方是有一个学习文档tutorial的,
[45:39.000 --> 45:40.000] 就它官方就有,
[45:40.000 --> 45:42.000] 然后你去python的官网上,
[45:42.000 --> 45:44.000] 它就有教你怎么怎么学python,
[45:44.000 --> 45:45.000] 怎么安装,
[45:45.000 --> 45:46.000] 就它写很细,
[45:46.000 --> 45:48.000] 这个教程是很不错的,
[45:48.000 --> 45:50.000] 进阶的话其实可以推荐两本书吧,
[45:50.000 --> 45:52.000] 第一本叫做Fluent Python,
[45:52.000 --> 45:55.000] 中文是叫做流畅的python,
[45:55.000 --> 45:58.000] 然后它是一个巴西人叫Luciano写的,
[45:58.000 --> 46:01.000] 那么这本书不光是在python领域很有名,
[46:01.000 --> 46:06.000] 它经常在各种编程书籍的排行榜上都是排名前茅的,
[46:06.000 --> 46:07.000] 就它写得非常好,
[46:07.000 --> 46:09.000] 叫流畅的python,
[46:09.000 --> 46:10.000] 有官方中文翻译,
[46:10.000 --> 46:11.000] 翻译质量怎么样我不知道,
[46:11.000 --> 46:13.000] 但是大家可以去了解一下,
[46:13.000 --> 46:15.000] 这个对这个人我是见过的,
[46:15.000 --> 46:16.000] 我还去我还上过他的课,
[46:16.000 --> 46:17.000] 在那开con的时候,
[46:17.000 --> 46:19.000] 当然是官方提供的票,
[46:19.000 --> 46:20.000] 我就免费去了,
[46:20.000 --> 46:23.000] 另外一本书是叫做python cookbook,
[46:23.000 --> 46:27.000] 就是很多书它可能都有一个什么什么语言cookbook嘛,
[46:27.000 --> 46:28.000] 那cookbook的意思就是说,
[46:28.000 --> 46:32.000] 它相当于提供了一些很短的这种代码,
[46:32.000 --> 46:35.000] 然后能让你马上用去解决某一个任务的,
[46:35.000 --> 46:37.000] 比如说你说我要去做一个什么什么事,
[46:37.000 --> 46:38.000] 然后你就去这本书一查,
[46:38.000 --> 46:40.000] 它就有一段代码能解决你这个问题,
[46:40.000 --> 46:41.000] 然后就抄过来就好了,
[46:41.000 --> 46:43.000] 这个书也是很不错的,
[46:43.000 --> 46:44.000] 对python cookbook,
[46:44.000 --> 46:45.000] 中文版也教这个,
[46:45.000 --> 46:46.000] 再补充一点,
[46:46.000 --> 46:48.000] 就是刚才提到pycon嘛,
[46:48.000 --> 46:52.000] 就是pycon是一个python conference的简称,
[46:52.000 --> 46:54.000] 就像很多其他的语言一样,
[46:54.000 --> 46:56.000] python也是有一个这种大会的,
[46:56.000 --> 46:59.000] pycon其实在全世界各个国家它都有办,
[46:59.000 --> 47:01.000] 像中国有自己的pycon,
[47:01.000 --> 47:04.000] 然后但是最大的就是每年会在美国办的,
[47:04.000 --> 47:05.000] 就是pycon US,
[47:05.000 --> 47:09.000] 然后这个它的每年的视频都是在youtube上可以找到的,
[47:09.000 --> 47:13.000] 然后我当时学习的时候也是看了很多这个视频,
[47:13.000 --> 47:15.000] 我觉得它是比较适合于你有一定基础,
[47:15.000 --> 47:18.000] 然后想深入了解某一个主题的时候,
[47:18.000 --> 47:20.000] 可以去搜一搜这种pycon的视频,
[47:20.000 --> 47:22.000] 所以说如果有pycon的粉丝啊,
[47:22.000 --> 47:25.000] 可以到youtube视频上去看一下pycon,
[47:25.000 --> 47:27.000] con就是conference,
[47:27.000 --> 47:28.000] 会议的意思是吧,
[47:28.000 --> 47:29.000] pycon,
[47:29.000 --> 47:32.000] 然后去看一下他们视频,
[47:32.000 --> 47:34.000] 可以朝拜一下大佬们,
[47:34.000 --> 47:37.000] 再讲一讲这个语言的前世今生啊,
[47:37.000 --> 47:42.000] 是不是也可以看到我们的这个like9M在上面的这个英姿飒爽的样子吗?
[47:43.000 --> 47:45.000] 我在中国pycon演讲过两次吧,
[47:45.000 --> 47:47.000] 但是很可惜都没有留下来视频,
[47:47.000 --> 47:49.000] 美国这边我只是去参会还没有讲过,
[47:49.000 --> 47:51.000] 所以看以后有没有机会吧,
[47:51.000 --> 47:52.000] 哎呀,
[47:52.000 --> 47:54.000] 中国这个摄像机不行啊,
[47:54.000 --> 47:55.000] 没有留下视频呢,
[47:55.000 --> 47:57.000] 其实我觉得也挺好,
[47:57.000 --> 47:59.000] 就我还是挺不想在网上留影的,
[47:59.000 --> 48:01.000] 所以如果以后真的有机会演讲,
[48:01.000 --> 48:02.000] 我还打算戴个面具,
[48:02.000 --> 48:05.000] 你想好面具上面画什么了吗?
[48:05.000 --> 48:08.000] 实在不行就拿个什么蝙蝠侠的面具吧,
[48:08.000 --> 48:10.000] 有这样的presenter吗?
[48:10.000 --> 48:12.000] 我有点好奇,
[48:12.000 --> 48:13.000] 没有这样的presenter,
[48:13.000 --> 48:15.000] 那可能戴个墨镜,
[48:15.000 --> 48:18.000] 现在可以直接用deepfake换个脸就可以了,
[48:20.000 --> 48:25.000] 今天我们就感谢我们的这个python中文社区的活跃啊,
[48:25.000 --> 48:27.000] 核心人员啊,
[48:27.000 --> 48:29.000] like9M来到我们的节目,
[48:29.000 --> 48:33.000] 我们的串台的节目向我们介绍了一些python的常识啊,
[48:33.000 --> 48:36.000] python是第一语言啊,
[48:36.000 --> 48:38.000] 这个用量第一,
[48:38.000 --> 48:40.000] 初学的第一语言啊,
[48:40.000 --> 48:42.000] 上德厅堂下德厨房的AI语言,
[48:42.000 --> 48:44.000] 互联网语言啊,
[48:44.000 --> 48:45.000] 它的历史,
[48:45.000 --> 48:47.000] 关于性能的吐槽,
[48:47.000 --> 48:49.000] 还有它未来发展的方向,
[48:49.000 --> 48:51.000] 以至于推荐大家学习的材料,
[48:51.000 --> 48:56.000] 那我们今天要不要就感谢我们的like9M来到我们节目,
[48:56.000 --> 48:58.000] 给我们带来精彩的内容,
[48:58.000 --> 49:02.000] 我也特别感谢斯加特来邀请我来牛肉锅烤面包做客,
[49:02.000 --> 49:05.000] 反正如果大家想深入了解一下python的主题,
[49:05.000 --> 49:07.000] 还是欢迎前往补舌者说,
[49:07.000 --> 49:09.000] 对对对,一定要听一听补舌者说,
[49:09.000 --> 49:10.000] 这个节目很好听,
[49:10.000 --> 49:11.000] 不仅仅有python的内容,
[49:11.000 --> 49:13.000] 还有这个职场的内容啊,
[49:13.000 --> 49:15.000] 并且讲的非常的细啊,
[49:15.000 --> 49:17.000] 就是我听了他们这期节目讲,
[49:17.000 --> 49:20.000] 如果被这个technique欺负怎么办,
[49:20.000 --> 49:22.000] 都给你非常好的答案啊,
[49:22.000 --> 49:25.000] 好吧,总之内容非常的丰富啊,
[49:25.000 --> 49:26.000] 如果喜欢我们节目,
[49:26.000 --> 49:30.000] 欢迎去各大泛用型播客平台啊,
[49:30.000 --> 49:32.000] 来订阅牛肉锅烤面包,
[49:32.000 --> 49:34.000] 以及补舌者说,
[49:34.000 --> 49:36.000] 如果想订阅牛肉锅烤面包,
[49:36.000 --> 49:37.000] 还可以去喜马拉雅,
[49:37.000 --> 49:40.000] 好,那我们就后会有期,
[49:40.000 --> 49:44.000] 拜拜,拜拜,拜拜,拜拜,