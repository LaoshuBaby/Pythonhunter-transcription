[00:00.000 --> 00:14.000] 【5期】
[00:14.000 --> 00:17.000] 大家好,欢迎收听捕蛇者说第五期
[00:17.000 --> 00:20.000] 这一期我们会和大家聊聊今年PyCon的两个视频
[00:20.000 --> 00:23.000] 第一个是Mocking & Patching Pitfalls
[00:23.000 --> 00:25.000] 关于Mocking的一些最佳实践
[00:25.000 --> 00:28.000] 第二个视频是关于PyP57-2的介绍
[00:28.000 --> 00:32.000] 视频的链接在上期节目和本期节目中贴出
[00:32.000 --> 00:35.000] 希望您在继续收听之前已经看过这两个视频
[00:35.000 --> 00:52.000] 【5期】
[00:52.000 --> 00:54.000] OK,Mocking & Patching Pitfalls
[00:54.000 --> 00:57.000] 这个视频其实主要讲的是
[00:57.000 --> 01:00.000] 你在测试里面为什么要Mock
[01:00.000 --> 01:02.000] 怎么Mock,然后Mock和Patch
[01:02.000 --> 01:06.000] 就是你从不同的阶段去Mock
[01:06.000 --> 01:08.000] 比如说你可以Mock一个函数
[01:08.000 --> 01:13.000] 你也可以Mock这个函数里面用到的一个Socket
[01:13.000 --> 01:16.000] 这样,甚至你可以不Mock
[01:16.000 --> 01:19.000] 你直接在测试环境里面搭建一个DB
[01:21.000 --> 01:24.000] 然后把DB里面放上测试用的数据
[01:24.000 --> 01:25.000] 这样
[01:26.000 --> 01:28.000] 然后就介绍了一些
[01:28.000 --> 01:32.000] 在写Mock的时候的痛点
[01:32.000 --> 01:33.000] 然后
[01:35.000 --> 01:39.000] 在什么情况下这个测试会拖慢效率
[01:39.000 --> 01:41.000] 然后变得不可维护
[01:41.000 --> 01:44.000] 以及那个讲师的一些经验吧
[01:44.000 --> 01:48.000] 对,然后我其实第一年工作的时候
[01:48.000 --> 01:49.000] 基本上都在写爬虫嘛
[01:49.000 --> 01:52.000] 因为爬虫的代码里面有很多网络请求
[01:52.000 --> 01:55.000] 我们是把这些网络请求都给Mock掉
[01:55.000 --> 01:58.000] 所以基本上你写一个爬虫
[01:58.000 --> 01:59.000] 你就要写一个测试
[01:59.000 --> 02:01.000] 然后测试里面肯定会有一个Mock
[02:02.000 --> 02:05.000] 我当时是就写了很多的Mock
[02:05.000 --> 02:09.000] 就是用的是就是那个标准库的那个Mock吗
[02:12.000 --> 02:13.000] 其实都有
[02:13.000 --> 02:15.000] 就是你去写Mock的时候
[02:15.000 --> 02:16.000] 你会发现
[02:18.000 --> 02:20.000] 你用标准库里面的那个Mock
[02:20.000 --> 02:22.000] 你可以解决所有的问题
[02:22.000 --> 02:25.000] 但是它肯定不是最好的
[02:25.000 --> 02:27.000] 比如说你用HTTP Mock
[02:27.000 --> 02:30.000] 你可能三行代码就可以写出来一个
[02:30.000 --> 02:33.000] 你用那个标准库里面的生成测试代码呀
[02:33.000 --> 02:35.000] Mock的那个目标
[02:35.000 --> 02:37.000] 这样可能要写一图
[02:37.000 --> 02:39.000] HTTP Mock的话
[02:39.000 --> 02:41.000] 其实也是基于标准库Mock
[02:41.000 --> 02:43.000] 然后进行封装
[02:43.000 --> 02:46.000] 但是它提供了一些很方便的东西
[02:46.000 --> 02:49.000] 就很多你就不用来回去写那些
[02:49.000 --> 02:54.000] 就是衣服URL等于什么什么什么那些东西
[02:54.000 --> 02:55.000] 比较方便
[02:56.000 --> 02:58.000] 对就是借口封装了吧
[02:58.000 --> 03:00.000] 我有一个好奇的点啊
[03:00.000 --> 03:02.000] 信涛就是听起来
[03:02.000 --> 03:05.000] 你们是把这个HTTP请求给Mock了对吧
[03:06.000 --> 03:09.000] 对那最重要的不就是那个HTTP请求吗
[03:09.000 --> 03:13.000] 那你们Mock之后主要的测试是关注哪一点
[03:13.000 --> 03:14.000] 哪一个方面呢
[03:15.000 --> 03:18.000] 对这是一个很经典的问题
[03:18.000 --> 03:21.000] 是一个就是我们讨论过的问题
[03:21.000 --> 03:24.000] 其实一开始我们的写的帕虫里面
[03:24.000 --> 03:26.000] 没有Mock所有的HTTP请求
[03:26.000 --> 03:27.000] 就导致
[03:28.000 --> 03:31.000] 首先你跑一次测试你发现速度很慢
[03:31.000 --> 03:32.000] 就要发HTTP请求
[03:32.000 --> 03:36.000] 第二你每跑一次测试都对外面你要抓的网站
[03:36.000 --> 03:38.000] 造成了一次HTTP请求
[03:38.000 --> 03:40.000] 然后第三他们的网站在变
[03:40.000 --> 03:42.000] 他们的网站如果变了
[03:42.000 --> 03:46.000] 你只知道你你这个帕虫处理完的assert是什么
[03:46.000 --> 03:50.000] 比如说发布日期等于等于什么
[03:50.000 --> 03:52.000] 但是它变了的话
[03:52.000 --> 03:54.000] 你就不知道它原来是什么了
[03:54.000 --> 03:58.000] 所以就想想还有没有其他问题
[03:58.000 --> 03:59.000] 应该就这些问题吧
[03:59.000 --> 04:02.000] 所以你如果Mock掉的话
[04:02.000 --> 04:05.000] 你会把外面网站的那个预期的
[04:05.000 --> 04:08.000] 预期的response你写到你的代码里面去
[04:08.000 --> 04:10.000] 假如它变了的话
[04:10.000 --> 04:12.000] 你就可以看一下你预期的response是什么
[04:12.000 --> 04:15.000] 看网站的现在的response是什么
[04:15.000 --> 04:17.000] 你就知道它哪部分变了
[04:17.000 --> 04:18.000] 然后你就可以去修改你的代码
[04:18.000 --> 04:20.000] 但是将带来的问题就是
[04:20.000 --> 04:21.000] 如果你不Mock的话
[04:21.000 --> 04:23.000] 它网站变了你测试就挂了对吧
[04:23.000 --> 04:25.000] 这样的话就知道它变了
[04:25.000 --> 04:28.000] 但是如果你Mock掉的话
[04:28.000 --> 04:32.000] 你知道你知道如果这个帕虫挂了
[04:32.000 --> 04:33.000] 这不是你的问题
[04:33.000 --> 04:34.000] 这肯定是外面的网站变了
[04:34.000 --> 04:36.000] 但是它变了你怎么知道呢
[04:36.000 --> 04:41.000] 可能要通过一些监控来发现了
[04:41.000 --> 04:45.000] 就是数据增量的监控或者一些其他监控
[04:45.000 --> 04:48.000] 你看这个网站好久没有抓到新数据了
[04:48.000 --> 04:49.000] 你回去看一下
[04:49.000 --> 04:52.000] 我的建议是这种情况
[04:52.000 --> 04:54.000] 你Mock还是需要的
[04:54.000 --> 04:57.000] 但是你Mock的同时需要对于真实
[04:57.000 --> 04:59.000] 就是你需要另外一套测试
[04:59.000 --> 05:01.000] 是针对真实的网页的
[05:01.000 --> 05:03.000] 就比如说你Mock下来有个页面
[05:03.000 --> 05:05.000] 你会抓就是你
[05:05.000 --> 05:07.000] 你有一个Mock的测试
[05:07.000 --> 05:09.000] 去详细测的某一个页面的
[05:09.000 --> 05:11.000] 上面很多属性的抓取
[05:11.000 --> 05:13.000] 然后你另外一个真实的测试
[05:13.000 --> 05:15.000] 你去抓那个真实的网页
[05:15.000 --> 05:18.000] 但是你只去advert一些
[05:18.000 --> 05:20.000] 就比如说一个标题是不是存在
[05:20.000 --> 05:24.000] 或者是就类似于这种很简单的一些
[05:24.000 --> 05:26.000] 类似于smoke test之类的东西
[05:26.000 --> 05:28.000] 然后我就把这两个结合起来
[05:28.000 --> 05:30.000] 可能会解决这个问题
[05:30.000 --> 05:34.000] 这实际上就是这种
[05:34.000 --> 05:36.000] 你说的这种测试其实意义不是很大
[05:36.000 --> 05:39.000] 因为你因为那个太多了
[05:39.000 --> 05:40.000] 如果你写的话
[05:40.000 --> 05:41.000] 第一个是需要时间吗
[05:41.000 --> 05:42.000] 就你想象一下
[05:42.000 --> 05:44.000] 假如说你要去抓1000个网站
[05:44.000 --> 05:46.000] 你有一千多个把程需要维护
[05:46.000 --> 05:48.000] 如果通过监控的话
[05:48.000 --> 05:50.000] 你如果每天去看一次
[05:50.000 --> 05:52.000] 然后有两个网站
[05:52.000 --> 05:54.000] 今天没有新增任何数据
[05:54.000 --> 05:56.000] 你去看一眼就可以了
[05:56.000 --> 05:58.000] 就是通过监控成本会比较低
[05:58.000 --> 06:00.000] OK监控也是一种办法吧
[06:00.000 --> 06:01.000] 我觉得
[06:01.000 --> 06:04.000] 然后其余带来的好处就是
[06:04.000 --> 06:07.000] 你的CI会非常稳定
[06:07.000 --> 06:09.000] 就不会出现第一次跑CI挂了
[06:09.000 --> 06:10.000] 然后你要重跑一次
[06:10.000 --> 06:11.000] 然后又一些挂了
[06:11.000 --> 06:12.000] 然后你再重跑一次
[06:12.000 --> 06:14.000] 所有的都过了这种情况
[06:14.000 --> 06:16.000] 然后测试的速度会非常快
[06:16.000 --> 06:18.000] 之前我们因为请求嘛
[06:18.000 --> 06:20.000] 就请求外部的http
[06:20.000 --> 06:21.000] 你没法保证速度
[06:21.000 --> 06:23.000] 但是你mock之后
[06:23.000 --> 06:24.000] 刷一下就跑完了
[06:24.000 --> 06:26.000] 那我比较好奇
[06:26.000 --> 06:28.000] 那你们对这个mock之后的预期
[06:28.000 --> 06:30.000] 是各有不同的对吗
[06:30.000 --> 06:32.000] 就是做不同爬虫测试的时候
[06:32.000 --> 06:35.000] 预期的response是返回不一致的
[06:35.000 --> 06:36.000] 是的
[06:36.000 --> 06:38.000] 这个其实是写测试工作比较大的一个地方
[06:38.000 --> 06:39.000] 比较头疼
[06:39.000 --> 06:41.000] 就是你要去搞
[06:41.000 --> 06:44.000] 就搞下来这个网站的response
[06:44.000 --> 06:47.000] 然后把它写到预期的response里面
[06:47.000 --> 06:49.000] 就从http层面
[06:49.000 --> 06:51.000] 把这个response给mock掉
[06:51.000 --> 06:53.000] 就不是不会去mock函数的
[06:53.000 --> 06:56.000] 然后其实这些mock的代码
[06:56.000 --> 06:59.000] 就是一个比较大的痛点
[06:59.000 --> 07:01.000] 就是这个过程非常有重复性
[07:01.000 --> 07:03.000] 你去搞下来这个response
[07:03.000 --> 07:05.000] 然后你写一个代码
[07:05.000 --> 07:07.000] 替换掉这个url的response
[07:07.000 --> 07:08.000] 这样
[07:08.000 --> 07:10.000] 这个其实我尝试过很多方法
[07:10.000 --> 07:13.000] 最后也没有找到过一个比较合适的
[07:13.000 --> 07:15.000] 然后最后我的解决方案是
[07:15.000 --> 07:18.000] 我写了一个生成测试代码的一个东西
[07:18.000 --> 07:21.000] 就是可以自动的把response抓下来
[07:21.000 --> 07:25.000] 然后用这些response生成一个mock的代码
[07:25.000 --> 07:27.000] 然后把这个代码这样贴到代码库里面去
[07:27.000 --> 07:29.000] 嗯,我就肯定需要这种的
[07:29.000 --> 07:32.000] 我其实还是有刚才那个疑问
[07:32.000 --> 07:35.000] 就是你的这个测试什么情况下会失败
[07:35.000 --> 07:37.000] 什么情况下会失败
[07:37.000 --> 07:39.000] 就是你爬上改了会失败
[07:39.000 --> 07:41.000] 比如说你处理的逻辑
[07:41.000 --> 07:45.000] 一开始你想取的是这个数据
[07:45.000 --> 07:49.000] 比如说你改了一个处理时间的格式
[07:49.000 --> 07:50.000] 比如说你把一个库
[07:50.000 --> 07:52.000] 你把处理时间的库
[07:52.000 --> 07:56.000] 从url换到了另一个库
[07:56.000 --> 07:59.000] 然后你可以看一下这个测试有没有挂
[07:59.000 --> 08:01.000] 然后后面爬重重构的时候
[08:01.000 --> 08:03.000] 也是一个比较好的
[08:03.000 --> 08:05.000] 但是其实大多数情况下你不改它
[08:05.000 --> 08:06.000] 它就不会挂
[08:06.000 --> 08:08.000] 我对于我们这边的话
[08:08.000 --> 08:10.000] 我自己常常写的话
[08:10.000 --> 08:13.000] 我自己更倾向于是要做mock
[08:13.000 --> 08:15.000] 但是更倾向于是在内存中
[08:15.000 --> 08:17.000] 起一个mock的httpserver来做
[08:17.000 --> 08:19.000] 就像是家环里面有一个
[08:19.000 --> 08:21.000] 针对于http client的库
[08:21.000 --> 08:23.000] 它其实相对来说
[08:23.000 --> 08:25.000] 就是相当于说是在内存里面
[08:25.000 --> 08:27.000] 起了一个server来做这件事情
[08:27.000 --> 08:30.000] 就不单纯的是把它给mock掉
[08:30.000 --> 08:34.000] 然后还是让它实际上存在一个IO的一个交互
[08:34.000 --> 08:36.000] 那个talk里面提到的
[08:36.000 --> 08:38.000] 就是它是比较倾
[08:38.000 --> 08:42.000] 就是用fake把mock替代掉这种思路
[08:42.000 --> 08:43.000] 对我自己也倾向于
[08:43.000 --> 08:45.000] 特别是像涉及到一些db
[08:45.000 --> 08:46.000] 或者是其他东西
[08:46.000 --> 08:52.000] 还是更倾向于去做一些内存的server来做
[08:52.000 --> 08:54.000] 就是我是这么想的
[08:54.000 --> 08:56.000] 就是你越往后去mock
[08:56.000 --> 08:59.000] 比如说我这个项目依赖到了redis
[08:59.000 --> 09:00.000] 或者是依赖到db
[09:00.000 --> 09:04.000] 那我就在ci的环境里面起来一个redis
[09:04.000 --> 09:06.000] 专门为ci服务
[09:06.000 --> 09:08.000] 就是越往后可能模拟的情况越真实
[09:08.000 --> 09:10.000] 但是越往前的话
[09:10.000 --> 09:12.000] 就是我通过这个函数来mock
[09:12.000 --> 09:14.000] 这个测试就会越稳定
[09:14.000 --> 09:17.000] 但是测试稳定并不是你的目的
[09:17.000 --> 09:18.000] 对吧
[09:18.000 --> 09:20.000] 你的测试目的是为了发现问题
[09:20.000 --> 09:23.000] 所以说测试稳定没有意义
[09:23.000 --> 09:25.000] 对其实fake的形式
[09:25.000 --> 09:28.000] 确实会比mock更容易暴露一些问题吧
[09:28.000 --> 09:30.000] 因为他只是说
[09:30.000 --> 09:33.000] 把最后面的那一步给替换掉了
[09:33.000 --> 09:34.000] 但是相应的
[09:34.000 --> 09:37.000] 其实它的实现成本会高一些
[09:37.000 --> 09:38.000] 对因为你毕竟mock
[09:38.000 --> 09:41.000] 你在上层你就拿到了自己的预期
[09:41.000 --> 09:43.000] 就是其实你并不关心你的
[09:43.000 --> 09:46.000] 这个依赖的内部运行是如何的
[09:46.000 --> 09:48.000] 你总是假设它能给你一个预期返回
[09:48.000 --> 09:50.000] 然后你来测自己的主流
[09:50.000 --> 09:53.000] 主逻辑对但是fake这种形式
[09:53.000 --> 09:57.000] 就是我是把我依赖的一个组件的
[09:57.000 --> 10:00.000] 最下层的依赖给替换掉
[10:00.000 --> 10:02.000] 是的你想你想
[10:02.000 --> 10:03.000] 就是假如说你写了
[10:03.000 --> 10:04.000] 你改了一点点代码
[10:04.000 --> 10:06.000] 然后你的测试挂了
[10:06.000 --> 10:09.000] 假如说你是在很前面mock掉
[10:09.000 --> 10:12.000] 你是mock掉一个测试里面的一个函数的话
[10:12.000 --> 10:14.000] 你就很快可以看到这个函数
[10:14.000 --> 10:15.000] 预期的返回是什么
[10:15.000 --> 10:17.000] 我这个改动为什么造成的
[10:17.000 --> 10:20.000] 假如说你用后往后面的mock
[10:20.000 --> 10:21.000] 你去mock数据库的话
[10:21.000 --> 10:23.000] 那你这个调试起来可能就比较麻烦
[10:23.000 --> 10:27.000] 你要看数据库里面实际的数据是什么样子的
[10:27.000 --> 10:28.000] 在哪个地方改了
[10:28.000 --> 10:30.000] 让调试的成本可能会高一点
[10:30.000 --> 10:32.000] 为啥我我没懂
[10:32.000 --> 10:34.000] 但是你数据库的那些fake的data
[10:34.000 --> 10:36.000] 不是你自己设置的吗
[10:36.000 --> 10:39.000] 就是而且一般一个比如说一个
[10:39.000 --> 10:41.000] 不管是内存还是怎么样
[10:41.000 --> 10:43.000] 就是你一个fake的implementation
[10:43.000 --> 10:45.000] 它就会给你一个假设
[10:45.000 --> 10:47.000] 就是你一个fake的implementation
[10:47.000 --> 10:48.000] 它应该是非常简单的
[10:48.000 --> 10:51.000] 就没有任何复杂逻辑的一种实现
[10:51.000 --> 10:54.000] 所以我并不知道它为什么会调试比较难
[10:54.000 --> 10:59.000] 这个数据库其实我们我经历过的项目
[10:59.000 --> 11:02.000] 基本上都是用的fake的数据库这种
[11:02.000 --> 11:07.000] 它复杂在就是假如说你的om里面用很多外件
[11:07.000 --> 11:09.000] 那你假如说你要构建一条测试数据的话
[11:09.000 --> 11:13.000] 你可能要把很多相关的
[11:13.000 --> 11:15.000] 就是跟你测试无关
[11:15.000 --> 11:18.000] 但是跟这个数据的外件相关的一些数据给插入进去
[11:18.000 --> 11:21.000] 我觉得还是分要分层来看吧
[11:21.000 --> 11:24.000] 就是如果是比如说你在写一个model
[11:24.000 --> 11:27.000] 或者DAO它在执行一个真正的
[11:27.000 --> 11:29.000] SQL的query查询
[11:29.000 --> 11:34.000] 那我理解你就不应该mock掉你的mySQL driver
[11:34.000 --> 11:37.000] 或者你的这个存储的一个driver
[11:37.000 --> 11:40.000] 去连真正的数据库这一步你是不能省略的
[11:40.000 --> 11:43.000] 对
[11:43.000 --> 11:46.000] 但是如果在更高层的时候
[11:46.000 --> 11:48.000] 你是可以选择的
[11:48.000 --> 11:53.000] 虽然我个人很推荐说你真的要连到数据库上跑一下
[11:53.000 --> 11:55.000] 我其实还挺欣赏于这样的
[11:55.000 --> 11:56.000] 但是对HTTP来说
[11:56.000 --> 12:01.000] 我觉得肯定还是说你直接mock掉这个HTTP client
[12:01.000 --> 12:05.000] 比你自己搞一个fake server要简单一些
[12:05.000 --> 12:09.000] 我觉得可能目前来看还是要看
[12:09.000 --> 12:11.000] 依赖你选择什么库吧
[12:11.000 --> 12:14.000] 像我自己还是倾向于就说是
[12:14.000 --> 12:17.000] 要去做那个
[12:17.000 --> 12:22.000] 我想想还是最好的可能说是要去做一个HTTP server的一个东西
[12:22.000 --> 12:23.000] 因为是这样
[12:23.000 --> 12:25.000] 因为你一个HTTP的话
[12:25.000 --> 12:27.000] 你还是要存在很多的信息
[12:27.000 --> 12:29.000] 就比如说headers
[12:29.000 --> 12:32.000] 然后headers里面有一些关键字段的设置
[12:32.000 --> 12:34.000] 比如说content type
[12:34.000 --> 12:37.000] 或者说是有一些公司会把一个
[12:37.000 --> 12:40.000] 比如说会把一些token加入在header里面
[12:40.000 --> 12:42.000] 用一些字段来表示
[12:42.000 --> 12:43.000] 这种情况下
[12:43.000 --> 12:44.000] 你单纯去mock的话
[12:44.000 --> 12:46.000] 就说mock的话
[12:46.000 --> 12:50.000] 有些时候会忽略这里面就潜在的server端的一些逻辑
[12:50.000 --> 12:53.000] 然后的话我建议还是就再看情况吧
[12:53.000 --> 12:57.000] 有些时候可能还说是在内存里面去起个HTTP server
[12:57.000 --> 12:59.000] 可能还是比较合适的
[12:59.000 --> 13:03.000] 你这个内存的HTTP server应该是指自己开发的
[13:03.000 --> 13:04.000] 对吧
[13:04.000 --> 13:06.000] 它是有周边库给提供的
[13:06.000 --> 13:09.000] 不是我是指说它内部的核心逻辑
[13:09.000 --> 13:10.000] 所以你create another
[13:10.000 --> 13:11.000] 你再做一个
[13:11.000 --> 13:13.000] 虽然很简单
[13:13.000 --> 13:14.000] 对
[13:14.000 --> 13:15.000] 但是你可以简单的
[13:15.000 --> 13:16.000] 用它就是一套的
[13:16.000 --> 13:19.000] 比如说你指定header是什么的情况下
[13:19.000 --> 13:22.000] 然后就是你在这个server里面去指定
[13:22.000 --> 13:24.000] header什么情况下是正确的
[13:24.000 --> 13:25.000] 或者说其他的
[13:25.000 --> 13:27.000] 然后你就可以去mock到这个header
[13:27.000 --> 13:30.000] 它这个请求是不是真正的发送了
[13:30.000 --> 13:31.000] 或者其他的
[13:31.000 --> 13:32.000] 我理解
[13:32.000 --> 13:35.000] 比如说如果你在做一个web server开发的话
[13:35.000 --> 13:37.000] 你测试自己的web server
[13:37.000 --> 13:39.000] 一般会选用这种方式
[13:39.000 --> 13:41.000] 就起一个内存上的server
[13:41.000 --> 13:43.000] 然后测试都是真的发请求
[13:43.000 --> 13:45.000] 然后达到自己的开发上
[13:45.000 --> 13:47.000] 然后拿到完整responsible测试
[13:47.000 --> 13:50.000] 但是我觉得信号的那种情况
[13:50.000 --> 13:53.000] 如果写一个fake server可能会麻烦一些
[13:53.000 --> 13:54.000] 对
[13:54.000 --> 13:56.000] 而且还有一种情况是
[13:56.000 --> 13:59.000] 你如果是用就是说是强烈型的语言
[13:59.000 --> 14:03.000] 就比如说像是HTTP client
[14:03.000 --> 14:05.000] 就是像Java这种
[14:05.000 --> 14:07.000] 或者说像golang这种东西
[14:07.000 --> 14:08.000] 你不太好mock的
[14:08.000 --> 14:10.000] 你想说是静态类型的
[14:10.000 --> 14:11.000] 对静态类型的
[14:11.000 --> 14:12.000] 对静态类型的
[14:12.000 --> 14:14.000] 就是说是静态类型的语言
[14:14.000 --> 14:15.000] 然后你不太
[14:15.000 --> 14:17.000] 即便你是做依赖注入
[14:17.000 --> 14:20.000] 你即便是做那个依赖注入的话
[14:20.000 --> 14:22.000] 也是一个并不太好去测试
[14:22.000 --> 14:24.000] 就是说是去mock的点
[14:24.000 --> 14:25.000] 所以说这种情况
[14:25.000 --> 14:27.000] 可能有些时候起一个HTTP server
[14:27.000 --> 14:29.000] 可能还是一个内存里面起一个server
[14:29.000 --> 14:31.000] 可能还是一个比较更合适的选择
[14:31.000 --> 14:33.000] 不过其实像golang
[14:33.000 --> 14:36.000] golang其实也可以做monkey patch
[14:36.000 --> 14:39.000] 只是说你要在
[14:39.000 --> 14:41.000] 只能在测试层面使用
[14:41.000 --> 14:45.000] 千万不要把monkey patch搞到生产环境
[14:45.000 --> 14:47.000] 但是代价太大了嘛
[14:47.000 --> 14:48.000] 对其实像Java也是一样
[14:48.000 --> 14:49.000] 然后的话这块东西
[14:49.000 --> 14:51.000] 其实本质上就是我们说
[14:51.000 --> 14:54.000] mock的话其实是尽可能少的侵入
[14:54.000 --> 14:55.000] 但是像静态语言
[14:55.000 --> 14:57.000] 对这块侵入还是很大的
[14:57.000 --> 14:59.000] Java也能mock吗
[14:59.000 --> 15:02.000] 就是像python那种mock可以做到吗
[15:02.000 --> 15:03.000] 是可以的
[15:03.000 --> 15:07.000] 是在编译器可以做这件事情的
[15:07.000 --> 15:10.000] Java有个东西叫做numbook
[15:10.000 --> 15:11.000] numbook的话
[15:11.000 --> 15:13.000] 他就是说是比如说你在一个lay上面
[15:13.000 --> 15:14.000] 对不对
[15:14.000 --> 15:15.000] 加了一个getter和setter的
[15:15.000 --> 15:17.000] 就是说annotation注解
[15:17.000 --> 15:18.000] 然后他在编
[15:18.000 --> 15:21.000] 他通过那个插件的形式在编译器
[15:21.000 --> 15:23.000] 就会在你这个lay生成的时候
[15:23.000 --> 15:26.000] 给你注入getter和setter方法
[15:26.000 --> 15:28.000] 然后对应的话就是mock的时候
[15:28.000 --> 15:30.000] 你可以通过一些annotation
[15:30.000 --> 15:31.000] 或者是其他一些手段
[15:31.000 --> 15:33.000] 然后去通过配合插件
[15:33.000 --> 15:36.000] 然后在编译器的时候去给你做那个
[15:36.000 --> 15:39.000] 就直接在测试环节给你做替换了
[15:39.000 --> 15:40.000] 就是Java其实有
[15:40.000 --> 15:42.000] 我用过一个Java的mock的库
[15:42.000 --> 15:45.000] 叫mock2好像
[15:45.000 --> 15:47.000] 这个就是我写Java也不多
[15:47.000 --> 15:49.000] 但是我用这个
[15:49.000 --> 15:51.000] 我觉得比python的mock要好用的很多
[15:51.000 --> 15:53.000] 就是他这个mock特别
[15:53.000 --> 15:54.000] 特别简单
[15:54.000 --> 15:55.000] 就你写一行
[15:55.000 --> 15:58.000] 问然后你把这个函数传进去
[15:58.000 --> 16:00.000] 然后这个函数其实是个调用
[16:00.000 --> 16:02.000] 他那个参数你可以
[16:02.000 --> 16:04.000] 写一些这个库里面的
[16:04.000 --> 16:05.000] 比如说any
[16:05.000 --> 16:08.000] 然后这个问后面点
[16:08.000 --> 16:10.000] 点问return就可以
[16:10.000 --> 16:12.000] mock调这个函数的返回值
[16:12.000 --> 16:13.000] 不知道他怎么实现的
[16:13.000 --> 16:15.000] 但是这个使用很有好
[16:15.000 --> 16:16.000] 我觉得
[16:16.000 --> 16:19.000] 对但是他其实也是应该就是
[16:19.000 --> 16:20.000] 在编译器做了一些手脚
[16:20.000 --> 16:22.000] 但是这个地方就存在一个问题
[16:22.000 --> 16:24.000] 就是说是他那个东西
[16:24.000 --> 16:26.000] 就是说是你要mock是没问题的
[16:26.000 --> 16:28.000] 但是你要前提是你的
[16:28.000 --> 16:30.000] 就是说是设置的合理
[16:30.000 --> 16:32.000] 像python那种
[16:32.000 --> 16:33.000] 像python那种
[16:33.000 --> 16:34.000] 我直接去mock某一个method
[16:34.000 --> 16:36.000] 就是你import的某一个值
[16:36.000 --> 16:38.000] 然后import后的某一个值
[16:38.000 --> 16:40.000] 就是某一个具体的内存中的某一个变量
[16:40.000 --> 16:43.000] 这种东西在Java里面还是相对困难
[16:43.000 --> 16:43.000] 对
[16:43.000 --> 16:46.000] 我觉得python这个其实他是一个双刃剑吧
[16:46.000 --> 16:51.000] 就是说一方面他能够去真正mock一个import的东西
[16:51.000 --> 16:53.000] 就是包括很深层的import
[16:53.000 --> 16:55.000] 是让你很多东西测试
[16:55.000 --> 16:56.000] 写起来方便了很多
[16:56.000 --> 17:00.000] 但另一方面他有会有一些比较tricky的bug
[17:00.000 --> 17:01.000] 对我觉得的话
[17:01.000 --> 17:03.000] 反正我觉得看这种看场景吧
[17:03.000 --> 17:07.000] 我自己更期待于是倾向于说是通过合理的代码
[17:07.000 --> 17:10.000] 然后可以说适当时候可以做mock
[17:10.000 --> 17:13.000] 但是更多时候可能就更倾向于说是去用一个
[17:13.000 --> 17:16.000] 内存中的server来模拟这些东西
[17:16.000 --> 17:19.000] 其实感觉manjusaka你提到这个
[17:19.000 --> 17:21.000] 就是他那个talk里讲的
[17:21.000 --> 17:23.000] 他talk里就说
[17:23.000 --> 17:28.000] 如果你发现你写了很多测试里写了很多mock的话
[17:28.000 --> 17:32.000] 实际上可能说明你的代码就是写的并不是特别好
[17:32.000 --> 17:36.000] 对我对其实其实有些时候你其实是把控制权
[17:36.000 --> 17:38.000] 就说是设计
[17:38.000 --> 17:41.000] 就说是其实你本质上也是在用那个设计模式那一套
[17:41.000 --> 17:44.000] 就说是比如说像控制反转这一套东西
[17:44.000 --> 17:46.000] 但是你其实本质上你用mock
[17:46.000 --> 17:48.000] 只是将就是说你的注入
[17:48.000 --> 17:51.000] 就说是注入这一套东西就给mock来做了
[17:51.000 --> 17:55.000] 就说是把风险转移到另外一个第三方的库上面去了
[17:55.000 --> 17:59.000] 就我觉得我现在就是我平时写C++比较多嘛
[17:59.000 --> 18:02.000] 然后可能跟java差不多就有些时候发现
[18:02.000 --> 18:07.000] 就比如说你为了让test能够正常的test
[18:07.000 --> 18:11.000] 然后我还需要专门为一个class创建一个interface
[18:11.000 --> 18:14.000] 就虽然我知道并不会有任何人用那个interface
[18:14.000 --> 18:16.000] 但是我还是要弄一个interface
[18:16.000 --> 18:19.000] 因为为了让我的test能跑起来
[18:19.000 --> 18:21.000] 我就觉得
[18:21.000 --> 18:23.000] 对,孤浪也是这个样子
[18:23.000 --> 18:26.000] 我是特别讨厌这种为了测试去写代码
[18:26.000 --> 18:28.000] 或者去改代码这种问题
[18:28.000 --> 18:30.000] 我觉得
[18:30.000 --> 18:35.000] 对,就是其实你本来可以确认它的范围
[18:35.000 --> 18:37.000] 就只有这一个场景
[18:37.000 --> 18:40.000] 但是因为测试你要给它单独抽象一个interface
[18:40.000 --> 18:42.000] 你就知道这个interface只有一套实现
[18:42.000 --> 18:44.000] 就是你刚才那套实现
[18:44.000 --> 18:46.000] 然后它只是为了测试服务
[18:46.000 --> 18:48.000] 然后你就会觉得特别麻烦
[18:48.000 --> 18:50.000] 对,而且我觉得有些时候很恶心的是
[18:50.000 --> 18:53.000] 有些时候比如说你在使用第三方库的时候
[18:53.000 --> 18:58.000] 然后第三方库它是它默认的使用的interface
[18:58.000 --> 19:01.000] 它并不就是说是实现了interface
[19:01.000 --> 19:05.000] 然后你还要对应的去裹一层interface来做
[19:05.000 --> 19:08.000] 这个事情在golang反而是很正常的事情
[19:08.000 --> 19:11.000] 对,我觉得可能是因为我们写python写的比较多
[19:11.000 --> 19:15.000] 对,我最开始来写golang的时候
[19:15.000 --> 19:17.000] 我觉得写测试简直不习惯
[19:17.000 --> 19:18.000] 所以我就觉得
[19:18.000 --> 19:22.000] 我现在觉得python提升开发效率的很大一点
[19:22.000 --> 19:25.000] 就是说它测试写起来比较自然
[19:25.000 --> 19:27.000] 你不需要为了测试去break
[19:27.000 --> 19:29.000] 或者修改你原来的实现
[19:29.000 --> 19:32.000] 就是就觉得是有这样一个优势的
[19:32.000 --> 19:34.000] 对,但是我觉得它带来的副作用就是说
[19:34.000 --> 19:36.000] 是有些时候你太有
[19:36.000 --> 19:38.000] 就是说是写起来太爽了
[19:38.000 --> 19:40.000] 有些时候你代码写一写就很恶心
[19:40.000 --> 19:42.000] 就是写出来代码就恶心
[19:42.000 --> 19:43.000] 对,有可能会这样
[19:43.000 --> 19:45.000] 但是是是有
[19:45.000 --> 19:47.000] 但是总体上来而言
[19:47.000 --> 19:50.000] 我觉得它还是还是好处多于坏处吧
[19:50.000 --> 19:52.000] 对,我觉得是
[19:52.000 --> 19:54.000] 对,就是说它相对来说这一块
[19:54.000 --> 19:56.000] 用起来还是很爽的
[19:56.000 --> 20:00.000] 所以说假如说可以不因为测试改代码的话
[20:00.000 --> 20:06.000] 你们觉得需不需要因为测试更换画面去修改代码
[20:06.000 --> 20:09.000] 假如说你代码本来是不需要重构的
[20:09.000 --> 20:13.000] 我觉得的话其实我觉得还是有必要的
[20:13.000 --> 20:15.000] 因为说实话你在测试的时候
[20:15.000 --> 20:18.000] 其实某种意义上来说是在就
[20:18.000 --> 20:22.000] 其实就已经是在对外使用了
[20:22.000 --> 20:24.000] 但是这个外的话就是说可能就是说
[20:24.000 --> 20:26.000] 并不说是我们说是外部什么的
[20:26.000 --> 20:27.000] 其实也是在对外使用
[20:27.000 --> 20:29.000] 如果说你在测试的时候
[20:29.000 --> 20:33.000] 发现你写的有些代码并不方便于你测试的话
[20:33.000 --> 20:35.000] 我觉得这个东西其实是有问题的
[20:35.000 --> 20:37.000] 我觉得可能需要去考虑一下
[20:37.000 --> 20:39.000] 这个东西是怎么样去处理
[20:39.000 --> 20:41.000] 我觉得看情况吧
[20:41.000 --> 20:43.000] 这个不是之前有一种说法吗
[20:43.000 --> 20:47.000] 就是如果你的写的代码不易于测试
[20:47.000 --> 20:50.000] 那也就意味着你的代码是存在问题的
[20:50.000 --> 20:53.000] 当然我觉得这个是过于绝对了
[20:53.000 --> 20:57.000] 对但是我觉得可能对于很多情况下
[20:57.000 --> 21:00.000] 这种东西还是有一定的用处的
[21:00.000 --> 21:01.000] 对我觉得是这样
[21:01.000 --> 21:05.000] 但是你们有没有见到过这样的代码
[21:05.000 --> 21:08.000] 就是你看这个代码你不知道他为什么这么写
[21:08.000 --> 21:10.000] 你根本就不知道他为什么
[21:10.000 --> 21:13.000] 这个事情完全不需要抽象出来一个函数
[21:13.000 --> 21:14.000] 但是他写成一个函数
[21:14.000 --> 21:16.000] 然后你看到测试的时候
[21:16.000 --> 21:19.000] 你发现他这样是为了单独去测试这个东西
[21:19.000 --> 21:21.000] 是有这种情况的
[21:21.000 --> 21:23.000] 是有这种对我觉得是有的
[21:23.000 --> 21:25.000] 所以我觉得就是要分情况看
[21:25.000 --> 21:28.000] 就比如说新涛说这种情况和之前我说那种
[21:28.000 --> 21:31.000] 就是为了测试而加的一个interface
[21:31.000 --> 21:33.000] 其实如果能避免的话
[21:33.000 --> 21:34.000] 我当然是希望避免的
[21:34.000 --> 21:37.000] 但是你像就类似于依赖注入这种
[21:37.000 --> 21:40.000] 在外面create一个object
[21:40.000 --> 21:43.000] 这种我觉得其实是当然他就是他也方便的测试
[21:43.000 --> 21:47.000] 然后实际上这样写也是就是更好的一种设计
[21:47.000 --> 21:49.000] 我觉得还是要分情况来看
[21:49.000 --> 21:50.000] 但是怎么说呢
[21:50.000 --> 21:52.000] 就比如说依赖注入这个事情
[21:52.000 --> 21:55.000] 如果说他也只有一种使用方式
[21:55.000 --> 21:56.000] 对吧
[21:56.000 --> 22:00.000] 那其实在我看来也是一个过度设计
[22:00.000 --> 22:03.000] 就是但是其实就是为了你像测试的一个妥协
[22:03.000 --> 22:05.000] 因为你不这么搞
[22:05.000 --> 22:07.000] 你不注入你就没法测试
[22:07.000 --> 22:09.000] 我觉得可能还是看情况吧
[22:09.000 --> 22:13.000] 就至少依赖注入没有任何就是坏处带给你
[22:13.000 --> 22:16.000] 我觉得就是一个就两种情况差不多
[22:16.000 --> 22:18.000] 只是麻烦一点
[22:18.000 --> 22:20.000] 没有明显的损害
[22:20.000 --> 22:21.000] 虽然只是麻烦一点
[22:21.000 --> 22:28.000] 对我其实还想之前就是Adam也提到测试mySQL
[22:28.000 --> 22:30.000] 然后我最近其实也有遇到一个bug
[22:30.000 --> 22:32.000] 就跟你说那个特别像
[22:32.000 --> 22:36.000] 就是我我是有一段有一个函数
[22:36.000 --> 22:38.000] 他大概就是从执行一段SQL
[22:38.000 --> 22:41.000] 然后从spender里面拿一些数据
[22:41.000 --> 22:43.000] 然后我在测试的时候呢
[22:43.000 --> 22:53.000] 我是直接就是就我用了一个假的算是mark的spender server吧
[22:53.000 --> 22:55.000] 然后他并不会真正去执行那段SQL
[22:55.000 --> 23:02.000] 而只是就是你靠一下那个就是get数据
[23:02.000 --> 23:04.000] 然后他就会给你返回一些你提前设定好的数据
[23:04.000 --> 23:06.000] 然后就出现一个问题
[23:06.000 --> 23:08.000] 就是说我其实写那段SQL是有问题的
[23:08.000 --> 23:10.000] 但是我就没有测出来
[23:10.000 --> 23:12.000] 就是还是挺重要
[23:12.000 --> 23:15.000] 我其实有一些小的经验总结吧
[23:15.000 --> 23:21.000] 就是因为我更多的开发的就是和这种数据绑定的一些应用
[23:21.000 --> 23:26.000] 对会大量的使用Method call Redis这种
[23:26.000 --> 23:30.000] 我其实倾向于对于数据存储不去做Mock
[23:30.000 --> 23:33.000] 对然后倾向于使用真实的场景
[23:33.000 --> 23:38.000] 因为你不确认说你发送的执行指令是否是正确的
[23:38.000 --> 23:40.000] 这个一定要是经过测试的
[23:40.000 --> 23:45.000] 对然后然后又因为我处于一个微服务环境下
[23:45.000 --> 23:48.000] 那针对所有的微服务的这种外部调用
[23:48.000 --> 23:51.000] 其实都要先做一个默认的stops
[23:51.000 --> 23:54.000] 就是他要有一些默认返回
[23:54.000 --> 24:02.000] 对然后如果我的业务逻辑中真的会和这个外部调用相关
[24:02.000 --> 24:04.000] 比如说我这次就想走分之A
[24:04.000 --> 24:06.000] 下次想走分之B
[24:06.000 --> 24:09.000] 那我再把这个条件的这个地方去Mock掉
[24:09.000 --> 24:10.000] 然后做Patch
[24:10.000 --> 24:13.000] 我可以手动控制说走哪个流程
[24:13.000 --> 24:18.000] 对就是其实在不同的地方还是要有不同的应用的
[24:18.000 --> 24:23.000] 就很难说像视频里说我们尽量的去削减Patch
[24:23.000 --> 24:25.000] 改用Fake
[24:25.000 --> 24:30.000] 对其实Fake和Patch中间还有stops这一步
[24:30.000 --> 24:36.000] 对其实确实有不同的这种应用的层面来满足不同的测试需求
[24:36.000 --> 24:44.000] 他对他那个视频也提到了就是几种他叫test double之类的一些区别吧
[24:44.000 --> 24:47.000] 这个最早应该是在Martin Fowler的博客里提到的吧
[24:47.000 --> 24:51.000] 我看到他那个和那篇博客真的好像
[24:51.000 --> 24:53.000] 就是讲什么是Mock
[24:53.000 --> 24:55.000] 什么是Dummy
[24:55.000 --> 24:57.000] 什么是Stop那个是吗
[24:57.000 --> 25:00.000] 是吧我其实不是很清楚他来源
[25:00.000 --> 25:03.000] 但可能对我说那个PyCon里这个视频
[25:03.000 --> 25:05.000] 我印象中也是是讲的这个
[25:05.000 --> 25:07.000] 对他有一个那个图
[25:07.000 --> 25:10.000] 反正反正我现在理解就是说
[25:10.000 --> 25:12.000] 其实test double有几种吗
[25:12.000 --> 25:15.000] 最我们最常说的就是Mock了
[25:15.000 --> 25:21.000] Mock我觉得就是他其实是Stop加上一些Assertion
[25:21.000 --> 25:27.000] 然后就是Stop其实就是你设定一个东西
[25:27.000 --> 25:31.000] 比如说你call他或者给他发送一个请求
[25:31.000 --> 25:33.000] 他的返回值应该是什么
[25:33.000 --> 25:37.000] 然后你设定的返回值加上你一些Assertion语句
[25:37.000 --> 25:39.000] 就比如说他要被call几次
[25:39.000 --> 25:41.000] 然后就构成了一个Mock
[25:41.000 --> 25:42.000] 然后我觉得是这样子
[25:42.000 --> 25:44.000] 就是这两个关系
[25:44.000 --> 25:45.000] 然后Fake的话
[25:45.000 --> 25:48.000] 其实他就是一个简单的implementation
[25:48.000 --> 25:51.000] 就你可以当你可以就是什么都不干
[25:51.000 --> 25:54.000] 但他还是有一个就是一样接口
[25:54.000 --> 25:59.000] 并且并不是就是并且并不需要你提供
[25:59.000 --> 26:01.000] 就是设定返回值的一个东西
[26:01.000 --> 26:03.000] 对我觉得差不多是这样子
[26:03.000 --> 26:04.000] 反正我觉得吧
[26:04.000 --> 26:06.000] 测试这个东西的话
[26:06.000 --> 26:09.000] 我自己觉得Mock这种侵入式的东西
[26:09.000 --> 26:12.000] 还是尽可能的会需要少一些
[26:12.000 --> 26:13.000] 要慎重
[26:13.000 --> 26:16.000] 因为可能会带来其他不必要的东西麻烦
[26:16.000 --> 26:19.000] 所以Adam你之前测那些SQL的时候
[26:19.000 --> 26:21.000] 你都会有一个专门的数据库
[26:21.000 --> 26:24.000] 就是每次清空然后起起来
[26:24.000 --> 26:26.000] 然后塞些数据进去是吗
[26:26.000 --> 26:27.000] 这样子来测
[26:27.000 --> 26:29.000] 对就是其实
[26:29.000 --> 26:32.000] 你的测试数据也是测试的一部分
[26:32.000 --> 26:37.000] 对就是其实首先你会每次真的起一个测试的Method
[26:37.000 --> 26:39.000] Method server
[26:39.000 --> 26:42.000] 对然后当然这个我们当时做了一个封装
[26:42.000 --> 26:46.000] 就每次新建一个完全不一样的Database
[26:46.000 --> 26:54.000] 对然后把你预知的所有的Schema给创建出对应的表
[26:54.000 --> 26:56.000] 然后还有一步是叫做Fixture
[26:56.000 --> 27:01.000] 就是其实你的测试下也会预知一些测试数据
[27:01.000 --> 27:03.000] 就对应表里要预填一些数据
[27:03.000 --> 27:05.000] 对一旦完成了这个
[27:05.000 --> 27:07.000] 你就有一个完整的测试环境
[27:07.000 --> 27:09.000] 你可以真的去Select
[27:09.000 --> 27:11.000] 真的去Create
[27:11.000 --> 27:12.000] 真的去删除
[27:12.000 --> 27:15.000] 对那其实就会方便很多
[27:15.000 --> 27:18.000] 就是其实听起来这也像是一个Fix server
[27:18.000 --> 27:20.000] 但是它其实是一个完整的实现了
[27:20.000 --> 27:22.000] 完整的一个Method server实现
[27:22.000 --> 27:24.000] 对连接到你最后一步
[27:24.000 --> 27:26.000] 对来替换掉你生产环境
[27:26.000 --> 27:29.000] 或者替换掉你原来想要Mock的那个地方
[27:29.000 --> 27:31.000] 我自己的话就经常的时间
[27:31.000 --> 27:34.000] 其实我自己会就是说是在测试的时候
[27:34.000 --> 27:36.000] 我本机上并不会跑测试
[27:36.000 --> 27:38.000] 我自己更喜欢用Docker Compose
[27:38.000 --> 27:41.000] 然后加然后把依赖齐起来
[27:41.000 --> 27:43.000] 然后直接在环境里面做
[27:43.000 --> 27:44.000] 就是真实的DB和Raid
[27:44.000 --> 27:47.000] 比如说像DB像RaidS这样的测试
[27:47.000 --> 27:49.000] 因为这些存储
[27:49.000 --> 27:52.000] 其实他们有很多各自的行为
[27:52.000 --> 27:56.000] 对你一定要真实的让自己的所谓的这个命令
[27:56.000 --> 27:57.000] 发送过去
[27:57.000 --> 27:59.000] 看能不能不能正常的执行
[27:59.000 --> 28:01.000] 这步一定要在测试做的
[28:01.000 --> 28:04.000] 对不然的话你很难说
[28:04.000 --> 28:07.000] 你能拿到你想要的结果
[28:07.000 --> 28:10.000] 对反正我自己的话就对于DB这块
[28:10.000 --> 28:14.000] 我就是更习惯就是说是先用一个Docker
[28:14.000 --> 28:18.000] 然后用然后把它依赖给就是说是这
[28:18.000 --> 28:22.000] 然后对应的就做当然这样的
[28:22.000 --> 28:25.000] 这样的坏处就是他测试会跑的稍微慢一点
[28:25.000 --> 28:27.000] 但是我觉得也是必要的
[28:27.000 --> 28:29.000] 对但是我觉得是可以接受的
[28:29.000 --> 28:31.000] 我觉得这方面我们的意见是统一的
[28:31.000 --> 28:33.000] 对于潜入数据这部分
[28:33.000 --> 28:36.000] 你将过的OM有一个库叫Factory Boy
[28:36.000 --> 28:40.000] 它可以根据你OM的类来自动生成一些数据
[28:40.000 --> 28:43.000] 比如说你有一个Book类
[28:43.000 --> 28:45.000] 有一个外界是Author
[28:45.000 --> 28:48.000] 然后Author也是一张表里面有作者的信息
[28:48.000 --> 28:51.000] 但是你要测试的只是Book的一个
[28:51.000 --> 28:55.000] 比如说发布日期这么一个属性
[28:55.000 --> 28:59.000] 然后你就用Factory Boy来产生一个这个类
[28:59.000 --> 29:02.000] 然后你只指定这个属性就可以了
[29:02.000 --> 29:05.000] 其他的像外界相关联的表的数据
[29:05.000 --> 29:07.000] 它都可以给你自动生成
[29:07.000 --> 29:10.000] 这个这样填充数据就很方便
[29:10.000 --> 29:14.000] 然后每次都是随机的
[29:14.000 --> 29:16.000] 就是你无关的数据它每次都是随机的
[29:16.000 --> 29:18.000] 这样测到的面也比较广
[29:18.000 --> 29:22.000] 我有个小问题
[29:22.000 --> 29:25.000] 就是因为我这边
[29:25.000 --> 29:27.000] 比如说我刚才说的预填数据
[29:27.000 --> 29:28.000] 其实都是有预期的
[29:28.000 --> 29:30.000] 就是我自己构造好的数据
[29:30.000 --> 29:31.000] 如果是随机的话
[29:31.000 --> 29:34.000] 那你怎么知道哪些case被测到了
[29:34.000 --> 29:37.000] 我觉得它那些随机的数据是它不care的数据
[29:37.000 --> 29:38.000] 是的
[29:38.000 --> 29:42.000] 就是你如果要测发布日期或者测zoo的这个数据
[29:42.000 --> 29:46.000] 你要手动就是你创建factory boy类的时候
[29:46.000 --> 29:50.000] 你要指定你想要哪些数据是什么样子的
[29:50.000 --> 29:52.000] 其余的它都可以自动给你
[29:52.000 --> 29:53.000] 你就可以不用关心了
[29:53.000 --> 29:54.000] 那还挺方便
[29:54.000 --> 29:56.000] 就是类似于对就比如说它那个owser一些
[29:56.000 --> 29:59.000] 就是owser那张表你并不需要测
[29:59.000 --> 30:01.000] 但是你需要有那样一个
[30:01.000 --> 30:02.000] 一个owser在那里
[30:02.000 --> 30:05.000] 对所以就是我觉得挺好的
[30:05.000 --> 30:07.000] 对主要是外界很烦
[30:07.000 --> 30:09.000] 然后它可以自动生成就很好
[30:09.000 --> 30:13.000] ok我觉得我们那个mock这个也聊差不多了
[30:13.000 --> 30:41.000] 让我们进入下一个视频
[30:41.000 --> 30:43.000] 好的那我们现在聊一聊
[30:43.000 --> 30:47.000] 然后传说中臭名昭著也不叫臭名昭著吧
[30:47.000 --> 30:50.000] 那就说是影响非常大的PP52
[30:50.000 --> 30:53.000] ok这个我来介绍一下吧
[30:53.000 --> 30:58.000] 然后Pipe572就是
[30:58.000 --> 31:02.000] 就是这个应该从哪里开始介绍的
[31:02.000 --> 31:06.000] 就这个东西是一个pipe
[31:06.000 --> 31:10.000] 我们是不是我们以前我们以前介绍过pipe是什么
[31:10.000 --> 31:13.000] 好像没有吧就当我们没介绍过吧
[31:13.000 --> 31:18.000] 然后那个pipe的全称是python enhancement proposal
[31:18.000 --> 31:21.000] 它意思就是说
[31:21.000 --> 31:25.000] 比如说你想给python去增加一个什么功能
[31:25.000 --> 31:27.000] 就举个例子来说
[31:27.000 --> 31:28.000] 你想把gill给去掉
[31:28.000 --> 31:32.000] 那么一般的流程就是说你要去提出一个pipe
[31:32.000 --> 31:35.000] 然后就是它相当于就是一个设计文档
[31:35.000 --> 31:36.000] 简单说
[31:36.000 --> 31:39.000] 然后你把这个东西发出去
[31:39.000 --> 31:41.000] 然后会有人来review
[31:41.000 --> 31:47.000] 然后如果说那些就是能够具有投票权的人
[31:47.000 --> 31:50.000] 就是说他愿意接收你这个pipe的话
[31:50.000 --> 31:54.000] 那么你就可以进入到下一个python的版本里面
[31:54.000 --> 31:59.000] 它就是一个python来实现新功能的这样一套流程吧
[31:59.000 --> 32:00.000] 简单说就是
[32:00.000 --> 32:01.000] 然后具体补充一下
[32:01.000 --> 32:03.000] 这个东西它并不一定是python新功能
[32:03.000 --> 32:07.000] python社区的治理也会由pipe来决定
[32:07.000 --> 32:09.000] 举个例子
[32:09.000 --> 32:12.000] gill不是因为572卸任了BDFL对吧
[32:12.000 --> 32:16.000] 然后的话后续就说是社区怎么样去治理
[32:16.000 --> 32:17.000] 也是通过pipe来做的
[32:17.000 --> 32:21.000] 就后续的PEP8xxxx然后来做
[32:21.000 --> 32:23.000] 然后最近有一个提案叫做
[32:23.000 --> 32:25.000] 就刚才我在上一期节目里面
[32:25.000 --> 32:28.000] 已经提到过有个东西叫做PEP571
[32:28.000 --> 32:29.000] 然后pipe581
[32:29.000 --> 32:33.000] 581的话是说将python的那个bugs系统
[32:33.000 --> 32:36.000] 它现在是自建的bugspython.org
[32:36.000 --> 32:39.000] 给迁移到用使用github的issue上面
[32:39.000 --> 32:41.000] 也是通过pipe来提出
[32:41.000 --> 32:42.000] 然后投票
[32:42.000 --> 32:44.000] 然后落地的
[32:44.000 --> 32:45.000] 对对对对
[32:45.000 --> 32:46.000] 不光是新功能
[32:46.000 --> 32:48.000] 就包括一些社区的这种也是
[32:48.000 --> 32:49.000] 对然后
[32:51.000 --> 32:53.000] 对然后572这个为什么有名呢
[32:53.000 --> 32:57.000] 就是就572加的这个功能只是很小一部分
[32:57.000 --> 32:58.000] 然后我们之后会聊
[32:58.000 --> 33:04.000] 但是他但是他彻底改变了python的governance model
[33:04.000 --> 33:08.000] 就是说改变了python社区的就是是怎么运作的
[33:08.000 --> 33:10.000] 呃那就是原来python社区嘛
[33:10.000 --> 33:12.000] 大家都知道BDFL
[33:12.000 --> 33:15.000] 然后Griddle是这个人次独裁者
[33:15.000 --> 33:21.000] 就是说他他有权决定你你你这个pipe要接受或者不接受
[33:21.000 --> 33:23.000] 或者是其他一些重大决定
[33:23.000 --> 33:25.000] 加某个功能或者不加某个功能
[33:25.000 --> 33:26.000] 这样子
[33:26.000 --> 33:32.000] 然后当然他有会有一些呃就是他的合作伙伴叫做BDFL delegates
[33:32.000 --> 33:34.000] 呃就相当于Griddle授权
[33:34.000 --> 33:40.000] 他们说他们也有这种呃也有这个就是决策的权利
[33:40.000 --> 33:46.000] 但是呢呃就是pipe572是Griddle呃他自己就是希望加进来的嘛
[33:46.000 --> 33:48.000] 当然也有其他几个其他几个人
[33:48.000 --> 33:55.000] 嗯然后但是他把这个pipe就是加进来这个过程中
[33:55.000 --> 33:57.000] 他遇到很多反对的声音
[33:57.000 --> 33:59.000] 就社区里有很多人不喜欢这个pipe
[33:59.000 --> 34:01.000] 那么最后导致了一个事情呢
[34:01.000 --> 34:05.000] 就是说Griddle在pipe572被接收之后
[34:05.000 --> 34:08.000] 就是他相当于是力排众议接受了这个pipe
[34:08.000 --> 34:11.000] 但他最后弄完这些事情之后
[34:11.000 --> 34:12.000] 他就表示心累了
[34:12.000 --> 34:14.000] 然后不想再当BDFL了
[34:14.000 --> 34:16.000] 所以就有一个很著名的事情
[34:16.000 --> 34:21.000] 就是说Griddle退出了呃终身独裁者这个决策
[34:21.000 --> 34:24.000] 然后就是成为了一个他还是core developer
[34:24.000 --> 34:29.000] 但是就不再担任这样一个就是决策的决策者了
[34:29.000 --> 34:33.000] 对然后这个某种意义上来说是导致了
[34:33.000 --> 34:35.000] 那个Python社区的一次分裂
[34:35.000 --> 34:38.000] 我觉得分裂也不能这么讲吧
[34:38.000 --> 34:41.000] 就是说其实以前也有人讨论过
[34:41.000 --> 34:44.000] 就是说因为Griddle毕竟不可能永生嘛
[34:44.000 --> 34:48.000] 就是就是呃权力交换这件事情迟早是要发生的
[34:48.000 --> 34:52.000] 但相当于现在这个事情就是把这个过程
[34:52.000 --> 34:55.000] 可能提前了十年或者二十年
[34:55.000 --> 34:58.000] 就是大家没有想到会在这个时间点发生
[34:58.000 --> 34:59.000] 但他就是发生了
[34:59.000 --> 35:07.000] 对嗯然后所以现在的Python的那个决策方式是叫那个steering console是吧
[35:07.000 --> 35:11.000] 呃总之他就是有一个好像是五个人的委员会
[35:11.000 --> 35:13.000] 然后这五个人的委员会呢
[35:13.000 --> 35:17.000] 是投就是所有核心开发者投票投出来的
[35:17.000 --> 35:21.000] 然后他的任期应该是一个Python大版本还是一年
[35:21.000 --> 35:23.000] 我也不是特别确定
[35:23.000 --> 35:25.000] 反正他就是说有一定的任期
[35:25.000 --> 35:30.000] 然后任期到之后会投投票选出来下一届的steering console
[35:30.000 --> 35:34.000] 然后就相当于这五个人代替了以前Griddle的
[35:34.000 --> 35:36.000] 呃这样一个位置
[35:36.000 --> 35:40.000] 那我们就聊一下这个Python572到底是说什么吧
[35:40.000 --> 35:45.000] 572他的那个官方名称是叫Assignment Expression
[35:45.000 --> 35:48.000] 呃就是就是什么意思呢
[35:48.000 --> 35:51.000] 就是说Assignment我们都知道就是复制嘛
[35:51.000 --> 35:54.000] 你可以a等于1或者a等于b这样子
[35:54.000 --> 35:59.000] 但是Python里原来你写一个Assignment的时候
[35:59.000 --> 36:03.000] 他是不会就他这个Assignment不是一个Expression
[36:03.000 --> 36:05.000] 就他没有返回值
[36:05.000 --> 36:07.000] 呃也就是说你a等于1
[36:07.000 --> 36:10.000] 然后你比如说你呃把这个东西用扣号扣起来
[36:10.000 --> 36:12.000] 他是是没有返回值的
[36:12.000 --> 36:14.000] 就你不能再复制给另外一个东西
[36:14.000 --> 36:19.000] 那现在572就是说他加了一个Assignment Expression
[36:19.000 --> 36:24.000] 你就可以写a比如a冒号等于1
[36:24.000 --> 36:28.000] 那么这个东西它是一个Expression也就是表达式
[36:28.000 --> 36:31.000] 它的返回值就是Assign给左边的那个东西
[36:31.000 --> 36:33.000] 也就是1
[36:33.000 --> 36:40.000] 所以这个就是572的一个就是他他新加的这么一个feature
[36:40.000 --> 36:42.000] 其实这个feature是比较简单的
[36:42.000 --> 36:46.000] 对很多人就是不太喜欢这个这种加这个功能嘛
[36:46.000 --> 36:51.000] 就觉得可能就是以前Python里面并不存在
[36:51.000 --> 36:55.000] 就并不需要这样一个并不需要这样一种新的复制
[36:55.000 --> 37:00.000] 然后呃所以就是导致这导致他争议的一部分原因吧
[37:00.000 --> 37:06.000] 哦对然后因为我之前对于572的一个就是说是顾虑在于
[37:06.000 --> 37:09.000] 呃他是呃他是存在
[37:09.000 --> 37:14.000] 他是存在就是说是他的作用作用范围是没有得到
[37:14.000 --> 37:16.000] 就是最开始那一版TR的时候
[37:16.000 --> 37:19.000] 他的作用范围是没有得到限制的
[37:19.000 --> 37:24.000] 然后的话就说是可能会就是他特别是在comprehensive那一部分
[37:24.000 --> 37:27.000] 然后是对作用代码是没有限制
[37:27.000 --> 37:28.000] 作用域是没有限制的
[37:28.000 --> 37:31.000] 然后就会产生对已有的代码产生影响
[37:33.000 --> 37:34.000] 我不太理解
[37:34.000 --> 37:37.000] 假如说你不用这个feature你之前的代码broken了吗
[37:37.000 --> 37:40.000] 呃是在那个comprehensive那一部分
[37:40.000 --> 37:45.000] 在那一部分就是说是comprehensive那一部分是有就是说是呃
[37:45.000 --> 37:46.000] 因为pp572的话
[37:46.000 --> 37:48.000] 他其实是分为两个部分
[37:48.000 --> 37:53.000] 一个就是说是呃一个是就是刚才所说的assignment
[37:53.000 --> 37:54.000] assignment expression
[37:54.000 --> 37:57.000] 然后还有在最早版本的提案是呃
[37:57.000 --> 38:01.000] 就是说是简化了那个list comprehensive的那一部分
[38:01.000 --> 38:03.000] 他是他是有两个部分的
[38:03.000 --> 38:05.000] 就是说那一部分呢
[38:05.000 --> 38:06.000] 对
[38:06.000 --> 38:11.000] 对然后他那一部分的话就会对已有的代码产生一定的影响
[38:11.000 --> 38:15.000] 然后这一点也是我在植物上和零件的态度保持一致的
[38:15.000 --> 38:17.000] 他那个简化你都详细聊一聊吗
[38:17.000 --> 38:19.000] 我知道的不多
[38:19.000 --> 38:21.000] 哦我确认我看了一下
[38:21.000 --> 38:24.000] 我重新看了我重我重新看了一下
[38:24.000 --> 38:27.000] 他那个地方呃语音那一部分后面撤销了
[38:27.000 --> 38:30.000] 然后所以说就和我最开始的顾虑是没有了
[38:30.000 --> 38:34.000] 但是我对于这种加语法糖的东西
[38:34.000 --> 38:36.000] 我也只是持很保守的态度
[38:36.000 --> 38:41.000] 你是指他changing the scope rules for comprehension那个吗
[38:41.000 --> 38:44.000] 然后对因为在572早期版本
[38:44.000 --> 38:48.000] 就是说是在大概是在18年呃6月份
[38:48.000 --> 38:50.000] 就刚刚接收的时候
[38:50.000 --> 38:55.000] 然后他是那个是涉及到改变了generator的语意的
[38:55.000 --> 38:58.000] 然后就是说是内部对对那一部分的话
[38:58.000 --> 39:03.000] 就是说是因为我们generator有些时候呃和comprehension连用吧
[39:03.000 --> 39:07.000] 然后他也相当于说呃改变了comprehension的
[39:07.000 --> 39:09.000] 他的一个语意与表现
[39:09.000 --> 39:13.000] 那一部分东西就是说是我们觉得就算是broken change
[39:13.000 --> 39:17.000] 然后但是后面他那一部分是呃给修改了
[39:17.000 --> 39:20.000] 哎其实我有一个问题
[39:20.000 --> 39:23.000] 假如说就是他不要这个冒号等号
[39:23.000 --> 39:26.000] 他那个等号本来如果就变成一个表达式的话
[39:26.000 --> 39:27.000] 就像C元那样
[39:27.000 --> 39:30.000] 你说用等号取代现在的冒号等于是吗
[39:30.000 --> 39:36.000] 就是把现在python里面的那个等号变成跟冒号等号一样
[39:36.000 --> 39:39.000] 但这肯定是个breaking change
[39:39.000 --> 39:41.000] 就你不知道他到底会break什么
[39:41.000 --> 39:43.000] 对这这是一个breaking change
[39:43.000 --> 39:46.000] 对因为你其实你assignment操作服
[39:46.000 --> 39:49.000] 你是直接完全改变了assignment操作服语意的
[39:49.000 --> 39:55.000] 是的就是你看c有一些语言就可以直接在复制的时候
[39:55.000 --> 39:57.000] 然后表达式左直往下传递
[39:57.000 --> 40:00.000] 那python应该是为什么不知道
[40:00.000 --> 40:02.000] 对就是我之前查了一下嘛
[40:02.000 --> 40:07.000] 就是c然后javascript他本身他的assignment就是会有返回值的
[40:07.000 --> 40:08.000] 就是assignment expression
[40:08.000 --> 40:10.000] 但是呃我c写的不多
[40:10.000 --> 40:13.000] 但他好像不是很推荐这种用法吧
[40:13.000 --> 40:16.000] 呃是他他其实用的很少的
[40:16.000 --> 40:19.000] 大部分都还是常规的就是先assign
[40:19.000 --> 40:21.000] 然后再来做expression
[40:21.000 --> 40:27.000] 但好像有一些trick是可以通过就是这种他的返回值来实现的
[40:27.000 --> 40:29.000] 对如果是按照新淘说的
[40:29.000 --> 40:34.000] 比如说我把这个海象操作服和那个assignment操作服合二为一
[40:34.000 --> 40:37.000] 那么这个我觉得就毫无疑问是个breaking change
[40:37.000 --> 40:40.000] 你可以说一下为什么他叫海象操作服吗
[40:40.000 --> 40:46.000] 呃就他其实他其实就说是你看他的两个等号对吧
[40:46.000 --> 40:49.000] 两个等号然后再加就是冒号加一个等号
[40:49.000 --> 40:51.000] 就像海象的两颗牙齿
[40:51.000 --> 40:54.000] 然后的话大家就就觉得可能说像个海象
[40:54.000 --> 40:56.000] 然后就说就做海象操作服
[40:56.000 --> 40:59.000] 我看到的有一些解释是这么说的
[40:59.000 --> 41:01.000] 对其实其实是这样的
[41:01.000 --> 41:03.000] 我觉得还挺挺挺挺有意思
[41:03.000 --> 41:05.000] 对对对反正我觉得吧
[41:05.000 --> 41:08.000] 我觉得我对于呃572
[41:08.000 --> 41:10.000] 我其实觉得他可能会减少一些东西
[41:10.000 --> 41:12.000] 但是减减化一些写法
[41:12.000 --> 41:15.000] 但是我觉得可能说他
[41:15.000 --> 41:20.000] 并不是我觉得并不是开发者所关心的东西吧
[41:20.000 --> 41:23.000] 至少对于我来讲是这样
[41:23.000 --> 41:26.000] 可能确实不是开发者所最关心的那些东西
[41:26.000 --> 41:30.000] 对因为因为我觉得因为我觉得的话
[41:30.000 --> 41:33.000] python很多时候他缺陷的东西还很多
[41:33.000 --> 41:36.000] 就比如说他之前一直推到sync io的完善
[41:36.000 --> 41:40.000] 然后再比如对再比如说他一个方便的调试
[41:40.000 --> 41:43.000] 就是说是第三方的调试监视工具
[41:43.000 --> 41:46.000] 但是572所带来的一个副作用
[41:46.000 --> 41:50.000] 就是说是你这样一个简单的语法提案都可以
[41:50.000 --> 41:53.000] 动用BDFL把它给合入进去
[41:53.000 --> 41:56.000] 那么还有什么提案是不可以的
[41:56.000 --> 42:00.000] 所以没有BDFL了
[42:00.000 --> 42:03.000] 对然后然后所以说大家就说是572的
[42:03.000 --> 42:06.000] 现在get推上推那个推特上面
[42:06.000 --> 42:09.000] 就很多人说了一句话就说572都能合进去
[42:09.000 --> 42:12.000] 凭什么我的PPP不难被接受
[42:12.000 --> 42:17.000] 其实我反倒觉得如果他是初学者
[42:17.000 --> 42:20.000] 可能比较容易接受就对于我们这种
[42:20.000 --> 42:23.000] 写了很多年python的人反而不太容易接受
[42:23.000 --> 42:28.000] 因为初学者他没有这种就是固有的的思维定式
[42:28.000 --> 42:32.000] 但是我觉得的话他我觉得他其实还是会
[42:32.000 --> 42:34.000] 对初学者造成一些confusion
[42:34.000 --> 42:37.000] 就是说是我到底什么时候该用assignment
[42:37.000 --> 42:40.000] assignment还是什么时候该用assignment expression
[42:40.000 --> 42:43.000] 我觉得还是会增加一些心智负担吧
[42:43.000 --> 42:47.000] 就不光是什么时候用assignment和assignment expression
[42:47.000 --> 42:51.000] 就包括他可能要理解我要在while的时候
[42:51.000 --> 42:54.000] 用的是这个assignment expression
[42:54.000 --> 42:58.000] 但是在with的时候我用的是as对吧这种
[42:58.000 --> 43:03.000] 就是引入这种引入这个语法我肯定是支持的
[43:03.000 --> 43:07.000] 因为它能让很多原来的code变得更简洁一些
[43:07.000 --> 43:12.000] 但是我不喜欢的是他目前的黑名单模式
[43:12.000 --> 43:15.000] 就是他为什么我说他是黑名单模式呢
[43:15.000 --> 43:18.000] 就是他你如果去读一下派普奇二
[43:18.000 --> 43:21.000] 他的文档的话就会发现他是
[43:21.000 --> 43:25.000] 就你可以在任何地方用这个海象操作符
[43:25.000 --> 43:26.000] 或者assignment expression
[43:26.000 --> 43:29.000] 但是呢他会列举1234567
[43:29.000 --> 43:33.000] 就是说这些地方有一些地方是不推荐你用的
[43:33.000 --> 43:37.000] 那么这样我觉得就会有一个问题
[43:37.000 --> 43:40.000] 就是增加了开发者的心智负担
[43:40.000 --> 43:43.000] 那么我比如说我就想用
[43:43.000 --> 43:45.000] 我比如说我环境就是3.8的
[43:45.000 --> 43:46.000] 我想用这个海象操作符
[43:46.000 --> 43:51.000] 那我难道还得去用之前去看一下这个文档
[43:51.000 --> 43:53.000] 我说这种情况下适不适合用吗
[43:53.000 --> 43:57.000] 或者是比如说一些编程风格就是适不适合用
[43:57.000 --> 43:59.000] 这样就很蠢对吧
[43:59.000 --> 44:04.000] 然后就反而就是我觉得就就是增加心智负担
[44:04.000 --> 44:06.000] 那我觉得更好更好的一种方式
[44:06.000 --> 44:09.000] 其实是类似于golang的这种形式
[44:09.000 --> 44:12.000] 就是golang里面他也有一个语法堂
[44:12.000 --> 44:15.000] 是呃就是这种海象操作符
[44:15.000 --> 44:18.000] 虽然他虽然他和python的语义不一样
[44:18.000 --> 44:21.000] 他是golang里面是声明加复制的语法堂
[44:21.000 --> 44:24.000] 但是他golang好的一点就是说
[44:24.000 --> 44:26.000] 总之就是说golang里面
[44:26.000 --> 44:32.000] 他会规定你能够在什么地方去用这个操作符
[44:32.000 --> 44:34.000] 那呃就是有限的几个地方
[44:34.000 --> 44:38.000] 比如说那个eve或者是for里面
[44:38.000 --> 44:40.000] 那在其他地方你如果用的话
[44:40.000 --> 44:41.000] 他编译就会出错
[44:41.000 --> 44:43.000] 程序就没有办法解析
[44:43.000 --> 44:46.000] 那我觉得python其实也完全可以这样做
[44:46.000 --> 44:47.000] 对吧
[44:47.000 --> 44:51.000] 这样就是我觉得白名单的模式会比黑名单要要好很多
[44:51.000 --> 44:55.000] 就是能极大的减少用户的心智负担
[44:55.000 --> 45:00.000] 但是我觉得如果说是要对于那个就做黑名单模式
[45:00.000 --> 45:02.000] 就是白名单模式的话
[45:02.000 --> 45:06.000] 可能说是对又是一个比较大的一个就是欠积了
[45:06.000 --> 45:09.000] 虽然说是这个欠积并不影响应用程度用户
[45:09.000 --> 45:11.000] 但是对于底层的实现来说
[45:11.000 --> 45:14.000] 我觉得可能又会进行有可能
[45:14.000 --> 45:15.000] 有可能
[45:15.000 --> 45:17.000] 不过这方面我也不是特别懂
[45:17.000 --> 45:19.000] 对因为感觉你这个说的话
[45:19.000 --> 45:23.000] 其实就是把一部分就说是把一部分的交给用户的东西
[45:23.000 --> 45:26.000] 那个语法前置就前置到语法检查来做对吧
[45:26.000 --> 45:30.000] 就交给对啊交给那个passer来做吗
[45:30.000 --> 45:34.000] 对然后就是说我觉得这一块的话可能又是个比较大的欠积
[45:34.000 --> 45:36.000] 然后就不知道ROI高不高了
[45:36.000 --> 45:38.000] 从用户的角度考虑对吧
[45:38.000 --> 45:40.000] 那样肯定是我觉得更好一点
[45:40.000 --> 45:42.000] 对对对对我觉得
[45:42.000 --> 45:45.000] 我觉得反正我觉得这个提案的话
[45:45.000 --> 45:50.000] 算是python应该算是python历史上意义比较是重大的几个提案吧
[45:50.000 --> 45:53.000] 但这个意义也有可能是正面意义也有可能是反面意义
[45:53.000 --> 45:57.000] 我会觉得说关于这个的
[45:57.000 --> 45:59.000] 就是我们觉得他到底好不好
[45:59.000 --> 46:01.000] 可能还是要再用一段时间
[46:01.000 --> 46:05.000] 我其实第一时间看到572我是比较反感的
[46:05.000 --> 46:08.000] 就是我当我第一次看到572提案的时候
[46:08.000 --> 46:11.000] 对因为他额外引入了一个
[46:11.000 --> 46:13.000] 这个海象操作服之后
[46:13.000 --> 46:15.000] 其实对我来说
[46:15.000 --> 46:18.000] 我觉得并没有什么太大的优势
[46:18.000 --> 46:21.000] 但是确实是增大了我的心智负担
[46:21.000 --> 46:22.000] 我又多了一种写法
[46:22.000 --> 46:24.000] 以及我要看别人的时候又多了一种写法
[46:24.000 --> 46:26.000] 以及他其实可以在很多地方运用
[46:26.000 --> 46:28.000] 但是那种运用又不是最佳应用
[46:28.000 --> 46:31.000] 对然后我觉得还是要写写看吧
[46:31.000 --> 46:33.000] 对因为毕竟都没写过
[46:33.000 --> 46:35.000] 然后可能也许未来就适应了
[46:35.000 --> 46:38.000] 也不确定我刚开始写golang的时候就觉得哇
[46:38.000 --> 46:41.000] 好难受好啰嗦
[46:41.000 --> 46:43.000] 现在还是好难受
[46:43.000 --> 46:45.000] 后来你就觉得
[46:45.000 --> 46:48.000] 这就是golang的风格
[46:48.000 --> 46:50.000] 阿Q精
[46:50.000 --> 46:52.000] 这算阿Q精神吗
[46:52.000 --> 46:53.000] 就是整个golang社区
[46:53.000 --> 46:55.000] 大家都是围绕这种风格构建的
[46:55.000 --> 46:58.000] 所以你就会觉得那你就只能习惯它
[46:58.000 --> 47:01.000] 因为你不可能说我选择别的方式
[47:01.000 --> 47:02.000] 确实会引入一些好处
[47:02.000 --> 47:05.000] 但是你会发现和整个的风格都不统一了
[47:05.000 --> 47:07.000] 你就没办法去把一个项目
[47:07.000 --> 47:10.000] 把n个库组织在一起
[47:10.000 --> 47:13.000] 对但是我始终觉得这个572的话
[47:13.000 --> 47:15.000] 要普及的话
[47:15.000 --> 47:17.000] 我估计最起码还是要有2-3年时间
[47:17.000 --> 47:21.000] 除非是有python很多更多的python3.8only的出来
[47:21.000 --> 47:23.000] 才有可能
[47:23.000 --> 47:27.000] 是就是大家生3.8肯定不会是因为572生的
[47:27.000 --> 47:29.000] 我觉得这个是对的
[47:29.000 --> 47:30.000] 对对对对对
[47:30.000 --> 47:33.000] 其实我觉得3.8好像我感兴趣的提案
[47:33.000 --> 47:34.000] 其实并不是太多
[47:34.000 --> 47:36.000] 当然有一个就是上次说的571
[47:36.000 --> 47:38.000] 那个projectionalonly
[47:38.000 --> 47:40.000] 对那个还行
[47:40.000 --> 47:45.000] 对其实我觉得就比如说假设一个公司
[47:45.000 --> 47:49.000] 他应用3.8可能也会有他自己的
[47:49.000 --> 47:52.000] 就是就规定一种代码风格
[47:52.000 --> 47:54.000] 就是说你的海象操作服
[47:54.000 --> 47:56.000] 只能在这么几个地方用
[47:56.000 --> 47:57.000] 对吧有可能是这样子的
[47:57.000 --> 48:01.000] 也许pylink也会支持这种海象操作服的这种
[48:01.000 --> 48:04.000] 不优雅实现的link
[48:04.000 --> 48:06.000] 对我觉得可以
[48:06.000 --> 48:10.000] 因为我觉得海象操作服其实
[48:10.000 --> 48:12.000] 他或多或少来讲
[48:12.000 --> 48:15.000] 其实还是有一点broker
[48:15.000 --> 48:17.000] 那个就是说是可读性的意思
[48:17.000 --> 48:19.000] 所以我的意思就是说
[48:19.000 --> 48:22.000] 他其实很多地方是损害可读性
[48:22.000 --> 48:26.000] 但有些地方是就是增加了可读性
[48:26.000 --> 48:27.000] 所以公司就会选择
[48:27.000 --> 48:29.000] 仅仅在某些地方让你使用
[48:29.000 --> 48:31.000] 就是这个意思
[48:31.000 --> 48:33.000] 对我觉得其实听众们也可以去看一下
[48:33.000 --> 48:34.000] 572实现
[48:34.000 --> 48:35.000] 然后历代的讨论
[48:35.000 --> 48:36.000] 我觉得这个讨论的话
[48:36.000 --> 48:40.000] 我们会以那个参考链接的形式给出来
[48:40.000 --> 48:42.000] 我觉得去大家去看一下572
[48:42.000 --> 48:45.000] 因为572是一个是一次很典型的一个社区
[48:45.000 --> 48:46.000] 共同讨论的一个事件
[48:46.000 --> 48:50.000] 这个我这个的热度应该算是近几年
[48:50.000 --> 48:51.000] 这几个p
[48:51.000 --> 48:53.000] 只要目前这只说是家庭语言特性里面
[48:53.000 --> 48:55.000] 这个pip里面最高的
[48:55.000 --> 48:57.000] 就是说我觉得大家也可以去参与
[48:57.000 --> 48:58.000] 进去去看一下
[48:58.000 --> 49:02.000] 然后大家对于某一个新特性是怎么样去看待
[49:02.000 --> 49:05.000] 我觉得这是一个很宝贵的一个收获
[49:19.000 --> 49:20.000] 我们这期来推荐吗
[49:20.000 --> 49:21.000] 对
[49:22.000 --> 49:24.000] 我没有准备
[49:24.000 --> 49:25.000] 我没有准备推荐
[49:25.000 --> 49:27.000] 我也没准备
[49:27.000 --> 49:29.000] 有人想有人如果想说
[49:29.000 --> 49:30.000] 我觉得随便说就好
[49:30.000 --> 49:31.000] 我也没准备
[49:31.000 --> 49:33.000] 如果没有就算了
[49:33.000 --> 49:36.000] 之前有一个打包工具
[49:36.000 --> 49:37.000] 看了一下
[49:37.000 --> 49:42.000] 叫pi oxydizer
[49:42.000 --> 49:43.000] 怎么听啊
[49:43.000 --> 49:44.000] 不太会读
[49:44.000 --> 49:45.000] 他是用
[49:48.000 --> 49:50.000] pyosidizer
[49:51.000 --> 49:52.000] 感觉好复杂
[49:52.000 --> 49:54.000] 这个不是面向开发者的一个
[49:54.000 --> 49:56.000] 那个打包工具
[49:56.000 --> 49:58.000] 就是说他不是对标的pipe
[49:58.000 --> 49:59.000] pipe env这种东西
[49:59.000 --> 50:03.000] 他是把python的解释器打进去
[50:03.000 --> 50:07.000] 然后分发给不会python的人的这种一个东西
[50:07.000 --> 50:10.000] 就是他可以把python的application打包成一个
[50:10.000 --> 50:12.000] 打包成可执行的那种是吧
[50:13.000 --> 50:14.000] 是的
[50:14.000 --> 50:17.000] 然后那我推荐两个吧
[50:17.000 --> 50:18.000] 稍等一下
[50:18.000 --> 50:19.000] 我还在找一个
[50:19.000 --> 50:23.000] 我推荐第一个的话是那个ycm generator
[50:23.000 --> 50:27.000] 然后的话ycm的话就是you complete me
[50:27.000 --> 50:30.000] 然后是大家应该知道这是那个web里面
[50:30.000 --> 50:32.000] 一个非常著名的一个插件
[50:32.000 --> 50:34.000] 然后就是用来写c++的
[50:34.000 --> 50:37.000] 但是那个you complete me
[50:37.000 --> 50:38.000] 他有了问题
[50:38.000 --> 50:40.000] 就是说是你要写c++的话
[50:40.000 --> 50:44.000] 你需要去就是说是配置相相对应的
[50:44.000 --> 50:46.000] 就是说是include路径这些东西
[50:46.000 --> 50:47.000] 对吧
[50:47.000 --> 50:50.000] 然后但是有些时候你对于一个大的开源项目
[50:50.000 --> 50:53.000] 有些时候你就觉得他的各种import和配置
[50:53.000 --> 50:54.000] 信息就很杂
[50:54.000 --> 50:56.000] 然后ycm generator的话
[50:56.000 --> 50:57.000] 我发出我链接
[50:57.000 --> 50:59.000] 然后我等下把链接发群里
[50:59.000 --> 51:00.000] 然后的话
[51:00.000 --> 51:03.000] 他那个就是说是他的一个最大的好处
[51:03.000 --> 51:07.000] 就是说是他会可以根据那个auto config
[51:07.000 --> 51:09.000] 或者说是make或者是cmake
[51:09.000 --> 51:11.000] 然后解析这些东西
[51:11.000 --> 51:13.000] 然后生成对应的you complete me文件
[51:13.000 --> 51:14.000] 就是说是配置文件
[51:14.000 --> 51:16.000] 然后你就直接可以开箱即用
[51:16.000 --> 51:17.000] 很方便的写bimp
[51:17.000 --> 51:19.000] 听起来很不错
[51:19.000 --> 51:21.000] 等会我随便我插一句
[51:21.000 --> 51:23.000] 你平时也写c++吗
[51:23.000 --> 51:25.000] 我写c
[51:25.000 --> 51:30.000] 因为那个我修你去修那个bugs的时候
[51:30.000 --> 51:32.000] 有些时候就会写一些c
[51:32.000 --> 51:33.000] 底层大佬
[51:33.000 --> 51:34.000] 对
[51:34.000 --> 51:35.000] 然后我自己有些
[51:35.000 --> 51:36.000] 我操别写清黑
[51:36.000 --> 51:38.000] 我都是修一些简单的东西
[51:38.000 --> 51:39.000] 然后的话
[51:39.000 --> 51:40.000] 第二个的话
[51:40.000 --> 51:45.000] 是我推荐一个zookeeper的库叫做keyzoo
[51:45.000 --> 51:46.000] keyzoo的话
[51:46.000 --> 51:48.000] 它是python里面
[51:48.000 --> 51:51.000] 我觉得算是目前来说是最可用的一个
[51:51.000 --> 51:55.000] 就是zookeeper的一个就是说是使用框架吧
[51:55.000 --> 51:59.000] 然后它里面也带了一些开箱即用的recipe
[51:59.000 --> 52:01.000] 最简单的就是说是我们
[52:01.000 --> 52:05.000] 因为我们组之前也贡献了一个叫做treecake
[52:05.000 --> 52:07.000] 然后这个treecake的一个诞生的一个前因
[52:07.000 --> 52:09.000] 就是说是zookeeper的话
[52:09.000 --> 52:12.000] 是没有设置地规监听语言
[52:12.000 --> 52:14.000] 然后treecake的话就可以通过一个
[52:14.000 --> 52:16.000] 构建一个内存快照来帮助
[52:16.000 --> 52:20.000] 就是说是在没有设置地规监听语言的情况下
[52:20.000 --> 52:23.000] 来就是说监听对应的数据变化
[52:23.000 --> 52:25.000] 然后这个东西它还有一些其他的
[52:25.000 --> 52:26.000] 比如说像选举
[52:26.000 --> 52:28.000] 比如说像分布式锁
[52:28.000 --> 52:30.000] 这样一些开箱即用的那个东西
[52:30.000 --> 52:33.000] 然后在python的环境里面
[52:33.000 --> 52:35.000] 我觉得这个算是比较可用的一个东西
[52:35.000 --> 52:37.000] 就是说我觉得我可以推荐一下
[52:37.000 --> 52:38.000] 好的
[52:41.000 --> 52:44.000] 以上就是补舍这首第五期的全部内容
[52:44.000 --> 52:46.000] 欢迎留言告诉我们你的想法
[52:46.000 --> 52:49.000] 或者加入我们的telegram讨论组
[52:49.000 --> 52:50.000] 感谢各位听众
[52:50.000 --> 53:19.000] 下期再见
